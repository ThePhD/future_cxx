<!doctype html><html lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
  <title>N37XA: Functions with Data - Closures in C (A Comprehensive Proposal Overviewing Blocks, Nested Functions, and Lambdas)</title>
<style data-fill-with="stylesheet">/******************************************************************************
 *                   Style sheet for the W3C specifications                   *
 *
 * Special classes handled by this style sheet include:
 *
 * Indices
 *   - .toc for the Table of Contents (<ol class="toc">)
 *     + <span class="secno"> for the section numbers
 *   - #toc for the Table of Contents (<nav id="toc">)
 *   - ul.index for Indices (<a href="#ref">term</a><span>, in § N.M</span>)
 *   - table.index for Index Tables (e.g. for properties or elements)
 *
 * Structural Markup
 *   - table.data for general data tables
 *     -> use 'scope' attribute, <colgroup>, <thead>, and <tbody> for best results !
 *     -> use <table class='complex data'> for extra-complex tables
 *     -> use <td class='long'> for paragraph-length cell content
 *     -> use <td class='pre'> when manual line breaks/indentation would help readability
 *   - dl.switch for switch statements
 *   - ol.algorithm for algorithms (helps to visualize nesting)
 *   - .figure and .caption (HTML4) and figure and figcaption (HTML5)
 *     -> .sidefigure for right-floated figures
 *   - ins/del
 *     -> ins/del.c### for candidate and proposed changes (amendments)
 *
 * Code
 *   - pre and code
 *
 * Special Sections
 *   - .note       for informative notes             (div, p, span, aside, details)
 *   - .example    for informative examples          (div, p, pre, span)
 *   - .issue      for issues                        (div, p, span)
 *   - .advisement for loud normative statements     (div, p, strong)
 *   - .annoying-warning for spec obsoletion notices (div, aside, details)
 *   - .correction for "candidate corrections"       (div, aside, details, section)
 *   - .addition   for "candidate additions"         (div, aside, details, section)
 *   - .correction.proposed for "proposed corrections" (div, aside, details, section)
 *   - .addition.proposed   for "proposed additions"   (div, aside, details, section)
 *
 * Definition Boxes
 *   - pre.def   for WebIDL definitions
 *   - table.def for tables that define other entities (e.g. CSS properties)
 *   - dl.def    for definition lists that define other entitles (e.g. HTML elements)
 *
 * Numbering
 *   - .secno for section numbers in .toc and headings (<span class='secno'>3.2</span>)
 *   - .marker for source-inserted example/figure/issue numbers (<span class='marker'>Issue 4</span>)
 *   - ::before styled for CSS-generated issue/example/figure numbers:
 *     -> Documents wishing to use this only need to add
 *        figcaption::before,
 *        .caption::before { content: "Figure "  counter(figure) " ";  }
 *        .example::before { content: "Example " counter(example) " "; }
 *        .issue::before   { content: "Issue "   counter(issue) " ";   }
 *
 * Header Stuff (ignore, just don't conflict with these classes)
 *   - .head for the header
 *   - .copyright for the copyright
 *
 * Outdated warning for old specs
 *
 * Miscellaneous
 *   - .overlarge for things that should be as wide as possible, even if
 *     that overflows the body text area. This can be used on an item or
 *     on its container, depending on the effect desired.
 *     Note that this styling basically doesn't help at all when printing,
 *     since A4 paper isn't much wider than the max-width here.
 *     It's better to design things to fit into a narrower measure if possible.
 *
 *   - js-added ToC jump links (see fixup.js)
 *
 ******************************************************************************/

/* color variables included separately for reliability */

/******************************************************************************/
/*                                    Body                                    */
/******************************************************************************/

	html {
	}

	body {
		counter-reset: example figure issue;

		/* Layout */
		max-width: 50em;			  /* limit line length to 50em for readability   */
		margin: 0 auto;				/* center text within page                    */
		padding: 1.6em 1.5em 2em 50px; /* assume 16px font size for downlevel clients */
		padding: 1.6em 1.5em 2em calc(26px + 1.5em); /* leave space for status flag    */

		/* Typography */
		line-height: 1.5;
		font-family: sans-serif;
		widows: 2;
		orphans: 2;
		word-wrap: break-word;
		overflow-wrap: break-word;
		hyphens: auto;

		color: black;
		color: var(--text);
		background: white top left fixed no-repeat;
		background: var(--bg) top left fixed no-repeat;
		background-size: 25px auto;
	}


/******************************************************************************/
/*                         Front Matter & Navigation                          */
/******************************************************************************/

/** Header ********************************************************************/

	div.head { margin-bottom: 1em; }
	div.head hr { border-style: solid; }

	div.head h1 {
		font-weight: bold;
		margin: 0 0 .1em;
		font-size: 220%;
	}

	div.head h2 { margin-bottom: 1.5em;}

/** W3C Logo ******************************************************************/

	.head .logo {
		float: right;
		margin: 0.4rem 0 0.2rem .4rem;
	}

	.head img[src*="logos/W3C"] {
		display: block;
		border: solid #1a5e9a;
		border: solid var(--logo-bg);
		border-width: .65rem .7rem .6rem;
		border-radius: .4rem;
		background: #1a5e9a;
		background: var(--logo-bg);
		color: white;
		color: var(--logo-text);
		font-weight: bold;
	}

	.head a:hover > img[src*="logos/W3C"],
	.head a:focus > img[src*="logos/W3C"] {
		opacity: .8;
	}

	.head a:active > img[src*="logos/W3C"] {
		background: #c00;
		background: var(--logo-active-bg);
		border-color: #c00;
		border-color: var(--logo-active-bg);
	}

	/* see also additional rules in Link Styling section */

/** Copyright *****************************************************************/

	p.copyright,
	p.copyright small { font-size: small; }

/** Back to Top / ToC Toggle **************************************************/

	@media print {
		#toc-nav {
			display: none;
		}
	}
	@media not print {
		#toc-nav {
			position: fixed;
			z-index: 3;
			bottom: 0; left: 0;
			margin: 0;
			min-width: 1.33em;
			border-top-right-radius: 2rem;
			box-shadow: 0 0 2px;
			font-size: 1.5em;
		}
		#toc-nav > a {
			display: block;
			white-space: nowrap;

			height: 1.33em;
			padding: .1em 0.3em;
			margin: 0;

			box-shadow: 0 0 2px;
			border: none;
			border-top-right-radius: 1.33em;

			color: #707070;
			color: var(--tocnav-normal-text);
			background: white;
			background: var(--tocnav-normal-bg);
		}
		#toc-nav > a:hover,
		#toc-nav > a:focus {
			color: black;
			color: var(--tocnav-hover-text);
			background: #f8f8f8;
			background: var(--tocnav-hover-bg);
		}
		#toc-nav > a:active {
			color: #c00;
			color: var(--tocnav-active-text);
			background: white;
			background: var(--tocnav-active-bg);
		}

		#toc-nav > #toc-jump {
			padding-bottom: 2em;
			margin-bottom: -1.9em;
		}

		/* statusbar gets in the way on keyboard focus; remove once browsers fix */
		#toc-nav > a[href="#toc"]:not(:hover):focus:last-child {
			padding-bottom: 1.5rem;
		}

		#toc-nav:not(:hover) > a:not(:focus) > span + span {
			/* Ideally this uses :focus-within on #toc-nav */
			display: none;
		}
		#toc-nav > a > span + span {
			padding-right: 0.2em;
		}
	}

/** ToC Sidebar ***************************************************************/

	/* Floating sidebar */
	@media screen {
		body.toc-sidebar #toc {
			position: fixed;
			top: 0; bottom: 0;
			left: 0;
			width: 23.5em;
			max-width: 80%;
			max-width: calc(100% - 2em - 26px);
			overflow: auto;
			padding: 0 1em;
			padding-left: 42px;
			padding-left: calc(1em + 26px);
			color: black;
			color: var(--tocsidebar-text);
			background: inherit;
			background-color: #f7f8f9;
			background-color: var(--tocsidebar-bg);
			z-index: 1;
			box-shadow: -.1em 0 .25em rgba(0,0,0,.1) inset;
			box-shadow: -.1em 0 .25em var(--tocsidebar-shadow) inset;
		}
		body.toc-sidebar #toc h2 {
			margin-top: .8rem;
			font-variant: small-caps;
			font-variant: all-small-caps;
			text-transform: lowercase;
			font-weight: bold;
			color: gray;
			color: hsla(203,20%,40%,.7);
			color: var(--tocsidebar-heading-text);
		}
		body.toc-sidebar #toc-jump:not(:focus) {
			width: 0;
			height: 0;
			padding: 0;
			position: absolute;
			overflow: hidden;
		}
	}
	/* Hide main scroller when only the ToC is visible anyway */
	@media screen and (max-width: 28em) {
		body.toc-sidebar {
			overflow: hidden;
		}
	}

	/* Sidebar with its own space */
	@media screen and (min-width: 78em) {
		body:not(.toc-inline) #toc {
			position: fixed;
			top: 0; bottom: 0;
			left: 0;
			width: 23.5em;
			overflow: auto;
			padding: 0 1em;
			padding-left: 42px;
			padding-left: calc(1em + 26px);
			color: black;
			color: var(--tocsidebar-text);
			background: inherit;
			background-color: #f7f8f9;
			background-color: var(--tocsidebar-bg);
			z-index: 1;
			box-shadow: -.1em 0 .25em rgba(0,0,0,.1) inset;
			box-shadow: -.1em 0 .25em var(--tocsidebar-shadow) inset;
		}
		body:not(.toc-inline) #toc h2 {
			margin-top: .8rem;
			font-variant: small-caps;
			font-variant: all-small-caps;
			text-transform: lowercase;
			font-weight: bold;
			color: gray;
			color: hsla(203,20%,40%,.7);
			color: var(--tocsidebar-heading-text);
		}

		body:not(.toc-inline) {
			padding-left: 29em;
		}
		/* See also Overflow section at the bottom */

		body:not(.toc-inline) #toc-jump:not(:focus) {
			width: 0;
			height: 0;
			padding: 0;
			position: absolute;
			overflow: hidden;
		}
	}
	@media screen and (min-width: 90em) {
		body:not(.toc-inline) {
			margin: 0 4em;
		}
	}

/******************************************************************************/
/*                                Sectioning                                  */
/******************************************************************************/

/** Headings ******************************************************************/

	h1, h2, h3, h4, h5, h6, dt {
		page-break-after: avoid;
		page-break-inside: avoid;
		font: 100% sans-serif;   /* Reset all font styling to clear out UA styles */
		font-family: inherit;	/* Inherit the font family. */
		line-height: 1.2;		/* Keep wrapped headings compact */
		hyphens: manual;		/* Hyphenated headings look weird */
	}

	h2, h3, h4, h5, h6 {
		margin-top: 3rem;
	}

	h1, h2, h3 {
		color: #005A9C;
		color: var(--heading-text);
	}

	h1 { font-size: 170%; }
	h2 { font-size: 140%; }
	h3 { font-size: 120%; }
	h4 { font-weight: bold; }
	h5 { font-style: italic; }
	h6 { font-variant: small-caps; }
	dt { font-weight: bold; }

/** Subheadings ***************************************************************/

	h1 + h2,
	#profile-and-date {
		/* #profile-and-date is a subtitle in an H2 under the H1 */
		margin-top: 0;
	}
	h2 + h3,
	h3 + h4,
	h4 + h5,
	h5 + h6 {
		margin-top: 1.2em; /* = 1 x line-height */
	}

/** Section divider ***********************************************************/

	:not(.head) > :not(.head) + hr {
		font-size: 1.5em;
		text-align: center;
		margin: 1em auto;
		height: auto;
		color: black;
		color: var(--hr-text);
		border: transparent solid 0;
		background: transparent;
	}
	:not(.head) > hr::before {
		content: "\2727\2003\2003\2727\2003\2003\2727";
	}

/******************************************************************************/
/*                            Paragraphs and Lists                            */
/******************************************************************************/

	p {
		margin: 1em 0;
	}

	dd > p:first-child,
	li > p:first-child {
		margin-top: 0;
	}

	ul, ol {
		margin-left: 0;
		padding-left: 2em;
	}

	li {
		margin: 0.25em 0 0.5em;
		padding: 0;
	}

	dl dd {
		margin: 0 0 .5em 2em;
	}

	.head dd + dd { /* compact for header */
		margin-top: -.5em;
	}

	/* Style for algorithms */
	ol.algorithm ol:not(.algorithm),
	.algorithm > ol ol:not(.algorithm) {
	border-left: 0.5em solid #DEF;
	border-left: 0.5em solid var(--algo-border);
	}

	/* Put nice boxes around each algorithm. */
	[data-algorithm]:not(.heading) {
	 padding: .5em;
	 border: thin solid #ddd;
	 border: thin solid var(--algo-border);
	 border-radius: .5em;
	 margin: .5em calc(-0.5em - 1px);
	}
	[data-algorithm]:not(.heading) > :first-child {
	 margin-top: 0;
	}
	[data-algorithm]:not(.heading) > :last-child {
	 margin-bottom: 0;
	}

	/* Style for switch/case <dl>s */
	dl.switch > dd > ol.only,
	dl.switch > dd > .only > ol {
	margin-left: 0;
	}
	dl.switch > dd > ol.algorithm,
	dl.switch > dd > .algorithm > ol {
	margin-left: -2em;
	}
	dl.switch {
	padding-left: 2em;
	}
	dl.switch > dt {
	text-indent: -1.5em;
	margin-top: 1em;
	}
	dl.switch > dt + dt {
	margin-top: 0;
	}
	dl.switch > dt::before {
	content: '\21AA';
	padding: 0 0.5em 0 0;
	display: inline-block;
	width: 1em;
	text-align: right;
	line-height: 0.5em;
	}

/** Terminology Markup ********************************************************/


/******************************************************************************/
/*                                 Inline Markup                              */
/******************************************************************************/

/** Terminology Markup ********************************************************/
	dfn   { /* Defining instance */
		font-weight: bolder;
	}
	a > i { /* Instance of term */
		font-style: normal;
	}
	dt dfn code, code.idl {
		font-size: inherit;
	}
	dfn var {
		font-style: normal;
	}

/** Change Marking ************************************************************/

	del {
		color: #aa0000;
		color: var(--del-text);
		background: transparent;
		background: var(--del-bg);
		text-decoration: line-through;
	}
	ins {
		color: #006100;
		color: var(--ins-text);
		background: transparent;
		background: var(--ins-bg);
		text-decoration: underline;
	}

	/* for amendments (candidate/proposed changes) */

	.amendment ins, .correction ins, .addition ins,
	ins[class^=c] {
		text-decoration-style: dotted;
	}
	.amendment del, .correction del, .addition del,
	del[class^=c] {
		text-decoration-style: dotted;
	}
	.amendment.proposed ins, .correction.proposed ins, .addition.proposed ins,
	ins[class^=c].proposed {
		text-decoration-style: double;
	}
	.amendment.proposed del, .correction.proposed del, .addition.proposed del,
	del[class^=c].proposed {
		text-decoration-style: double;
	}

/** Miscellaneous improvements to inline formatting ***************************/

	sup {
		vertical-align: super;
		font-size: 80%
	}

/******************************************************************************/
/*                                    Code                                    */
/******************************************************************************/

/** General monospace/pre rules ***********************************************/

	pre, code, samp {
		font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;
		font-size: .9em;
		hyphens: none;
		text-transform: none;
		text-align: left;
		text-align: start;
		font-variant: normal;
		orphans: 3;
		widows: 3;
		page-break-before: avoid;
	}
	pre code,
	code code {
		font-size: 100%;
	}

	pre {
		margin-top: 1em;
		margin-bottom: 1em;
		overflow: auto;
	}

/** Inline Code fragments *****************************************************/

	/* Do something nice. */

/******************************************************************************/
/*                                    Links                                   */
/******************************************************************************/

/** General Hyperlinks ********************************************************/

	/* We hyperlink a lot, so make it less intrusive */
	a[href] {
		color: #034575;
		color: var(--a-normal-text);
		text-decoration: underline #707070;
		text-decoration: underline var(--a-normal-underline);
		text-decoration-skip-ink: none;
	}
	a:visited {
		color: #034575;
		color: var(--a-visited-text);
		text-decoration-color: #bbb;
		text-decoration-color: var(--a-visited-underline);
	}

	/* Indicate interaction with the link */
	a[href]:focus,
	a[href]:hover {
		text-decoration-thickness: 2px;
	}
	a[href]:active {
		color: #c00;
		color: var(--a-active-text);
		text-decoration-color: #c00;
		text-decoration-color: var(--a-active-underline);
	}

	/* Backout above styling for W3C logo */
	.head .logo,
	.head .logo a {
		border: none;
		text-decoration: none;
		background: transparent;
	}

/******************************************************************************/
/*                                    Images                                  */
/******************************************************************************/

	img {
		border-style: none;
	}

	img, svg {
		/* Intentionally not color-scheme aware. */
		background: white;
	}

	/* For autogen numbers, add
	  .caption::before, figcaption::before { content: "Figure " counter(figure) ". "; }
	*/

	figure, .figure, .sidefigure {
		page-break-inside: avoid;
		text-align: center;
		margin: 2.5em 0;
	}
	.figure img,	.sidefigure img,	figure img,
	.figure object, .sidefigure object, figure object {
		max-width: 100%;
		margin: auto;
		height: auto;
	}
	.figure pre, .sidefigure pre, figure pre {
		text-align: left;
		display: table;
		margin: 1em auto;
	}
	.figure table, figure table {
		margin: auto;
	}
	@media screen and (min-width: 20em) {
		.sidefigure {
			float: right;
			width: 50%;
			margin: 0 0 0.5em 0.5em;
		}
	}
	.caption, figcaption, caption {
		font-style: italic;
		font-size: 90%;
	}
	.caption::before, figcaption::before, figcaption > .marker {
		font-weight: bold;
	}
	.caption, figcaption {
		counter-increment: figure;
	}

	/* DL list is indented 2em, but figure inside it is not */
	dd > .figure, dd > figure { margin-left: -2em; }

/******************************************************************************/
/*                             Colored Boxes                                  */
/******************************************************************************/

	.issue, .note, .example, .assertion, .advisement, blockquote,
	.amendment, .correction, .addition {
		margin: 1em auto;
		padding: .5em;
		border: .5em;
		border-left-style: solid;
		page-break-inside: avoid;
	}
	span.issue, span.note {
		padding: .1em .5em .15em;
		border-right-style: solid;
	}

	blockquote > :first-child,
	.note  > p:first-child,
	.issue > p:first-child,
	.amendment > p:first-child,
	.correction > p:first-child,
	.addition > p:first-child {
		margin-top: 0;
	}
	blockquote > :last-child,
	.note  > p:last-child,
	.issue > p:last-child,
	.amendment > p:last-child,
	.correction > p:last-child,
	.addition > p:last-child {
		margin-bottom: 0;
	}


	.issue::before, .issue > .marker,
	.example::before, .example > .marker,
	.note::before, .note > .marker,
	details.note > summary > .marker,
	.amendment::before, .amendment > .marker,
	details.amendment > summary > .marker,
	.addition::before, .addition > .marker,
	addition.amendment > summary > .marker,
	.correction::before, .correction > .marker,
	correction.amendment > summary > .marker
	{
		text-transform: uppercase;
		padding-right: 1em;
	}

	.example::before, .example > .marker {
		display: block;
		padding-right: 0em;
	}

/** Blockquotes ***************************************************************/

	blockquote {
		border-color: silver;
		border-color: var(--blockquote-border);
		background: transparent;
		background: var(--blockquote-bg);
		color: currentcolor;
		color: var(--blockquote-text);
	}

/** Open issue ****************************************************************/

	.issue {
		border-color: #e05252;
		border-color: var(--issue-border);
		background: #fbe9e9;
		background: var(--issue-bg);
		color: black;
		color: var(--issue-text);
		counter-increment: issue;
		overflow: auto;
	}
	.issue::before, .issue > .marker {
		color: #831616;
		color: var(--issueheading-text);
	}
	/* Add .issue::before { content: "Issue " counter(issue) " "; } for autogen numbers,
	  or use class="marker" to mark up the issue number in source. */

/** Example *******************************************************************/

	.example {
		border-color: #e0cb52;
		border-color: var(--example-border);
		background: #fcfaee;
		background: var(--example-bg);
		color: black;
		color: var(--example-text);
		counter-increment: example;
		overflow: auto;
		clear: both;
	}
	.example::before, .example > .marker {
		color: #574b0f;
		color: var(--exampleheading-text);
	}
	/* Add .example::before { content: "Example " counter(example) " "; } for autogen numbers,
	  or use class="marker" to mark up the example number in source. */

/** Non-normative Note ********************************************************/

	.note {
		border-color: #52e052;
		border-color: var(--note-border);
		background: #e9fbe9;
		background: var(--note-bg);
		color: black;
		color: var(--note-text);
		overflow: auto;
	}

	.note::before, .note > .marker,
	details.note > summary {
		color: hsl(120, 70%, 30%);
		color: var(--noteheading-text);
	}
	/* Add .note::before { content: "Note "; } for autogen label,
	  or use class="marker" to mark up the label in source. */

	details.note[open] > summary {
		border-bottom: 1px silver solid;
		border-bottom: 1px var(--notesummary-underline) solid;
	}

/** Assertion Box *************************************************************/
	/*  for assertions in algorithms */

	.assertion {
		border-color: #AAA;
		border-color: var(--assertion-border);
		background: #EEE;
		background: var(--assertion-bg);
		color: black;
		color: var(--assertion-text);
	}

/** Advisement Box ************************************************************/
	/*  for attention-grabbing normative statements */

	.advisement {
		border-color: orange;
		border-color: var(--advisement-border);
		border-style: none solid;
		background: #fec;
		background: var(--advisement-bg);
		color: black;
		color: var(--advisement-text);
	}
	strong.advisement {
		display: block;
		text-align: center;
	}
	.advisement::before, .advisement > .marker {
		color: #b35f00;
		color: var(--advisementheading-text);
	}

/** Amendment Box *************************************************************/

	.amendment, .correction, .addition {
		border-color: #330099;
		border-color: var(--amendment-border);
		background: #F5F0FF;
		background: var(--amendment-bg);
		color: black;
		color: var(--amendment-text);
	}
	.amendment.proposed, .correction.proposed, .addition.proposed {
		border-style: solid;
		border-block-width: 0.25em;
	}
	.amendment::before, .amendment > .marker,
	details.amendment > summary::before, details.amendment > summary > .marker,
	.correction::before, .correction > .marker,
	details.correction > summary::before, details.correction > summary > .marker,
	.addition::before, .addition > .marker,
	details.addition > summary::before, details.addition > summary > .marker {
		color: #220066;
		color: var(--amendmentheading-text);
	}
	.amendment.proposed::before, .amendment.proposed > .marker,
	details.amendment.proposed > summary::before, details.amendment.proposed > summary > .marker,
	.correction.proposed::before, .correction.proposed > .marker,
	details.correction.proposed > summary::before, details.correction.proposed > summary > .marker,
	.addition.proposed::before, .addition.proposed > .marker,
	details.addition.proposed > summary::before, details.addition.proposed > summary > .marker {
		font-weight: bold;
	}

/** Spec Obsoletion Notice ****************************************************/
	/* obnoxious obsoletion notice for older/abandoned specs. */

	details {
		display: block;
	}
	summary {
		font-weight: bolder;
	}

	.annoying-warning:not(details),
	details.annoying-warning:not([open]) > summary,
	details.annoying-warning[open] {
		background: hsla(40,100%,50%,0.95);
		background: var(--warning-bg);
		color: black;
		color: var(--warning-text);
		padding: .75em 1em;
		border: red;
		border: var(--warning-border);
		border-style: solid none;
		box-shadow: 0 2px 8px black;
		text-align: center;
	}
	.annoying-warning :last-child {
		margin-bottom: 0;
	}

@media not print {
	details.annoying-warning[open] {
		position: fixed;
		left: 0;
		right: 0;
		bottom: 2em;
		z-index: 1000;
	}
}

	details.annoying-warning:not([open]) > summary {
		text-align: center;
	}

/** Entity Definition Boxes ***************************************************/

	.def {
		padding: .5em 1em;
		background: #def;
		background: var(--def-bg);
		margin: 1.2em 0;
		border-left: 0.5em solid #8ccbf2;
		border-left: 0.5em solid var(--def-border);
		color: black;
		color: var(--def-text);
	}

/******************************************************************************/
/*                                    Tables                                  */
/******************************************************************************/

	th, td {
		text-align: left;
		text-align: start;
	}

/** Property/Descriptor Definition Tables *************************************/

	table.def {
		/* inherits .def box styling, see above */
		width: 100%;
		border-spacing: 0;
	}

	table.def td,
	table.def th {
		padding: 0.5em;
		vertical-align: baseline;
		border-bottom: 1px solid #bbd7e9;
		border-bottom: 1px solid var(--defrow-border);
	}

	table.def > tbody > tr:last-child th,
	table.def > tbody > tr:last-child td {
		border-bottom: 0;
	}

	table.def th {
		font-style: italic;
		font-weight: normal;
		padding-left: 1em;
		width: 3em;
	}

	/* For when values are extra-complex and need formatting for readability */
	table td.pre {
		white-space: pre-wrap;
	}

	/* A footnote at the bottom of a def table */
	table.def td.footnote {
		padding-top: 0.6em;
	}
	table.def td.footnote::before {
		content: " ";
		display: block;
		height: 0.6em;
		width: 4em;
		border-top: thin solid;
	}

/** Data tables (and properly marked-up index tables) *************************/
	/*
		<table class="data"> highlights structural relationships in a table
		when correct markup is used (e.g. thead/tbody, th vs. td, scope attribute)

		Use class="complex data" for particularly complicated tables --
		(This will draw more lines: busier, but clearer.)

		Use class="long" on table cells with paragraph-like contents
		(This will adjust text alignment accordingly.)
		Alternately use class="longlastcol" on tables, to have the last column assume "long".
	*/

	table {
		word-wrap: normal;
		overflow-wrap: normal;
		hyphens: manual;
	}

	table.data,
	table.index {
		margin: 1em auto;
		border-collapse: collapse;
		border: hidden;
		width: 100%;
	}
	table.data caption,
	table.index caption {
		max-width: 50em;
		margin: 0 auto 1em;
	}

	table.data td,  table.data th,
	table.index td, table.index th {
		padding: 0.5em 1em;
		border-width: 1px;
		border-color: silver;
		border-color: var(--datacell-border);
		border-top-style: solid;
	}

	table.data thead td:empty {
		padding: 0;
		border: 0;
	}

	table.data  thead,
	table.index thead,
	table.data  tbody,
	table.index tbody {
		border-bottom: 2px solid;
	}

	table.data colgroup,
	table.index colgroup {
		border-left: 2px solid;
	}

	table.data  tbody th:first-child,
	table.index tbody th:first-child  {
		border-right: 2px solid;
		border-top: 1px solid silver;
		border-top: 1px solid var(--datacell-border);
		padding-right: 1em;
	}

	table.data th[colspan],
	table.data td[colspan] {
		text-align: center;
	}

	table.complex.data th,
	table.complex.data td {
		border: 1px solid silver;
		border: 1px solid var(--datacell-border);
		text-align: center;
	}

	table.data.longlastcol td:last-child,
	table.data td.long {
		vertical-align: baseline;
		text-align: left;
	}

	table.data img {
		vertical-align: middle;
	}


/*
Alternate table alignment rules

	table.data,
	table.index {
		text-align: center;
	}

	table.data  thead th[scope="row"],
	table.index thead th[scope="row"] {
		text-align: right;
	}

	table.data  tbody th:first-child,
	table.index tbody th:first-child  {
		text-align: right;
	}

Possible extra rowspan handling

	table.data  tbody th[rowspan]:not([rowspan='1']),
	table.index tbody th[rowspan]:not([rowspan='1']),
	table.data  tbody td[rowspan]:not([rowspan='1']),
	table.index tbody td[rowspan]:not([rowspan='1']) {
		border-left: 1px solid silver;
	}

	table.data  tbody th[rowspan]:first-child,
	table.index tbody th[rowspan]:first-child,
	table.data  tbody td[rowspan]:first-child,
	table.index tbody td[rowspan]:first-child{
		border-left: 0;
		border-right: 1px solid silver;
	}
*/

/******************************************************************************/
/*                                  Indices                                   */
/******************************************************************************/


/** Table of Contents *********************************************************/

	.toc a {
		/* More spacing; use padding to make it part of the click target. */
		padding: 0.1rem 1px 0;
		/* Larger, more consistently-sized click target */
		display: block;
		/* Switch to using border-bottom for underlines */
		text-decoration: none;
		border-bottom: 1px solid;
		/* Reverse color scheme */
		color: black;
		color: var(--toclink-text);
		border-color: #3980b5;
		border-color: var(--toclink-underline);
	}
	.toc a:visited {
		color: black;
		color: var(--toclink-visited-text);
		border-color: #054572;
		border-color: var(--toclink-visited-underline);
	}
	.toc a:focus,
	.toc a:hover {
		background: rgba(75%, 75%, 75%, .25);
		background: var(--a-hover-bg);
		border-bottom-width: 3px;
		margin-bottom: -2px;
	}
	.toc a:not(:focus):not(:hover) {
		/* Allow colors to cascade through from link styling */
		border-bottom-color: transparent;
	}

	.toc, .toc ol, .toc ul, .toc li {
		list-style: none; /* Numbers must be inlined into source */
		/* because generated content isn't search/selectable and markers can't do multilevel yet */
		margin:  0;
		padding: 0;
	}
	.toc {
		line-height: 1.1em;
	}

	/* ToC not indented until third level, but font style & margins show hierarchy */
	.toc > li			{ font-weight: bold;   }
	.toc > li li		 { font-weight: normal; }
	.toc > li li li	  { font-size:   95%;	}
	.toc > li li li li	{ font-size:   90%;	}
	.toc > li li li li li { font-size:   85%;	}

	/* @supports not (display:grid) { */
		.toc > li			{ margin: 1.5rem 0;	}
		.toc > li li		 { margin: 0.3rem 0;	}
		.toc > li li li	  { margin-left: 2rem;   }

		/* Section numbers in a column of their own */
		.toc .secno {
			float: left;
			width: 4rem;
			white-space: nowrap;
		}
		.toc > li li li li .secno { font-size: 85%; }
		.toc > li li li li li .secno { font-size: 100%; }

		.toc li {
			clear: both;
		}

		:not(li) > .toc			 { margin-left:  5rem; }
		.toc .secno				 { margin-left: -5rem; }
		.toc > li li li .secno	  { margin-left: -7rem; }
		.toc > li li li li .secno	{ margin-left: -9rem; }
		.toc > li li li li li .secno { margin-left: -11rem; }

		/* Tighten up indentation in narrow ToCs */
		@media (max-width: 30em) {
			:not(li) > .toc			 { margin-left:  4rem; }
			.toc .secno				 { margin-left: -4rem; }
			.toc > li li li			 { margin-left:  1rem; }
			.toc > li li li .secno	  { margin-left: -5rem; }
			.toc > li li li li .secno	{ margin-left: -6rem; }
			.toc > li li li li li .secno { margin-left: -7rem; }
		}
		/* Loosen it on wide screens */
		@media screen and (min-width: 78em) {
			body:not(.toc-inline) :not(li) > .toc			 { margin-left:  4rem; }
			body:not(.toc-inline) .toc .secno				 { margin-left: -4rem; }
			body:not(.toc-inline) .toc > li li li			 { margin-left:  1rem; }
			body:not(.toc-inline) .toc > li li li .secno	  { margin-left: -5rem; }
			body:not(.toc-inline) .toc > li li li li .secno	{ margin-left: -6rem; }
			body:not(.toc-inline) .toc > li li li li li .secno { margin-left: -7rem; }
	}
	/* } */

	@supports (display:grid) and (display:contents) {
		/* Use #toc over .toc to override non-@supports rules. */
		#toc {
			display: grid;
			align-content: start;
			grid-template-columns: auto 1fr;
			grid-column-gap: 1rem;
			column-gap: 1rem;
			grid-row-gap: .6rem;
			row-gap: .6rem;
		}
		#toc h2 {
			grid-column: 1 / -1;
			margin-bottom: 0;
		}
		#toc ol,
		#toc li,
		#toc a {
			display: contents;
			/* Switch <a> to subgrid when supported */
		}
		#toc span {
			margin: 0;
		}
		#toc > .toc > li > a > span {
			/* The spans of the top-level list,
			  comprising the first items of each top-level section. */
			margin-top: 1.1rem;
		}
		#toc#toc .secno { /* Ugh, need more specificity to override base.css */
			grid-column: 1;
			width: auto;
			margin-left: 0;
		}
		#toc .content {
			grid-column: 2;
			width: auto;
			margin-right: 1rem;
			border-bottom: 3px solid transparent;
			margin-bottom: -3px;
		}
		#toc .content:hover,
		#toc .content:focus {
			background: rgba(75%, 75%, 75%, .25);
			background: var(--a-hover-bg);
			border-bottom-color: #054572;
			border-bottom-color: var(--toclink-underline);
		}
		#toc li li li .content {
			margin-left: 1rem;
		}
		#toc li li li li .content {
			margin-left: 2rem;
		}
	}


/** Index *********************************************************************/

	/* Index Lists: Layout */
	ul.index	  { margin-left: 0; columns: 15em; text-indent: 1em hanging; }
	ul.index li	{ margin-left: 0; list-style: none; break-inside: avoid; }
	ul.index li li { margin-left: 1em; }
	ul.index dl	{ margin-top: 0; }
	ul.index dt	{ margin: .2em 0 .2em 20px;}
	ul.index dd	{ margin: .2em 0 .2em 40px;}
	/* Index Lists: Typography */
	ul.index ul,
	ul.index dl { font-size: smaller; }
	@media not print {
		ul.index li a + span {
			white-space: nowrap;
			color: transparent; }
		ul.index li a:hover + span,
		ul.index li a:focus + span {
			color: #707070;
			color: var(--indexinfo-text);
		}
	}

/** Index Tables *****************************************************/
	/* See also the data table styling section, which this effectively subclasses */

	table.index {
		font-size: small;
		border-collapse: collapse;
		border-spacing: 0;
		text-align: left;
		margin: 1em 0;
	}

	table.index td,
	table.index th {
		padding: 0.4em;
	}

	table.index tr:hover td:not([rowspan]),
	table.index tr:hover th:not([rowspan]) {
		color: black;
		color: var(--indextable-hover-text);
		background: #f7f8f9;
		background: var(--indextable-hover-bg);
	}

	/* The link in the first column in the property table (formerly a TD) */
	table.index th:first-child a {
		font-weight: bold;
	}

/** Outdated warning **********************************************************/

.outdated-spec {
	color: black;
	color: var(--outdatedspec-text);
	background-color: rgba(0,0,0,0.5);
	background-color: var(--outdatedspec-bg);
}

.outdated-warning {
	position: fixed;
	bottom: 50%;
	left: 0;
	right: 0;
	margin: 0 auto;
	width: 50%;
	background: maroon;
	background: var(--outdated-bg);
	color: white;
	color: var(--outdated-text);
	border-radius: 1em;
	box-shadow: 0 0 1em red;
	box-shadow: 0 0 1em var(--outdated-shadow);
	padding: 2em;
	text-align: center;
	z-index: 2;
}

.outdated-warning a {
	color: currentcolor;
	background: transparent;
}

.edited-rec-warning {
	background: darkorange;
	background: var(--editedrec-bg);
	box-shadow: 0 0 1em;
}

.outdated-warning button {
	color: var(--outdated-text);
	border-radius: 1em;
	box-shadow: 0 0 1em red;
	box-shadow: 0 0 1em var(--outdated-shadow);
	padding: 2em;
	text-align: center;
	z-index: 2;
}

.outdated-warning a {
	color: currentcolor;
	background: transparent;
}

.edited-rec-warning {
	background: darkorange;
	background: var(--editedrec-bg);
	box-shadow: 0 0 1em;
}

.outdated-warning button {
	position: absolute;
	top: 0;
	right:0;
	margin: 0;
	border: 0;
	padding: 0.25em 0.5em;
	background: transparent;
	color: white;
	color: var(--outdated-text);
	font:1em sans-serif;
	text-align:center;
}

.outdated-warning span {
	display: block;
}

.outdated-collapsed {
	bottom: 0;
	border-radius: 0;
	width: 100%;
	padding: 0;
}

/******************************************************************************/
/*                                    Print                                   */
/******************************************************************************/

	@media print {
		/* Pages have their own margins. */
		html {
			margin: 0;
		}
		/* Serif for print. */
		body {
			font-family: serif;
		}

		.outdated-warning {
			position: absolute;
			border-style: solid;
			border-color: red;
		}

		.outdated-warning input {
			display: none;
		}
	}
	@page {
		margin: 1.5cm 1.1cm;
	}



/******************************************************************************/
/*                             Overflow Control                               */
/******************************************************************************/

	.figure .caption, .sidefigure .caption, figcaption {
		/* in case figure is overlarge, limit caption to 50em */
		max-width: 50rem;
		margin-left: auto;
		margin-right: auto;
	}
	.overlarge {
		/* Magic to create good item positioning:
		  "content column" is 50ems wide at max; less on smaller screens.
		  Extra space (after ToC + content) is empty on the right.

		  1. When item < content column, centers item in column.
		  2. When content < item < available, left-aligns.
		  3. When item > available, fills available + scroll bar.
		*/
		display: grid;
		grid-template-columns: minmax(0, 50em);
	}
	.overlarge > table {
		/* limit preferred width of table */
		max-width: 50em;
		margin-left: auto;
		margin-right: auto;
	}

	@media (min-width: 55em) {
		.overlarge {
			margin-right: calc(13px + 26.5rem - 50vw);
			max-width: none;
		}
	}
	@media screen and (min-width: 78em) {
		body:not(.toc-inline) .overlarge {
			/* 30.5em body padding 50em content area */
			margin-right: calc(40em - 50vw) !important;
		}
	}
	@media screen and (min-width: 90em) {
		body:not(.toc-inline) .overlarge {
			/* 4em html margin 30.5em body padding 50em content area */
			margin-right: calc(84.5em - 100vw) !important;
		}
	}

	@media not print {
		.overlarge {
			overflow-x: auto;
			/* See Lea Verou's explanation background-attachment:
			* http://lea.verou.me/2012/04/background-attachment-local/
			*
			background: top left  / 4em 100% linear-gradient(to right,  #ffffff, rgba(255, 255, 255, 0)) local,
						top right / 4em 100% linear-gradient(to left, #ffffff, rgba(255, 255, 255, 0)) local,
						top left  / 1em 100% linear-gradient(to right,  #c3c3c5, rgba(195, 195, 197, 0)) scroll,
						top right / 1em 100% linear-gradient(to left, #c3c3c5, rgba(195, 195, 197, 0)) scroll,
						white;
			background-repeat: no-repeat;
			*/
		}
	}
</style>
<style>
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      vertical-align: top;
    }
    th, td {
      border-left: none;
      border-right: none;
      padding: 0px 10px;
    }
    th {
      text-align: center;
    }
  </style>
  <meta content="Bikeshed version c3a8ac783, updated Wed Jul 24 12:20:06 2024 -0700" name="generator">
  <link href="https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Functions%20with%20Data%20-%20Closures%20in%20C.html" rel="canonical">
  <link href="https://isocpp.org/favicon.ico" rel="icon">
  <meta content="ff8fad63c344026ba793e113dd8af3bd29588dcc" name="revision">
  <meta content="dark light" name="color-scheme">
<style>
:root {
	/* Default (light) theme */
	--foreground-point: rgb(0,0,0);
	--background-point: rgb(255,255,255);

	--ins-text-color: rgb(0, 182, 15);
	--diff-ins-text-color: rgb(0, 176, 189);
	--del-text-color: rgb(255, 58, 58);
	--diff-del-text-color: rgb(139, 0, 194);
}

/* dark theme */
@media (prefers-color-scheme: dark) {
	:root {
		--foreground-point: rgb(255,255,255);
		--background-point: rgb(0,0,0);

		--ins-text-color: rgb(48, 255, 48);
		--diff-ins-text-color: rgb(91, 250, 255);
		--del-text-color: rgb(255, 52, 52);
		--diff-del-text-color: rgb(244, 129, 255);
	}
}

:root {
	--ins-text-background-color: color-mix(in srgb, var(--ins-text-color) 5%, var(--background-point));
	--ins-code-background-color: color-mix(in srgb, var(--ins-text-color) 15%, var(--background-point));
	--ins-text-decoration-color: color-mix(in srgb, var(--ins-text-color) 10%, var(--foreground-point));
	--ins-text-border-color: color-mix(in srgb, var(--ins-text-color) 50%, var(--foreground-point));
	--diff-ins-text-background-color: color-mix(in srgb, var(--diff-ins-text-color) 5%, var(--background-point));
	--diff-ins-code-background-color: color-mix(in srgb, var(--diff-ins-text-color) 15%, var(--background-point));
	--diff-ins-text-decoration-color: color-mix(in srgb, var(--diff-ins-text-color) 10%, var(--foreground-point));

	--del-text-background-color: color-mix(in srgb, var(--del-text-color) 5%, var(--background-point));
	--del-code-background-color: color-mix(in srgb, var(--del-text-color) 15%, var(--background-point));
	--del-text-decoration-color: color-mix(in srgb, var(--del-text-color) 10%, var(--foreground-point));
	--diff-del-text-background-color: color-mix(in srgb, var(--diff-del-text-color) 5%, var(--background-point));
	--diff-del-code-background-color: color-mix(in srgb, var(--diff-del-text-color) 15%, var(--background-point));
	--diff-del-text-decoration-color: color-mix(in srgb, var(--diff-del-text-color) 10%, var(--foreground-point));
}

@media print {
	.pagebreak { break-after: always }
}

ins .wording-section .highlight:not(.idl) { background: var(--ins-code-background-color); }
diff-ins .wording-section .highlight:not(.idl) { background: var(--diff-ins-code-background-color); }
del .wording-section .highlight:not(.idl) { background: var(--del-code-background-color); }
diff-del .wording-section .highlight:not(.idl) { background: var(--diff-del-code-background-color); }


.tg  {
	border-collapse: collapse;
	border-spacing:0;
}

.tg td{
	padding:10px 10px;
	border-style: solid;
	border-width:1px;
	overflow: hidden;
	word-break: normal;
	border-color: var(--foreground-point, unset);
}
.tg th{
	font-weight: normal;
	padding: 10px 10px;
	border-style: solid;
	border-width: 1px;
	overflow: hidden;
	word-break: normal;
	border-color: black;
}
.tg .tg-c3ow { 
	border-color: unset;
	text-align: center;
	vertical-align: top
}

.quote-ins, quote-ins, quote-ins p, quote-ins div, span.quote-ins, span.quote-ins * {
	border-color: var(--ins-text-border-color);
}

.ins, ins, ins p, ins div, span.ins, span.ins * {
	background-color: var(--ins-text-background-color);
	background: var(--ins-text-background-color);
	color: var(--ins-text-color);
	text-decoration: underline;
	text-decoration-color: var(--ins-text-decoration-color);
	border-color: var(--ins-text-decoration-color);
}

.diff-ins, diff-ins, diff-ins p, diff-ins div, span.diff-ins, span.diff-ins * {
	background-color: var(--diff-ins-text-background-color);
	background: var(--diff-ins-text-background-color);
	color: var(--diff-ins-text-color);
	text-decoration: underline double;
	text-decoration-color: var(--diff-ins-text-decoration-color);
}

.del, del, del p, del div, span.del, span.del * {
	background-color: var(--del-text-background-color);
	background: var(--del-text-background-color);
	color: var(--del-text-color);
	text-decoration: line-through;
	text-decoration-color: var(--del-text-decoration-color);
}

.diff-del, diff-del, diff-del p, diff-del div, span.diff-del, span.diff-del * {
	background-color: var(--diff-del-text-background-color);
	background: var(--diff-del-text-background-color);
	color: var(--diff-del-text-color);
	text-decoration: line-through double;
	text-decoration-color: var(--diff-del-text-decoration-color);
}

code.c-kw {
	font-weight: bold;
}

math, span.math {
	font-family: serif;
	font-style: italic;
}

ul {
	list-style-type: "— ";
}

.wording-clause {
	counter-reset: wording-paragraph;
}

.wording-clause-header {
	font-size: 115%;
	display: block;
	padding-bottom: 1em;
	clear: both;
}

.wording-clause-number {
	font-weight: bold;
}

.wording-clause-title {
	font-weight: bold;
	margin: 2em;
}

.wording-clause-stable-tag {
	float: right;
}

.wording-clause-section-title {
	font-size: 105%;
	font-weight: bold;
}

.clause-stable-tag {
	float: right;
}

.footnote-ref {
	font-size: 75%;
	vertical-align: super;
}

.footnote {
	font-size: 75%;
	vertical-align: bottom;
}

table.invis, table.printf-specifiers {
	padding: 15px;
	border: 0px;
	tr {
		border: 0px;
	}
	th {
		width: 13%;
		border: 0px;
	}
	th ~ th {
		width:initial;
		border: 0px;
	}
	td {
		border: 0px;
	}
}

table.basic {
	*, tbody {
		margin: auto;
		tr {
			border: 1px solid var(--foreground-point);
			margin: auto;
		}
		td {
			border: 1px solid var(--foreground-point);
			margin: auto;
		}
		th {
			border: 1px solid var(--foreground-point);
			margin: auto;
		}
	}
}

div.wording-section {
	counter-reset: wording-paragraph;
}

div.wording-numbered, div.wording-newnumbered,
div.wording-numbered-continued, div.wording-newnumbered-continued {
	margin-left: 2.5em;
	margin-top: 1em;
	margin-bottom: 1em;
}

div.wording-numbered:before, div.wording-newnumbered:before,
div.wording-continue-numbered:before, div.wording-continue-newnumbered:before {
	position: absolute;
	margin-left: -2.5em;
	display: block;
}

div.wording-numbered:before {
	content: counter(wording-paragraph);
	counter-increment: wording-paragraph;
	font-size: smaller;
}

div.wording-newnumbered:before {
	content: counter(wording-paragraph)"✨";
	counter-increment: wording-paragraph;
	font-size: smaller;
}

div.wording-numbered-list ul, div.wording-newnumbered ul {
	counter-reset: wording-list-item;
}

div.wording-numbered-list li, div.wording-newnumbered li {
	margin-left: 4em;
}

div.wording-numbered-list li:before, div.wording-newnumbered li:before {
	position: absolute;
	margin-left: -4em;
	display: block;
}

div.wording-numbered-list li:before {
	font-size: smaller;
	content: "(" counter(wording-paragraph) "." counter(wording-list-item) ")";
	counter-increment: wording-list-item;
}

div.wording-newnumbered-list li:before {
	content: "(✨" counter(wording-paragraph) "." counter(wording-list-item) ")";
	counter-increment: wording-list-item;
}

div.wording-numbered-0 {
	counter-reset: wording-paragraph -1;
}

div.wording-numbered-1 {
	counter-reset: wording-paragraph 0;
}

div.wording-numbered-2 {
	counter-reset: wording-paragraph 1;
}

div.wording-numbered-3 {
	counter-reset: wording-paragraph 2;
}

div.wording-numbered-4 {
	counter-reset: wording-paragraph 3;
}

div.wording-numbered-5 {
	counter-reset: wording-paragraph 4;
}

div.wording-numbered-6 {
	counter-reset: wording-paragraph 5;
}

div.wording-numbered-7 {
	counter-reset: wording-paragraph 6;
}

div.wording-numbered-8 {
	counter-reset: wording-paragraph 7;
}

div.wording-numbered-9 {
	counter-reset: wording-paragraph 8;
}

div.wording-numbered-10 {
	counter-reset: wording-paragraph 9;
}

div.wording-numbered-11 {
	counter-reset: wording-paragraph 10;
}

div.wording-numbered-12 {
	counter-reset: wording-paragraph 11;
}

div.wording-numbered-13 {
	counter-reset: wording-paragraph 12;
}

div.wording-numbered-14 {
	counter-reset: wording-paragraph 13;
}

div.wording-numbered-15 {
	counter-reset: wording-paragraph 14;
}

div.wording-numbered-16 {
	counter-reset: wording-paragraph 15;
}

div.wording-numbered-17 {
	counter-reset: wording-paragraph 16;
}

div.wording-numbered-18 {
	counter-reset: wording-paragraph 17;
}

div.wording-numbered-19 {
	counter-reset: wording-paragraph 18;
}

div.wording-numbered-20 {
	counter-reset: wording-paragraph 19;
}

div.wording-numbered-21 {
	counter-reset: wording-paragraph 20;
}

div.wording-numbered-22 {
	counter-reset: wording-paragraph 21;
}

div.wording-numbered-23 {
	counter-reset: wording-paragraph 22;
}

div.wording-numbered-24 {
	counter-reset: wording-paragraph 23;
}

div.wording-numbered-25 {
	counter-reset: wording-paragraph 24;
}

div.wording-numbered-26 {
	counter-reset: wording-paragraph 27;
}

div.wording-numbered-27 {
	counter-reset: wording-paragraph 26;
}

div.wording-numbered-28 {
	counter-reset: wording-paragraph 27;
}

div.wording-numbered-29 {
	counter-reset: wording-paragraph 28;
}

div.wording-numbered-30 {
	counter-reset: wording-paragraph 29;
}

div.wording-numbered-31 {
	counter-reset: wording-paragraph 30;
}

div.wording-numbered-32 {
	counter-reset: wording-paragraph 31;
}

div.wording-numbered-33 {
	counter-reset: wording-paragraph 32;
}

div.wording-numbered-34 {
	counter-reset: wording-paragraph 33;
}

div.wording-numbered-35 {
	counter-reset: wording-paragraph 34;
}

div.wording-numbered-36 {
	counter-reset: wording-paragraph 35;
}

div.wording-numbered-37 {
	counter-reset: wording-paragraph 36;
}

div.wording-numbered-38 {
	counter-reset: wording-paragraph 37;
}

div.wording-numbered-39 {
	counter-reset: wording-paragraph 38;
}
</style>
<style>/* Boilerplate: style-autolinks */
.css.css, .property.property, .descriptor.descriptor {
    color: var(--a-normal-text);
    font-size: inherit;
    font-family: inherit;
}
.css::before, .property::before, .descriptor::before {
    content: "‘";
}
.css::after, .property::after, .descriptor::after {
    content: "’";
}
.property, .descriptor {
    /* Don't wrap property and descriptor names */
    white-space: nowrap;
}
.type { /* CSS value <type> */
    font-style: italic;
}
pre .property::before, pre .property::after {
    content: "";
}
[data-link-type="property"]::before,
[data-link-type="propdesc"]::before,
[data-link-type="descriptor"]::before,
[data-link-type="value"]::before,
[data-link-type="function"]::before,
[data-link-type="at-rule"]::before,
[data-link-type="selector"]::before,
[data-link-type="maybe"]::before {
    content: "‘";
}
[data-link-type="property"]::after,
[data-link-type="propdesc"]::after,
[data-link-type="descriptor"]::after,
[data-link-type="value"]::after,
[data-link-type="function"]::after,
[data-link-type="at-rule"]::after,
[data-link-type="selector"]::after,
[data-link-type="maybe"]::after {
    content: "’";
}

[data-link-type].production::before,
[data-link-type].production::after,
.prod [data-link-type]::before,
.prod [data-link-type]::after {
    content: "";
}

[data-link-type=element],
[data-link-type=element-attr] {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", monospace;
    font-size: .9em;
}
[data-link-type=element]::before { content: "<" }
[data-link-type=element]::after  { content: ">" }

[data-link-type=biblio] {
    white-space: pre;
}

@media (prefers-color-scheme: dark) {
    :root {
        --selflink-text: black;
        --selflink-bg: silver;
        --selflink-hover-text: white;
    }
}
</style>
<style>/* Boilerplate: style-colors */
/* Any --*-text not paired with a --*-bg is assumed to have a transparent bg */
:root {
    color-scheme: light dark;

    --text: black;
    --bg: white;

    --unofficial-watermark: url(https://www.w3.org/StyleSheets/TR/2016/logos/UD-watermark);

    --logo-bg: #1a5e9a;
    --logo-active-bg: #c00;
    --logo-text: white;

    --tocnav-normal-text: #707070;
    --tocnav-normal-bg: var(--bg);
    --tocnav-hover-text: var(--tocnav-normal-text);
    --tocnav-hover-bg: #f8f8f8;
    --tocnav-active-text: #c00;
    --tocnav-active-bg: var(--tocnav-normal-bg);

    --tocsidebar-text: var(--text);
    --tocsidebar-bg: #f7f8f9;
    --tocsidebar-shadow: rgba(0,0,0,.1);
    --tocsidebar-heading-text: hsla(203,20%,40%,.7);

    --toclink-text: var(--text);
    --toclink-underline: #3980b5;
    --toclink-visited-text: var(--toclink-text);
    --toclink-visited-underline: #054572;

    --heading-text: #005a9c;

    --hr-text: var(--text);

    --algo-border: #def;

    --del-text: red;
    --del-bg: transparent;
    --ins-text: #080;
    --ins-bg: transparent;

    --a-normal-text: #034575;
    --a-normal-underline: #bbb;
    --a-visited-text: var(--a-normal-text);
    --a-visited-underline: #707070;
    --a-hover-bg: rgba(75%, 75%, 75%, .25);
    --a-active-text: #c00;
    --a-active-underline: #c00;

    --blockquote-border: silver;
    --blockquote-bg: transparent;
    --blockquote-text: currentcolor;

    --issue-border: #e05252;
    --issue-bg: #fbe9e9;
    --issue-text: var(--text);
    --issueheading-text: #831616;

    --example-border: #e0cb52;
    --example-bg: #fcfaee;
    --example-text: var(--text);
    --exampleheading-text: #574b0f;

    --note-border: #52e052;
    --note-bg: #e9fbe9;
    --note-text: var(--text);
    --noteheading-text: hsl(120, 70%, 30%);
    --notesummary-underline: silver;

    --assertion-border: #aaa;
    --assertion-bg: #eee;
    --assertion-text: black;

    --advisement-border: orange;
    --advisement-bg: #fec;
    --advisement-text: var(--text);
    --advisementheading-text: #b35f00;

    --warning-border: red;
    --warning-bg: hsla(40,100%,50%,0.95);
    --warning-text: var(--text);

    --amendment-border: #330099;
    --amendment-bg: #F5F0FF;
    --amendment-text: var(--text);
    --amendmentheading-text: #220066;

    --def-border: #8ccbf2;
    --def-bg: #def;
    --def-text: var(--text);
    --defrow-border: #bbd7e9;

    --datacell-border: silver;

    --indexinfo-text: #707070;

    --indextable-hover-text: black;
    --indextable-hover-bg: #f7f8f9;

    --outdatedspec-bg: rgba(0, 0, 0, .5);
    --outdatedspec-text: black;
    --outdated-bg: maroon;
    --outdated-text: white;
    --outdated-shadow: red;

    --editedrec-bg: darkorange;
}

@media (prefers-color-scheme: dark) {
    :root {
        --text: #ddd;
        --bg: black;

        --unofficial-watermark: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='400'%3E%3Cg fill='%23100808' transform='translate(200 200) rotate(-45) translate(-200 -200)' stroke='%23100808' stroke-width='3'%3E%3Ctext x='50%25' y='220' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EUNOFFICIAL%3C/text%3E%3Ctext x='50%25' y='305' style='font: bold 70px sans-serif; text-anchor: middle; letter-spacing: 6px;'%3EDRAFT%3C/text%3E%3C/g%3E%3C/svg%3E");

        --logo-bg: #1a5e9a;
        --logo-active-bg: #c00;
        --logo-text: white;

        --tocnav-normal-text: #999;
        --tocnav-normal-bg: var(--bg);
        --tocnav-hover-text: var(--tocnav-normal-text);
        --tocnav-hover-bg: #080808;
        --tocnav-active-text: #f44;
        --tocnav-active-bg: var(--tocnav-normal-bg);

        --tocsidebar-text: var(--text);
        --tocsidebar-bg: #080808;
        --tocsidebar-shadow: rgba(255,255,255,.1);
        --tocsidebar-heading-text: hsla(203,20%,40%,.7);

        --toclink-text: var(--text);
        --toclink-underline: #6af;
        --toclink-visited-text: var(--toclink-text);
        --toclink-visited-underline: #054572;

        --heading-text: #8af;

        --hr-text: var(--text);

        --algo-border: #456;

        --del-text: #f44;
        --del-bg: transparent;
        --ins-text: #4a4;
        --ins-bg: transparent;

        --a-normal-text: #6af;
        --a-normal-underline: #555;
        --a-visited-text: var(--a-normal-text);
        --a-visited-underline: var(--a-normal-underline);
        --a-hover-bg: rgba(25%, 25%, 25%, .2);
        --a-active-text: #f44;
        --a-active-underline: var(--a-active-text);

        --borderedblock-bg: rgba(255, 255, 255, .05);

        --blockquote-border: silver;
        --blockquote-bg: var(--borderedblock-bg);
        --blockquote-text: currentcolor;

        --issue-border: #e05252;
        --issue-bg: var(--borderedblock-bg);
        --issue-text: var(--text);
        --issueheading-text: hsl(0deg, 70%, 70%);

        --example-border: hsl(50deg, 90%, 60%);
        --example-bg: var(--borderedblock-bg);
        --example-text: var(--text);
        --exampleheading-text: hsl(50deg, 70%, 70%);

        --note-border: hsl(120deg, 100%, 35%);
        --note-bg: var(--borderedblock-bg);
        --note-text: var(--text);
        --noteheading-text: hsl(120, 70%, 70%);
        --notesummary-underline: silver;

        --assertion-border: #444;
        --assertion-bg: var(--borderedblock-bg);
        --assertion-text: var(--text);

        --advisement-border: orange;
        --advisement-bg: #222218;
        --advisement-text: var(--text);
        --advisementheading-text: #f84;

        --warning-border: red;
        --warning-bg: hsla(40,100%,20%,0.95);
        --warning-text: var(--text);

        --amendment-border: #330099;
        --amendment-bg: #080010;
        --amendment-text: var(--text);
        --amendmentheading-text: #cc00ff;

        --def-border: #8ccbf2;
        --def-bg: #080818;
        --def-text: var(--text);
        --defrow-border: #136;

        --datacell-border: silver;

        --indexinfo-text: #aaa;

        --indextable-hover-text: var(--text);
        --indextable-hover-bg: #181818;

        --outdatedspec-bg: rgba(255, 255, 255, .5);
        --outdatedspec-text: black;
        --outdated-bg: maroon;
        --outdated-text: white;
        --outdated-shadow: red;

        --editedrec-bg: darkorange;
    }
    /* In case a transparent-bg image doesn't expect to be on a dark bg,
       which is quite common in practice... */
    img { background: white; }
}
</style>
<style>/* Boilerplate: style-counters */
body {
    counter-reset: example figure issue;
}
.issue {
    counter-increment: issue;
}
.issue:not(.no-marker)::before {
    content: "Issue " counter(issue);
}

.example {
    counter-increment: example;
}
.example:not(.no-marker)::before {
    content: "Example " counter(example);
}
.invalid.example:not(.no-marker)::before,
.illegal.example:not(.no-marker)::before {
    content: "Invalid Example" counter(example);
}

figcaption {
    counter-increment: figure;
}
figcaption:not(.no-marker)::before {
    content: "Figure " counter(figure) " ";
}
</style>
<style>/* Boilerplate: style-issues */
a[href].issue-return {
    float: right;
    float: inline-end;
    color: var(--issueheading-text);
    font-weight: bold;
    text-decoration: none;
}
</style>
<style>/* Boilerplate: style-md-lists */
/* This is a weird hack for me not yet following the commonmark spec
   regarding paragraph and lists. */
[data-md] > :first-child {
    margin-top: 0;
}
[data-md] > :last-child {
    margin-bottom: 0;
}
</style>
<style>/* Boilerplate: style-selflinks */
:root {
    --selflink-text: white;
    --selflink-bg: gray;
    --selflink-hover-text: black;
}
.heading, .issue, .note, .example, li, dt {
    position: relative;
}
a.self-link {
    position: absolute;
    top: 0;
    left: calc(-1 * (3.5rem - 26px));
    width: calc(3.5rem - 26px);
    height: 2em;
    text-align: center;
    border: none;
    transition: opacity .2s;
    opacity: .5;
}
a.self-link:hover {
    opacity: 1;
}
.heading > a.self-link {
    font-size: 83%;
}
.example > a.self-link,
.note > a.self-link,
.issue > a.self-link {
    /* These blocks are overflow:auto, so positioning outside
       doesn't work. */
    left: auto;
    right: 0;
}
li > a.self-link {
    left: calc(-1 * (3.5rem - 26px) - 2em);
}
dfn > a.self-link {
    top: auto;
    left: auto;
    opacity: 0;
    width: 1.5em;
    height: 1.5em;
    background: var(--selflink-bg);
    color: var(--selflink-text);
    font-style: normal;
    transition: opacity .2s, background-color .2s, color .2s;
}
dfn:hover > a.self-link {
    opacity: 1;
}
dfn > a.self-link:hover {
    color: var(--selflink-hover-text);
}

a.self-link::before            { content: "¶"; }
.heading > a.self-link::before { content: "§"; }
dfn > a.self-link::before      { content: "#"; }
</style>
<style>/* Boilerplate: style-syntax-highlighting */
code.highlight { padding: .1em; border-radius: .3em; }
pre.highlight, pre > code.highlight { display: block; padding: 1em; margin: .5em 0; overflow: auto; border-radius: 0; }

.highlight:not(.idl) { background: rgba(0, 0, 0, .03); }
c-[a] { color: #990055 } /* Keyword.Declaration */
c-[b] { color: #990055 } /* Keyword.Type */
c-[c] { color: #708090 } /* Comment */
c-[d] { color: #708090 } /* Comment.Multiline */
c-[e] { color: #0077aa } /* Name.Attribute */
c-[f] { color: #669900 } /* Name.Tag */
c-[g] { color: #222222 } /* Name.Variable */
c-[k] { color: #990055 } /* Keyword */
c-[l] { color: #000000 } /* Literal */
c-[m] { color: #000000 } /* Literal.Number */
c-[n] { color: #0077aa } /* Name */
c-[o] { color: #999999 } /* Operator */
c-[p] { color: #999999 } /* Punctuation */
c-[s] { color: #a67f59 } /* Literal.String */
c-[t] { color: #a67f59 } /* Literal.String.Single */
c-[u] { color: #a67f59 } /* Literal.String.Double */
c-[cp] { color: #708090 } /* Comment.Preproc */
c-[c1] { color: #708090 } /* Comment.Single */
c-[cs] { color: #708090 } /* Comment.Special */
c-[kc] { color: #990055 } /* Keyword.Constant */
c-[kn] { color: #990055 } /* Keyword.Namespace */
c-[kp] { color: #990055 } /* Keyword.Pseudo */
c-[kr] { color: #990055 } /* Keyword.Reserved */
c-[ld] { color: #000000 } /* Literal.Date */
c-[nc] { color: #0077aa } /* Name.Class */
c-[no] { color: #0077aa } /* Name.Constant */
c-[nd] { color: #0077aa } /* Name.Decorator */
c-[ni] { color: #0077aa } /* Name.Entity */
c-[ne] { color: #0077aa } /* Name.Exception */
c-[nf] { color: #0077aa } /* Name.Function */
c-[nl] { color: #0077aa } /* Name.Label */
c-[nn] { color: #0077aa } /* Name.Namespace */
c-[py] { color: #0077aa } /* Name.Property */
c-[ow] { color: #999999 } /* Operator.Word */
c-[mb] { color: #000000 } /* Literal.Number.Bin */
c-[mf] { color: #000000 } /* Literal.Number.Float */
c-[mh] { color: #000000 } /* Literal.Number.Hex */
c-[mi] { color: #000000 } /* Literal.Number.Integer */
c-[mo] { color: #000000 } /* Literal.Number.Oct */
c-[sb] { color: #a67f59 } /* Literal.String.Backtick */
c-[sc] { color: #a67f59 } /* Literal.String.Char */
c-[sd] { color: #a67f59 } /* Literal.String.Doc */
c-[se] { color: #a67f59 } /* Literal.String.Escape */
c-[sh] { color: #a67f59 } /* Literal.String.Heredoc */
c-[si] { color: #a67f59 } /* Literal.String.Interpol */
c-[sx] { color: #a67f59 } /* Literal.String.Other */
c-[sr] { color: #a67f59 } /* Literal.String.Regex */
c-[ss] { color: #a67f59 } /* Literal.String.Symbol */
c-[vc] { color: #0077aa } /* Name.Variable.Class */
c-[vg] { color: #0077aa } /* Name.Variable.Global */
c-[vi] { color: #0077aa } /* Name.Variable.Instance */
c-[il] { color: #000000 } /* Literal.Number.Integer.Long */

@media (prefers-color-scheme: dark) {
    .highlight:not(.idl) { background: rgba(255, 255, 255, .05); }

    c-[a] { color: #d33682 } /* Keyword.Declaration */
    c-[b] { color: #d33682 } /* Keyword.Type */
    c-[c] { color: #2aa198 } /* Comment */
    c-[d] { color: #2aa198 } /* Comment.Multiline */
    c-[e] { color: #268bd2 } /* Name.Attribute */
    c-[f] { color: #b58900 } /* Name.Tag */
    c-[g] { color: #cb4b16 } /* Name.Variable */
    c-[k] { color: #d33682 } /* Keyword */
    c-[l] { color: #657b83 } /* Literal */
    c-[m] { color: #657b83 } /* Literal.Number */
    c-[n] { color: #268bd2 } /* Name */
    c-[o] { color: #657b83 } /* Operator */
    c-[p] { color: #657b83 } /* Punctuation */
    c-[s] { color: #6c71c4 } /* Literal.String */
    c-[t] { color: #6c71c4 } /* Literal.String.Single */
    c-[u] { color: #6c71c4 } /* Literal.String.Double */
    c-[ch] { color: #2aa198 } /* Comment.Hashbang */
    c-[cp] { color: #2aa198 } /* Comment.Preproc */
    c-[cpf] { color: #2aa198 } /* Comment.PreprocFile */
    c-[c1] { color: #2aa198 } /* Comment.Single */
    c-[cs] { color: #2aa198 } /* Comment.Special */
    c-[kc] { color: #d33682 } /* Keyword.Constant */
    c-[kn] { color: #d33682 } /* Keyword.Namespace */
    c-[kp] { color: #d33682 } /* Keyword.Pseudo */
    c-[kr] { color: #d33682 } /* Keyword.Reserved */
    c-[ld] { color: #657b83 } /* Literal.Date */
    c-[nc] { color: #268bd2 } /* Name.Class */
    c-[no] { color: #268bd2 } /* Name.Constant */
    c-[nd] { color: #268bd2 } /* Name.Decorator */
    c-[ni] { color: #268bd2 } /* Name.Entity */
    c-[ne] { color: #268bd2 } /* Name.Exception */
    c-[nf] { color: #268bd2 } /* Name.Function */
    c-[nl] { color: #268bd2 } /* Name.Label */
    c-[nn] { color: #268bd2 } /* Name.Namespace */
    c-[py] { color: #268bd2 } /* Name.Property */
    c-[ow] { color: #657b83 } /* Operator.Word */
    c-[mb] { color: #657b83 } /* Literal.Number.Bin */
    c-[mf] { color: #657b83 } /* Literal.Number.Float */
    c-[mh] { color: #657b83 } /* Literal.Number.Hex */
    c-[mi] { color: #657b83 } /* Literal.Number.Integer */
    c-[mo] { color: #657b83 } /* Literal.Number.Oct */
    c-[sa] { color: #6c71c4 } /* Literal.String.Affix */
    c-[sb] { color: #6c71c4 } /* Literal.String.Backtick */
    c-[sc] { color: #6c71c4 } /* Literal.String.Char */
    c-[dl] { color: #6c71c4 } /* Literal.String.Delimiter */
    c-[sd] { color: #6c71c4 } /* Literal.String.Doc */
    c-[se] { color: #6c71c4 } /* Literal.String.Escape */
    c-[sh] { color: #6c71c4 } /* Literal.String.Heredoc */
    c-[si] { color: #6c71c4 } /* Literal.String.Interpol */
    c-[sx] { color: #6c71c4 } /* Literal.String.Other */
    c-[sr] { color: #6c71c4 } /* Literal.String.Regex */
    c-[ss] { color: #6c71c4 } /* Literal.String.Symbol */
    c-[fm] { color: #268bd2 } /* Name.Function.Magic */
    c-[vc] { color: #cb4b16 } /* Name.Variable.Class */
    c-[vg] { color: #cb4b16 } /* Name.Variable.Global */
    c-[vi] { color: #cb4b16 } /* Name.Variable.Instance */
    c-[vm] { color: #cb4b16 } /* Name.Variable.Magic */
    c-[il] { color: #657b83 } /* Literal.Number.Integer.Long */
}
</style>
 <body class="h-entry">
  <div class="head">
   <p data-fill-with="logo"></p>
   <h1 class="p-name no-ref" id="title">N37XA<br>Functions with Data - Closures in C (A Comprehensive Proposal Overviewing Blocks, Nested Functions, and Lambdas)</h1>
   <h2 class="no-num no-toc no-ref heading settled" id="profile-and-date"><span class="content">Published Proposal, <time class="dt-updated" datetime="2025-12-28">2025-12-28</time></span></h2>
   <div data-fill-with="spec-metadata">
    <dl>
     <dt>Previous Revisions:
     <dd><a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3694.htm">n3694 (r1)</a>, <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3657.htm">n3657</a>
     <dt class="editor">Authors:
     <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:phdofthehouse@gmail.com">JeanHeyd Meneide</a>
     <dd class="editor p-author h-card vcard"><a class="p-name fn u-email email" href="mailto:shepherd@soasis.org">Shepherd (Shepherd's Oasis LLC)</a>
     <dt>Paper Source:
     <dd><a href="https://thephd.dev/_vendor/future_cxx/papers/source/C%20-%20Functions%20with%20Data%20-%20Closures%20in%20C.bs">GitHub</a>
     <dt>Issue Tracking:
     <dd><a href="https://github.com/ThePhD/future_cxx/issues">GitHub</a>
     <dt>Project:
     <dd>ISO/IEC 9899 Programming Languages — C, ISO/IEC JTC1/SC22/WG14
     <dt>Proposal Category:
     <dd>Change Request, Feature Request
     <dt>Target:
     <dd>C2y
    </dl>
   </div>
   <div data-fill-with="warning"></div>
   <hr title="Separator for header">
  </div>
  <div class="p-summary" data-fill-with="abstract">
   <h2 class="no-num no-toc no-ref heading settled" id="abstract"><span class="content">Abstract</span></h2>
   <p>Nested Functions (GCC), Blocks (Clang &amp; Apple-derived compilers), Wide Function Pointers (Borland and existing C library functions), and Lambdas (C++) provide a series of takes on how to, effectively, bundle functions with data in different ways and transport that information to the caller. This proposal goes through the existing practice and enumerates their tradeoffs so as to propose the best possible solution to the problem space in C, prioritizing C-like syntax and avoiding pitfalls from the existing solutions.</p>
  </div>
  <nav data-fill-with="table-of-contents" id="toc">
   <h2 class="no-num no-toc no-ref" id="contents">Table of Contents</h2>
   <ol class="toc" role="directory">
    <li>
     <a href="#changelog"><span class="secno">1</span> <span class="content">Changelog</span></a>
     <ol class="toc">
      <li><a href="#changelog-r2"><span class="secno">1.1</span> <span class="content">Revision 2 - December 28<sup>th</sup>, 2025</span></a>
      <li><a href="#changelog-r1"><span class="secno">1.2</span> <span class="content">Revision 1 - October 6<sup>th</sup>, 2025</span></a>
      <li><a href="#changelog-r0"><span class="secno">1.3</span> <span class="content">Revision 0 - July 24<sup>th</sup>, 2025</span></a>
     </ol>
    <li>
     <a href="#intro"><span class="secno">2</span> <span class="content">Introduction and Motivation</span></a>
     <ol class="toc">
      <li><a href="#intro-preamble"><span class="secno">2.1</span> <span class="content">Preamble</span></a>
      <li>
       <a href="#intro-nested.functions"><span class="secno">2.2</span> <span class="content">GNU Nested Functions</span></a>
       <ol class="toc">
        <li><a href="#intro-nested.functions-security"><span class="secno">2.2.1</span> <span class="content">Non-Executable Stacks</span></a>
        <li>
         <a href="#intro-nested.functions-design"><span class="secno">2.2.2</span> <span class="content">Early Design Flaw: Nested Functions turn the stack Executable!</span></a>
         <ol class="toc">
          <li><a href="#intro-nested.functions-security-popularity"><span class="secno">2.2.2.1</span> <span class="content">The Prevalence of Executable Stack, and GNU Nested Functions</span></a>
          <li><a href="#intro-nested.functions-security-blame"><span class="secno">2.2.2.2</span> <span class="content">The Standard Is To Blame</span></a>
         </ol>
        <li>
         <a href="#intro-nested.functions-alternative.implementations"><span class="secno">2.2.3</span> <span class="content">Alternative Nested Function Implementations</span></a>
         <ol class="toc">
          <li><a href="#intro-nested.functions-alternative.implementations-attempt.two"><span class="secno">2.2.3.1</span> <span class="content">Attempt 2</span></a>
          <li><a href="#intro-nested.functions-alternative.implementations-attempt.three"><span class="secno">2.2.3.2</span> <span class="content">Attempt 3</span></a>
          <li><a href="#intro-nested.functions-user.control"><span class="secno">2.2.3.3</span> <span class="content">A Possible 4th Attempt: Explicit User Control</span></a>
         </ol>
        <li><a href="#intro-nested.functions-captures"><span class="secno">2.2.4</span> <span class="content">The Nature of Captures</span></a>
        <li><a href="#intro-nested.functions-captures.no.workaround"><span class="secno">2.2.5</span> <span class="content">GNU Nested Functions By-Name Captures Cannot Be Worked Around Normally</span></a>
        <li><a href="#intro-nested.functions-context"><span class="secno">2.2.6</span> <span class="content">Additional Modifications for Nested Functions</span></a>
       </ol>
      <li>
       <a href="#intro-blocks"><span class="secno">2.3</span> <span class="content">Apple Blocks</span></a>
       <ol class="toc">
        <li><a href="#intro-blocks-expression"><span class="secno">2.3.1</span> <span class="content">Expression</span></a>
        <li>
         <a href="#intro-blocks-runtime"><span class="secno">2.3.2</span> <span class="content">Runtime Required</span></a>
         <ol class="toc">
          <li><a href="#intro-blocks-runtime-stack.based"><span class="secno">2.3.2.1</span> <span class="content">More Complications: Generally Unsafe to Return</span></a>
         </ol>
        <li><a href="#intro-blocks-captures"><span class="secno">2.3.3</span> <span class="content">Captures</span></a>
        <li><a href="#intro-blocks-escapes"><span class="secno">2.3.4</span> <span class="content">Optimization: Folding Escapes</span></a>
        <li><a href="#intro-blocks-trampoline"><span class="secno">2.3.5</span> <span class="content">(Explicit) Trampolines: Page-based Non-Executable Implementation</span></a>
       </ol>
      <li>
       <a href="#intro-lambdas"><span class="secno">2.4</span> <span class="content">C++-Style Lambdas</span></a>
       <ol class="toc">
        <li><a href="#intro-lambdas-captures"><span class="secno">2.4.1</span> <span class="content">Captures and Data</span></a>
        <li><a href="#intro-lambdas-destructors"><span class="secno">2.4.2</span> <span class="content">What About Lifetime / Destructors?</span></a>
       </ol>
      <li><a href="#intro-function.literals"><span class="secno">2.5</span> <span class="content">Function Literals and Local Functions</span></a>
      <li><a href="#intro-static.chain"><span class="secno">2.6</span> <span class="content"><code class="highlight"><c- n>__builtin_call_with_static_chain</c-></code></span></a>
      <li><a href="#intro-solution"><span class="secno">2.7</span> <span class="content">Solution</span></a>
     </ol>
    <li>
     <a href="#design"><span class="secno">3</span> <span class="content">Design</span></a>
     <ol class="toc">
      <li>
       <a href="#design-no"><span class="secno">3.1</span> <span class="content">What is NOT Being Proposed!</span></a>
       <ol class="toc">
        <li><a href="#design-no-statement.expressions"><span class="secno">3.1.1</span> <span class="content">Statement Expressions?</span></a>
        <li><a href="#design-no-wide.function.pointer"><span class="secno">3.1.2</span> <span class="content">Wide Function Pointer Type?</span></a>
       </ol>
      <li>
       <a href="#design-capture.functions"><span class="secno">3.2</span> <span class="content">Capture Functions: Rehydrated Nested Function</span></a>
       <ol class="toc">
        <li><a href="#design-capture.functions-complete.objects"><span class="secno">3.2.1</span> <span class="content">Capture Functions are Complete Objects (unless only Declared)</span></a>
        <li><a href="#design-capture.functions-unique.types"><span class="secno">3.2.2</span> <span class="content">Deduced Return Types, Unique Types</span></a>
        <li><a href="#design-capture.functions-data.captures"><span class="secno">3.2.3</span> <span class="content">Data Captures are Explicit</span></a>
        <li><a href="#design-capture.functions-data.captures.rename"><span class="secno">3.2.4</span> <span class="content">Data Captures can be Renamed</span></a>
        <li><a href="#design-capture.functions-data.captures.fields"><span class="secno">3.2.5</span> <span class="content">NEW: Data Captures are Accessible</span></a>
        <li><a href="#design-capture.functions-forward.decls"><span class="secno">3.2.6</span> <span class="content">Forward Declarations Work</span></a>
        <li><a href="#design-catpure.functions-forward.decls.silly"><span class="secno">3.2.7</span> <span class="content">Forward Declarations without a name are a bit useless</span></a>
        <li><a href="#design-capture.functions-recursion"><span class="secno">3.2.8</span> <span class="content">Capable of Recursion</span></a>
        <li><a href="#design-capture.functions-expression"><span class="secno">3.2.9</span> <span class="content">Not An Expression</span></a>
        <li><a href="#design-capture.functions-footgun.reference"><span class="secno">3.2.10</span> <span class="content">Footgun: By-Name Capture Exceeds Captures’s Lifetime</span></a>
        <li><a href="#design-capture.functions-footgun.wide"><span class="secno">3.2.11</span> <span class="content">Future Footgun: Wide Function Pointers</span></a>
       </ol>
      <li>
       <a href="#design-lambdas"><span class="secno">3.3</span> <span class="content">Lambdas</span></a>
       <ol class="toc">
        <li><a href="#design-lambdas-expressions"><span class="secno">3.3.1</span> <span class="content">Lambdas are Expressions</span></a>
        <li><a href="#design-lambdas-recursion"><span class="secno">3.3.2</span> <span class="content">Recursion Is Impossible</span></a>
        <li><a href="#design-lambdas-returns"><span class="secno">3.3.3</span> <span class="content">Trailing Return Types / Deduced Return Type</span></a>
        <li><a href="#design-lambdas-forward.decls"><span class="secno">3.3.4</span> <span class="content">Forward-declaration is Impossible</span></a>
       </ol>
      <li>
       <a href="#design-benchmarks"><span class="secno">3.4</span> <span class="content">Measuring Solution Spaces</span></a>
       <ol class="toc">
        <li>
         <a href="#design-benchmarks-manorboy"><span class="secno">3.4.1</span> <span class="content">Donald Knuth’s Man or Boy Test</span></a>
         <ol class="toc">
          <li><a href="#design-benchmarks-manorboy-methodology"><span class="secno">3.4.1.1</span> <span class="content">Methodology</span></a>
          <li><a href="#design-benchmarks-manorboy-results"><span class="secno">3.4.1.2</span> <span class="content">Results</span></a>
          <li><a href="#design-benchmarks-manorboy-conclusions"><span class="secno">3.4.1.3</span> <span class="content">Conclusions, Comparisons to Other Proposals, and Inferences</span></a>
         </ol>
       </ol>
     </ol>
    <li>
     <a href="#wording"><span class="secno">4</span> <span class="content">Wording</span></a>
     <ol class="toc">
      <li>
       <a href="#wording-__self_func"><span class="secno">4.1</span> <span class="content"><code class="highlight"><c- n>__self_func</c-></code> Changes</span></a>
       <ol class="toc">
        <li><a href="#wording-__self_func-6.4.3.2"><span class="secno">4.1.1</span> <span class="content">Modify "Predefined identifiers" (6.4.3.2)</span></a>
        <li><a href="#wording-__self_func-6.4.2"><span class="secno">4.1.2</span> <span class="content">Add the new keyword <code class="highlight"><c- n>__self_func</c-></code> to §6.4.2</span></a>
        <li><a href="#wording-__self_func-6.5.2"><span class="secno">4.1.3</span> <span class="content">Add <code class="highlight"><c- n>__self_func</c-></code> to the <em>primary-expression</em> grammar of §6.5.2</span></a>
        <li><a href="#wording-__self_func-6.5.2.✨"><span class="secno">4.1.4</span> <span class="content">Add a new section §6.5.2.✨ "<code class="highlight"><c- n>__self_func</c-></code> after §6.5.2.1 "Generic selection"</span></a>
       </ol>
      <li>
       <a href="#wording-core"><span class="secno">4.2</span> <span class="content">Core, Shared Changes</span></a>
       <ol class="toc">
        <li><a href="#wording-core-6.2.1"><span class="secno">4.2.1</span> <span class="content">Modify §6.2.1 "Scopes of identifiers, type names, and compound literals"</span></a>
        <li><a href="#wording-core-6.2.5"><span class="secno">4.2.2</span> <span class="content">Modify §6.2.5 "Types"</span></a>
        <li><a href="#wording-core-6.2.7"><span class="secno">4.2.3</span> <span class="content">Modify §6.2.7 "Compatible type and composite type"</span></a>
        <li><a href="#wording-core-6.2.new0"><span class="secno">4.2.4</span> <span class="content">Add a new section §6.2.✨0 "Invocable", likely §6.2.10</span></a>
        <li><a href="#wording-core-6.2.new1"><span class="secno">4.2.5</span> <span class="content">Add a new section §6.2.✨1 "Closures", after §6.2.✨0 "Invocables", likely §6.2.11</span></a>
        <li><a href="#wording-core-6.3.3.1"><span class="secno">4.2.6</span> <span class="content">Modify §6.3.3.1 "Lvalues, arrays, and function designators"</span></a>
        <li><a href="#wording-core-6.5.3.3"><span class="secno">4.2.7</span> <span class="content">Modify §6.5.3.3 "Function calls"</span></a>
        <li><a href="#wording-core-6.5.5"><span class="secno">4.2.8</span> <span class="content">Modify §6.5.5 "Cast operators"</span></a>
        <li><a href="#wording-core-6.5.17.2"><span class="secno">4.2.9</span> <span class="content">Modify §6.5.17.2 "Simple assignment"</span></a>
        <li><a href="#wording-core-6.7.7.4"><span class="secno">4.2.10</span> <span class="content">Remove §6.7.7.4 "Function declarators" to rewrite in a new version it in terms of invocables</span></a>
        <li><a href="#wording-core-6.8.1"><span class="secno">4.2.11</span> <span class="content">Modify §6.8 "Statements and blocks"'s §6.8.1 "General" for blanket jump/label banning</span></a>
        <li><a href="#wording-core-6.8.3"><span class="secno">4.2.12</span> <span class="content">Modify §6.8.3 "Compound Statement"</span></a>
        <li><a href="#wording-core-6.9.2"><span class="secno">4.2.13</span> <span class="content">Rewrite §6.9.2 "Function definitions" in terms of Invocables</span></a>
       </ol>
      <li>
       <a href="#wording-lambda"><span class="secno">4.3</span> <span class="content">Lambda Expression Changes</span></a>
       <ol class="toc">
        <li><a href="#wording-lambda-6.5.3.1"><span class="secno">4.3.1</span> <span class="content">Add <em>lambda-expression</em> to the <em>postfix-expression</em> grammar of §6.5.3.1</span></a>
        <li><a href="#wording-lambda-6.5.3.new"><span class="secno">4.3.2</span> <span class="content">Add a new section §6.5.3.✨ "Lambda expressions" somewhere after §6.5.3.4 "Structure and union members", likely §6.5.3.5</span></a>
       </ol>
      <li>
       <a href="#wording-capture.functions"><span class="secno">4.4</span> <span class="content">Capture Function Changes</span></a>
       <ol class="toc">
        <li><a href="#wording-capture.functions-6.7.7.1"><span class="secno">4.4.1</span> <span class="content">Add <em>capture-function-declarator</em> to the <em>direct-declarator</em> grammars of §6.7.7.1 "General" of "Declarators"</span></a>
        <li><a href="#wording-capture.functions-6.7.7.new"><span class="secno">4.4.2</span> <span class="content">Add a new section §6.7.7.✨ "Capture function declarators" somewhere after §6.7.7.4 "Function declarators", likely becoming §6.7.7.5</span></a>
        <li><a href="#wording-capture.functions-6.7.8"><span class="secno">4.4.3</span> <span class="content">Add <em>capture-function-abstract-declarator</em> to the <em>direct-abstract-declarator</em> grammars of §6.7.8 "Type names"</span></a>
        <li><a href="#wording-capture.functions-6.8.3"><span class="secno">4.4.4</span> <span class="content">Modify §6.8.3 "Compound statements" and add a new grammar production for "<em>block-item</em>"</span></a>
        <li><a href="#wording-capture.functions-6.9"><span class="secno">4.4.5</span> <span class="content">Modify the title of §6.9 to feature more than external definitions to "Definitions" and add a new grammar production for "<em>external-declaration</em>"</span></a>
        <li><a href="#wording-capture.functions-6.9.new"><span class="secno">4.4.6</span> <span class="content">Add a new section §6.9.✨ "Capture function definitions" somewhere after §6.9.2 "Function definitions", likely 6.9.3</span></a>
       </ol>
     </ol>
    <li>
     <a href="#appendix"><span class="secno">5</span> <span class="content">Appendix</span></a>
     <ol class="toc">
      <li>
       <a href="#appendix-nested.functions.context"><span class="secno">5.1</span> <span class="content">Accessing Context in Nested Functions</span></a>
       <ol class="toc">
        <li><a href="#appendix-nested.functions.context-section.1.section.2"><span class="secno">5.1.1</span> <span class="content">§1 &amp; §2</span></a>
        <li><a href="#appendix-nested.functions.context-section.3"><span class="secno">5.1.2</span> <span class="content">§3</span></a>
        <li><a href="#appendix-nested.functions.context-section.4"><span class="secno">5.1.3</span> <span class="content">§4</span></a>
        <li><a href="#appendix-nested.functions.context-section.5.section.6"><span class="secno">5.1.4</span> <span class="content">§5 and §6</span></a>
        <li><a href="#appendix-nested.functions.context-appendix.b"><span class="secno"></span> <span class="content">Appendix B: C++ Lambda Quiz</span></a>
        <li><a href="#appendix-nested.functions.context-appendix.a"><span class="secno"></span> <span class="content">Appendix A: List of Issues with C++ Lambdas</span></a>
        <li><a href="#appendix-nested.functions.context-conclusions"><span class="secno">5.1.5</span> <span class="content">Insufficient</span></a>
       </ol>
      <li><a href="#appendix-wide.function.pointer"><span class="secno">5.2</span> <span class="content">Wide Function Pointer Type</span></a>
      <li><a href="#appendix-make.trampoline"><span class="secno">5.3</span> <span class="content">Make Trampoline and Singular Function Pointers</span></a>
      <li><a href="#appendix-executable.stack.cves"><span class="secno">5.4</span> <span class="content">Executable Stack CVEs</span></a>
     </ol>
    <li>
     <a href="#references"><span class="secno"></span> <span class="content">References</span></a>
     <ol class="toc">
      <li><a href="#informative"><span class="secno"></span> <span class="content">Informative References</span></a>
     </ol>
   </ol>
  </nav>
  <main>
   <div class="pagebreak"></div>
   <h2 class="heading settled" data-level="1" id="changelog"><span class="secno">1. </span><span class="content">Changelog</span><a class="self-link" href="#changelog"></a></h2>
   <h3 class="heading settled" data-level="1.1" id="changelog-r2"><span class="secno">1.1. </span><span class="content">Revision 2 - December 28<sup>th</sup>, 2025</span><a class="self-link" href="#changelog-r2"></a></h3>
   <ul>
    <li data-md>
     <p>Talk more directly about <code class="highlight"><c- n>__builtin_call_with_static_chain</c-></code>, which is sometimes used to call Go-style functions from C <a href="#intro-static.chain">§ 2.6 __builtin_call_with_static_chain</a>.</p>
    <li data-md>
     <p>Add benchmarks for various existing Closures solutions from the Man or Boy test into <a href="#design-benchmarks">§ 3.4 Measuring Solution Spaces</a>. Discusses performance and design impacts thorough for the Man or Boy tests and how it relates to other proposals in the conclusions section (<a href="#design-benchmarks-manorboy-conclusions">§ 3.4.1.3 Conclusions, Comparisons to Other Proposals, and Inferences</a>).</p>
    <li data-md>
     <p>Talk about how type names and non-identified declarators are silly for Capture Functions (<a href="#design-catpure.functions-forward.decls.silly">§ 3.2.7 Forward Declarations without a name are a bit useless</a>).</p>
   </ul>
   <h3 class="heading settled" data-level="1.2" id="changelog-r1"><span class="secno">1.2. </span><span class="content">Revision 1 - October 6<sup>th</sup>, 2025</span><a class="self-link" href="#changelog-r1"></a></h3>
   <ul>
    <li data-md>
     <p>Integrate <code class="highlight"><c- n>__self_func</c-></code> (<a data-link-type="biblio" href="#biblio-__self_func" title="__self_func">[__self_func]</a>) into this paper. Hopefully the reasoning for this is self-evident and nobody asks me justify the obvious in this version of the proposal.</p>
    <li data-md>
     <p>Comment on Function Literals / Local Functions in <a href="#intro-function.literals">§ 2.5 Function Literals and Local Functions</a>.</p>
    <li data-md>
     <p>Initial wording. ✨</p>
     <ul>
      <li data-md>
       <p>There is no wording for 6.7.3.4 "Tags" because the type is not accessible from the declarator; the type is generated by the implementation and the entire apparatus of declaration types is covered under the existing rules for declarations of the same identifier, same as they are for functions in a way.</p>
      <li data-md>
       <p>There is currently a constraint on accessing a capture function’s members with <code class="highlight"><c- p>.</c-></code> and <code class="highlight"><c- o>-></c-></code> if there is no definition available at that point. This makes it easier to prevent accessing a value at the wrong time. However, it might not be elegant or useful enough in certain situations. This is paired with <a href="#design-capture.functions-forward.decls">§ 3.2.6 Forward Declarations Work</a>.</p>
      <li data-md>
       <p>Unfortunately, the wording is effectively a major surgery to parts of the standard to enable an elegant use. The good news is that it will enable using a "wide function pointer type" easily by just stating it is an invocable type and, particularly, a closure type. Even if we never accept Capture Functions or Lambdas, this is a useful rewrite of the core part of how functions/callables work.</p>
      <li data-md>
       <p>There is no Clause 7 wording. This will explicitly be a separate paper.</p>
     </ul>
   </ul>
   <h3 class="heading settled" data-level="1.3" id="changelog-r0"><span class="secno">1.3. </span><span class="content">Revision 0 - July 24<sup>th</sup>, 2025</span><a class="self-link" href="#changelog-r0"></a></h3>
   <ul>
    <li data-md>
     <p>Initial release. ✨</p>
    <li data-md>
     <p>This paper has no wording. It is not fit for standardization at the moment and only tries to thoroughly discuss the motivation and design behind this work.</p>
   </ul>
   <h2 class="heading settled" data-level="2" id="intro"><span class="secno">2. </span><span class="content">Introduction and Motivation</span><a class="self-link" href="#intro"></a></h2>
   <p>A colloquial overview (but with a bit less technical depth) of these options is available as a <a href="https://thephd.dev/lambdas-nested-functions-block-expressions-oh-my">writeup here</a> (<a data-link-type="biblio" href="#biblio-lambdas-nested-functions-block-expressions-oh-my" title="Lambdas, Nested Functions, and Blocks, oh my!">[lambdas-nested-functions-block-expressions-oh-my]</a>), though it was written in 2021 before Heap-based trampolines existed and some of the other proposals discussed here existed. We keep it as a gentler, milder introduction to the problem space written with a much less serious prose.</p>
   <p>C has had an extremely long and somewhat complicated history of wanting to pair a set of data with a given function call. Early problems first started with the standardization of C89’s <code class="highlight"><c- n>qsort</c-></code>, which only took a single function pointer argument and no way to pass data through for additional constraints:</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>qsort</c-><c- p>(</c->
  <c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>count</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>size</c-><c- p>,</c->
  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>comp</c-><c- p>)(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>)</c->
<c- p>);</c->
</pre>
   <p>This worked, until -- occasionally -- people wanted to provide modifications to certain behaviors based on local data rather than static data. For example, to modify the sort order of a call to <code class="highlight"><c- n>qsort</c-></code>, one would originally have to program it like this in standard C:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>static</c-> <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

<c- b>int</c-> <c- nf>compare</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
  <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
  <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
  <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
<c- p>}</c->

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
  <c- n>qsort</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare</c-><c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>There were multiple limiting factors in getting data into the function outside of using <code class="highlight"><c- k>static</c-></code>. Accessing data in the local block was impossible for a <code class="highlight"><c- n>compare</c-></code> function that, necessarily, had to be defined outside of <code class="highlight"><c- n>main</c-></code>. This necessitated a way of transporting data to the <code class="highlight"><c- n>compare</c-></code> function to do the work in a way that would work for <code class="highlight"><c- n>qsort</c-></code>. Since it offered no way to transmit user data parameter, other forms of data transfer became commonplace:</p>
   <ul>
    <li data-md>
     <p><code class="highlight"><c- k>static</c-></code> data was the most popular ISO Standard C way of handling this in <code class="highlight"><c- n>qsort</c-></code>-style APIs, resulting in a large number of (<code class="highlight"><c- kr>inline</c-></code>) <code class="highlight"><c- k>static</c-></code> global variables throughout early programs using clever tricks to duplicate variables VIA <code class="highlight"><c- n>fork</c-></code>-style or loading several translation units with different <code class="highlight"><c- k>static</c-></code> variables;</p>
    <li data-md>
     <p>and, <code class="highlight"><c- k>_Thread_local</c-></code> in the case of avoiding contention on variables when multithreading was formally introduced circa C11.</p>
   </ul>
   <p>Still, for all of its benefits and ease-of-use, these techniques are not perfect. Concerns and problems around (potentially false) sharing data only grew in time as each program had to manage larger and larger swaths of 1980’s-style global variable soups, something that has famously ended up being used as a sign of negative code quality in legal matters. This particular problem was combatted by "reentrant" functions or "reentrancy" requirements, which is where the family of <code class="highlight"><c- n>qsort_s</c-></code> and <code class="highlight"><c- n>qsort_r</c-></code>-style functions (from Annex K implementations or BSD libraries) came from:</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>qsort_s</c-><c- p>(</c->
  <c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>count</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>size</c-><c- p>,</c->
  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>comp</c-><c- p>)(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>),</c->
  <c- b>void</c-><c- o>*</c-> <c- n>user</c->
<c- p>);</c->

<c- b>void</c-> <c- nf>qsort_r</c-><c- p>(</c->
  <c- b>void</c-><c- o>*</c-> <c- n>ptr</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>count</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>size</c-><c- p>,</c->
  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>comp</c-><c- p>)(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>),</c->
  <c- b>void</c-><c- o>*</c-> <c- n>user</c->
<c- p>);</c->
</pre>
   <p>And they are used like so:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- b>int</c-> <c- nf>compare</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c-> <c- p>{</c->
  <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>user</c-><c- p>;</c->
  <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
  <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
  <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
<c- p>}</c->

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
  <c- n>qsort_r</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>in_reverse</c-><c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>While this example just has a single <code class="highlight"><c- b>int</c-></code> as the type, other instances of using callbacks in this manner have resulted in Type Confusion bugs, where the <code class="highlight"><c- b>void</c-><c- o>*</c-></code> pointer is cast to the wrong type or the wrong callback is used in conjunction with that <code class="highlight"><c- b>void</c-><c- o>*</c-></code> callback type. The lack of type safety occasionally bites people, and given that it’s ferreted through a <code class="highlight"><c- b>void</c-><c- o>*</c-></code> it’s hard to tackle this problem when dozens of little "helper" functions have to litter source code at file-scope. Finally, we add this frivolous example of ISO C (that does not make much sense upon first read):</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>typedef</c-> <c- b>int</c-> <c- nf>compare_fn_t</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>);</c->

<c- b>int</c-> <c- nf>compare</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c-> <c- p>{</c->
  <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>user</c-><c- p>;</c->
  <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
  <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
  <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
<c- p>}</c->

<c- n>compare_fn_t</c-><c- o>*</c-> <c- nf>make_compare</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[],</c-> <c- b>int</c-><c- o>*</c-> <c- n>in_reverse</c-><c- p>)</c-> <c- p>{</c->
  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- o>*</c-><c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- k>return</c-> <c- n>compare</c-><c- p>;</c->
<c- p>}</c->

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->  

  <c- n>compare_fn_t</c-><c- o>*</c-> <c- n>compare</c-> <c- o>=</c-> <c- n>make_compare</c-><c- p>(</c-><c- n>argc</c-><c- p>,</c-> <c- n>argv</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>in_reverse</c-><c- p>);</c->
  <c- n>qsort_r</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>in_reverse</c-><c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>The point of the above code is to show that it’s legal to return a function pointer to a normal function call, because it has a duration for the lifetime of the program (<code class="highlight"><c- k>static</c-></code> storage duration, basically). This serves as a good proxy for the various Closure types we will be looking at: can they be returned safely from a function? Is there a way to make it return safely from the function? If we didn’t pass <code class="highlight"><c- o>&amp;</c-><c- n>in_reverse</c-></code> in as an argument, but created a local variable inside of <code class="highlight"><c- n>make_compare</c-></code>, can it survive the return? These are all important questions to answer, especially as global variables became more discouraged towards C95 and C99 to prevent unintended data clobbering or sharing, and as reentrancy started to become more important. Because of <code class="highlight"><c- b>void</c-><c- o>*</c-></code>’s lack of type safety which enabled unfortunate type confusion bugs, sharing issues, and the lack of locality of the writing of functions, a new extension was cooked up by GCC to handle this program. Similar to Ada and Algol features but spun directly for C at the time, it was a feature lovingly dubbed Nested Functions.</p>
   <h3 class="heading settled" data-level="2.1" id="intro-preamble"><span class="secno">2.1. </span><span class="content">Preamble</span><a class="self-link" href="#intro-preamble"></a></h3>
   <p>Before we talk about GNU Nested Functions, Apple Blocks, C++ Lambdas, Function Literals, or anything else, there’s a few examples similar to the <code class="highlight"><c- n>qsort</c-></code> one that will be used above. The purpose of these examples will be to talk about:</p>
   <ul>
    <li data-md>
     <p>whether or not there’s a way to use these things in expressions by themselves;</p>
    <li data-md>
     <p>whether or not there’s a way to manage the lifetime of an object in a dynamic or safe fashion;</p>
    <li data-md>
     <p>and, whether or not there’s a way to make these things work with a single function pointer, function pointer + <code class="highlight"><c- b>void</c-><c- o>*</c-></code> user data, or otherwise.</p>
   </ul>
   <p>The one returning a function pointer seems utterly frivolous in the above for <code class="highlight"><c- n>make_compare</c-></code>, but is meant as a proxy to determine how to handle dynamic lifetime of functions, where a closure needs to outlive the scope in which it was created or returned. This serves as a stand-in for code similar to returning things "up" the stack, or where the closure is meant to be invoked at some later point like in asynchronous code. That is how the current landscape is going to be evaluated.</p>
   <p>To aid in this evaluation, in the final section of this introduction, we will be filling out this table of features to see what each ecosystem brings to the table in terms of features. There are explanations below for each one in the first column:</p>
   <table class="basic">
    <thead>
     <tr>
      <th>Feature
      <th>GNU Nested Functions
      <th>Apple Blocks
      <th>C++-Style Lambdas in C
      <th>Function Literals
      <th>Local Functions
    <tbody>
     <tr>
      <td>Capture By-Name
      <td>
      <td>
      <td>
      <td>
      <td>
     <tr>
      <td>Capture By-Value
      <td>
      <td>
      <td>
      <td>
      <td>
     <tr>
      <td>Selective Capture
      <td>
      <td>
      <td>
      <td>
      <td>
     <tr>
      <td>Safe to Return Closure
      <td>
      <td>
      <td>
      <td>
      <td>
     <tr>
      <td>Relocatable to Heap<br>(Lifetime Management)
      <td>
      <td>
      <td>
      <td>
      <td>
     <tr>
      <td>Usable Directly as Expression
      <td>
      <td>
      <td>
      <td>
      <td>
     <tr>
      <td>Forward-Declarable
      <td>
      <td>
      <td>
      <td>
      <td>
     <tr>
      <td>Immediately Invokable
      <td>
      <td>
      <td>
      <td>
      <td>
     <tr>
      <td>Convertible to Function Pointer
      <td>
      <td>
      <td>
      <td>
      <td>
     <tr>
      <td>Convertible to "Wide" Function Type
      <td>
      <td>
      <td>
      <td>
      <td>
     <tr>
      <td>Access to Non-Erased Object/Type
      <td>
      <td>
      <td>
      <td>
      <td>
     <tr>
      <td>Access to Captures through Object/Type
      <td>
      <td>
      <td>
      <td>
      <td>
     <tr>
      <td>Recursion Possible
      <td>
      <td>
      <td>
      <td>
      <td>
   </table>
   <ul>
    <li data-md>
     <p>Capture By-Name: can refer to an object directly, as if working with it as an l-value or dereferencing a pointer to that object. Sometimes also called "capture by reference".</p>
    <li data-md>
     <p>Capture By-Value: can refer to a copy of an object from within the function, at some fixed point in time. The lifetime of the copied object from the capture is tied to the closure rather than the scope it comes from.</p>
    <li data-md>
     <p>Selective Capture: can pick and choose what to capture and how it gets captured.</p>
    <li data-md>
     <p>Safe to Return Closure: part of the dynamic lifetime problem, but is there a way to write this closure type such that it is safe to return?</p>
    <li data-md>
     <p>Relocatable to Heap (Lifetime Management): if it is possible to extend or otherwise change the lifetime of a closure so that it can last longer, either by copying or relocating the closure.</p>
    <li data-md>
     <p>Usable Directly as Expression: whether or not the closure can appear as a function argument or something else.</p>
    <li data-md>
     <p>Forward-Declarable: whether or not the closure can be forward-declared and perhaps used in some ways (e.g., callable as a function but perhaps any related object definition might not be usable).</p>
    <li data-md>
     <p>Immediately Invokable: whether or not the closure can be immediately invoked, usually without naming it.</p>
    <li data-md>
     <p>Convertible to Function Pointer: whether or not the closure can be converted to a function pointer of an identical signature to be called.</p>
    <li data-md>
     <p>Convertible to "Wide" Function Type: whether or not the closure can be converted to a "wide" function pointer type, now or into the future.</p>
    <li data-md>
     <p>Access to Non-Erased Object/Type: can use and store the closure object without erasing the type or the object first.</p>
    <li data-md>
     <p>Access to Captures through Object/Type: access the closure’s captures outside of the closure’s invocable body.</p>
    <li data-md>
     <p>Recursion Possible: can refer to itself in order to create a recursive algorithm in the normal fashion, without needing a special feature like C++'s Deducing This or the proposed <code class="highlight"><c- n>__self_func</c-></code> (<a data-link-type="biblio" href="#biblio-__self_func" title="__self_func">[__self_func]</a>).</p>
   </ul>
   <h3 class="heading settled" data-level="2.2" id="intro-nested.functions"><span class="secno">2.2. </span><span class="content">GNU Nested Functions</span><a class="self-link" href="#intro-nested.functions"></a></h3>
   <p>Nested Functions (<a data-link-type="biblio" href="#biblio-nested-functions" title="Nested Functions (Using the GNU Compiler Collection (GCC))">[nested-functions]</a>) were the logical extension of function definition syntax pulled down into the local level. Despite being the oldest functions-with-data attempt (30+ years), it only has one proposal by Dr. Martin Uecker done recently (<a data-link-type="biblio" href="#biblio-n2661" title="n2661: Nested Functions">[n2661]</a>) and is not widely adopted as an extension across C compilers. The goal was very simple, and during the C89 timeframe eminently doable due to the absence of a deep understanding of security implications for machines not yet being actively exploited in both civilian and military contexts. The syntax of a function definition within a block scope created a function that could be called in the obvious way but still reference surrounding block scope objects <em>by name</em>:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
	
  <c- b>int</c-> <c- n>compare</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>}</c->
  <c- n>qsort</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare</c-><c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>The notable benefits of this approach were:</p>
   <ul>
    <li data-md>
     <p>looks, feels, and smells like a regular function definition;</p>
    <li data-md>
     <p>can access local data instead of static data, preventing issues with forked data or shared data;</p>
    <li data-md>
     <p>produced a single function pointer and so did not need an additional user data pointer (typically a <code class="highlight"><c- b>void</c-><c- o>*</c-></code>);</p>
    <li data-md>
     <p>and, places the function doing the comparison work closer to the actual usage site.</p>
   </ul>
   <p>Unfortunately, the early and enduring design of this feature -- in order to enable some of the benefits listed above -- very quickly ran afoul of early security concerns, and soon earned itself a big CVE due to the way it worked. In particular, the implementation strategy for a nested function is a brilliant piece of engineering that runs afoul of one of the only enduring security mitigations that have not fallen by the wayside: Non-Executable Stacks. To understanding why this matters, a brief description of what (Non-)Executable Stacks are, and why they are important.</p>
   <h4 class="heading settled" data-level="2.2.1" id="intro-nested.functions-security"><span class="secno">2.2.1. </span><span class="content">Non-Executable Stacks</span><a class="self-link" href="#intro-nested.functions-security"></a></h4>
   <p>In C -- using common practice to leverage lots of hot-patching, assembly hot-fixing, direct opcode injection, and more -- programs frequently made use of stack-based data buffers where they also dumped their programs. This meant that binaries would read from their stack with the instruction pointer, allowing programs to dynamically inject behavior into a currently running program either in parts or -- if that data came from outside sources -- a fully dynamic sort of live-machine coding. The problem with this approach was that if a normal user could use the stack to make the program do a set of behaviors, so could a malicious actor: this was the easiest and widest branch of attacks upon C programs, and it was an endemic issue given the extremely large number of stack-based, fixed-sized buffers or -- after the advent of C99 -- variable-length arrays. Commandeering programs was as easy as finding a place where naïve programmers and hackers employed the now-deprecated <code class="highlight"><c- n>gets</c-></code>, or where input was loaded in a too-relaxed way into a stack buffer. Overrunning the buffer and gaining control of the program by getting a <code class="highlight"><c- n>jmp</c-></code> instruction to jump not back to some expected place in the stack but instead to a piece of a new program written by malicious inputs into the program made it easy to exploit C programs day in and day out, over and over again.</p>
   <p>After quite a few attempts and retries on mitigations and a several years of evolution, one of the lowest-hanging and easiest mitigations for a large class of direct attacks using stack buffers was to simply make the stack non-executable. This meant directly writing shellcode and jumping to it was no longer a valid way to attack many programs, and as a simple mitigation it has endured as one of many different mitigation techniques that prevents exploits. Executable stacks are, to this day, still one of the easiest-to-exploit properties of programs on a large share of modern computing platforms.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> This does not mitigate ALL stack-based exploits completely. It just eliminated the bottom-of-the-barrel, 40% ones; instead, folks now had to use what was already on the stack in terms of data to try and trick the program’s own logic to enter an unexpected state and, summarily put it into a vulnerable position. The kickoff from that vulnerable position to either abuse another vulnerability (e.g. an improperly checked heap pointer) can then be elevated to the point of illicit code execution (<a data-link-type="biblio" href="#biblio-solar-non-executable-stack-exploits" title="Getting around non-executable stack (and fix)">[solar-non-executable-stack-exploits]</a>). Both formally and informally, this is known as <a href="https://en.wikipedia.org/wiki/Return-oriented_programming">Return-Oriented Programming (ROP)</a>.</p>
   <p>Most programs, whether using Variable of Fixed-Length Arrays, loved to keep (small)-ish buffers on the stack that they constantly wrote data into in response to user input or read data (such as configuration files or network input). Preventing the ability of a poorly written program that did not guard against all forms of malicious input from turning into an easy Remote Code Execution issue was a gigantic security win. The overwhelming majority of exploits running at the time were effectively halted, even if they contained the perfect shell code to do so.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> Similar exploit-prevention techniques such as inserting security cookies on the stack, using Address Space Layout Randomization (ASLR), Control-Flow Integrity (CFI) checks, and more have also been developed further to shore up other issues from exploitation and vulnerabilities in C code since then, after ROP, Return to Libc, Heap-based Exploiters (Write-What-Where primitives), and Type-Confusion, became the new dominating exploit techniques.</p>
   <p>This means that as a "table stakes" or entry-level bit on security, avoiding an Executable Stack is important for most C features.</p>
   <h4 class="heading settled" data-level="2.2.2" id="intro-nested.functions-design"><span class="secno">2.2.2. </span><span class="content">Early Design Flaw: Nested Functions turn the stack Executable!</span><a class="self-link" href="#intro-nested.functions-design"></a></h4>
   <p>The original design of Nested Functions suffered for its compact and brilliant design, unfortunately. Let’s remind ourselves of the previous example relating to <code class="highlight"><c- n>qsort</c-></code>: somehow, without marking the variable as <code class="highlight"><c- k>static</c-></code> or <code class="highlight"><c- k>_Thread_local</c-></code>, a nested function is able to access all of the object <em>by name</em> from its enclosing scope.</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- d>/* LOCAL variable.... */</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
	
  <c- b>int</c-> <c- n>compare</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
    <c- d>/* HOW is `in_reverse` usable here?! */</c-> 
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>}</c->
  <c- n>qsort</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare</c-><c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>The secret of this is in the brilliance of the original design: since it was so commonplace at the time, Nested Functions decided that the best way to be able to find the variables in the enclosing scope was to take a location associated with the enclosing block scope -- the Stack -- and turn it into an executable piece of code. This executable piece of code had an address. Because the executable code and its address came from the program’s stack, it meant that there was no need to provide a pointer to do reference-based / "<em>by-name</em>" object capturing. The function pointer <em>itself</em> served as both the jump to the code to execute, and a location that could then have a number of pre-determined, fixed offsets applied to it to reach all of the variables in that piece of code. This meant that rather than needing an object with <code class="highlight"><c- k>static</c-></code> storage or <code class="highlight"><c- k>_Thread_local</c-></code> storage, the block-scope variable could be accessed directly!</p>
   <p>Unfortunately, this required the stack, still, to be executable in order to function.</p>
   <p>This is the critical issue that has resulted in most other vendors not picking up the feature. Compilers want to work flawlessly with GCC-compiled code: this means that compiling a nested function and passing it to a function pointer has to result in a (somewhat) similar Application Binary Interface (ABI) that can be used as applications expect. This means the decision to make GCC nested functions trampoline from the stack is a non-ignorable detail. This is the primary reason Clang and other vendors have refused to implement Nested Functions, chiefly citing security concerns and the inability to develop a worthwhile ABI that is compatible. Just how prevalent are the security issues that Clang and other vendors avoided by refusing to implement the GNU Nested Functions extension? Well...</p>
   <h5 class="heading settled" data-level="2.2.2.1" id="intro-nested.functions-security-popularity"><span class="secno">2.2.2.1. </span><span class="content">The Prevalence of Executable Stack, and GNU Nested Functions</span><a class="self-link" href="#intro-nested.functions-security-popularity"></a></h5>
   <p>A ton of users relied on or otherwise kept using Executable Stacks, even into today. While the non-executable stack fix was deployed to great success in the early 2020s, some platforms -- particularly, Linux and similar POSIX-based platforms -- kept this up. This clashed with users who became far too comfortable with the issues related to Executable Stack:</p>
   <blockquote>
    <p>Year of Linux desktop will never happen as long as glibc is de-facto standard libc. As far as I know, this regression is wontfix, so many games just won’t work anymore.</p>
    <p>Imagine being a game dev from 5 years ago and making a native Linux version of your game in a good faith, that’s 100% a net-negative money-wise, only for it to stop working in a couple years. Backward compatibility on Linux does not exist as far as regular users concerned, and the only way to make software that works in years to come is to make it for Windows, and hopefully let Valve and Wine teams handle the rest.</p>
    <p>--  February 19, 2025, <a href="https://twitter.com/valigo_gg/status/1892189377830220025">Valentin Ignatev</a></p>
   </blockquote>
   <p>Briefly ignoring the extreme hyperbole: note the dates and the mentioned time of this tweet. 5 years ago; e.g. developed in 2020, with the complaint happening in 2025. The tweet included a screenshot from the article titled "<em>The glibc 2.41 update has been causing problems for Linux gaming</em>" (<a data-link-type="biblio" href="#biblio-gamingonlinux-dawe" title="The glibc 2.41 update has been causing problems for Linux gaming">[gamingonlinux-dawe]</a>). Windows and MacOS have been disabling executable stacks globally, by default, for years and refusing to load such applications. This complaint happened when glibc stopped forcefully setting executable stack, even if the tweet that garnered the public push back did not mention WHY these games were breaking. This talks to the severe need for a solution in this space that is not security breaking, and even telling folks to simply "turn on executable stack" for themselves is not wonderful:</p>
   <blockquote>
    <p>... Don’t just take my advice on it though if you’re a developer or gamer reading this, always look up what you’re doing fully. Run at your own risk. ...</p>
    <p>-- February 13, 2025, <a href="https://www.gamingonlinux.com/2025/02/the-glibc-2-41-update-has-been-causing-problems-for-linux-gaming/">Article Author Liam Dawe</a></p>
   </blockquote>
   <p>Unfortunately, this lax approach to security -- especially for video games -- has resurfaced quite a few truly unfortunate bugs. Popular Windows games such as Dark Souls: PREPARE TO DIE Edition and Call of Duty: WWII have exploitable Remote Code Execution (RCE) bugs in their code. One of them seems to be getting patched, but the other -- in Dark Souls -- is not going to be patched out. The idea that glibc -- or platforms in general -- can take a lax position to security on devices, even for something as "frivolous" as the (multi-billion dollar revenue) video game industry is simply not tenable. From a highly skilled Rendering Engineer commenting on the controversy caused by the glibc 2.41 update:</p>
   <blockquote>
    <p>glibc is in the right here. iirc windows and mac DEP policy disabled executable stack by default for the past ~20 years or so. shocked this was not already the case in linux userland</p>
    <p>-- February 21, 2025 <a href="https://twitter.com/awr_hey/status/1892874306776158494">A. W. R.</a></p>
   </blockquote>
   <p>The engineer in charge of pushing the change and looking over the situation commented on the article and general attitude represented by Mr. Ignatev:</p>
   <blockquote>
    <p>It is interesting that the headline did not get into details why I made this change: <a href="https://sourceware.org/pipermail/libc-alpha/2024-December/163146.html">https://sourceware.org/pipermail/libc-alpha/2024-December/163146.html</a></p>
    <p>In a short: the old behavior was used in a know RCE described in CVE-2023-38408.</p>
    <p>-- February 20, 2025, <a href="https://twitter.com/adhemerval/status/1892348528531231025">Adhemerval Zanella</a></p>
   </blockquote>
   <p>It is important to know that many other developers do not share this perception. Even as far back as 2018, when Microsoft kept up its Security Posture in its Windows Subsystem for Linux, people railed against the high-security default of refusing to work with programs that allowed executable stack (<a data-link-type="biblio" href="#biblio-wsl-no-executable-stack" title="fis-gtm does not run due to missing support for executable stack">[WSL-no-executable-stack]</a>):</p>
   <blockquote>
    <p>The accepted trade-off is to have a non-executable stack be default but have an executable stack for programs which need them. Not supporting this is just a deficiency in WSL.</p>
    <ul>
     <li data-md>
      <p>August 7, 2018, <a href="https://github.com/microsoft/WSL/issues/286#issuecomment-411092033">Dr. Martin Uecker</a></p>
    </ul>
   </blockquote>
   <p class="note" role="note"><span class="marker">NOTE:</span> This does not necessarily mean that Dr. Uecker wanted an executable stack in all programs. It’s just that for backwards compatibility purposes, it should be <em>allowed</em> to happened rather than fully banned, which is the opposite opinion of how WSL1, SELinux, several BSDs, and many other operating system loaders work.</p>
   <p>Whose perspective is correct?</p>
   <h5 class="heading settled" data-level="2.2.2.2" id="intro-nested.functions-security-blame"><span class="secno">2.2.2.2. </span><span class="content">The Standard Is To Blame</span><a class="self-link" href="#intro-nested.functions-security-blame"></a></h5>
   <p>This proposal agrees with both Mr. Zanella and Ms. A.W.R., and disagrees with Dr. Uecker and Mr. Ignatev; it is impossible to pretend like this is not a problem with more and more exploits taking advantage of not only executable stack, but directly targeting "harmless" software that makes use of it (such as video games). But, even more importantly, the real culprit here is ISO C. There were many alternatives to executable stack-based GNU Nested Functions, and other such entrapments. However, because of how convenient GNU Nested Functions are and how accepted they are in the GNU ecosystem, it has led to multiple security vulnerabilities that should have never existed in the first place (<a href="#appendix-executable.stack.cves">§ 5.4 Executable Stack CVEs</a>).</p>
   <p>Unlike Address Space Layout Randomization (ASLR) and several other run-time mitigations, non-executable stacks have been both the cheapest and most enduring security wins in the last 50 years of computing. Marking sections of memory as unable to be run as part of the program permanently shifted the landscape of targeted exploits to be focused almost exclusively on buffer overrun-into-heap-exploitation bugs or through ROP gadgets, as well as trying to find sequences of logic to put programs in a state of disrepair that ultimately grant attackers either a Denial of Service (DoS) attack or full control VIA Remote Code Execution (RCE). Exploits were now exceedingly harder and required orchestration of multiple carefully-crafted scenarios to hit the "Weird Machine" state so coveted by exploiters. This is not the case for executable stack.</p>
   <h4 class="heading settled" data-level="2.2.3" id="intro-nested.functions-alternative.implementations"><span class="secno">2.2.3. </span><span class="content">Alternative Nested Function Implementations</span><a class="self-link" href="#intro-nested.functions-alternative.implementations"></a></h4>
   <p>We have already discussed the first and most popular attempt which leaves the stack executable. Because of the negative security properties of this, there were two more attempts, one still on-going (<a href="#intro-nested.functions-alternative.implementations-attempt.three">§ 2.2.3.2 Attempt 3</a>) and one with limited success that requires the entire world to be recompiled or face potential ABI breaks (<a href="#intro-nested.functions-alternative.implementations-attempt.two">§ 2.2.3.1 Attempt 2</a>).</p>
   <h5 class="heading settled" data-level="2.2.3.1" id="intro-nested.functions-alternative.implementations-attempt.two"><span class="secno">2.2.3.1. </span><span class="content">Attempt 2</span><a class="self-link" href="#intro-nested.functions-alternative.implementations-attempt.two"></a></h5>
   <p>An Ada-style Function Descriptors implementation was attempted. The problem with this change for GCC is that it uses a bit (the lowest bit, which traditionally is always 0) in the function pointer itself to mark the function pointer as one that is relying on the Function Descriptor technology. Setting the lowest bit on the function pointer means that it is unsafe to call directly, and therefore every function call must first be masked with <code class="highlight"><c- n>func_ptr</c-> <c- o>&amp;</c-> <c- o>~</c-><c- mb>0b1ull</c-></code> before being called. This is a runtime cost and a general-purpose pessimization that applies to ALL function pointers, making the Function Descriptor approach unsuitable for solving the ABI problem both internally with existing GCC code and to the satisfaction of other developers.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> This is also inadvisable for specific ABIs such as ARMv7, where the lowest bit in function pointers is used to determine instruction switching capabilities.</p>
   <h5 class="heading settled" data-level="2.2.3.2" id="intro-nested.functions-alternative.implementations-attempt.three"><span class="secno">2.2.3.2. </span><span class="content">Attempt 3</span><a class="self-link" href="#intro-nested.functions-alternative.implementations-attempt.three"></a></h5>
   <p>A third attempted implementation of Nested Functions attempts to use a separately-allocated trampoline. It can come from either: a stack that is set up at program load time in coordination with the compiler and whose exclusive purpose is to be a memory region for both trampolines and a slot for a <code class="highlight"><c- b>void</c-><c- o>*</c-></code> environment/context; OR, a dynamic allocation that serves as the function pointer plus a <code class="highlight"><c- b>void</c-><c- o>*</c-></code> environment/context pointer. These approaches simply do not work in the general case because it is unclear when, if ever, the function pointer will stop being used. However, one part of Nested Functions -- the fact that they refer to everything <em>by name</em> / "<em>capture by reference</em>" all of the things they use -- means that this can be sufficiently approximated by simply stating that GNU Nested Functions will deallocate such a trampoline (or shrink the stack it was cut from) when the enclosing block that was used for the nested function is gone. (Of course, this means that the function pointer will exhibit the exact same lifetime issues as with the current stack, so it solves some problems but leaves others on the table.)</p>
   <p>There is also the slight issue that using a separated trampoline that is on a separate heap or a separate stack <em>might</em> need (but is not necessarily required) a secondary level of indirection. The original, executable stack implementation of GNU Nested Functions prevents this because both the code and the variables are in-line: having a separated trampoline may require such a trampoline to first load the right function call with <code class="highlight"><c- n>__builtin_call_with_static_chain</c-></code> <a href="#intro-static.chain">§ 2.6 __builtin_call_with_static_chain</a> within the code of the trampoline to have the code work properly.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> As of early 2025 in GCC 14, GCC provided a heap-based implementation that got rid of the executable stack. This requires some amount of dynamic allocation in cases where it cannot prove that the function is only passed down, not have its address taken in a meaningful way, or if it is not used immediately (as determined by the optimizer). It can be turned on with <code class="highlight"><c- o>-</c-><c- n>ftrampoline</c-><c- o>-</c-><c- n>impl</c-><c- o>=</c-><c- n>heap</c-></code>.</p>
   <h5 class="heading settled" data-level="2.2.3.3" id="intro-nested.functions-user.control"><span class="secno">2.2.3.3. </span><span class="content">A Possible 4th Attempt: Explicit User Control</span><a class="self-link" href="#intro-nested.functions-user.control"></a></h5>
   <p>An experimental technique for allocating a trampoline can be done by having an <code class="highlight"><c- n>_Any_func</c-><c- o>*</c-></code> pointer, as is being standardized by using an in-progress proposal <a data-link-type="biblio" href="#biblio-_any_func" title="_Any_func - A Universal Function Pointer Storage Type">[_Any_func]</a>. Then, rather than needing to implicitly create a trampoline on usage, a user can instead request it and control the allocation explicitly, while passing it back. A fictional example of such an intrinsic -- called <code class="highlight"><c- n>__gnu_make_trampoline</c-></code> -- is seen here:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- d>/* LOCAL variable.... */</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
	
  <c- k>typedef</c-> <c- b>int</c-> <c- n>compare_fn_t</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>);</c->

  <c- b>int</c-> <c- n>compare</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>}</c->
  <c- c1>// explicitly make a single-function-pointer trampoline, without an executable stack</c->
  <c- c1>// __gnu_make_trampoline takes a function identifier, returns a _Any_func*</c->
  <c- n>compare_fn_t</c-><c- o>*</c-> <c- n>compare_fn_ptr</c-> <c- o>=</c-> <c- n>__gnu_make_trampoline</c-><c- p>(</c-><c- n>compare</c-><c- p>);</c->

  <c- c1>// use it</c->
  <c- n>qsort</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare_fn_ptr</c-><c- p>);</c->

  <c- c1>// explicitly free a single-function-pointer trampoline, without an executable stack</c->
  <c- n>__gnu_destroy_trampoline</c-><c- p>(</c-><c- n>compare_fn_ptr</c-><c- p>);</c->

  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>This is discussed further in <a href="#appendix-make.trampoline">§ 5.3 Make Trampoline and Singular Function Pointers</a>.</p>
   <h4 class="heading settled" data-level="2.2.4" id="intro-nested.functions-captures"><span class="secno">2.2.4. </span><span class="content">The Nature of Captures</span><a class="self-link" href="#intro-nested.functions-captures"></a></h4>
   <p>There’s a final issue with nested functions, and it’s that it is not suitable for use with asynchronous code or code that returns "up". Consider the same bit of code as before, but slightly modified:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>typedef</c-> <c- b>int</c-> <c- nf>compare_fn_t</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>);</c->

<c- n>compare_fn_t</c-><c- o>*</c-> <c- nf>make_compare</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- d>/* LOCAL variable.... */</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- b>int</c-> <c- n>compare</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>compare</c-><c- p>;</c->
<c- p>}</c->

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->  

  <c- n>compare_fn_t</c-><c- o>*</c-> <c- n>compare</c-> <c- o>=</c-> <c- n>make_compare</c-><c- p>(</c-><c- n>argc</c-><c- p>,</c-> <c- n>argv</c-><c- p>);</c->
  <c- n>qsort</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare</c-><c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>In this example, we have simply moved the <code class="highlight"><c- n>in_reverse</c-></code> and <code class="highlight"><c- n>compare</c-></code> generation into a function, for ease-of-use. One can imagine that we need to create this sort of function multiple times, from perhaps different sources of data. GNU Nested Functions allow us to do this and to return the function "up" the call stack. The problem, of course, is that Nested Functions (in a heap-based implementation or the current executable stack implementation) both point to the current "function frame" that it is created in. That is, while <code class="highlight"><c- n>make_compare</c-></code> -- once it has returned -- is no longer alive and all of its automatic storage durations have died, the <code class="highlight"><c- n>compare</c-></code> function pointer is still there and passed up the stack. This means that all accesses to <code class="highlight"><c- n>in_reverse</c-></code> are accessing memory that is no longer alive, and it is effectively Undefined Behavior.</p>
   <p><strong class="advisement"> The actual manifestation of the undefined behavior in this program is very clear: adding the <code class="highlight"><c- o>-</c-><c- n>r</c-></code> argument to make <code class="highlight"><c- n>in_reverse</c-></code> turn to <code class="highlight"><c- mi>1</c-></code> does not have any <a href="https://godbolt.org/z/81d7Tqn1E">effect on the program anymore</a>:<br><a href="https://godbolt.org/z/81d7Tqn1E">https://godbolt.org/z/81d7Tqn1E</a></strong></p>
   <p>This is a critical failure of Nested Functions: it only ever "captures" function values <em>by-name</em> / <em>by-reference</em>. There is no option to capture <em>by-value</em>, and therefore the transportation and use of these function pointers to asynchronous code or "up" the call stack means it is fundamentally dangerous. This was not a huge problem in the early days of C, where programs were very flat and it was easy to always "move" function calls up. Unfortunately, we now have asynchronous programming, coroutine libraries / green threading models, callbacks that are saved and invoked much, much later in a program, and all sorts of models for shared code. This is the part of Nested Functions that cannot be saved; it is an intrinsic part of the design that unfortunately will always lead to Undefined Behavior because there is no way to get around that limitations in the GNU Nested Functions design. This is another serious problem that ultimately make it impossible to consider Nested Functions as THE solution for all of the C ecosystem.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> As a general rule of thumb, if the entity being designed has the ability to be transferred out of its current scope (Blocks, Nested Functions, Lambdas, ...) then it must as a rule allow for determining how it interacts with the scope it is nested in. The answer for function calls in most languages (without a garbage collector or other memory-preserving solution) is "cannot interact with its surrounding scope", which simplifies the problem. But, the whole point of these features IS to interact with the surrounding scope, and so care must be taken to make it work better.</p>
   <h4 class="heading settled" data-level="2.2.5" id="intro-nested.functions-captures.no.workaround"><span class="secno">2.2.5. </span><span class="content">GNU Nested Functions By-Name Captures Cannot Be Worked Around Normally</span><a class="self-link" href="#intro-nested.functions-captures.no.workaround"></a></h4>
   <p>The deeply unfortunate part of GNU Nested Functions is that even if someone realizes the issue with by-name capture of the surrounding scope and tries to escape it, there <strong>is</strong> not successful way to actually provide that escape. Consider, briefly, the <code class="highlight"><c- n>make_compare</c-></code>-style example from before but with a slight modification to "heapify" the <code class="highlight"><c- n>in_reverse</c-></code> variable for safety reasons:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>typedef</c-> <c- b>int</c-> <c- nf>compare_fn_t</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>);</c->

<c- n>compare_fn_t</c-><c- o>*</c-> <c- nf>make_compare</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- d>/* LOCAL, heap-allocated variable.... */</c->
  <c- b>int</c-><c- o>*</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- n>malloc</c-><c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- b>int</c-><c- p>));</c->
  <c- o>*</c-><c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- o>*</c-><c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- b>int</c-> <c- n>compare</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>compare</c-><c- p>;</c->
<c- p>}</c->

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->  

  <c- n>compare_fn_t</c-><c- o>*</c-> <c- n>compare</c-> <c- o>=</c-> <c- n>make_compare</c-><c- p>(</c-><c- n>argc</c-><c- p>,</c-> <c- n>argv</c-><c- p>);</c->
  <c- n>qsort</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare</c-><c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>Ignoring for a moment that there’s no <code class="highlight"><c- n>free</c-></code> called in this scenario, the bigger and more pressing problem here is that this code does not even work. Despite having properly had the memory on the heap now, a by-name reference to the <code class="highlight"><c- n>in_reverse</c-></code> pointer means that once the <code class="highlight"><c- n>make_compare</c-></code> function exits, that pointer is no longer alive. Doing <code class="highlight"><c- o>*</c-><c- n>in_reverse</c-></code> is just deferfencing a pointer whose value may or may not have changed and is effectively a form of stack-based use-after-free. This means that even if you want to try to make local variable references "safe" by relocating objects in the local arena to the heap, it is still not enough. You would need to deploy <code class="highlight"><c- k>static</c-></code> or <code class="highlight"><c- k>_Thread_local</c-></code> data in order to solve the problem, still, which brings us back to the original problems at the beginning of this introduction (<a href="#intro">§ 2 Introduction and Motivation</a>).</p>
   <h4 class="heading settled" data-level="2.2.6" id="intro-nested.functions-context"><span class="secno">2.2.6. </span><span class="content">Additional Modifications for Nested Functions</span><a class="self-link" href="#intro-nested.functions-context"></a></h4>
   <p>The paper <a data-link-type="biblio" href="#biblio-n3654" title="n3654: Accessing the Context of Nested Functions">[n3654]</a> discusses various potential modifications and directions for GNU Nested Functions. It contains many assertions and future directions, which are discussed in the Appendix (<a href="#appendix-nested.functions.context">§ 5.1 Accessing Context in Nested Functions</a>).</p>
   <h3 class="heading settled" data-level="2.3" id="intro-blocks"><span class="secno">2.3. </span><span class="content">Apple Blocks</span><a class="self-link" href="#intro-blocks"></a></h3>
   <p>Blocks are an approach to having functions and data that originate from Objective-C (<a data-link-type="biblio" href="#biblio-apple-blocks" title="Documentation Archive: Declaring and Creating Blocks">[apple-blocks]</a>) and are associated with Apple’s Clang. They were proposed a long time ago in an overview of Apple Extensions for C by Garst in 2009 (<a data-link-type="biblio" href="#biblio-n1370" title="n1370: Apple Extensions to C">[n1370]</a>), refined into a specific proposal in 2010 (<a data-link-type="biblio" href="#biblio-n1451" title="n1451: Blocks Proposal">[n1451]</a> <a data-link-type="biblio" href="#biblio-n1457" title="n1457: Blocks">[n1457]</a>). It was later <strong>further</strong> refined into a proper "Closures" proposal, and the name changed (<a data-link-type="biblio" href="#biblio-n2030" title="n2030: A Closure for C">[n2030]</a>). However, none of these papers made the standard and despite a brief moment where GCC maintained a Blocks runtime, the extension has not been adopted outside of the C / Objective-C ecosystem (and the Blocks extension is no longer allowed or used at the moment).</p>
   <p>Because there is a wealth of proposals and literature talking about Blocks, their implementation, their runtime, and more (see <a href="https://stackoverflow.com/a/65775152">an answer discussing the intrinsics and implementation bits for Blocks</a>), rather than inform proposal readers how they work and why they are not suitable for ISO C, this proposal will focus exclusively on why they are not usable for the whole C ecosystem.</p>
   <h4 class="heading settled" data-level="2.3.1" id="intro-blocks-expression"><span class="secno">2.3.1. </span><span class="content">Expression</span><a class="self-link" href="#intro-blocks-expression"></a></h4>
   <p>Unlike GNU Nested Functions, Block definitions are an expression. That means that -- given appropriate typing -- one can use blocks directly within a function call:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
	
  <c- n>qsort_b</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c->
    <c- o>^</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
      <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
    <c- p>}</c->
  <c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>The special <code class="highlight"><c- n>function_type</c-><c- o>^</c-></code> and <code class="highlight"><c- n>return_type</c-> <c- p>(</c-><c- n>identifier</c-><c- o>^</c-><c- p>)(</c-><c- n>argument0</c-><c- p>,</c-> <c- n>argumentN</c-><c- p>...)</c-></code> are Block types, which are special types that act as a <strong>handle</strong> to a Block. Blocks are not just a simplistic combination of a function and a context, however: much more effort is put into making them safe at execution time, and that is done by putting everything related to Blocks behind a hefty runtime.</p>
   <h4 class="heading settled" data-level="2.3.2" id="intro-blocks-runtime"><span class="secno">2.3.2. </span><span class="content">Runtime Required</span><a class="self-link" href="#intro-blocks-runtime"></a></h4>
   <p>Apple Blocks are, at their core, dynamic objects that engage in type-erasure at the top-most level. Where C++ lambdas are completely non-type-erased and each contains a unique type, and where Nested Functions are completely type-erased behind normal function pointers with executable stacks + trampolines, Blocks are callbacks that are unique but have all of their type information erased and carted around in a <strong>new</strong> function pointer-like construct: the block. Block types are denoted by the <code class="highlight"><c- o>^</c-></code> in their function type name, and typically are cheaply copiable <strong>handles</strong> to a heap-stored callable.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> The layout of the heap-stored callable is dictated by Apple, and has been reverse-engineered and deconstructed many times. Some of this work has been done by the Clang Team, and is the most up-to-date, thorough specification for it is stored in with the Clang documentation (<a data-link-type="biblio" href="#biblio-clang-blocks-spec" title="Clang + LLVM (Latest): Block Implementation Specification">[clang-blocks-spec]</a>).</p>
   <p>Of course, all of this is just to illustrate the problem: while Microsoft as a platform may not need to care, GCC and Clang both tend to occupy the same hardware and software spaces. Even if one compiler or another figured out how to be clever, the base layout -- and the premise of blocks being a <strong>handle</strong> to a heap, and not a compile-time sized object -- means that some form of dynamic allocation or heap is required. This is a net-negative for memory-constrained environments, and in implementations that attempt to be ABI-compatible with the original Apple Blocks implementation will be forced to lay their blocks out in the way that Apple has already specified.</p>
   <h5 class="heading settled" data-level="2.3.2.1" id="intro-blocks-runtime-stack.based"><span class="secno">2.3.2.1. </span><span class="content">More Complications: Generally Unsafe to Return</span><a class="self-link" href="#intro-blocks-runtime-stack.based"></a></h5>
   <p>All block literals are <strong>not</strong> initially placed on the heap or allocated through the run-time, as a blanket optimization applied to all block literals. They start out on the stack! Which means that while the above code using a literal works just fine, this code is actually Undefined Behavior, in a way that’s equally as bad as GNU Nested Functions:</p>
<pre class="language-cpp highlight"><c- cp>#define __STDC_WANT_LIB_EXT1__ 1</c->

<c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>typedef</c-> <c- b>int</c-> <c- nf>compare_fn_t</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>);</c->

<c- n>compare_fn_t</c-><c- o>^</c-> <c- n>make_compare</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- d>/* LOCAL variable.... */</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- n>compare_fn_t</c-><c- o>^</c-> <c- n>compare</c-> <c- o>=</c-> <c- o>^</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>};</c->
  <c- k>return</c-> <c- n>compare</c-><c- p>;</c->
<c- p>}</c->

<c- b>int</c-> <c- n>compare_trampoline</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c-> <c- p>{</c->
  <c- n>compare_fn_t</c-><c- o>^*</c-> <c- n>p_compare</c-> <c- o>=</c-> <c- p>(</c-><c- n>compare_fn_t</c-><c- o>^*</c-><c- p>)</c-><c- n>user</c-><c- p>;</c->
  <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p_compare</c-><c- p>)(</c-><c- n>left</c-><c- p>,</c-> <c- n>right</c-><c- p>);</c->
<c- p>}</c->

<c- b>int</c-> <c- n>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->  

  <c- n>compare_fn_t</c-><c- o>^</c-> <c- n>compare</c-> <c- o>=</c-> <c- n>make_compare</c-><c- p>(</c-><c- n>argc</c-><c- p>,</c-> <c- n>argv</c-><c- p>);</c->
  <c- n>qsort_s</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare_trampoline</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>compare</c-><c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>This code does not work. Despite having a runtime, it will NOT perform the lift to the heap automatically. The return from <code class="highlight"><c- n>make_compare</c-></code> into <code class="highlight"><c- n>compare_fn_t</c-><c- o>^</c-> <c- n>compare</c-></code> is a dangling reference, and is explicitly discouraged by reference materials and documentation from Apple. It must be modified to use <code class="highlight"><c- n>Block_copy</c-></code> on the <code class="highlight"><c- k>return</c-></code>:</p>
<pre class="language-cpp highlight"><c- cp>#define __STDC_WANT_LIB_EXT1__ 1</c->

<c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>typedef</c-> <c- b>int</c-> <c- nf>compare_fn_t</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>);</c->

<c- n>compare_fn_t</c-><c- o>^</c-> <c- n>make_compare</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- d>/* LOCAL variable.... */</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- n>compare_fn_t</c-><c- o>^</c-> <c- n>compare</c-> <c- o>=</c-> <c- o>^</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>};</c->
  <c- k>return</c-> <c- n>Block_copy</c-><c- p>(</c-><c- n>compare</c-><c- p>);</c->
<c- p>}</c->

<c- b>int</c-> <c- n>compare_trampoline</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c-> <c- p>{</c->
  <c- n>compare_fn_t</c-><c- o>^*</c-> <c- n>p_compare</c-> <c- o>=</c-> <c- p>(</c-><c- n>compare_fn_t</c-><c- o>^*</c-><c- p>)</c-><c- n>user</c-><c- p>;</c->
  <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p_compare</c-><c- p>)(</c-><c- n>left</c-><c- p>,</c-> <c- n>right</c-><c- p>);</c->
<c- p>}</c->

<c- b>int</c-> <c- n>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->  

  <c- n>compare_fn_t</c-><c- o>^</c-> <c- n>compare</c-> <c- o>=</c-> <c- n>make_compare</c-><c- p>(</c-><c- n>argc</c-><c- p>,</c-> <c- n>argv</c-><c- p>);</c->
  <c- n>qsort_s</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare_trampoline</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>compare</c-><c- p>);</c->
  <c- n>Block_release</c-><c- p>(</c-><c- n>compare</c-><c- p>);</c->

  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>Annoyingly, every call to <code class="highlight"><c- n>Block_copy</c-></code> must be paired with a call to <code class="highlight"><c- n>Block_release</c-></code>. This means that there’s now an invisible (from the perspective of <code class="highlight"><c- n>main</c-></code>) block copy that now needs to be managed with a specific call to <code class="highlight"><c- n>Block_release</c-></code>. One can imagine that every function that returns a Block type should just be assumed to need releasing, but this isn’t always the case: this means there’s an invisible lifetime tracking that even the runtime and the heap does not solve for us! Truly, unfortunate.</p>
   <p>There is also a small gotcha in this example, that only shows up based on where the <code class="highlight"><c- n>compare</c-></code> block is created. This has to do with how Captures work under the Blocks feature.</p>
   <h4 class="heading settled" data-level="2.3.3" id="intro-blocks-captures"><span class="secno">2.3.3. </span><span class="content">Captures</span><a class="self-link" href="#intro-blocks-captures"></a></h4>
   <p>Captures in Apple Blocks work in one of two ways.</p>
   <ul>
    <li data-md>
     <p>referring to the existing object by-name in your code, which will make a <strong>copy</strong> of the object inside of the Block’s implicit capture;</p>
    <li data-md>
     <p>or, annotating a variable with <code class="highlight"><c- n>__block</c-></code>, which will load the object into a sort of intrusive pointer / automatic reference-counted place in memory (managed by the Blocks runtime) to allow it to be referred to be both the surrounding code and the block’s inner guts by-name.</p>
   </ul>
   <p>The reason Apple used this technique, as talked about before, is because it’s <strong>safer</strong> than Nested Functions in the particular regard of using variables and carting them around.</p>
<pre class="language-cpp highlight"><c- cp>#define __STDC_WANT_LIB_EXT1__ 1</c->

<c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>typedef</c-> <c- b>int</c-> <c- nf>compare_fn_t</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>);</c->

<c- n>compare_fn_t</c-><c- o>^</c-> <c- n>make_compare</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- d>/* LOCAL variable.... */</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- n>compare_fn_t</c-><c- o>^</c-> <c- n>compare</c-> <c- o>=</c-> <c- o>^</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>};</c->
  <c- k>return</c-> <c- n>Block_copy</c-><c- p>(</c-><c- n>compare</c-><c- p>);</c->
<c- p>}</c->

<c- b>int</c-> <c- n>compare_trampoline</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c-> <c- p>{</c->
  <c- n>compare_fn_t</c-><c- o>^*</c-> <c- n>p_compare</c-> <c- o>=</c-> <c- p>(</c-><c- n>compare_fn_t</c-><c- o>^*</c-><c- p>)</c-><c- n>user</c-><c- p>;</c->
  <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p_compare</c-><c- p>)(</c-><c- n>left</c-><c- p>,</c-> <c- n>right</c-><c- p>);</c->
<c- p>}</c->

<c- b>int</c-> <c- n>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->  

  <c- n>compare_fn_t</c-><c- o>^</c-> <c- n>compare</c-> <c- o>=</c-> <c- n>make_compare</c-><c- p>(</c-><c- n>argc</c-><c- p>,</c-> <c- n>argv</c-><c- p>);</c->
  <c- n>qsort_s</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare_trampoline</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>compare</c-><c- p>);</c->
  <c- n>Block_release</c-><c- p>(</c-><c- n>compare</c-><c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>The first thing to note is that, because this cannot be translated to a single function pointer, we cannot use <code class="highlight"><c- n>qsort</c-></code>. This means that using such a function without creating some kind of special trampoline is off-limits to us. Again, this is something that could be solved by the introduction of an explicit heap-based trampoline creator (<a href="#appendix-make.trampoline">§ 5.3 Make Trampoline and Singular Function Pointers</a>). Or, one would need to introduce a "wide function pointer" type -- which is exactly what <code class="highlight"><c- n>function_type</c-><c- o>^</c-></code> is -- and change <code class="highlight"><c- n>qsort</c-></code>’s signature to use it for the callback.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> Simply upgrading <code class="highlight"><c- n>qsort</c-></code> with a Block type is an ABI break that would cause old, already-compiled libraries and programs mixed with new programs to combust in painful, hard-to-detect ways. To solve this problem one would need to rely on existing C extensions like Assembly Labels, or work towards Transparent Aliases (<a data-link-type="biblio" href="#biblio-transparent-aliases" title="Transparent Aliases">[transparent-aliases]</a>).</p>
   <p>But, if someone uses <code class="highlight"><c- n>qsort_s</c-></code> -- which takes a <code class="highlight"><c- b>void</c-><c- o>*</c-></code> user data parameter -- one can use it without altering the signature of <code class="highlight"><c- n>qsort</c-></code> directly and create a <code class="highlight"><c- b>void</c-><c- o>*</c-></code>-kick off point as a trampoline. However, there is a bit of an interesting conundrum. Take, for example, moving the creation of the block function further upwards inside of <code class="highlight"><c- n>make_compare</c-></code>:</p>
<pre class="language-cpp highlight"><c- cp>#define __STDC_WANT_LIB_EXT1__ 1</c->

<c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>typedef</c-> <c- b>int</c-> <c- nf>compare_fn_t</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>);</c->

<c- n>compare_fn_t</c-><c- o>^</c-> <c- n>make_compare</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- d>/* LOCAL variable.... */</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->
	
  <c- n>compare_fn_t</c-><c- o>^</c-> <c- n>compare</c-> <c- o>=</c-> <c- o>^</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>};</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>Block_copy</c-><c- p>(</c-><c- n>compare</c-><c- p>);</c->
<c- p>}</c->

<c- b>int</c-> <c- n>compare_trampoline</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c-> <c- p>{</c->
  <c- n>compare_fn_t</c-><c- o>^*</c-> <c- n>p_compare</c-> <c- o>=</c-> <c- p>(</c-><c- n>compare_fn_t</c-><c- o>^*</c-><c- p>)</c-><c- n>user</c-><c- p>;</c->
  <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p_compare</c-><c- p>)(</c-><c- n>left</c-><c- p>,</c-> <c- n>right</c-><c- p>);</c->
<c- p>}</c->

<c- b>int</c-> <c- n>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->  

  <c- n>compare_fn_t</c-><c- o>^</c-> <c- n>compare</c-> <c- o>=</c-> <c- n>make_compare</c-><c- p>(</c-><c- n>argc</c-><c- p>,</c-> <c- n>argv</c-><c- p>);</c->
  <c- n>qsort_s</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare_trampoline</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>compare</c-><c- p>);</c->
  <c- n>Block_release</c-><c- p>(</c-><c- n>compare</c-><c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>This code will sort the list incorrectly even if <code class="highlight"><c- n>in_reverse</c-></code> is set to <code class="highlight"><c- mi>1</c-></code>. That’s because Blocks will capture the variables that get used at the point-of-creation. The value at the point-of-creation is <code class="highlight"><c- mi>0</c-></code>, therefore, <code class="highlight"><c- n>in_reverse</c-></code> is <code class="highlight"><c- mi>0</c-></code> when the function is called later. Even though the <code class="highlight"><c- n>in_reverse</c-></code> variable is <strong>copied</strong> into the block, the block is now sensitive to where it is being created without any indication that it behaves that way. This is safe, but the behavior would throw someone who uses Nested Functions religiously off completely.</p>
   <p>This is, of course, easily fixable by just... moving it down, so it’s hardly a problem:</p>
<pre class="language-cpp highlight"><c- cp>#define __STDC_WANT_LIB_EXT1__ 1</c->

<c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>typedef</c-> <c- b>int</c-> <c- nf>compare_fn_t</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>);</c->

<c- n>compare_fn_t</c-><c- o>^</c-> <c- n>make_compare</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- d>/* LOCAL variable.... */</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->
	
  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->

  <c- c1>// Compare function, with block copy: copies the right value</c->
  <c- n>compare_fn_t</c-><c- o>^</c-> <c- n>compare</c-> <c- o>=</c-> <c- o>^</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>};</c->

  <c- k>return</c-> <c- n>Block_copy</c-><c- p>(</c-><c- n>compare</c-><c- p>);</c->
<c- p>}</c->

<c- b>int</c-> <c- n>compare_trampoline</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c-> <c- p>{</c->
  <c- n>compare_fn_t</c-><c- o>^*</c-> <c- n>p_compare</c-> <c- o>=</c-> <c- p>(</c-><c- n>compare_fn_t</c-><c- o>^*</c-><c- p>)</c-><c- n>user</c-><c- p>;</c->
  <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p_compare</c-><c- p>)(</c-><c- n>left</c-><c- p>,</c-> <c- n>right</c-><c- p>);</c->
<c- p>}</c->

<c- b>int</c-> <c- n>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->  

  <c- n>compare_fn_t</c-><c- o>^</c-> <c- n>compare</c-> <c- o>=</c-> <c- n>make_compare</c-><c- p>(</c-><c- n>argc</c-><c- p>,</c-> <c- n>argv</c-><c- p>);</c->
  <c- n>qsort_s</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare_trampoline</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>compare</c-><c- p>);</c->
  <c- n>Block_release</c-><c- p>(</c-><c- n>compare</c-><c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>If you don’t want to move the creation of the Block for some particular reason, it is not the only way to capture a variable for Blocks! The second way it can capture variables is by using <code class="highlight"><c- n>__block</c-></code>, which works like so:</p>
<pre class="language-cpp highlight"><c- cp>#define __STDC_WANT_LIB_EXT1__ 1</c->

<c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>typedef</c-> <c- b>int</c-> <c- nf>compare_fn_t</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>);</c->

<c- n>compare_fn_t</c-><c- o>^</c-> <c- n>make_compare</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- d>/* BLOCK-QUALIFIED variable.... */</c->
  <c- n>__block</c-> <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->
	
  <c- n>compare_fn_t</c-><c- o>^</c-> <c- n>compare</c-> <c- o>=</c-> <c- o>^</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>};</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>Block_copy</c-><c- p>(</c-><c- n>compare</c-><c- p>);</c->
<c- p>}</c->

<c- b>int</c-> <c- n>compare_trampoline</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c-> <c- p>{</c->
  <c- n>compare_fn_t</c-><c- o>^*</c-> <c- n>p_compare</c-> <c- o>=</c-> <c- p>(</c-><c- n>compare_fn_t</c-><c- o>^*</c-><c- p>)</c-><c- n>user</c-><c- p>;</c->
  <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p_compare</c-><c- p>)(</c-><c- n>left</c-><c- p>,</c-> <c- n>right</c-><c- p>);</c->
<c- p>}</c->

<c- b>int</c-> <c- n>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->  

  <c- n>compare_fn_t</c-><c- o>^</c-> <c- n>compare</c-> <c- o>=</c-> <c- n>make_compare</c-><c- p>(</c-><c- n>argc</c-><c- p>,</c-> <c- n>argv</c-><c- p>);</c->
  <c- n>qsort_s</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare_trampoline</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>compare</c-><c- p>);</c->
  <c- n>Block_release</c-><c- p>(</c-><c- n>compare</c-><c- p>);</c->

  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>This will work as expected, even though the creation of the block comes after <code class="highlight"><c- n>in_reverse</c-></code> is declared and before modification of the variable. <code class="highlight"><c- n>__block</c-></code> lifts the variable being declared up into a heap (or heap-like space) that is managed by either a garbage collector or an automatic reference-counted memory implementation. This both reverses the onus of capturing / handling the variable onto the surrounding scope and makes it safe-by-design. This does leave an unfortunate gap in that there’s no way to do the dangerous thing or opt into a direct reference without making an explicit declaration of the pointer and then using the pointer by-copy instead in that block, which can leave some memory footprint and program speed on the table without aggressive optimization.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> The address of <code class="highlight"><c- n>in_reverse</c-></code> might <strong>actually</strong> change, depending on if the Apple intrinsic <code class="highlight"><c- n>Block_copy</c-></code> is used to copy the block itself before being run. This code does not depend on it, but a hash map that stores the address of variables might experience the address of any <code class="highlight"><c- n>__block</c-></code>-annotated variables changing between creation and the innovation of <code class="highlight"><c- n>Block_copy</c-></code>. This was changed later on to always set the variable in a location so that a steady address exists, but how conforming it is to keep the old behavior is likely an implementation choice. While there was previously a Blocks runtime for GCC, it’s fallen off: it may make a comeback again in order to be more compatible with the C and C++ code on Apple platforms: whether they will choose the same implementation technique is not known as of the writing of this paper.</p>
   <p>All in all, however, these two things are safe: either a copy is happening and is stored along with the creation of the block on the heap, or the variable itself is having its lifetime prolonged by a sort of automatic-tracking. The second of these is very against the typical properties of C, but that matters little in the face of the obvious safety it brings to the table. Unfortunately, because all of this happens magically and in a mostly-unspecified manner, it’s very detrimental to the proliferation of the C ecosystem and having several loosely-connected implementations working towards the same improved implementations.</p>
   <h4 class="heading settled" data-level="2.3.4" id="intro-blocks-escapes"><span class="secno">2.3.4. </span><span class="content">Optimization: Folding Escapes</span><a class="self-link" href="#intro-blocks-escapes"></a></h4>
   <p>As a matter of optimization, Blocks do not necessarily have to pollute the heap. And indeed, most immediately invocations of a block or pass-down (rather than pass-up) invocations that are visible will be optimized into a direct call. Unfortunately, this is not something that is encouraged by the general design of Apple Blocks and Objective-C or Objective-C++. Because taking the address or passing the function along leaves it open to how far the handle-to-some-heap Block-typed object might be passed, compilers have to correctly (and pessimistically) generate the full, indirect-function-call representation as a matter of course. <code class="highlight"><c- n>Block_copy</c-></code> also needs to be used, explicitly, in many cases, making it not much better in regular C code that uses <code class="highlight"><c- n>malloc</c-></code>.</p>
   <p>As a brief aside in Programming Language design, this sort of optimization problem is mitigated by changing how the defaults are applied and giving the user explicit control. For example, the Swift Programming Language solves this problem while still being compatible with Objective-C and C++ by making it so every "Block" or "Closure" type must be annotated if it "escapes" beyond the compiler’s knowledge, otherwise the program just refuses to compile (<a data-link-type="biblio" href="#biblio-swift-escapes" title="The Swift Programming Language: Closures">[swift-escapes]</a>). This allows aggressive optimization to be applied by-default, with weaker static analysis-based optimizations or escape analysis optimization only acting as a fallback in the <code class="highlight">@<c- n>escaping</c-></code>-annotated case. The annotation also makes it so <code class="highlight"><c- n>Block_copy</c-></code> does not need to be invoked and rather than having to copy it to a heap version of itself, it is simply put in the right format and place, ready to interoperate cleanly with C, C++, Objective-C or Objective-C++.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> Swift’s native function type and ABI is not identical to the Blocks type at all. This is just an example in how designing with no-escape as a default and then taking it off to allow for taking its address or returning it from a function</p>
   <p>In the opposite direction, the C-style attribute that can be used to say "the closure never escapes", which enables optimizations for crunching the object down and assuming that it never is invoked outside of the function. This is available through the <code class="highlight"><c- n>NS_NOESCAPE</c-></code> macro, which expands to <code class="highlight"><c- n>__attribute__</c-><c- p>((</c-><c- n>noescape</c-><c- p>))</c-></code> and can be used to gain better binary size and reduce indirection for code execution speed where possible.</p>
   <h4 class="heading settled" data-level="2.3.5" id="intro-blocks-trampoline"><span class="secno">2.3.5. </span><span class="content">(Explicit) Trampolines: Page-based Non-Executable Implementation</span><a class="self-link" href="#intro-blocks-trampoline"></a></h4>
   <p>Objective-C has the ability to create a C-style function pointer from a Block (<a data-link-type="biblio" href="#biblio-objective-c-block-trampoline" title="Objective-C Runtime / imp_implementationWithBlock">[objective-c-block-trampoline]</a>), and this implementation can be wielded from regular C code on Apple too. This implementation is an entirely different version that does not use a heap but instead a separate "stack" (a single page). That page is a writable (but NOT executable) slab of memory trampolines and Block pointer data in it. The actual trampoline function pulls from this single page one of the data pointers and then sets it up to call; because the trampoline is separate from the actual data, there is much less security risk from writing and reading a pointer that otherwise might be local to executable memory.</p>
   <p>However, because of the implementation, occasionally Objective-C can run out of trampolines: if enough are created before any are deallocated, the entire page can be filled up with trampolines. This will trigger errors and failures to create the block. Therefore, even compared to heap-based GNU Nested Function implementation (<a href="#intro-nested.functions-alternative.implementations-attempt.three">§ 2.2.3.2 Attempt 3</a>), there exists a potential tradeoff in the designs. This is why trampolines need to be explicit and should be handled in a separate paper, with an interface that can be generalized and can report potential errors (<a href="#appendix-make.trampoline">§ 5.3 Make Trampoline and Singular Function Pointers</a>).</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> Modern designs of the Page-based Non-Executable Implementation includes a growable array / linked list of pages, however, so the growth problem no longer exists for Modern Objective-C (read: Apple) platforms anymore. This still presents there being an allocation problem, in needing to have space to grow and having a potential failure point if getting the combination of writable-but-not-executable and read-able-and-executable pages for this design happens to hit a problem.</p>
   <h3 class="heading settled" data-level="2.4" id="intro-lambdas"><span class="secno">2.4. </span><span class="content">C++-Style Lambdas</span><a class="self-link" href="#intro-lambdas"></a></h3>
   <p>C++ lambdas, despite coming from C++ initially, is the only solution not to apply executable stack, separate stack, Function Descriptors, or other dynamic/runtime data, to the problem. It was detailed in a large collection of proposals from Jens Gustedt and almost made C23, but ambition in trying to allow for type-generic programming through lambdas with <code class="highlight"><c- k>auto</c-></code> parameters stalled progress and ultimately halted everything (<a data-link-type="biblio" href="#biblio-n2923" title="Type inference for variable definitions and function returns">[n2923]</a> <a data-link-type="biblio" href="#biblio-n2924" title="Type-generic Lambdas">[n2924]</a> <a data-link-type="biblio" href="#biblio-n2892" title="Basic lambdas for C">[n2892]</a> <a data-link-type="biblio" href="#biblio-n2893" title="Options for Lambdas">[n2893]</a>). It makes a unique type for each and every lambda object that gets created using the syntax <code class="highlight"><c- p>[</c-> <c- n>captures</c-> <c- p>...</c-> <c- p>]</c-> <c- p>(</c-> <c- n>args</c-> <c- p>...</c-> <c- p>)</c-> <c- p>{</c-> <c- d>/* code ... */</c-> <c- p>}</c-></code>, and that object has an implementation-defined but compile-time known size.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> While type inference for function returns are not yet in, a section of <a data-link-type="biblio" href="#biblio-n2923" title="Type inference for variable definitions and function returns">[n2923]</a> was broken off for just variable definitions which ultimately succeeded. Type-inferred variable declarations work properly in C23 and are an important part of Lambdas being able to work in the manner envisioned by Gustedt’s proposals and by C++.</p>
   <p>If a lambda has no captures, it can reduce to a function pointer like so:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>static</c-> <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
	
  <c- k>auto</c-> <c- n>compare</c-> <c- o>=</c-> <c- p>[](</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>};</c->
  <c- c1>// "compare" below becomes a function pointer</c->
  <c- n>qsort</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare</c-><c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>The one thing that makes it different from GNU Nested Functions -- and somewhat similar to Blocks -- is that it is also an expression. That means that it can also be used inside of a function call expression as an argument, or as part of any other complicated chain of additions:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>static</c-> <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
	
  <c- n>qsort</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c->
    <c- p>[](</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>untyped_left</c-><c- p>;</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>untyped_right</c-><c- p>;</c->
      <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
    <c- p>}</c->
  <c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>Again, this only works because there are no captures. When captures get involved, the above code will simply stop compiling at all because the conversion to a function pointer stops working. This can be solved in the ways discussed previously, such as:</p>
   <ul>
    <li data-md>
     <p>a version of <code class="highlight"><c- n>qsort</c-></code> which takes a <code class="highlight"><c- b>void</c-><c- o>*</c-></code> user data parameter, like <code class="highlight"><c- n>qsort_s</c-></code> does;</p>
    <li data-md>
     <p>a version of <code class="highlight"><c- n>qsort</c-></code> which takes a "wide" function pointer types, similar to how Blocks do with the <code class="highlight"><c- n>qsort_b</c-></code> defined by Apple/BSDs;</p>
    <li data-md>
     <p>or, allowing a separate facility which lifts the complex closure type into a single function pointer through a trampoline or similar (<a href="#appendix-make.trampoline">§ 5.3 Make Trampoline and Singular Function Pointers</a>).</p>
   </ul>
   <p>This gives Lambdas a heavy weakness similar to all of the other solutions: there must be either a trampoline, a wide function pointer type, a <code class="highlight"><c- b>void</c-><c- o>*</c-></code> user data/context pointer, or a something else to accommodate the lack of transformation into a singular function pointer.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> C++ as a language has a more robust set of core primitives, they don’t have to worry about this problem. <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function</c-><c- o>&lt;</c-><c- n>FUNCTION_TYPE</c-><c- o>></c-></code> is a type-erased way to transport a whole function object, as a copy, through API boundaries that is defined entirely in their library mechanisms. For a view into any old function, there is <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function_ref</c-><c- o>&lt;</c-><c- n>FUNCTION_TYPE</c-><c- o>></c-></code>, which is like a function pointer but allows pointing into many different kinds of functions that exist in C++. This makes the integration of lambdas into C++ easy; in C, it is much more difficult to have this all participate in the system automatically. There is no <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function</c-></code>-alike in C, and there’s no <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function_ref</c-></code>-alike in C either for new function types like GNU Nested Functions, Apple Blocks, or otherwise. This problem has to be solved separately, with a Wide Function Pointer type (<a href="#appendix-wide.function.pointer">§ 5.2 Wide Function Pointer Type</a>) or with explicit user trampoline-making capability such as <a href="#appendix-make.trampoline">§ 5.3 Make Trampoline and Singular Function Pointers</a>.</p>
   <h4 class="heading settled" data-level="2.4.1" id="intro-lambdas-captures"><span class="secno">2.4.1. </span><span class="content">Captures and Data</span><a class="self-link" href="#intro-lambdas-captures"></a></h4>
   <p>Lambdas do not capture any context by default, unlike both GNU Nested Functions or Apple Blocks. Instead, every capture must be manually annotated as either being taken by value or by reference, or a "universal capture" must be used to set a default method of capturing all visible, in-scope, block objects.</p>
<pre class="language-cpp highlight"><c- cp>#define __STDC_WANT_LIB_EXT1__ 1</c->

<c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- c1>// a new kind of return type: "inferred"</c->
<c- k>auto</c-> <c- n>make_compare</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->
	
  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
  <c- c1>// explicitly capture in the "[ ]" of the lambda</c->
  <c- k>auto</c-> <c- n>compare</c-> <c- o>=</c-> <c- p>[</c-><c- n>in_reverse</c-><c- p>](</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>};</c->
  <c- k>return</c-> <c- n>compare</c-><c- p>;</c->
<c- p>}</c->

<c- b>int</c-> <c- n>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->  

  <c- k>auto</c-> <c- n>compare</c-> <c- o>=</c-> <c- n>make_compare</c-><c- p>(</c-><c- n>argc</c-><c- p>,</c-> <c- n>argv</c-><c- p>);</c->
  <c- k>auto</c-> <c- n>compare_trampoline</c-> <c- o>=</c-> <c- p>[](</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c-> <c- p>{</c->
    <c- n>typeof</c-><c- p>(</c-><c- n>compare</c-><c- p>)</c-><c- o>*</c-> <c- n>p_compare</c-> <c- o>=</c-> <c- n>user</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p_compare</c-><c- p>)(</c-><c- n>left</c-><c- p>,</c-> <c- n>right</c-><c- p>);</c->
  <c- p>};</c->
  <c- n>qsort_s</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare_trampoline</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>compare</c-><c- p>);</c->

  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>This, unfortunately, also makes them susceptible to location just like Blocks; the moment of creation during execution is the state they capture when using unadorned identifiers <code class="highlight"><c- n>in_reverse</c-></code> and <code class="highlight"><c- o>=</c-></code> captures. This code would capture <code class="highlight"><c- n>in_reverse</c-></code> before any important modifications happens.</p>
<pre class="language-cpp highlight"><c- cp>#define __STDC_WANT_LIB_EXT1__ 1</c->

<c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- c1>// a new kind of return type: "inferred" (`auto`)</c->
<c- k>auto</c-> <c- n>make_compare</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->
	
  <c- c1>// "capture all variables" annotation `=` -- same as writing the flat name of</c->
  <c- c1>// every object currently in-scope.</c->
  <c- k>auto</c-> <c- n>compare</c-> <c- o>=</c-> <c- p>[</c-><c- o>=</c-><c- p>](</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>};</c->
  <c- c1>// lambdas and captures do not reflect any changes beyond this point,</c->
  <c- c1>// including the `in_reverse`</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>compare</c-><c- p>;</c->
<c- p>}</c->

<c- b>int</c-> <c- n>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->  

  <c- k>auto</c-> <c- n>compare</c-> <c- o>=</c-> <c- n>make_compare</c-><c- p>(</c-><c- n>argc</c-><c- p>,</c-> <c- n>argv</c-><c- p>);</c->
  <c- k>auto</c-> <c- n>compare_trampoline</c-> <c- o>=</c-> <c- p>[](</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c-> <c- p>{</c->
    <c- n>typeof</c-><c- p>(</c-><c- n>compare</c-><c- p>)</c-><c- o>*</c-> <c- n>p_compare</c-> <c- o>=</c-> <c- n>user</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p_compare</c-><c- p>)(</c-><c- n>left</c-><c- p>,</c-> <c- n>right</c-><c- p>);</c->
  <c- p>};</c->
  <c- n>qsort_s</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare_trampoline</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>compare</c-><c- p>);</c->

  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>Like Apple Blocks, a lambda with captures is safe to return with the by-value capture (if one briefly ignores the need for <code class="highlight"><c- n>Block_copy</c-></code> to reseat the memory of a Block). Additionally, it is better here because there is no usage of the heap needed to do this.</p>
   <p>ASSERTION: This is PRIMARILY due to C++-style Lambdas just being normal objects. They have a compile-time <code class="highlight"><c- k>sizeof</c-><c- p>(...)</c-></code>, a compile-time <code class="highlight"><c- k>alignof</c-><c- p>(...)</c-></code>, can have their unique type inspected with <code class="highlight"><c- n>typeof</c-><c- p>(...)</c-></code> (<code class="highlight"><c- n>decltype</c-><c- p>(...)</c-></code> in C++), and are generally autonomous. There’s no erasure happening here as is with Blocks (the <code class="highlight"><c- n>function_type</c-><c- o>^</c-></code> type) or Nested Functions (the <code class="highlight"><c- n>function_type</c-><c- o>*</c-></code> type); each Lambdas is a unique type, similar to the unique type gained by pairing a function with a hand-made <code class="highlight"><c- k>struct</c-></code>.</p>
   <p>The only problem is that this requires a feature that was proposed for C23 but didn’t make it (along with Lambdas not making it): deduced return types. There was consensus to have the feature, but the feature was bundled with the set of Lambda proposals, and thus fell through during the final stretch of C23. Therefore, a proposal for inferring the type of a function return should be separated from the previous proposals (such as <a data-link-type="biblio" href="#biblio-n2923" title="Type inference for variable definitions and function returns">[n2923]</a>) in order to accommodate such behavior in C.</p>
   <p>One of the things that’s better about Lambdas over Apple Blocks is that they <em>also</em> allow for <em>by-name</em> capture, just like Nested Functions do. So, this code -- despite having the lambda defined in <code class="highlight"><c- n>main</c-></code> and before <code class="highlight"><c- n>in_reverse</c-></code> is changed -- will work as expected:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

  <c- c1>// &amp; is by-reference capture</c->
  <c- k>auto</c-> <c- n>compare</c-> <c- o>=</c-> <c- p>[</c-><c- o>&amp;</c-><c- p>](</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>};</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
	
  <c- k>auto</c-> <c- n>compare_trampoline</c-> <c- o>=</c-> <c- p>[](</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c-> <c- p>{</c->
    <c- n>typeof</c-><c- p>(</c-><c- n>compare</c-><c- p>)</c-><c- o>*</c-> <c- n>p_compare</c-> <c- o>=</c-> <c- n>user</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p_compare</c-><c- p>)(</c-><c- n>left</c-><c- p>,</c-> <c- n>right</c-><c- p>);</c->
  <c- p>};</c->
  <c- n>qsort_s</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare_trampoline</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>compare</c-><c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p><strong class="advisement"> This will invoke undefined behavior in the case of moving this <em>by-name</em> capturing lambda into a function and then returning it. Capturing a name with <code class="highlight"><c- o>&amp;</c-><c- n>some_identifier</c-></code> (or using the "default capture" of <code class="highlight"><c- o>&amp;</c-></code> by itself) always captures by pointer of the variable.</strong></p>
   <p>Even if it is more explicit that in the Nested Functions case, the danger is still present and so care must still be exercised. That is, the following is undefined behavior because of the explicit by-reference <code class="highlight"><c- o>&amp;</c-></code> capture:</p>
<pre class="language-cpp highlight"><c- cp>#define __STDC_WANT_LIB_EXT1__ 1</c->

<c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- c1>// a new kind of return type: "inferred" (`auto`)</c->
<c- k>auto</c-> <c- n>make_compare</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->
	
  <c- c1>// capture just one variable, and capture it "by-name" / "by-reference"</c->
  <c- k>auto</c-> <c- n>compare</c-> <c- o>=</c-> <c- p>[</c-><c- o>&amp;</c-><c- n>in_reverse</c-><c- p>](</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>};</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- c1>// lambda will reflect this change</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->

  <c- c1>// uh oh...</c->
  <c- k>return</c-> <c- n>compare</c-><c- p>;</c->
<c- p>}</c->

<c- b>int</c-> <c- n>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->  

  <c- k>auto</c-> <c- n>compare</c-> <c- o>=</c-> <c- n>make_compare</c-><c- p>(</c-><c- n>argc</c-><c- p>,</c-> <c- n>argv</c-><c- p>);</c->
  <c- k>auto</c-> <c- n>compare_trampoline</c-> <c- o>=</c-> <c- p>[](</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c-> <c- p>{</c->
    <c- n>typeof</c-><c- p>(</c-><c- n>compare</c-><c- p>)</c-><c- o>*</c-> <c- n>p_compare</c-> <c- o>=</c-> <c- n>user</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p_compare</c-><c- p>)(</c-><c- n>left</c-><c- p>,</c-> <c- n>right</c-><c- p>);</c->
  <c- p>};</c->
  <c- n>qsort_s</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare_trampoline</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>compare</c-><c- p>);</c->

  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>This means that lambdas can be <strong>made</strong> to be unsafe, by capturing things whose lifetime dies even as the lambda itself is passed around or returned. This allows for a sleeker representation and no runtime-heap, but with the OBVIOUS drawback that no automated reference-counted variable also means no implicit lifetime safety like with the <code class="highlight"><c- n>__block</c-></code> variables. Thankfully, since captures can be done both ways, the user can either choose to capture by reference, choose to capture by value, or -- if needed -- choose to allocate and then capture the new allocated pointer by value themselves. Of course, any explicit allocation will need to be freed, just as it would in a Blocks scenario. This usually implies waiting for a signaling callback from the API that it is done, or elevating the lifetime to a higher level to be deleted at a later time.</p>
   <h4 class="heading settled" data-level="2.4.2" id="intro-lambdas-destructors"><span class="secno">2.4.2. </span><span class="content">What About Lifetime / Destructors?</span><a class="self-link" href="#intro-lambdas-destructors"></a></h4>
   <p>A common criticism of Lambdas and their unique type, whole-object approach is that such an approach with captures requires C++-style destructors to work well. We are completely unsure why this is the case or why this criticism keeps being levied specifically at Lambdas. In the previous section on Apple Blocks (<a href="#intro-blocks-runtime-stack.based">§ 2.3.2.1 More Complications: Generally Unsafe to Return</a>), coordinated function calls and documentation are the only way to communicate that a user has <code class="highlight"><c- n>Block_copy</c-></code>’d an object and therefore requires <code class="highlight"><c- n>Block_release</c-></code>. Similarly with GNU Nested Functions, returning them up the stack <em>at all</em> is pure undefined behavior, that has tangible effects on the program (<a href="#intro-nested.functions-captures">§ 2.2.4 The Nature of Captures</a>): these are problems endemic to C. Using a complex data structure like a binary tree or allocating memory requires that it is documented and communicated to the user: capturing such complex types and having it called over a longer period of time simply means the user has the responsibility to clean up or free the resources.</p>
   <p>C APIs will always provide a user with provided functions a way to know when something must be cleaned up. For example, the Lua C API has an allocation function that is specifically called with a "new size" parameter of <code class="highlight"><c- mi>0</c-></code>, it means memory passed in must be freed; that’s how it communicates what the current action is. Similarly, ev/libev -- with <code class="highlight"><c- n>ev_set_allocator</c-></code> -- provides a hook to allow a user to manage the memory of the library, while also providing <strong>several</strong> statuses in callbacks for watchers (<code class="highlight"><c- n>initialized</c-></code>/<code class="highlight"><c- n>pending</c-></code>/<code class="highlight"><c- n>running</c-></code>/<code class="highlight"><c- n>stopped</c-></code>/etc.). Even for standard C, <code class="highlight"><c- n>thrd_create</c-></code> passes a <code class="highlight"><c- b>void</c-><c- o>*</c-></code> user data to the <code class="highlight"><c- n>func</c-></code> that gets run on the new thread: a user must allocate and then pass the user data to the thread, and it becomes the thread’s responsibility to manage the lifetime of that type in a manner that is thread safe.</p>
   <p>Any C API worth its salt, when dealing with convoluted lifetimes, provides to a given callback (through its parameters) a notification that the memory is not usable anymore, OR a separate callback (for more full-fledged APIs) that notifies the API that its finished or done with a specific operation, and therefore safe to close things out. The secondary alternative is, of course, statically sourcing lifetime until the user themselves guarantees all resources can be safely freed using some outside knowledge (e.g., an explicit set of calls after the start of the library to cleanup/close/stop the library). This is not just a point with lambdas: every attempt at solving this problem has to engage with this. Whether it’s using <code class="highlight"><c- n>Block_copy</c-></code> to ensure the lifetime of an Apple Block, or <code class="highlight"><c- n>malloc</c-></code> to make sure a <code class="highlight"><c- k>struct</c-></code> type being pointed to by a <code class="highlight"><c- b>void</c-><c- o>*</c-></code> is accessible after a dispatch to an asynchronous function call. This is simply not a problem unique to lambdas: lifetime tracking and safety will always be a problem in C because C has no extended concept of lifetime duration beyond Effective Types.</p>
   <p>Any problem with lifetime is going to be present in every single iteration of the solution to this problem, and is going to manifest in different ways:</p>
   <ul>
    <li data-md>
     <p>UB if you return a GNU Nested Function pointer that works with variables in the function scope being exited;</p>
    <li data-md>
     <p>UB if you return an Apple Blocks pointer without <code class="highlight"><c- n>Block_copy</c-></code>;</p>
    <li data-md>
     <p>UB if you capture things that go out of scope in general (safe defaults for Apple Blocks, safe defaults for Lambdas with <code class="highlight"><c- p>[</c-><c- o>=</c-><c- p>]</c-></code> or just <code class="highlight"><c- n>ident</c-></code> captures);</p>
    <li data-md>
     <p>UB if you convert to the wrong <code class="highlight"><c- k>struct</c-></code> inside of an ISO C function to access a user data <code class="highlight"><c- b>void</c-><c- o>*</c-></code> pointer;</p>
    <li data-md>
     <p>UB if you <em>by-name</em> capture in a lambda and leave the scope;</p>
   </ul>
   <p>and so on, and so forth. That’s a C-intrinsic problem, and the only thing any design in this space can do is offer better tools or better control to manage or avoid such problems where possible. Lifetime management is not solvable in C as it stands, and no amount of features or tinkering or attributes will really change the intrinsic language design flaw that is pointers and references that do not have any compile-time trackable properties asides from what can be inferred with (potentially strenuous) static analysis.</p>
   <p>One way to alleviate this -- which would be beyond what is currently within C++ and what has been proposed previously -- is to allow for lambdas (beyond their initialization/creation) to have "accessor" syntax for any of its captures using the <code class="highlight"><c- n>lambda</c-><c- p>.</c-><c- n>identifier</c-></code> syntax. This is explored in the later design for the solutions, within <a href="#design-capture.functions-data.captures.fields">§ 3.2.5 NEW: Data Captures are Accessible</a>.</p>
   <h3 class="heading settled" data-level="2.5" id="intro-function.literals"><span class="secno">2.5. </span><span class="content">Function Literals and Local Functions</span><a class="self-link" href="#intro-function.literals"></a></h3>
   <p>There is not much to say about Function Literals (<a data-link-type="biblio" href="#biblio-n3679" title="Function Literals">[n3679]</a>) and Local Functions (<a data-link-type="biblio" href="#biblio-n3678" title="Local Functions">[n3678]</a>) as they deliberately do not engage with the problem of trying to capture and use data. The syntax for Function Literals is based on Compound Literals, wherein the <code class="highlight"><c- p>(</c-> <c- n>abstract</c-><c- o>-</c-><c- n>declarator</c-> <c- p>){</c-> <c- p>...</c-> <c- p>}</c-></code> syntax is repurposed. Currently, <code class="highlight"><c- n>abstract</c-><c- o>-</c-><c- n>declarator</c-></code> being a function type is just a constraint violation in C, so it is safe to repurpose this syntax. The syntax for Local Functions is identical to GCC’s Nested Functions, and thus, all the criticisms and flaws of Nested Functions apply (<a href="#intro-nested.functions">§ 2.2 GNU Nested Functions</a>) with the additional problem that they are refusing to engage with Captures at all, and therefore make it unsuitable for both the GNU Nested Function use case or the Apple Blocks use case.</p>
   <p>By not engaging with the closure/capture issue, Function Literals seek to just be a prettier form of ISO C regular functions. This provides the benefits of not needing to have a wide function pointer type immediately (albeit one is still needed for the general ecosystem), and it allows code to be read in a much more friendly format by localizing the function pointer and, potentially, any user data structures that go with a <code class="highlight"><c- b>void</c-><c- o>*</c-></code>. As a compound literal, it also immediately works since it can be created/used as an expression, meaning it can be passed to function arguments:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>static</c-> <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
  <c- n>qsort</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c->
    <c- p>(</c-><c- b>int</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>))</c-> <c- p>{</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
      <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
    <c- p>}</c->
  <c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>Unfortunately, not having any solution or future direction for captures and repurposing the compound literal syntax for it means that it seems more like a dead end. In the above example, we still have to transfer the <code class="highlight"><c- n>in_reverse</c-></code> with a static for the <code class="highlight"><c- n>qsort</c-></code> call. It gets slightly better if the API has a <code class="highlight"><c- b>void</c-><c- o>*</c-></code> user data carveout, like for <code class="highlight"><c- n>qsort_r</c-></code>:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
  <c- n>qsort_r</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c->
    <c- p>(</c-><c- b>int</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>))</c-> <c- p>{</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>user</c-><c- p>;</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
      <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
    <c- p>},</c->
    <c- o>&amp;</c-><c- n>in_reverse</c->
  <c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>A more pronounced example that uses more than an <code class="highlight"><c- b>int</c-></code> shows that one can write both the <code class="highlight"><c- k>struct</c-></code> and callback locally:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>

<c- k>typedef</c-> <c- b>void</c-> <c- nf>async_callback_t</c-><c- p>(</c-><c- b>int</c-> <c- n>result</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>data</c-><c- p>);</c->
<c- b>void</c-> <c- nf>async</c-><c- p>(</c-><c- n>async_callback_t</c-><c- o>*</c-> <c- n>callback</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>data</c-><c- p>);</c->

<c- b>int</c-> <c- nf>main</c-><c- p>()</c-> <c- p>{</c->
	
  <c- c1>// struct and callback are next to each other</c->
  <c- k>struct</c-> <c- p>{</c-> <c- b>int</c-> <c- n>value</c-><c- p>;</c-> <c- p>}</c-><c- o>*</c-> <c- n>capture</c-> <c- o>=</c-> <c- n>calloc</c-><c- p>(</c-><c- mi>1</c-><c- p>,</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>capture</c-><c- p>));</c->  
  <c- k>auto</c-> <c- n>function</c->  <c- o>=</c-> <c- p>(</c-><c- b>void</c-> <c- p>(</c-><c- b>int</c-> <c- n>result</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-> <c- n>data</c-><c- p>))</c-> <c- p>{</c->
    <c- c1>// anonymous struct only identified by `typeof`,</c->
    <c- c1>// keeps the exact type and helps reduce Type Confusion errors</c->
    <c- n>typeof</c-><c- p>(</c-><c- n>capture</c-><c- p>)</c-> <c- n>captured</c-> <c- o>=</c-> <c- n>data</c-><c- p>;</c->
    <c- n>free</c-><c- p>(</c-><c- n>captured</c-><c- p>);</c->
  <c- p>};</c->
  <c- n>async</c-><c- p>(</c-><c- n>function</c-><c- p>,</c-> <c- n>capture</c-><c- p>);</c-> <c- c1>// used immediately: hard to lose track</c->
  <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
<c- p>}</c->
</pre>
   <h3 class="heading settled" data-level="2.6" id="intro-static.chain"><span class="secno">2.6. </span><span class="content"><code class="highlight"><c- n>__builtin_call_with_static_chain</c-></code></span><a class="self-link" href="#intro-static.chain"></a></h3>
   <p>This is an intrinsic that is available both in GCC and in Clang(<a data-link-type="biblio" href="#biblio-builtin_call_with_static_chain_gcc" title="GCC Online Documentation: Constructing Calls">[builtin_call_with_static_chain_gcc]</a>). It is the thinnest possible wrapper around the idea of a function call and an associated environment; effectively, it picks a location to store a "context" pointer and "chains" that with the expression that will be the function call without needing to pass that context pointer as an argument.</p>
   <p>This kind of intrinsic is effectively directly relatable to what a Wide Function Pointer’s (<a href="#appendix-wide.function.pointer">§ 5.2 Wide Function Pointer Type</a>) internals would look like. It is also either directly compatible with or cheaply convertible to the inner workings of the (vast) majority of cheap closure pointers in other languages, such as Go, Lua, C++, and more. This is a nice intrinsic to have but it is extremely low-level; it is also deeply implementation-defined and underspecified/undocumented even in the implementations that have it. It also does not translate universally, though plenty of individuals remake the same conceptual thing in other languages (Lua with its "environment" tables for execution of certain functions, Zig and Odin contexts for function bodies, and more).</p>
   <p>Standardizing this directly is likely not worth the hassle of trying to pin down a formal specification of what the "static chain" ultimately is. It is also only a single kind of implementation technique for the closure problem: it is not necessarily required to be implemented in the manner that a static chain call would provide or imply. Nevertheless, this is an intrinsic so deep into implementation internals that it could be done separately; we think it would be more applicable and worthwhile to get the better-defined primitives on top of such an intrinsic (such as a Wide Function Pointer type and manual Trampoline creation).</p>
   <h3 class="heading settled" data-level="2.7" id="intro-solution"><span class="secno">2.7. </span><span class="content">Solution</span><a class="self-link" href="#intro-solution"></a></h3>
   <p>This proposal is going to work to standardize both Capture Functions as a C extension-familiar way of working with data that is based on existing practice. It is also going to standardize lambdas for the technical differences between it and Capture Functions, in particular its ability to be used for macros (small but important) and its ability to be C++-compatible (unifying more header and in-line code).</p>
   <p>A different proposal is going to work on the "Make Trampoline" aspect, to allow interoperation with old code. Another different proposal is going to work on providing a "wide function pointer" type. As used in the examples here, we hope to see <code class="highlight"><c- o>%</c-></code> as a pointer-like modifier for a "wide function pointer" type, and if not that perhaps a <code class="highlight"><c- n>_Closure</c-><c- p>(</c-><c- n>function</c-><c- o>-</c-><c- n>type</c-><c- p>)</c-></code> spelling to make it directly accessible by most.</p>
   <h2 class="heading settled" data-level="3" id="design"><span class="secno">3. </span><span class="content">Design</span><a class="self-link" href="#design"></a></h2>
   <p>Given the following properties from all of the extensions and proposals for this in the wild:</p>
   <table class="basic">
    <thead>
     <tr>
      <th>Feature
      <th>GNU Nested Functions
      <th>Apple Blocks
      <th>C++-Style Lambdas in C
      <th>Function Literals
      <th>Local Functions
    <tbody>
     <tr>
      <td>Capture By-Name
      <td>✅<br>(default, use-based)
      <td>✅<br>(<code class="highlight"><c- n>__block</c-> <c- n>ident</c-><c- p>;</c-></code>)
      <td>✅<br>(<code class="highlight"><c- p>[</c-><c- o>&amp;</c-><c- p>]</c-></code>, <code class="highlight"><c- p>[</c-><c- o>&amp;</c-><c- n>ident</c-><c- p>]</c-></code>)
      <td>❌
      <td>❌
     <tr>
      <td>Capture By-Value
      <td>❌
      <td>✅<br>(default, use-based)
      <td>✅<br>(<code class="highlight"><c- p>[</c-><c- o>=</c-><c- p>]</c-></code>, <code class="highlight"><c- p>[</c-><c- n>ident</c-><c- p>]</c-></code>)
      <td>❌
      <td>❌
     <tr>
      <td>Selective Capture
      <td>❌<br>(use-based, by-name only)
      <td>✅<br>(for by-name)<br>❌<br>(for by-value, use-based)
      <td>✅
      <td>❌
      <td>❌
     <tr>
      <td>Safe to Return Closure
      <td>❌
      <td>⚠️<br>(requires <code class="highlight"><c- n>Block_copy</c-></code>)
      <td>✅
      <td>✅<br>(never unsafe)
      <td>✅<br>(never unsafe)
     <tr>
      <td>Relocatable to Heap<br>(Lifetime Management)
      <td>❌
      <td>✅<br>(<code class="highlight"><c- n>Block_copy</c-></code>/<code class="highlight"><c- n>Block_release</c-></code>)
      <td>✅<br>(<code class="highlight"><c- n>malloc</c-></code>/<code class="highlight"><c- n>memcpy</c-></code>/<code class="highlight"><c- n>free</c-></code>)
      <td>✅<br>(not needed)
      <td>✅<br>(not needed)
     <tr>
      <td>Usable Directly as Expression
      <td>❌
      <td>✅
      <td>✅
      <td>✅
      <td>❌
     <tr>
      <td>Forward-Declarable
      <td>✅
      <td>❌
      <td>❌
      <td>❌
      <td>✅
     <tr>
      <td>Immediately Invokable
      <td>❌
      <td>✅
      <td>✅
      <td>✅
      <td>❌
     <tr>
      <td>Convertible to Function Pointer
      <td>✅
      <td>❌
      <td>⚠️<br>(only capture-less)
      <td>✅
      <td>✅
     <tr>
      <td>Convertible to "Wide" Function Type
      <td>✅
      <td>✅
      <td>✅
      <td>✅
      <td>✅
     <tr>
      <td>Access to Non-Erased Object/Type
      <td>❌<br>((wide) function pointer only)
      <td>❌<br>(Block type/wide function pointer only)
      <td>✅<br>(unique type/size)
      <td>❌<br>(no object to access)
      <td>❌
     <tr>
      <td>Access to Captures through Object/Type
      <td>❌
      <td>❌
      <td>❌
      <td>❌
      <td>❌
     <tr>
      <td>Recursion Possible
      <td>✅<br>(use the identifier of the nested function)
      <td>❌<br>(<code class="highlight"><c- n>__self_func</c-></code> required)
      <td>❌<br>(<code class="highlight"><c- n>__self_func</c-></code> required)
      <td>❌<br>(<code class="highlight"><c- n>__self_func</c-></code> required)
      <td>✅<br>(use the identifier of the local function)
   </table>
   <p>This proposal is going to propose two distinct options for standardization, with the recommendation to do both. It is critical to do both for the approval of the C ecosystem in general (with <a href="#design-capture.functions">§ 3.2 Capture Functions: Rehydrated Nested Function</a>), and for  the maximum amount of external language compatibility (C++ in particular, with <a href="#design-lambdas">§ 3.3 Lambdas</a>). The necessary and core goals of this proposal are focused on</p>
   <ul>
    <li data-md>
     <p>compile-time knowable size of the function object (can be treated as a regular object);</p>
    <li data-md>
     <p>that has a unique type with its own size;</p>
    <li data-md>
     <p>does not require a heap or a special stack (unless type-erased or otherwise relocated by (explicit) user action);</p>
    <li data-md>
     <p>can be interacted with like a normal function (but not necessarily as a normal function pointer);</p>
    <li data-md>
     <p>and, does not compromise the security of all or a portion of the program.</p>
   </ul>
   <p>Lambdas already have usage experience with well-known properties that can be directly translated to C and is easy enough to understand, despite the unfortunate syntax. Capture Functions are a simple modification of Nested Functions that produce a sized object (similar to Lambdas) and makes their captures explicit, allowing for a degree of control and additional safety that was not present in the original Nested Functions design.</p>
   <p>We are <strong>not</strong> focused on interoperability with singular function pointers. We believe that should be left to a separate, explicit mechanism in the language, capable of allowing the user to choose where the memory comes from and setting it up appropriately. This way, a user can make the decision <strong>on their own</strong> if they want to use e.g. executable stack (with the consequences that it brings) or just have a part of (heap) memory they set with e.g. Linux <code class="highlight"><c- n>mprotect</c-><c- p>(...)</c-></code> or Win32 <code class="highlight"><c- n>VirtualProtect</c-></code> to be readable, writable, and executable. Such a trampoline-maker (as briefly talked about in <a href="#appendix-make.trampoline">§ 5.3 Make Trampoline and Singular Function Pointers</a>) can also be applied across implementations in a way that the secret sauce powering Nested Functions cannot be: this is much more appealing as an approach.</p>
   <p>We <strong>DO NOT</strong> take any of the design from Blocks because the Blocks design is, as a whole, unsuitable for C. While its deployment of a blocks "type" to fulfill the necessary notion of a "wide function pointer" type is superior to what Nested Functions have produced, the implementation details it imposes for <code class="highlight"><c- n>__block</c-></code> variables and the excessive reliance on an (underspecified) runtime/heap are detrimental to a shared &amp; unified approach to C.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> The Blocks runtime/heap layout has changed (at least) once in its history: the only reason this worked is because Apple owned every part of the Blocks ecosystem. Apple can do whatever they want with it, however they want, whenever they want: this does not work in a language with diverse, loosely coordinated implementations like C and not Objective-C, Objective-C++, or Swift.</p>
   <p>As the heap is (typically) repulsive to some freestanding implementations, we do not want to standardize something that will have similar technological drawbacks like VLAs, where -- even if no syntactical or language-design issues exist from the way blocks are written -- the presence of an unspecified source of memory (stack or heap) produces uncertainty in the final code generation of a program.</p>
   <p>The feature table for these two looks like this:</p>
   <table class="basic">
    <thead>
     <tr>
      <th>Feature
      <th>C Lambdas
      <th>Capture Functions
    <tbody>
     <tr>
      <td>Capture By-Name
      <td>✅ (<code class="highlight"><c- p>[</c-><c- o>&amp;</c-><c- p>]</c-></code>, <code class="highlight"><c- p>[</c-><c- o>&amp;</c-><c- n>ident</c-><c- p>]</c-></code>)
      <td>✅ (<code class="highlight"><c- n>_Capture</c-><c- p>(</c-><c- o>&amp;</c-><c- p>)</c-></code>, <code class="highlight"><c- n>_Capture</c-><c- p>(</c-><c- o>&amp;</c-><c- n>ident</c-><c- p>)</c-></code>)
     <tr>
      <td>Capture By-Value
      <td>✅ (<code class="highlight"><c- p>[</c-><c- o>=</c-><c- p>]</c-></code>, <code class="highlight"><c- p>[</c-><c- n>ident</c-><c- p>]</c-></code>)
      <td>✅ (<code class="highlight"><c- n>_Capture</c-><c- p>(</c-><c- o>=</c-><c- p>)</c-></code>, <code class="highlight"><c- n>_Capture</c-><c- p>(</c-><c- n>ident</c-><c- p>)</c-></code>)
     <tr>
      <td>Selective Capture
      <td>✅
      <td>✅
     <tr>
      <td>Safe to Return Closure
      <td>✅
      <td>✅
     <tr>
      <td>Relocatable to Heap<br>(Lifetime Management)
      <td>✅ (<code class="highlight"><c- n>malloc</c-></code>/<code class="highlight"><c- n>memcpy</c-></code>/<code class="highlight"><c- n>free</c-></code>)
      <td>✅ (<code class="highlight"><c- n>malloc</c-></code>/<code class="highlight"><c- n>memcpy</c-></code>/<code class="highlight"><c- n>free</c-></code>)<br>
     <tr>
      <td>Usable Directly as Expression
      <td>✅
      <td>❌
     <tr>
      <td>Forward-Declarable
      <td>❌
      <td>✅
     <tr>
      <td>Immediately Invokable
      <td>✅
      <td>✅
     <tr>
      <td>Convertible to Function Pointer
      <td>⚠️<br>(only capture-less)
      <td>⚠️<br>(only capture-less)
     <tr>
      <td>Convertible to "Wide" Function Type
      <td>✅
      <td>✅
     <tr>
      <td>Access to Non-Erased Object/Type
      <td>✅<br>(unique type/size)
      <td>✅<br>(unique type/size)
     <tr>
      <td>Access to Captures through Object/Type
      <td>✅
      <td>✅
     <tr>
      <td>Recursion Possible
      <td>❌<br>(<code class="highlight"><c- n>__self_func</c-></code> required)
      <td>✅
   </table>
   <h3 class="heading settled" data-level="3.1" id="design-no"><span class="secno">3.1. </span><span class="content">What is NOT Being Proposed!</span><a class="self-link" href="#design-no"></a></h3>
   <p>While we would like to standardize them in the future, this proposal is NOT looking to standardize statement expressions, a "make trampoline" compiler intrinsic, or a wide function pointer type.</p>
   <h4 class="heading settled" data-level="3.1.1" id="design-no-statement.expressions"><span class="secno">3.1.1. </span><span class="content">Statement Expressions?</span><a class="self-link" href="#design-no-statement.expressions"></a></h4>
   <p>Statement Expressions should be standardized. While it is related to these efforts, it is entirely separate and has a full, robust set of constraints and concerns in standardizing. It has more existing implementation experience, deployment experience, and implementer practice than any of Blocks or Nested Functions combined. Therefore, it will be pursued in a different proposal. This was briefly noted in a proposal collecting existing extensions in 2007 by Stoughton (<a data-link-type="biblio" href="#biblio-n1229" title="Potential Extensions For Inclusion In a Revision of ISO/IEC 9899">[n1229]</a>); while there was enthusiastic support at the time, nothing materialized of the mention nor the in-meeting enthusiasm. Some attempts are being made at standardizing it, but it is notably difficult to standardize due to the large number of corner cases that arise from needing to clarify semantics of constructs that normally cannot appear in certain places being able to suddenly appear there, like a <code class="highlight"><c- k>break</c-><c- p>;</c-></code> being placed in the initializer expression of a <code class="highlight"><c- k>for</c-></code> loop.</p>
   <p>Another advantage of Statement Expressions is that, unlike any of Apple Blocks / C++ Lambdas / GNU Nested Functions, there is no separating function body. This is critical for writing macros that coordinate with one another, AND is critical in writing reusable macros that have no additional cost and does not set up extra individual entry points. For example, there are hundreds of permutations of the functions in C2y’s <code class="highlight"><c- o>&lt;</c-><c- n>stdmchar</c-><c- p>.</c-><c- n>h</c-><c- o>></c-></code> that could be written to make them easier to use, to make them not require double-pointers, to infer the size from a C-style string, and so on, and so forth. The choice of having a bunch of macros which simply repeat the same code means not having to add hundreds of permutations of the <code class="highlight"><c- o>&lt;</c-><c- n>stdmchar</c-><c- p>.</c-><c- n>h</c-><c- o>></c-></code> functions (5 different character types across 5 different encoding types with 6 forms of "pointer and length, just pointer" for input/output, and typical skip/ignore/replace-character error handling strategies, pairwise with one another where order matters).</p>
   <p>Another place that statement expressions come in handy is with <code class="highlight"><c- n>RESULT</c-></code>/<code class="highlight"><c- n>TRY</c-></code>/etc. macros, primarily used for low-level code where handling (and possibly enforcing error handling) is desirable through error codes and return types, as demonstrated <a href="https://gist.github.com/LAK132/0d264549745e8196df1e632d5b518c37">by jade and lak here: https://gist.github.com/LAK132/0d264549745e8196df1e632d5b518c37</a>. Being able to error and jump out or error and stop if things do not work is a very common (and powerful) idiom for writing straightforward code, and is employed heavily in many different ways across the C ecosystem in various forms.</p>
   <p>This paper does not standardize Statement Expressions, and leaves that to a future paper similar to n3643 (<a data-link-type="biblio" href="#biblio-n3643" title="n3643: Statement Expressions (draft)">[n3643]</a>).</p>
   <h4 class="heading settled" data-level="3.1.2" id="design-no-wide.function.pointer"><span class="secno">3.1.2. </span><span class="content">Wide Function Pointer Type?</span><a class="self-link" href="#design-no-wide.function.pointer"></a></h4>
   <p>We do hope that another paper creates a new "Wide Function Pointer" type of some kind. Some suggestions can be found in <a href="#appendix-wide.function.pointer">§ 5.2 Wide Function Pointer Type</a>.</p>
   <h3 class="heading settled" data-level="3.2" id="design-capture.functions"><span class="secno">3.2. </span><span class="content">Capture Functions: Rehydrated Nested Function</span><a class="self-link" href="#design-capture.functions"></a></h3>
   <p>Capture Functions are a slight modification of the design of Nested Functions. We start from the base of Nested Functions with three goals in mind.</p>
   <ul>
    <li data-md>
     <p>Implementers are not comfortable with the implementation baggage associated with Nested Functions or maintaining potential ABI compatibility with those choices (heap/stack trampolines versus separate-page allocations).</p>
    <li data-md>
     <p>We want to allow a way to access captured values explicitly, and control how those captures work.</p>
    <li data-md>
     <p>We want them to be safe to move around and relocate, whether to the heap or copied into static memory or otherwise.</p>
   </ul>
   <p>A brief demonstration of all of the well-defined behavior:</p>
<pre class="language-cpp highlight"><c- k>auto</c-> <c- n>make_seven</c-> <c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>)</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>y</c-> <c- o>=</c-> <c- mi>7</c-><c- p>;</c->
  <c- b>int</c-> <c- nf>seven_fn</c-><c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- n>x</c-><c- p>,</c-> <c- n>y</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- n>y</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>seven_fn</c-><c- p>;</c-> <c- c1>// OK: unique type which</c->
  <c- c1>// is a complete object</c->
<c- p>}</c->

<c- k>typedef</c-> <c- b>int</c-> <c- n>eight_fn_t</c-><c- p>();</c->

<c- n>eight_fn_t</c-><c- o>*</c-> <c- nf>make_eight</c-> <c- p>()</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>eight_fn</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>()</c-> <c- p>{</c->
    <c- k>return</c-> <c- mi>8</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>eight_fn</c-><c- p>;</c-> <c- c1>// OK: empty capture converts to function pointer</c->
<c- p>}</c->

<c- cp>#if 0</c->
<c- c>typedef int nine_fn_t();</c->

<c- c>nine_fn_t* make_nine () {</c->
<c- c>  int val = 30;</c->
<c- c>  int nine_fn () _Capture(val) {</c->
<c- c>    return val;</c->
<c- c>  }</c->
<c- c>  return nine_fn; // constraint violation: cannot convert</c->
<c- c>  // captures to function pointer</c->
<c- c>}</c->
<c- cp>#endif</c->

<c- b>int</c-> <c- nf>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>3</c-><c- p>;</c->
  <c- b>int</c-> <c- n>zero</c-> <c- p>()</c-> <c- p>{</c->
    <c- c1>// OK, no external variables used</c->
    <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>also_zero</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>()</c-> <c- p>{</c->
    <c- c1>// same as above, just explicit</c->
    <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
  <c- p>}</c->
<c- cp>#if 0</c->
<c- c>  int double_it () {</c->
<c- c>    return x * 2; // constraint violation</c->
<c- c>  }</c->
<c- cp>#endif</c->
  <c- b>int</c-> <c- n>triple_it</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- n>x</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>3</c-><c- p>;</c-> <c- c1>// OK, x = 3 when called</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>quadruple_it</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>&amp;</c-><c- n>x</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>4</c-><c- p>;</c-> <c- c1>// OK, x = 5 when called</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>quintuple_it</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>=</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>5</c-><c- p>;</c-> <c- c1>// OK, x = 3 when called</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>sextuple_it</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>&amp;</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>6</c-><c- p>;</c-> <c- c1>// OK, x = 5 when caled</c->
  <c- p>}</c->
  <c- n>x</c-> <c- o>=</c-> <c- mi>5</c-><c- p>;</c->
  <c- k>auto</c-> <c- n>seven_tuple_it</c-> <c- o>=</c-> <c- n>make_seven</c-><c- p>(</c-><c- n>x</c-><c- p>);</c->
  <c- n>eight_fn_t</c-><c- o>*</c-> <c- n>eight</c-> <c- o>=</c-> <c- n>make_eight</c-><c- p>();</c->
  <c- k>return</c-> <c- n>zero</c-><c- p>()</c-> <c- o>+</c-> <c- n>triple_it</c-><c- p>()</c-> <c- o>+</c-> <c- n>quadruple_it</c-><c- p>()</c->
    <c- o>+</c-> <c- n>quintuple_it</c-><c- p>()</c-> <c- o>+</c-> <c- n>sextuple_it</c-><c- p>()</c-> <c- o>+</c-> <c- n>seven_tuple_it</c-><c- p>()</c->
    <c- o>+</c-> <c- n>eight</c-><c- p>();</c->
  <c- c1>// same as</c->
  <c- c1>// return 117;</c->
  <c- c1>// 0 + (3 * 3) + (5 * 4)</c->
  <c- c1>// + (3 * 5) + (5 * 6) + (5 * 7)</c->
  <c- c1>// + 8</c->
<c- p>}</c->
</pre>
   <p>We go over the purpose of the design of this and the reasons for that design here.</p>
   <h4 class="heading settled" data-level="3.2.1" id="design-capture.functions-complete.objects"><span class="secno">3.2.1. </span><span class="content">Capture Functions are Complete Objects (unless only Declared)</span><a class="self-link" href="#design-capture.functions-complete.objects"></a></h4>
   <p>The most important change from typical GNU Nested Functions and mirroring behavior from C++ Lambdas is that nested functions -- the identifier itself introduced by the definition of the function -- is a regular, normal, complete C object. This enables it to be:</p>
   <ul>
    <li data-md>
     <p>returned, if the type is knowable at the time of function definition (or <code class="highlight"><c- k>auto</c-></code> return types are incorporated into the language);</p>
    <li data-md>
     <p>passed to a function, if the function is defined after the creation of the capture functions;</p>
    <li data-md>
     <p>and, stored elsewhere through static/<code class="highlight"><c- k>_Thread_local</c-></code> data with assignment or <code class="highlight"><c- n>memcpy</c-></code>, or even on the heap.</p>
   </ul>
   <p>These are important qualities to allow these functions with data to be used with asynchronous code, as (stored) callbacks, and in other scenarios. The size and alignment of the object is implementation-defined, and its layout is also entirely implementation-defined, much like the properties of a regular <code class="highlight"><c- k>struct</c-></code> or <code class="highlight"><c- k>union</c-></code> type. This allows implementations to not have to figure out how to squash everything into a single erased type, and instead enforce the Single Responsibility Principle; they already know how to create unique types, they already know how to create and fill structure types, and now separately a wide function pointer type or a "make trampoline" compiler feature (<a href="#appendix-make.trampoline">§ 5.3 Make Trampoline and Singular Function Pointers</a>) can be developed.</p>
   <p>Given an extremely simple example:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;stdio.h>

<c- k>typedef</c-> <c- b>void</c-> <c- nf>work_fn_t</c-><c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>);</c->
<c- b>void</c-> <c- nf>add_work</c-><c- p>(</c-><c- n>work_fn_t</c-><c- o>*</c-> <c- n>work</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>);</c->
<c- b>bool</c-> <c- nf>work_done</c-><c- p>();</c->

<c- b>void</c-> <c- nf>kickoff</c-><c- p>(</c-><c- b>int</c-> <c- n>start</c-><c- p>,</c-> <c- b>int</c-> <c- n>limit</c-><c- p>)</c-> <c- p>{</c->
  <c- b>void</c-> <c- n>work</c-><c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- n>start</c-><c- p>,</c-> <c- n>limit</c-><c- p>)</c-> <c- p>{</c->
    <c- n>printf</c-><c- p>(</c-><c- s>"doing work for %d to %d</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c-> <c- n>start</c-><c- p>,</c-> <c- n>limit</c-><c- p>);</c->
    <c- k>for</c-> <c- p>(</c-><c- b>int</c-> <c- n>i</c-> <c- o>=</c-> <c- n>start</c-><c- p>;</c-> <c- n>i</c-> <c- o>&lt;</c-> <c- n>limit</c-><c- p>;</c-> <c- o>++</c-><c- n>i</c-><c- p>)</c-> <c- p>{</c->
      <c- n>printf</c-><c- p>(</c-><c- s>"sooo much work - %d</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c-> <c- n>i</c-><c- p>);</c->
    <c- p>}</c->
  <c- p>}</c->
  <c- b>void</c-> <c- n>work_trampoline</c-><c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c-> <c- p>{</c->
    <c- p>(</c-><c- o>*</c-><c- p>((</c-><c- n>typeof</c-><c- p>(</c-><c- n>work</c-><c- p>)</c-><c- o>*</c-><c- p>)</c-><c- n>user</c-><c- p>))()</c->
    <c- c1>// free lambda after work is done</c->
    <c- n>free</c-><c- p>(</c-><c- n>user</c-><c- p>);</c->
  <c- p>};</c->
  <c- c1>// elevate to higher lifetime to survive async function call time</c->
  <c- b>void</c-><c- o>*</c-> <c- n>work_ptr</c-> <c- o>=</c-> <c- n>malloc</c-><c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>work</c-><c- p>));</c->
  <c- n>memcpy</c-><c- p>(</c-><c- n>work_ptr</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>work</c-><c- p>,</c-> <c- k>sizeof</c-><c- p>(</c-><c- n>work</c-><c- p>));</c->
  <c- n>add_work</c-><c- p>(</c-><c- n>work_trampoline</c-><c- p>,</c-> <c- n>work_ptr</c-><c- p>);</c->
<c- p>}</c->

<c- b>int</c-> <c- nf>main</c-> <c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>start</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->
  <c- b>int</c-> <c- n>limit</c-> <c- o>=</c-> <c- mi>30</c-><c- p>;</c->
  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c->
    <c- n>start</c-> <c- o>=</c-> <c- n>atoi</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>2</c-><c- p>)</c->
    <c- n>limit</c-> <c- o>=</c-> <c- n>atoi</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>2</c-><c- p>]);</c->

  <c- n>kickoff</c-><c- p>(</c-><c- n>start</c-><c- p>,</c-> <c- n>limit</c-><c- p>);</c->

  <c- k>while</c-> <c- p>(</c-><c- o>!</c-><c- n>work_done</c-><c- p>());</c->
  <c- c1>// no memory leaks at the end of the program</c->
  <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
<c- p>}</c->
</pre>
   <p>There are caveats about this, but they are related to forward declarations (<a href="#design-capture.functions-forward.decls">§ 3.2.6 Forward Declarations Work</a>).</p>
   <h4 class="heading settled" data-level="3.2.2" id="design-capture.functions-unique.types"><span class="secno">3.2.2. </span><span class="content">Deduced Return Types, Unique Types</span><a class="self-link" href="#design-capture.functions-unique.types"></a></h4>
   <p>Reusing an example from the above code, the <code class="highlight"><c- n>make_seven</c-></code> function needs to have a special, inferred/deduced return type. This is because the type of a capture function is not known until it is defined:</p>
<pre class="language-cpp highlight"><c- k>auto</c-> <c- n>make_seven</c-> <c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>)</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>y</c-> <c- o>=</c-> <c- mi>7</c-><c- p>;</c->
  <c- b>int</c-> <c- nf>seven_fn</c-><c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- n>x</c-><c- p>,</c-> <c- n>y</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- n>y</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>seven_fn</c-><c- p>;</c-> <c- c1>// OK: unique type which</c->
  <c- c1>// is a complete object</c->
<c- p>}</c->
</pre>
   <p>The <code class="highlight"><c- k>auto</c-></code> return type here just means "the first <code class="highlight"><c- k>return</c-></code> expression is the return type of the function". This only works with in-line function definitions, and does not allow for a separated function declaration/definition (as the separated declaration would not have a material, real type until the definition could be read). This only applies to functions with inferred return types like this, where the first declaration of such a function must also be its definition.</p>
   <p>If no <code class="highlight"><c- k>return</c-></code> appears in such a function, or all the <code class="highlight"><c- k>return</c-></code>s do not contain an expression, the return type is inferred to be <code class="highlight"><c- b>void</c-></code>. Otherwise, all the <code class="highlight"><c- k>return</c-> <c- o>&lt;</c-><c- n>expr</c-><c- o>></c-><c- p>;</c-></code> must return the exact same type. If there exists one or more <code class="highlight"><c- k>return</c-> <c- o>&lt;</c-><c- n>expr</c-><c- o>></c-><c- p>;</c-></code>s and the types are not exactly the same in the whole function definition, then it is a hard error. This is already partly described in Jens Gustedt’s "Type inference for variable definitions and function returns v6" (<a data-link-type="biblio" href="#biblio-n2923" title="Type inference for variable definitions and function returns">[n2923]</a>); reviving this paper would be a matter of rebasing it on the current working draft and improving the wording present.</p>
   <h4 class="heading settled" data-level="3.2.3" id="design-capture.functions-data.captures"><span class="secno">3.2.3. </span><span class="content">Data Captures are Explicit</span><a class="self-link" href="#design-capture.functions-data.captures"></a></h4>
   <p>Data captures, the way in which local data is accessible inside of the function, are explicit. The only reason captures are explicit is because it is impossible to tell if something should be captured by value (and copied into whatever implementation-defined holding space is used for the Capture Functions’s complete object), or if something should be captured by name/reference (and only have its pointer/address copied into whatever implementation-defined holding space is used for the Capture Functions’s complete object). This detail matters both for safety reasons when assigning, copying, storing, and otherwise relocating a capture function from its original scope.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> <code class="highlight"><c- k>static</c-></code> and <code class="highlight"><c- k>_Thread_local</c-></code> objects, as well as typical file-scope declarations, are accessible within a capture function in the normal way. <code class="highlight"><c- n>constexpr</c-></code> objects, without a <code class="highlight"><c- k>static</c-></code> specifier, at local scope are also accessible.</p>
   <p>Allowing for explicit captures also allows for better type checking (used objects must be explicit acknowledged by the programmer that they should be used), and allows for covering both the use cases of Apple Blocks (default by-value capture) and GNU Nested Functions (default by-name capture) without breaking anything. The lack of a capture also covers all of the use cases that Function Literals would have covered, which means that Capture Functions can sufficiently cover all of the existing use cases currently in production in C ecosystems. To match the default behaviors:</p>
   <ul>
    <li data-md>
     <p>Apple Blocks: <code class="highlight"><c- n>_Capture</c-><c- p>(</c-><c- o>=</c-><c- p>)</c-></code> (capture all by-value).</p>
    <li data-md>
     <p>GNU Nested Functions: <code class="highlight"><c- n>_Capture</c-><c- p>(</c-><c- o>&amp;</c-><c- p>)</c-></code> (capture all by-name/reference).</p>
    <li data-md>
     <p>Function Literals: <code class="highlight"><c- n>_Capture</c-><c- p>()</c-></code> (capture nothing).</p>
   </ul>
   <p>Only one "capture all" is allowed. That is, <code class="highlight"><c- n>_Capture</c-><c- p>(</c-><c- o>=</c-><c- p>,</c-> <c- o>&amp;</c-><c- p>)</c-></code> (and vice-versa) is illegal. The rest of the <em>specific</em> captures for accessible identifiers can be specified in any order. Note that <em>specific</em> captures for a given object override the default implicit "capture all" behavior. For example:</p>
<pre class="language-cpp highlight"><c- b>int</c-> <c- nf>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>30</c-><c- p>;</c->
  <c- b>int</c-> <c- n>y</c-> <c- o>=</c-> <c- mi>10</c-><c- p>;</c->
  <c- b>int</c-> <c- n>fn</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>&amp;</c-><c- p>,</c-> <c- n>x</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>+</c-> <c- n>y</c-><c- p>;</c->
  <c- p>}</c->
  <c- n>x</c-> <c- o>=</c-> <c- mi>50</c-><c- p>;</c->
  <c- n>y</c-> <c- o>=</c-> <c- mi>40</c-><c- p>;</c->
  <c- k>return</c-> <c- n>fn</c-><c- p>();</c->
<c- p>}</c->
</pre>
   <p>This program returns <code class="highlight"><c- mi>70</c-></code> (<code class="highlight"><c- n>x</c-></code> is captured by-value as <code class="highlight"><c- mi>30</c-></code>, <code class="highlight"><c- n>y</c-></code> is captured by-name and is changed to <code class="highlight"><c- mi>40</c-></code> before invocation). The change to <code class="highlight"><c- n>x</c-></code> on the outside to <code class="highlight"><c- mi>50</c-></code> is not reflected inside of the invocation. This allows an ease-of-use for specifying the "default" implicit all-capture, while letting the user select specifically which captures should work.</p>
   <h4 class="heading settled" data-level="3.2.4" id="design-capture.functions-data.captures.rename"><span class="secno">3.2.4. </span><span class="content">Data Captures can be Renamed</span><a class="self-link" href="#design-capture.functions-data.captures.rename"></a></h4>
   <p>Data captures can be renamed (or computed, with an expression that does not include a <code class="highlight"><c- p>,</c-></code> unless it is parenthesized). This is important for e.g. incrementing reference counters for copying large, important data structures into callbacks that may either be invoked multiple times or have their own long-lived lifetime. The syntax for this occurs within the <code class="highlight"><c- n>_Capture</c-></code> clause of a capture function:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;tree.h>

<c- n>TREE_DECLARE</c-><c- p>(</c-><c- n>int_tree_t</c-><c- p>,</c-> <c- n>int_tree</c-><c- p>,</c-> <c- b>int</c-><c- p>);</c->
<c- n>TREE_IMPLEMENT</c-><c- p>(</c-><c- n>int_tree_t</c-><c- p>,</c-> <c- n>int_tree</c-><c- p>,</c-> <c- b>int</c-><c- p>);</c->

<c- cp>#include</c-> &lt;stdcountof.h>

<c- k>enum</c-> <c- nc>queue_status</c-> <c- p>{</c->
  <c- n>qs_success</c-><c- p>,</c->
  <c- n>qs_timedout</c-><c- p>,</c->
  <c- n>qs_busy</c-><c- p>,</c->
  <c- n>qs_fail</c-><c- p>,</c->
  <c- n>qs_invalid</c->
<c- p>};</c->

<c- k>typedef</c-> <c- b>int</c-> <c- nf>work_fn_t</c-><c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>);</c->

<c- n>queue_status</c-> <c- nf>add_dispatch_work</c-><c- p>(</c-><c- n>work_fn_t</c-><c- o>*</c-> <c- n>work</c-><c- p>,</c-> <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>);</c->
<c- n>queue_status</c-> <c- nf>is_work_done</c-><c- p>();</c->
<c- b>void</c-> <c- nf>work_shutdown</c-><c- p>();</c->

<c- b>int</c-> <c- nf>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>data</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
  <c- n>int_tree_t</c-> <c- n>tree</c-> <c- o>=</c-> <c- n>int_tree_init_with</c-><c- p>(</c-><c- n>data</c-><c- p>,</c-> <c- n>data</c-> <c- o>+</c-> <c- n>countof</c-><c- p>(</c-><c- n>data</c-><c- p>));</c->
  <c- b>int</c-> <c- n>work</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- n>my_tree</c-> <c- o>=</c-> <c- n>int_tree_copy</c-><c- p>(</c-><c- n>tree</c-><c- p>))</c-> <c- p>{</c->
    <c- d>/* do work.... */</c->
    <c- b>int</c-> <c- n>elem</c-> <c- o>=</c-> <c- n>int_tree_remove</c-><c- p>(</c-><c- n>my_tree</c-><c- p>,</c-> <c- n>int_tree_min_node</c-><c- p>(</c-><c- n>my_tree</c-><c- p>));</c->
    <c- d>/* blah blah blah */</c->
    <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>work_trampoline</c-> <c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c-> <c- n>_Capture</c-><c- p>()</c-> <c- p>{</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- p>((</c-><c- n>typeof</c-><c- p>(</c-><c- n>work</c-><c- p>)</c-><c- o>*</c-><c- p>)</c-><c- n>user</c-><c- p>))();</c->
  <c- p>}</c->
  <c- k>if</c-> <c- p>(</c-><c- n>add_dispatch_work</c-><c- p>(</c-><c- n>work_trampoline</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>work</c-><c- p>)</c-> <c- o>!=</c-> <c- n>qs_success</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- mi>1</c-><c- p>;</c->
  <c- p>}</c->
  <c- n>queue_status</c-> <c- n>err</c-><c- p>;</c->
  <c- k>while</c-> <c- p>((</c-><c- n>err</c-> <c- o>=</c-> <c- n>work_done</c-><c- p>())</c-> <c- o>!=</c-> <c- n>qs_success</c-><c- p>)</c-> <c- p>{</c->
    <c- n>swith</c-> <c- p>()</c-> <c- p>{</c->
      <c- k>case</c-> <c- no>qs_invalid</c-><c- p>:</c->
      <c- k>case</c-> <c- no>qs_timedout</c-><c- p>:</c->
      <c- k>case</c-> <c- no>qs_failed</c-><c- p>:</c->
        <c- c1>// some error happened</c->
        <c- n>work_shutdown</c-><c- p>();</c->
        <c- k>return</c-> <c- mi>2</c-><c- p>;</c->
      <c- k>default</c-><c- o>:</c->
        <c- k>break</c-><c- p>;</c->
    <c- p>}</c->
  <c- p>}</c->
  <c- n>work_shutdown</c-><c- p>();</c->
  <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="3.2.5" id="design-capture.functions-data.captures.fields"><span class="secno">3.2.5. </span><span class="content">NEW: Data Captures are Accessible</span><a class="self-link" href="#design-capture.functions-data.captures.fields"></a></h4>
   <p>An important adjustment to make sure this code works better than the way it did for Blocks or Nested Functions is the ability not only to copy (<a href="#design-capture.functions-complete.objects">§ 3.2.1 Capture Functions are Complete Objects (unless only Declared)</a>) or otherwise rename objects (<a href="#design-capture.functions-data.captures.rename">§ 3.2.4 Data Captures can be Renamed</a>), but ALSO to get at the internals of a given Capture Functions. This is something missing from GNU Nested Functions (which provides no real resolution for it) as well, and something that could matter for Apple Blocks but does not in practice because they can turn any object into a shared one with the <code class="highlight"><c- n>__block</c-></code> modifier on an object. In particular, this only matters in the case of a closure which is given a (copied) resource that must either be released or freed.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> Thanks to Alex Celeste, for being the first person to bring this to my attention!</p>
   <p>The syntax looks just like normal structure access, and is based on the names placed in the <code class="highlight"><c- n>_Capture</c-></code> clause:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdio.h>

<c- b>int</c-> <c- nf>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>30</c-><c- p>;</c->
  <c- b>double</c-> <c- n>y</c-> <c- o>=</c-> <c- mf>5.0</c-><c- p>;</c->
  <c- b>char</c-> <c- n>z</c-> <c- o>=</c-> <c- sc>'a'</c-><c- p>;</c->

  <c- b>int</c-> <c- n>cap_fn0</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>=</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>renamed_x</c-> <c- o>=</c-> <c- n>x</c-><c- p>)</c-> <c- p>{</c->
    <c- n>printf</c-><c- p>(</c-><c- s>"inside cap_fn0 | renamed_x: %d, y: %f, z: %c</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c->
      <c- n>renamed_x</c-><c- p>,</c-> <c- n>y</c-><c- p>,</c-> <c- n>z</c-><c- p>);</c->
  <c- p>}</c->
	
  <c- b>int</c-> <c- n>cap_fn1</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>&amp;</c-><c- p>,</c-> <c- n>renamed_y</c-> <c- o>=</c-> <c- n>y</c-><c- p>)</c-> <c- p>{</c->
    <c- n>printf</c-><c- p>(</c-><c- s>"inside cap_fn1 | x: %d, renamed_y: %f, z: %c</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c->
      <c- n>x</c-><c- p>,</c-> <c- n>renamed_y</c-><c- p>,</c-> <c- n>z</c-><c- p>);</c->
  <c- p>}</c->
	
  <c- n>x</c-> <c- o>=</c-> <c- mi>60</c-><c- p>;</c->
  <c- n>y</c-> <c- o>=</c-> <c- mf>10.0</c-><c- p>;</c->
  <c- n>z</c-> <c- o>=</c-> <c- sc>'z'</c-><c- p>;</c->

  <c- n>cap_fn0</c-><c- p>();</c->
  <c- n>cap_fn1</c-><c- p>();</c->
	
  <c- n>printf</c-><c- p>(</c-><c- s>"</c-><c- se>\n</c-><c- s>"</c-><c- p>);</c->

  <c- n>printf</c-><c- p>(</c-><c- s>"inside main fn | cap_fn0.renamed_x: %d, cap_fn0.y: %f, cap_fn0.z: %c</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c->
    <c- n>cap_fn0</c-><c- p>.</c-><c- n>renamed_x</c-><c- p>,</c-> <c- n>cap_fn0</c-><c- p>.</c-><c- n>y</c-><c- p>,</c-> <c- n>cap_fn0</c-><c- p>.</c-><c- n>z</c-><c- p>);</c->
  <c- n>printf</c-><c- p>(</c-><c- s>"inside main fn | cap_fn1.x: %d, cap_fn1.renamed_y: %f, cap_fn1.z: %c</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c->
    <c- n>cap_fn1</c-><c- p>.</c-><c- n>x</c-><c- p>,</c-> <c- n>cap_fn1</c-><c- p>.</c-><c- n>renamed_y</c-><c- p>,</c-> <c- n>cap_fn1</c-><c- p>.</c-><c- n>z</c-><c- p>);</c->

  <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
<c- p>}</c->
</pre>
   <p>This would print:</p>
<pre class="language-sh highlight">inside cap_fn0 <c- p>|</c-> renamed_x: <c- m>60</c->, y: <c- m>5</c->.0, z: a
inside cap_fn1 <c- p>|</c-> x: <c- m>60</c->, renamed_y: <c- m>10</c->.0, z: z

inside main fn <c- p>|</c-> cap_fn0.renamed_x: <c- m>60</c->, cap_fn0.y: <c- m>5</c->.0, cap_fn0.z: a
inside main fn <c- p>|</c-> cap_fn1.x: <c- m>60</c->, cap_fn1.renamed_y: <c- m>10</c->.0, cap_fn1.z: z
</pre>
   <p>How the implementation actually accesses the information is implementation-defined, and the layout of the Capture Functions object is not defined the specification, except to say it’s implementation-defined (<a href="#wording">§ 4 Wording</a>).</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> This leaves room for an implementation to, for example, use creative ways to retrieve objects and object references. Using a pointer to the current stack frame and then computing a raw offset to get to a specific bit of data, or using entirely registers, are all possible depending on how the captures are implemented. Such improvements and optimizations -- especially in the face of potential asynchronous calls and the need to protect against false sharing -- must be left up to Quality of Implementation.</p>
   <p>As an example for releasing resources outside of the function call itself for the purposes of a function call that gets used more than once and isn’t passed a "We’re Done" signal, we can reuse the example from <a href="#intro-nested.functions-captures.no.workaround">§ 2.2.5 GNU Nested Functions By-Name Captures Cannot Be Worked Around Normally</a>:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>typedef</c-> <c- b>int</c-> <c- nf>compare_fn_t</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>right</c-><c- p>);</c->

<c- k>auto</c-> <c- n>make_compare</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- d>/* LOCAL, heap-allocated variable.... */</c->
  <c- b>int</c-><c- o>*</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- n>malloc</c-><c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- b>int</c-><c- p>));</c->
  <c- o>*</c-><c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- o>*</c-><c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
	
  <c- b>int</c-> <c- n>compare</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- n>_Capture</c-><c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- p>{</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
    <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>compare</c-><c- p>;</c->
<c- p>}</c->

<c- b>int</c-> <c- n>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->  

  <c- k>auto</c-> <c- n>compare</c-> <c- o>=</c-> <c- n>make_compare</c-><c- p>(</c-><c- n>argc</c-><c- p>,</c-> <c- n>argv</c-><c- p>);</c->
  <c- n>qsort_r</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c-> <c- n>compare</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>compare</c-><c- p>);</c->
  <c- c1>// with data field captures, we can now `free` the</c->
  <c- c1>// field `in_reverse` from the lambda</c->
  <c- n>free</c-><c- p>(</c-><c- n>compare</c-><c- p>.</c-><c- n>in_reverse</c-><c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>Thanks to the capture of <code class="highlight"><c- n>in_reverse</c-></code> with the by-value <code class="highlight"><c- n>_Capture</c-><c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-></code> indication, the return of this function is safe. And, since we have access to the unique type that is generated (through the <code class="highlight"><c- k>auto</c-></code> return type), we can access the pointer <code class="highlight"><c- n>in_reverse</c-></code> normally and naturally. This isn’t possible with normal C++-style lambdas, as they haven’t decided to make this available (though our design for Lambdas in C will also include the named captures as accessible fields). It’s also not possible in the other solutions which rely on type-erasure as a first-class part of the design (Apple Blocks with the Blocks type, GNU Nested Functions only being accessible through a pointer or convertible to a wide function pointer in <a data-link-type="biblio" href="#biblio-n2661" title="n2661: Nested Functions">[n2661]</a> or <a data-link-type="biblio" href="#biblio-n3564" title="Resumable Functions">[n3564]</a>, Borland’s closure annotation or function literals). This is why making it possible to access the unique type first and foremost is of great benefit.</p>
   <h4 class="heading settled" data-level="3.2.6" id="design-capture.functions-forward.decls"><span class="secno">3.2.6. </span><span class="content">Forward Declarations Work</span><a class="self-link" href="#design-capture.functions-forward.decls"></a></h4>
   <p>Capture functions can be forward declared, similar to how GNU Nested Functions can be forward-declared if one uses the <code class="highlight"><c- k>auto</c-></code> keyword in front of the definition of a Nested Functions:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->
  <c- c1>// forward-declared compare</c->
  <c- b>int</c-> <c- n>compare</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- n>_Capture</c-><c- p>(</c-><c- n>in_reverse</c-><c- p>);</c->
  <c- c1>// even though it is captured by value...</c->
	
  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->

  <c- d>/*</c->
<c- d>  compare.in_reverse; // CONSTRAINT VIOLATION: cannot access until definition</c->
<c- d>  */</c->
	
  <c- b>int</c-> <c- n>compare_trampoline</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c->
    <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>,</c->
    <c- b>void</c-><c- o>*</c-> <c- n>user</c-><c- p>)</c->
  <c- n>_Capture</c-><c- p>()</c-> <c- p>{</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- p>(</c-><c- n>typeof</c-><c- p>(</c-><c- n>compare</c-><c- p>)</c-><c- o>*</c-><c- p>)</c-><c- n>user</c-><c- p>)(</c-><c- n>untyped_left</c-><c- p>,</c-> <c- n>untyped_right</c-><c- p>);</c->
  <c- p>}</c->

  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
  <c- n>qsort_r</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c->
    <c- n>compare_trampoline</c-><c- p>,</c->
    <c- o>&amp;</c-><c- n>compare</c->
  <c- p>);</c->
  <c- c1>// define it here;</c->
  <c- c1>// captures and arguments must be identical otherwise it is a violation</c->
  <c- c1>// `in_reverse` is captured at the point of definition, not the point of declaration.</c->
  <c- b>int</c-> <c- n>compare</c-><c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- n>_Capture</c-><c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- p>{</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>user</c-><c- p>;</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
      <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
  <c- p>};</c->
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>Some important points for Capture Functions’s forward declarations:</p>
   <ul>
    <li data-md>
     <p>the values captured have their values taken at the point of definition, not at the point of declaration;</p>
    <li data-md>
     <p>because of this, one cannot use the <code class="highlight"><c- p>.</c-></code> or the <code class="highlight"><c- o>-></c-></code> operators on a capture function declaration, only a definition;</p>
    <li data-md>
     <p>and, forward declarations can only have the function call operation applied to them, before they are defined.</p>
   </ul>
   <p class="note" role="note"><span class="marker">NOTE:</span> It is unclear whether the Apple Blocks-like by-value capture should occur at the point of the first declaration or the definition. Currently, the reasoning is that using the definition for the values captured is better because there can be multiple forward declarations (in perhaps sprawling manners due to <code class="highlight"><c- cp>#include</c-></code> and other code copy-paste mechanisms) but only one definition, and thus the definition should be the important part.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> The other opinion is that restricting access to <code class="highlight"><c- p>.</c-></code> and <code class="highlight"><c- o>-></c-></code> by effectively labeling the "object" part of the closure type as an incomplete type is not worth it, and that capturing things by-value at the first forward declaration is good.</p>
   <p>There is no existing practice for this due to the way GNU Nested Functions -- the only existing practice where forward-declaraing the closure type is allowed -- work. That is, they only capture by-name/by-reference, and so the value is always the value at the point of execution and not at the point of evaluation. Apple Blocks and other solutions do not have this problem since they are expressions and thus do not have to engage in any sort of work with the "split between declaration vs. definition" issue at all.</p>
   <h4 class="heading settled" data-level="3.2.7" id="design-catpure.functions-forward.decls.silly"><span class="secno">3.2.7. </span><span class="content">Forward Declarations without a name are a bit useless</span><a class="self-link" href="#design-catpure.functions-forward.decls.silly"></a></h4>
   <p>Forward declarations without a name are a bit silly, because they are unique types. An unnamed declarator means that there’s a unique type that has been forward-declared but serves no other purpose:</p>
<pre class="language-cpp highlight"><c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- n>compare_closure1_t</c-><c- p>)(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>=</c-><c- p>);</c->
  <c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- n>compare_closure2_t</c-><c- p>)(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>=</c-><c- p>);</c->
  <c- k>typedef</c-> <c- n>compare_closure_t</c-> <c- n>compare_closure1_t</c-><c- p>;</c->
  <c- k>typedef</c-> <c- n>compare_closure_t</c-> <c- n>compare_closure2_t</c-><c- p>;</c-> <c- c1>// constraint violation: not a compatible type redeclaration</c->
  <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
<c- p>}</c->
</pre>
   <p>The syntax is kept for parity with the rest of the declarator syntax. It also allows a user to make a unique type within a translation unit, though there are obviously other ways to do this.</p>
   <h4 class="heading settled" data-level="3.2.8" id="design-capture.functions-recursion"><span class="secno">3.2.8. </span><span class="content">Capable of Recursion</span><a class="self-link" href="#design-capture.functions-recursion"></a></h4>
   <p>Capture Functions are able to refer to themselves for the purpose of recursion. This means that <code class="highlight"><c- n>__self_func</c-></code> (<a data-link-type="biblio" href="#biblio-__self_func" title="__self_func">[__self_func]</a>), unlike for expression-based/unnamed Function Literals/Lambdas/Block literals, is not required:</p>
<pre class="language-cpp highlight"><c- b>int</c-> <c- nf>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>tripling</c-> <c- p>(</c-><c- b>int</c-> <c- n>times</c-><c- p>,</c-> <c- b>int</c-> <c- n>start</c-><c- p>)</c-> <c- p>{</c->
    <c- k>if</c-> <c- p>(</c-><c- n>times</c-> <c- o>>=</c-> <c- mi>5</c-><c- p>)</c-> <c- p>{</c->
      <c- k>return</c-> <c- n>start</c-><c- p>;</c->
    <c- p>}</c->
    <c- k>return</c-> <c- n>tripling</c-><c- p>(</c-><c- n>times</c-> <c- o>+</c-> <c- mi>1</c-><c- p>,</c-> <c- n>start</c-> <c- o>*</c-> <c- mi>3</c-><c- p>);</c-> <c- c1>// normal recursion</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>tripling</c-><c- p>(</c-><c- mi>0</c-><c- p>,</c-> <c- mi>1</c-><c- p>);</c->
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="3.2.9" id="design-capture.functions-expression"><span class="secno">3.2.9. </span><span class="content">Not An Expression</span><a class="self-link" href="#design-capture.functions-expression"></a></h4>
   <p>The one true technical downside is that Capture Functions are declarations / definitions. They cannot be used (without the Statement Expression extension) in a function call’s argument list, which means that (short) closures and anonymous functions still need the full function definition. This is annoying and, honestly, one of the reasons <a href="#design-lambdas">§ 3.3 Lambdas</a> are preferred as a shorthand syntax.</p>
   <p>It also means that, without Statement Expressions, Capture Functions cannot be used for the implementation of many macros which are typically expected to be usable as normal expressions.</p>
   <h4 class="heading settled" data-level="3.2.10" id="design-capture.functions-footgun.reference"><span class="secno">3.2.10. </span><span class="content">Footgun: By-Name Capture Exceeds Captures’s Lifetime</span><a class="self-link" href="#design-capture.functions-footgun.reference"></a></h4>
   <p>A brief display of the undefined behavior:</p>
<pre class="language-cpp highlight"><c- k>auto</c-> <c- n>ub</c-> <c- p>(</c-><c- b>int</c-> <c- n>parameter</c-><c- p>)</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>automatic</c-> <c- o>=</c-> <c- mi>7</c-><c- p>;</c->
  <c- b>int</c-> <c- nf>fn</c-><c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- n>parameter</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>automatic</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>parameter</c-> <c- o>+</c-> <c- n>automatic</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>fn</c-><c- p>;</c-> <c- c1>// well-defined copy return</c->
  <c- c1>// but dangling reference to `automatic`!</c->
<c- p>}</c->

<c- b>int</c-> <c- n>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- k>auto</c-> <c- n>fn</c-> <c- o>=</c-> <c- n>ub</c-><c- p>(</c-><c- mi>2</c-><c- p>);</c->
  <c- k>return</c-> <c- n>fn</c-><c- p>();</c-> <c- c1>// undefined behavior:</c->
  <c- c1>// `automatic` no longer exists.</c->
<c- p>}</c->
</pre>
   <p>In general, undefined behavior occurs in the same way that it occurs within existing C code: use of an object after its lifetime has ended (in this case, an automatic storage duration object has gone out-of-scope). The fix for <code class="highlight"><c- n>ub</c-></code> in this case is to capture <code class="highlight"><c- n>automatic</c-></code> by-value. This makes it safe to copy that function object to the heap, or the stack. Additionally, no UB is possible by conversion to a function pointer.</p>
   <h4 class="heading settled" data-level="3.2.11" id="design-capture.functions-footgun.wide"><span class="secno">3.2.11. </span><span class="content">Future Footgun: Wide Function Pointers</span><a class="self-link" href="#design-capture.functions-footgun.wide"></a></h4>
   <p>Wide function pointers, if and when they come to C, can make for footguns with capturing lambdas given that they will (likely) allow conversions from any Nested Function / Block / Lambda to them implicitly. Using a fictional wide function pointer syntax using <code class="highlight"><c- o>%</c-></code>:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- nf>foo_fn_t</c-><c- p>(</c-><c- b>int</c-><c- p>);</c->

<c- n>foo_fn_t</c-><c- o>%</c-> <c- n>call_me</c-> <c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>)</c-> <c- p>{</c->
  <c- k>return</c-> <c- p>[</c-><c- n>x</c-><c- p>](</c-><c- b>int</c-> <c- n>y</c-><c- p>)</c-> <c- p>{</c-> <c- k>return</c-> <c- n>x</c-> <c- o>+</c-> <c- n>y</c-><c- p>;</c-> <c- p>};</c-> <c- c1>// converts to wide function pointer type!</c->
  <c- c1>// undefined behavior if the return value is ever</c->
  <c- c1>// called outside of this function </c->
<c- p>}</c->

<c- b>int</c-> <c- n>use_me</c-><c- p>(</c-><c- n>foo_fn_t</c-><c- o>%</c-> <c- n>fn</c-><c- p>)</c-> <c- p>{</c->
  <c- k>return</c-> <c- n>fn</c-><c- p>(</c-><c- mi>2</c-><c- p>);</c->
<c- p>}</c->

<c- b>int</c-> <c- n>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>30</c-><c- p>;</c->
  <c- k>return</c-> <c- n>use_me</c-><c- p>(</c-><c- n>call_me</c-><c- p>(</c-><c- n>x</c-><c- p>));</c->
<c- p>}</c->
</pre>
   <p>This is a similar problem to Nested Functions returning a regular function pointer from a function call. Unfortunately, a conversion being allowed here is necessary to allow the 75%+ use case of passing it as a parameter, such as:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- nf>foo_fn_t</c-><c- p>(</c-><c- b>int</c-><c- p>);</c->

<c- b>void</c-> <c- nf>pass_to_me</c-> <c- p>(</c-><c- n>foo_fn_t</c-><c- o>%</c-> <c- n>func</c-><c- p>);</c->

<c- b>int</c-> <c- nf>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>30</c-><c- p>;</c->
  <c- n>pass_to_me</c-><c- p>(</c->
    <c- p>[</c-><c- n>x</c-><c- p>](</c-><c- b>int</c-> <c- n>y</c-><c- p>)</c-> <c- p>{</c-> <c- k>return</c-> <c- n>x</c-> <c- o>+</c-> <c- n>y</c-><c- p>;</c-> <c- p>}</c->
  <c- p>);</c-> <c- c1>// converts to wide function pointer type!</c->
  <c- k>return</c-> <c- mi>0</c-><c- p>;</c-> 
<c- p>}</c->
</pre>
   <p>Thusly, in a future with a wide function pointer type, such a problem might be allowed. This is similar to the <a href="#design-capture.functions-footgun.reference">§ 3.2.10 Footgun: By-Name Capture Exceeds Captures’s Lifetime</a>. A special carveout in the specification for the return value case could be developed, but this would need work to avoid precluding useful cases.</p>
   <h3 class="heading settled" data-level="3.3" id="design-lambdas"><span class="secno">3.3. </span><span class="content">Lambdas</span><a class="self-link" href="#design-lambdas"></a></h3>
   <p>Lambdas are simply a reskinned version of Capture Functions. They have all the same functionality, but with the benefits that they are:</p>
   <ul>
    <li data-md>
     <p>expressions, and therefore can be used in-line in a function call as an argument or as part of an argument;</p>
    <li data-md>
     <p>expressions, and therefore can be immediately invoked;</p>
    <li data-md>
     <p>and, C++-compatible in their design.</p>
   </ul>
   <p>We are deliberately leaving these as the only three benefits of lambdas over Capture Functions for the sole reason that, after Capture Functions, Lambdas will be VERY minimal effort to support. The reason for that is that they are, semantically, just a "Syntactic Reskin" of Capture Functions, save for their presence as an expression.</p>
<pre class="language-cpp highlight"><c- k>auto</c-> <c- n>make_seven</c-> <c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>)</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>y</c-> <c- o>=</c-> <c- mi>7</c-><c- p>;</c->
  <c- k>return</c-> <c- p>[</c-><c- n>x</c-><c- p>,</c-> <c- n>y</c-><c- p>]()</c-> <c- p>{</c-> <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- n>y</c-><c- p>;</c-> <c- p>};</c->
<c- p>}</c->

<c- b>int</c-> <c- n>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>3</c-><c- p>;</c->
  <c- k>auto</c-> <c- n>zero</c-> <c- o>=</c-> <c- p>[]</c-> <c- p>()</c-> <c- p>{</c->
    <c- c1>// OK, no external variables used</c->
    <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
  <c- p>};</c->
<c- cp>#if 0</c->
<c- c>  auto double_it = [] () {</c->
<c- c>    return x * 2; // constraint violation</c->
<c- c>  };</c->
<c- cp>#endif</c->
  <c- k>auto</c-> <c- n>triple_it</c-> <c- o>=</c-> <c- p>[</c-><c- n>x</c-><c- p>]</c-> <c- p>()</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>3</c-><c- p>;</c-> <c- c1>// OK, x = 3 when called</c->
  <c- p>};</c->
  <c- k>auto</c-> <c- n>quadruple_it</c-> <c- o>=</c-> <c- p>[</c-><c- o>&amp;</c-><c- n>x</c-><c- p>]</c-> <c- p>()</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>4</c-><c- p>;</c-> <c- c1>// OK, x = 5 when called</c->
  <c- p>};</c->
  <c- k>auto</c-> <c- n>quintuple_it</c-> <c- o>=</c-> <c- p>[</c-><c- o>=</c-><c- p>]</c-> <c- p>()</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>5</c-><c- p>;</c-> <c- c1>// OK, x = 3 when called</c->
  <c- p>};</c->
  <c- k>auto</c-> <c- n>sextuple_it</c-> <c- o>=</c-> <c- p>[</c-><c- o>&amp;</c-><c- p>]</c-> <c- p>()</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>6</c-><c- p>;</c-> <c- c1>// OK, x = 5 when caled</c->
  <c- p>};</c->
  <c- n>x</c-> <c- o>=</c-> <c- mi>5</c-><c- p>;</c->
  <c- k>auto</c-> <c- n>seven_tuple_it</c-> <c- o>=</c-> <c- n>make_seven</c-><c- p>(</c-><c- n>x</c-><c- p>);</c->
  <c- k>return</c-> <c- n>zero</c-><c- p>()</c-> <c- o>+</c-> <c- n>triple_it</c-><c- p>()</c-> <c- o>+</c-> <c- n>quadruple_it</c-><c- p>()</c->
    <c- o>+</c-> <c- n>quintuple_it</c-><c- p>()</c-> <c- o>+</c-> <c- n>sextuple_it</c-><c- p>()</c-> <c- o>+</c-> <c- n>seven_tuple_it</c-><c- p>();</c->
  <c- c1>// return 109;</c->
  <c- c1>// 0 + (3 * 3) + (5 * 4)</c->
  <c- c1>// + (3 * 5) + (5 * 6)</c->
  <c- c1>// + (5 * 7)</c->
<c- p>}</c->
</pre>
   <p>Given this, there is nothing else to write for this section: all of the benefits of Capture Functions (<a href="#design-capture.functions">§ 3.2 Capture Functions: Rehydrated Nested Function</a>) applies to these types in full, and just copying all of that text from one to another to say exactly the same thing is not important. We will instead just talk about the differences exclusively in comparison to Capture Functions in the next few sections.</p>
   <h4 class="heading settled" data-level="3.3.1" id="design-lambdas-expressions"><span class="secno">3.3.1. </span><span class="content">Lambdas are Expressions</span><a class="self-link" href="#design-lambdas-expressions"></a></h4>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>
<c- cp>#include</c-> &lt;string.h>
<c- cp>#include</c-> &lt;stddef.h>

<c- k>static</c-> <c- b>int</c-> <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c->

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- k>if</c-> <c- p>(</c-><c- n>argc</c-> <c- o>></c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
    <c- b>char</c-><c- o>*</c-> <c- n>r_loc</c-> <c- o>=</c-> <c- n>strchr</c-><c- p>(</c-><c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>],</c-> <c- sc>'r'</c-><c- p>);</c->
    <c- k>if</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>!=</c-> NULL<c- p>)</c-> <c- p>{</c->
      <c- b>ptrdiff_t</c-> <c- n>r_from_start</c-> <c- o>=</c-> <c- p>(</c-><c- n>r_loc</c-> <c- o>-</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>]);</c->
      <c- k>if</c-> <c- p>(</c-><c- n>r_from_start</c-> <c- o>==</c-> <c- mi>1</c-> <c- o>&amp;&amp;</c-> <c- n>argv</c-><c- p>[</c-><c- mi>1</c-><c- p>][</c-><c- mi>0</c-><c- p>]</c-> <c- o>==</c-> <c- sc>'-'</c-> <c- o>&amp;&amp;</c-> <c- n>strlen</c-><c- p>(</c-><c- n>r_loc</c-><c- p>)</c-> <c- o>==</c-> <c- mi>1</c-><c- p>)</c-> <c- p>{</c->
        <c- n>in_reverse</c-> <c- o>=</c-> <c- mi>1</c-><c- p>;</c->
      <c- p>}</c-> 
    <c- p>}</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
  <c- n>qsort</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>list</c-><c- p>)</c-><c- o>/</c-><c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>)),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c->
    <c- c1>// expression, fits in-line</c->
    <c- p>[](</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>untyped_left</c-><c- p>;</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- p>(</c-><c- k>const</c-> <c- b>int</c-><c- o>*</c-><c- p>)</c-><c- n>untyped_right</c-><c- p>;</c->
      <c- k>return</c-> <c- p>(</c-><c- n>in_reverse</c-><c- p>)</c-> <c- o>?</c-> <c- o>*</c-><c- n>right</c-> <c- o>-</c-> <c- o>*</c-><c- n>left</c-> <c- o>:</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
    <c- p>}</c->
  <c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c->
<c- p>}</c->
</pre>
   <p>This also makes it <strong>suitable for use in macros</strong>, which is not something a regular Capture Functions can accomplish.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> This can be alleviated by using Statement Expressions, which would allow Capture Functions to work within typical macro contexts.</p>
   <h4 class="heading settled" data-level="3.3.2" id="design-lambdas-recursion"><span class="secno">3.3.2. </span><span class="content">Recursion Is Impossible</span><a class="self-link" href="#design-lambdas-recursion"></a></h4>
   <p>Unfortunately, it is impossible to call a lambda from within itself (not without C++'s feature "deducing this", which requires templates and other things to work), and therefore that is another disadvantage. It can be fixed with the proposed <code class="highlight"><c- n>__self_func</c-></code> feature (<a data-link-type="biblio" href="#biblio-__self_func" title="__self_func">[__self_func]</a>):</p>
<pre class="language-cpp highlight"><c- b>int</c-> <c- nf>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>tripling</c-> <c- p>(</c-><c- b>int</c-> <c- n>times</c-><c- p>,</c-> <c- b>int</c-> <c- n>start</c-><c- p>)</c-> <c- p>{</c->
    <c- k>if</c-> <c- p>(</c-><c- n>times</c-> <c- o>>=</c-> <c- mi>5</c-><c- p>)</c-> <c- p>{</c->
      <c- k>return</c-> <c- n>start</c-><c- p>;</c->
    <c- p>}</c->
    <c- k>return</c-> <c- n>__self_func</c-><c- p>(</c-><c- n>times</c-> <c- o>+</c-> <c- mi>1</c-><c- p>,</c-> <c- n>start</c-> <c- o>*</c-> <c- mi>3</c-><c- p>);</c-> <c- c1>// __self_func feature</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>tripling</c-><c- p>(</c-><c- mi>0</c-><c- p>,</c-> <c- mi>1</c-><c- p>);</c->
<c- p>}</c->
</pre>
   <h4 class="heading settled" data-level="3.3.3" id="design-lambdas-returns"><span class="secno">3.3.3. </span><span class="content">Trailing Return Types / Deduced Return Type</span><a class="self-link" href="#design-lambdas-returns"></a></h4>
   <p>Finally, one may need to add the concept of a "trailing return type" to C in order to allow modifying the return type of a lambda. At the moment, the way a lambda with no specified return type works is that every single <code class="highlight"><c- k>return</c-></code> statement must have exactly the same type (there is no negotiation for some "promoted" type or similar). That is, returning a <code class="highlight"><c- b>long</c-></code> in one branch and an <code class="highlight"><c- b>int</c-></code> in another branch is an error: they all must be cast to <code class="highlight"><c- b>int</c-></code> or they all must be cast to <code class="highlight"><c- b>long</c-></code>:</p>
<pre class="language-cpp highlight"><c- b>int</c-> <c- nf>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- k>auto</c-> <c- n>okay0</c-> <c- o>=</c-> <c- p>[]()</c-> <c- p>{</c->
    <c- k>if</c-> <c- p>(</c-><c- mi>1</c-><c- p>)</c-> <c- p>{</c->
      <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
    <c- p>}</c->
    <c- k>else</c-> <c- p>{</c->
      <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
    <c- p>}</c->
  <c- p>}();</c-> <c- c1>// ok</c->
  <c- k>auto</c-> <c- n>violation0</c-> <c- o>=</c-> <c- p>[]()</c-> <c- p>{</c->
    <c- k>if</c-> <c- p>(</c-><c- mi>1</c-><c- p>)</c-> <c- p>{</c->
      <c- k>return</c-> <c- mi>0U</c-><c- p>;</c->
    <c- p>}</c->
    <c- k>else</c-> <c- p>{</c->
      <c- k>return</c-> <c- mf>0L</c-><c- p>;</c->
    <c- p>}</c->
  <c- p>}();</c-> <c- c1>// constraint violation: different return types</c->
  <c- k>auto</c-> <c- n>okay1</c-> <c- o>=</c-> <c- p>[]()</c-> <c- p>{</c->
    <c- k>if</c-> <c- p>(</c-><c- mi>1</c-><c- p>)</c-> <c- p>{</c->
      <c- k>return</c-> <c- p>(</c-><c- b>unsigned</c-> <c- b>long</c-> <c- b>long</c-><c- p>)</c-><c- mi>0U</c-><c- p>;</c->
    <c- p>}</c->
    <c- k>else</c-> <c- p>{</c->
      <c- k>return</c-> <c- p>(</c-><c- b>unsigned</c-> <c- b>long</c-> <c- b>long</c-><c- p>)</c-><c- mf>0L</c-><c- p>;</c->
    <c- p>}</c->
  <c- p>}();</c-> <c- c1>// ok: cast to identical types</c->
  <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
<c- p>}</c->
</pre>
   <p>This can be <strong>extremely</strong> annoying to deal with. Trailing return types fix this problem by allowing lambdas to use a trailing <code class="highlight"><c- o>-></c-> <c- n>type</c-><c- o>-</c-><c- n>name</c-></code> to have the function return type become <code class="highlight"><c- n>type</c-><c- o>-</c-><c- n>name</c-></code>:</p>
<pre class="language-cpp highlight"><c- b>int</c-> <c- nf>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- k>auto</c-> <c- n>okay0</c-> <c- o>=</c-> <c- p>[]()</c-> <c- p>{</c->
    <c- k>if</c-> <c- p>(</c-><c- mi>1</c-><c- p>)</c-> <c- p>{</c->
      <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
    <c- p>}</c->
    <c- k>else</c-> <c- p>{</c->
      <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
    <c- p>}</c->
  <c- p>}();</c-> <c- c1>// ok</c->
  <c- k>auto</c-> <c- n>violation0</c-> <c- o>=</c-> <c- p>[]()</c-> <c- o>-></c-> <c- b>unsigned</c-> <c- b>int</c-> <c- p>{</c->
    <c- k>if</c-> <c- p>(</c-><c- mi>1</c-><c- p>)</c-> <c- p>{</c->
      <c- k>return</c-> <c- mi>0U</c-><c- p>;</c->
    <c- p>}</c->
    <c- k>else</c-> <c- p>{</c->
      <c- k>return</c-> <c- mf>0L</c-><c- p>;</c->
    <c- p>}</c->
  <c- p>}();</c-> <c- c1>// now okay: fixed return type, conversions happen normally</c->
  <c- k>auto</c-> <c- n>okay1</c-> <c- o>=</c-> <c- p>[]()</c-> <c- p>{</c->
    <c- k>if</c-> <c- p>(</c-><c- mi>1</c-><c- p>)</c-> <c- p>{</c->
      <c- k>return</c-> <c- p>(</c-><c- b>unsigned</c-> <c- b>long</c-> <c- b>long</c-><c- p>)</c-><c- mi>0U</c-><c- p>;</c->
    <c- p>}</c->
    <c- k>else</c-> <c- p>{</c->
      <c- k>return</c-> <c- p>(</c-><c- b>unsigned</c-> <c- b>long</c-> <c- b>long</c-><c- p>)</c-><c- mf>0L</c-><c- p>;</c->
    <c- p>}</c->
  <c- p>}();</c-> <c- c1>// ok: cast to identical types</c->
  <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
<c- p>}</c->
</pre>
   <p>This fixes other problems in the C language as well, such as not being able to specify functions with proper variable-length array returns without using ugly syntax. The <code class="highlight"><c- k>auto</c-></code> part only applies for regular function definitions, and could also be applied to Capture Functions for ease-of-use (but is not required for it to function appropriately). One could also just have <code class="highlight"><c- k>auto</c-></code> but no <code class="highlight"><c- o>-></c-></code> to have regular functions achieve the lambda behavior, where all <code class="highlight"><c- k>return</c-></code> expressions must evaluate to the exact same type. Not having a <code class="highlight"><c- k>return</c-></code> or having a <code class="highlight"><c- k>return</c-><c- p>;</c-></code> both imply the return type is <code class="highlight"><c- b>void</c-></code>, and thus any other kind of <code class="highlight"><c- k>return</c-> <c- o>&lt;</c-><c- n>expr</c-><c- o>></c-><c- p>;</c-></code> in that function would be illegal.</p>
   <h4 class="heading settled" data-level="3.3.4" id="design-lambdas-forward.decls"><span class="secno">3.3.4. </span><span class="content">Forward-declaration is Impossible</span><a class="self-link" href="#design-lambdas-forward.decls"></a></h4>
   <p>It is impossible to forward-declare a lambda given the fact that every lambda is a definition of a unique object as an expression and does not do the usual declaration/definition split. Implementations may fold identical lambdas together but that is only observable as an optimization, and is not a guarantee of the design. This contrasts with Capture Functions, wherein they can be declared (with all of their captures) under a specific identifier in a specific scope and reserve that identifier for that type, and then later defined in that scope or a dependent scope.</p>
   <p>That is the full set of notable technical differences between Lambdas and Capture Functions.</p>
   <h3 class="heading settled" data-level="3.4" id="design-benchmarks"><span class="secno">3.4. </span><span class="content">Measuring Solution Spaces</span><a class="self-link" href="#design-benchmarks"></a></h3>
   <p>One of the ways we can increase the confidence we have in our data is to provide benchmarks for the things we are working on proposing to the C standard. We do not mind adding new and improved functionality to the benchmarks to do more measurements it is an open set and we would appreciate any help in benchmarking or measuring or coming up with new ways to observe behavior.</p>
   <h4 class="heading settled" data-level="3.4.1" id="design-benchmarks-manorboy"><span class="secno">3.4.1. </span><span class="content">Donald Knuth’s Man or Boy Test</span><a class="self-link" href="#design-benchmarks-manorboy"></a></h4>
   <p>This is a set of benchmarks using Donald Knuth’s Man or Boy program, which tests self-references and recursion in the same function / closure object. It also flexes a number of properties that can evaluate the quality of a closure implementation, and so is suitable as a microbenchmark. Both a linear version and a logarithmic version of the graphs are made available due to how the performance differences skew things wildly in one direction or another. The benchmark’s source code is available in the ztd.idk repository (<a data-link-type="biblio" href="#biblio-ztd-idk-closures-benchmark" title="ztd.idk Closures Benchmark">[ztd-idk-closures-benchmark]</a>).</p>
   <h5 class="heading settled" data-level="3.4.1.1" id="design-benchmarks-manorboy-methodology"><span class="secno">3.4.1.1. </span><span class="content">Methodology</span><a class="self-link" href="#design-benchmarks-manorboy-methodology"></a></h5>
   <p>The tests were ran on a 13-inch 2020 MacBook Pro M1. It has 16 GB of RAM and is on MacOS 15.7.2 Sequoia at the time the test was taken, using the stock MacOS AppleClang Compiler and the stock brew install gcc compiler in order to produce the numbers seen on December 28<sup>th</sup>, 2025.</p>
   <p>The experimental setup used the Man or Boy test, but with the given <code class="highlight"><c- n>k</c-></code> value loaded by calling a function in a DLL / Shared Object. The expected <code class="highlight"><c- n>k</c-></code> value that the Man or Boy test is supposed to yield is also loaded from a DLL / Shared Object. This prevents optimizing out all recursion and doing enough ahead-of-time computation to simply collapse the benchmarked code into a constant-time, translation-time calculation. It ensures the benchmark is actually measuring the actual performance characteristics of the technique used, as all of them are computing from the same initial <code class="highlight"><c- n>k</c-></code> value and all of them are expected to produce the same <code class="highlight"><c- n>expected_k</c-></code> answer.</p>
   <p>There 2 measures being conducted: Real ("wall clock") Time and CPU Time. The time is gathered by running a single iteration of the code within a <code class="highlight"><c- k>for</c-></code> loop. That loop runs anywhere from a couple thousand to hundreds of thousands of times to produce confidence in that run of the benchmark, and each loop run is considered an individual iteration. The iterations are then averaged to produce the first point after there is confidence that the measurement is accurate and the benchmark is warm. The iteration process to produce a single mean was then repeated 150 times. All 150 means are used as the points for the values (shown as transparent dots) on the bar graph, and the average of all of those 150 means is then used as the height of a bar in a bar graph.</p>
   <p>The bars are presented side-by-side as a horizontal bar chart with various categories of C or C++ code being measured. The 13 total categories of C and C++ code are:</p>
   <ul>
    <li data-md>
     <p>no-op: Literally doing nothing. It’s just there to test environmental noise and make sure none of our benchmarks are so off-base that we’re measuring noise rather than computation. Helps keep us grounded in reality.</p>
    <li data-md>
     <p>Normal Functions: regular C functions which add an extra argument to the function call in order to pass more data. Somewhat similar in representation to rewriting <code class="highlight"><c- n>qsort</c-></code> to <code class="highlight"><c- n>qsort_r</c-></code>/<code class="highlight"><c- n>qsort_s</c-></code> to pass a user data pointer.</p>
    <li data-md>
     <p>Normal Functions (Rosetta Code): regular C functions which add an extra argument to the function call in order to pass more data. Taken directly from the Rosetta Code weekly, and uses a pointer <code class="highlight"><c- b>int</c-><c- o>*</c-> <c- n>k</c-></code> to refer to an already-existing value of <code class="highlight"><c- n>k</c-></code> during a series of recursive calls.</p>
    <li data-md>
     <p>Normal Functions (Static): regular C function which uses a static variable to pass the specific context to the next function. Not thread safe.</p>
    <li data-md>
     <p>Normal Functions (Thread Local): same as "Normal Functions (Static)" but using a <code class="highlight"><c- k>thread_local</c-></code> variable instead of a <code class="highlight"><c- k>static</c-></code> variable. Obviously thread safe.</p>
    <li data-md>
     <p>Lambdas (No Function Helpers): a solution using C++-style lambdas. Rather than using helper functions like <code class="highlight"><c- n>f0</c-></code>, <code class="highlight"><c- n>f1</c-></code>, and <code class="highlight"><c- n>f_1</c-></code>, we compute a raw lambda that stores the value meant to be returned for the Man-or-Boy test (with a body of just <code class="highlight"><c- k>return</c-> <c- n>i</c-><c- p>;</c-></code>) in the lambda itself and then pass that uniquely-typed lambda to the core of the test. The entire test is templated and uses a fake recursion template parameter to halt the translation-time recursion after a certain depth.</p>
    <li data-md>
     <p>Lambdas: The same as above but actually using <code class="highlight"><c- b>int</c-> <c- n>f0</c-><c- p>(</c-><c- b>void</c-><c- p>)</c-></code>, etc. helper functions at the start rather than lambdas. Tries to reduce optimizer pressure by using “normal” types which do not add to the generated number of lambda-typed, recursive, templated function calls.</p>
    <li data-md>
     <p>Lambdas (<code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function_ref</c-></code>): The same as above, but rather than using a function template to handle each uniquely-typed lambda like a precious baby bird, it instead erases the lambda behind a <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function_ref</c-><c- o>&lt;</c-><c- b>int</c-><c- p>(</c-><c- b>void</c-><c- p>)</c-><c- o>></c-></code>. This allows the recursive function to retain exactly one signature.</p>
    <li data-md>
     <p>Lambdas (<code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function</c-></code>): The same as above, but replaces <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function_ref</c-><c- o>&lt;</c-><c- b>int</c-><c- p>(</c-><c- b>void</c-><c- p>)</c-><c- o>></c-></code> with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function</c-><c- o>&lt;</c-><c- b>int</c-><c- p>(</c-><c- b>void</c-><c- p>)</c-><c- o>></c-></code>. This is an allocating, C++03-style type.</p>
    <li data-md>
     <p>Lambdas (Rosetta Code): The code straight out of the C++11 Rosetta Code Lambda section on the Man-or-Boy Rosetta Code implementation.</p>
    <li data-md>
     <p>Apple Blocks: Uses Apple Blocks to implement the test, along with the __block specifier to refer directly to certain variables on the stack.</p>
    <li data-md>
     <p>GNU Nested Functions (Rosetta Code): The code straight out of the C Rosetta Code section on the Man-or-Boy Rosetta Code implementation.</p>
    <li data-md>
     <p>GNU Nested Functions: GNU Nested Functions similar to the Rosetta Code implementation, but with some slight modifications in a hope to potentially alleviate some stack pressure if possible by using regular helper functions like <code class="highlight"><c- n>f0</c-></code>, <code class="highlight"><c- n>f1</c-></code>, and <code class="highlight"><c- n>f_1</c-></code>.</p>
    <li data-md>
     <p>Custom C++ Class: A custom-written C++ class using a discriminated union to decide whether it’s doing a straight function call or attempting to engage in the Man-or-Boy recursion.</p>
    <li data-md>
     <p>C++03 shared_ptr (Rosetta Code): A C++ class using <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>enable_shared_from_this</c-></code> and <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>shared_ptr</c-></code> with a virtual function call to invoke the “right” function call during recursion.</p>
   </ul>
   <p>Each bar graph has a black error bar at the end, representing the standard error of the measurements performed. At 150 iterations, the error bars (which are most easily understood and read in the linear graphs) are a decent visual approximation of whether or not two solutions are within a statistical threshold of one another.</p>
   <p>The two compilers tested are Apple Clang 17 and GCC 15. There are two graph images for each kind of measurement (linear, logarithmic, and linear-but-with-outliers-removed) because one is for Apple Clang and the other is for GCC. This is particularly important because neither compiler implements the other’s closure extension (Clang does Apple Blocks but not Nested Functions, while GCC does Nested Functions in exclusively its C frontend but does not implement Apple Blocks).</p>
   <p>MSVC was not tested because MSVC implements none of the extensions being tested, and we do not expect that its performance characteristics would be wildly different.</p>
   <h5 class="heading settled" data-level="3.4.1.2" id="design-benchmarks-manorboy-results"><span class="secno">3.4.1.2. </span><span class="content">Results</span><a class="self-link" href="#design-benchmarks-manorboy-results"></a></h5>
   <p>The result graphs are as follows, presented in pairs for Apple Clang 17 and GCC 15:</p>
   <p><img height="480" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABQAAAALQCAYAAADPfd1WAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjgsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvwVt1zgAAAAlwSFlzAAAPYQAAD2EBqD+naQABAABJREFUeJzs3Qd4U+X7//E73YO27I0oKqCioAy34ARxgHuL4+v4ureCAzeIIop7Iu699wL3QkERXCAIKnu0FLp7/tfn+f5O/mlI26QU0pT367qizcnJyXNGUnL3vp874HmeZwAAAAAAAAAapaR4DwAAAAAAAADA+kMAEAAAAAAAAGjECAACAAAAAAAAjRgBQAAAAAAAAKARIwAIAAAAAAAANGIEAAEAAAAAAIBGjAAgAAAAAAAA0IgRAAQAAAAAAAAaMQKAAAAAAAAAQCNGABAAAAAAAABoxAgAAgAAAAAAAI0YAUAAAAAAAACgESMACAAAAAAAADRiBAABAAAAAACARowAIAAAAOyxxx6zQCBgU6ZMqXI0li5dan369LEmTZrYBx98sN6O1Ntvv23XXnttxMc0rnPOOWedtr9o0SK74oorbNttt3X7kpGRYVtuuaWdf/759scffwTX0xj0eo2R9iua2+TJk9f5tdasWeOOZX1sK5IBAwa4sXbp0sU8z1vr8U8//TS4P7q2G4u5c+eudb5yc3OtZ8+edscdd1hFRUW8hwgAaKBS4j0AAAAANEx///237bvvvi549uGHH9pOO+20XgOA99xzT7VBwHXx7bff2oEHHugCRQok7rzzzpaWlma//fabPfnkk9avXz9bsWKFNXZfffVVlfs33HCDTZo0yT7++OMqy7feeut6CQBed911wWDd+pCTk2Nz5sxx4997772rPPboo4+6wFhBQYE1Rueee64de+yx7ueVK1fa66+/bhdeeKHNnz/fxo4dG+/hAQAaIAKAAAAAWIuy4vbZZx8rKyuzTz75xGXOJSIFgIYMGeIy/r788kvr2LFj8DEFps444wx78cUXLREoqJaVlVXn54cHcFu1amVJSUnrNbC7Pm2yySYuCKhgX2gAcNWqVfbCCy/YcccdZw899JAlmqKiIne91pSJqn0PPW+DBg2yn3/+2Z555hkCgACAiCgBBgAAQBXTpk2z3XbbzVJSUuzzzz9fK/h30kknuTLaWbNm2eDBg93PnTp1sosvvthKSkqC66n8M1JJqV/G6JdmanvK/pPQ0katF+qJJ56wrbbaygXBVPL45ptv1nrmFABauHChjRkzpkrwL9Thhx9e4zYqKyvd87t3727p6enWunVrO/HEE12GZKipU6e6TEM9rvXat29vBxxwQHC98P0OpeWh2Y9+KfIPP/zgxtesWTPbfPPN3WPKZLz33nutV69elpmZ6R7TOn/++aetq9LSUrvxxhuD+6og4cknn2xLliypsp6y7hRAbdGihRuDAlKHHXaYC1JqP/U8URagfz51nuvbKaecYi+//LLLgvM9++yz7v9HH330WuvrmtX+qPxb11GHDh3soIMOsunTp1dZz792FVC78sor3blURqGC4socjYbeOwpMKkip19pll13srbfeilh6//7777t90XHTuqHvo2jl5eVZampqzNeuMkH1Xlf2YDiNSee4uLg45vEAABoWAoAAAACoErRQYEeBAv2sOdYiUWbgwQcf7AIcr732mgsUjBs3zm655ZaYj+bVV18dDMKpTNW/tWvXLriOAid33323XX/99fbSSy9Z8+bN7ZBDDqk16KXASnJysgvy1NV///tfu/zyy105tEotFTB59913XUBHcyTK6tWrg+XSCmZqvkTNyabAmDLS6urQQw+1LbbYwmW03X///W6ZshYvuOACF4x69dVXXTBwxowZbjx6/bpSsEjZkqNHj3blpTrm+ln7omtCmWmiAJ8CmyqjVvadjoXWy87OdgFEnTctk1NPPTV4PnWe65uCfDq/CtT5HnnkEXc9KWAX7t9//3UBLY1XY9S5UvBrxx13jBjYGzFihP3111/28MMP24MPPugyY3Ut1TbXnrJm99prL8vPz3fj0fgUCNRzn3vuubXW1/tHwTsFuZWRGh7Ii3SuysvL3W3ZsmXB83DCCSfEfO3qetIxeOCBB6o8d/ny5S6YqnOojEQAQILzAAAAsNGbMGGCOim4W15enrd48eJqj8mwYcPces8//3yV5YMHD/a6desWvD9p0iS3nv4fas6cOW65XtN39tlnu2WRaHmbNm28goKC4LKFCxd6SUlJ3qhRo2o8d927d/fatm0b9fkdOXJklXH88ssv7v5ZZ51VZb1vvvnGLR8xYoS7P2XKFHf/1VdfrXbbkfY7dB/12uHjuOaaa6qs99VXX7nlY8eOrbJ8/vz5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9E455RT3BVDvvXDan7333ttWrlxpd955p/uSes8997jA7Ycffui+UEei47169WprqM4991x37HQMtW9qpKBzq0DxqFGj3Hu0IdD1EW2QPBrff/+9Pf7443biiSe6c6QA6DvvvGP//e9/7euvv672+tZ7RUENBaHz8/Ojfj1ds1deeaWdeeaZNnz4cPd6uk79z/CaLFmyxF27zZo1c+NSUEHnRte43g/6LE0Eeo/p/f/555/bZZdd5gJ/em/oXFT3HqntfbmuAUD9AUSi+UOTPo/eeustO+GEE1ygvLy83J577jk74ogj3Hb0GRPr54U+F++44w63zYsuusgFqT777DMXbPnggw/cLTzw7b9nQ2255Zb1+vuqLuNal+OlYzJw4EDbY4893L8RFCB//fXXXZBs9uzZ7hiGfwYocKffCeHHQwG8WN43df0siOTdd9+1vLy84P1I/3bTdaxxpaSkuNfTuVNAUAHQaD4PQun46t8Q/j7X5Oyzz642IBnp3yaic6bjos89XS+i46k/Eul3g5alpaXFNGZgnXkAADRCl112mdehQwevoqIi4uM9evTwWrdu7fXt29fLy8vz1qxZs0HGNWHCBE+/fufMmRPzc7/88ksvOTnZGzRokFdcXLzW4yUlJd5rr70WvN+/f393a8hCz893333njo2OUbQGDBjgZWVlefn5+TWuV15e7rVr187bb7/9qix/6qmn3Gu+/fbbNT5/6dKlXkZGhnf66adXWX7TTTd5gUDAmzFjRkz7mp2d7Q0bNsyL1rXXXuvG+eGHH9Zpn9566y237Omnn66y7r777uu1b9/ebct3xBFHeC1btqxyTOfOneulpqa691Ukt956q3u/3Xnnne51dC5D3XPPPW65rmFfWVmZt/XWW3v9+vWLuM1vvvnGS0tL81544QX3XL1GQ6H3b3Vj0meJ3qPRXFfR0vmJ9J6Pl+XLl3ulpaVrLT/77LPdfs+bNy/i8w488EDvoIMOcte+3gPRmDJlipeUlOTdcsstdRrrpZde6q5dXcM+Xdu6xo888khvfVu9enW9bGfcuHHuOHz11VdRP6e29+W6WLJkidvmyJEjo16/srJyreUHHHCA+wwPvb6j/bwoLCx0t0j7red/9tlnUb1n6/v3VSzjqo/jddxxx3np6elrvaZ+N+Tm5kbcfm3HI9r3TV0/C0LpGtK62ufaDBkyxF3Tet11sXLlSred22+/3evcubM7rtV58cUXvSZNmngTJ05049TvpGice+65bv0HHnigyvKFCxd6KSkp7nc1sKFRAgwAaHT0V2Bl9emv2pH+gvzNN9/Yzz//7P6yftppp7lMlJdeemmt9fSX7h49eri/3O+0006u5Erlm/qrc2hpi19apIxDZYltsskm7i/FyiqsrcQx9C/4ynjQX6JV7qRSn/Dn3nzzze51lG2mspdw+kuysstqosyBHXfc0ZUT6bVUOqxj5Xn6d+r/p9IalcToL/JaR/uu0tdIf81XRorKf7TP/vHxy/xqK3WOdH6ipcyGTz75xI488sha/4KvTARlPKh0OpSyKZSdUVvWpI6DMuHCn6/7OnbRlPPUdV+1/QkTJliXLl1sr732qtM+6Wct02Ph41dGhd4TfsbCm2++aYcddliVY9q5c2fbc889Ix6nP/74w2Wj3HvvvdWeBz1PGSO6TnzK4FD24rfffusyJMLfw8pcUtZFrNm5KgNTlqyuRb0ndNyUPRaeVanr85xzznHZwFtttZV73/Xs2dPt/7rQe0XvKWXC3HrrrcHlyqjRuJS1q3OhrCadT32+hAr9PLnxxhtdqbne7x9//LErddMx8elzSBklurZUouZTmaiOrzKoqisBjuU9Hk6vqf0L169fv2CpZLgnn3zSvV91ncTi7rvvdvuvTKW60LWn46xr2KfrVNlPb7zxhrvma6PsM2VX6Zwpu0rlnDo/4eX//u+MTz/91GXo6ZrSdeyfU10PyljWsdfx1vrK2tV2lFmszEhlQCnTTyWwoZTFpTHod1E0onlfRhLNdar98TOB9TvFL3OsbloDURZipKw3XTPKJgwt34z280LnQrdI25T58+dbfYr2M7w+xhXL8dJ7UZ91uqZCqdS0uqy1+nrf1OWzoK503SmzUf9u0+uui4svvthVFpx33nk1rqfjrM9c/9920dLvFWWCn3rqqXb66adXeUyf4yqnVtUGsKERAAQANDoKZixbtswFLCLRl3PRF7Ojjz7afUnzl4VbuHChW+e4445zc1Adfvjh7ku5SmsifVHVl2mV/ujLrr4saF6a6spDfFpXJaX6x/XEiRNd2aUCdCrp8YOA+qKvAIDm1unUqZOtyz+gzzjjDPcaL7/8crAE6IYbblhr3R9//NH9I1nlKtp3la/qH7P6chs6H6H+IasvJBq7/kGrOYL0j+X1TYEKBcdU2lQbBXxF+xBKX1wU9PAfr+35+uIfSl8g9EWttuevCwWH//rrL3e9hn4hjGWf9LOCXPoSHcp/rr+ugqqady98m/66KoELncPKP/4KJNUUfNb2q9umhM+Zp/k7VdYY6bqsicam971K0lR6pxIvBQ0UrNG1Hk6P632r19MfAfS+U/CltvkOa6NAjt6rmpvN/6Lsf2EfOXKke10/qKsgUKR51DR/l97zmvtQJXU6f/pCruvBp9J/Bfn0JT/0DwZax587rCbRvMdjofHqGlOJeSgFszR3mkp5O3bsGNM2NRbtu86PgkLJycluGwqY1Vbyp2tZ13R1154ej+Zcaxv6g5K+1CtArGOkYJ4+S8MpKK9rTuu//fbbLpgWGkj84osv3P/1RxKVMR900EFuewq86TNN16rOX+jnmgJG+uzW58+IESNcAEHHWfMg6nM3XLTvy0iiuU71uaffdaKx63ecbvrjT6xUuqlgogKNdf28iHQdio5POF2DCpbp9/5uu+3mAkobSk3jWpfjpdJ4vRcUzNIfdPSZoGtVQTyVi8eqPt431X0WhM8zGErXt97fur5VOqtS6lAKQuva1uerpq9QgFqffdpepH9nVfdaen/pd4Teg3q9muiY6o8w+mNRtDQVhD4bVLqt93okGpc+C/w/0gAbzAbPOQQAYD1TqZh+xanMIlI5lkpidtppp+AylaOpjHPWrFlV1lX5rLYTWlYrp512mivF+uuvv6qU0qiUsqioKLheQUGB17x5c2+fffaptgRY49E6KosLLzXq2bNnsNxJ+6LnHX300VEfh9pKgPUaKqu6/vrrvRYtWlQpN1JJjEpe/X0U7ZvGesYZZ1QpF1UpX2jpjrarUq1YS51jKQFWSaTKd7p37x7VtlWqq20vWLBgrcdUJtW1a9can69zrhKrSPTc8DLc2sRSAnzUUUe50u+///67zvu05ZZbegMHDlxrvX///ddt4+abb3b3v/jiC3f/mWeeWWtdraPH9BzfXXfd5TVr1iz4XvOv7/BSQ5WShV43PpX4hZcmT5061a3/7rvvxly6d//997t1n3/++YifCe+//35wme63adPGvU992g+9t0eNGlXj60QzJp03rbNo0aJqr2G9//bee2/vkEMOWWvbm2+++VqldQ8//HCVsrobb7zRvQcOPvhg7+ST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ibU1qbomtj7//PPdtv/73/+uNZl2p06dvN122817+eWXvRdffNHr27evl5KS4n3++efVNgGRJ554wk2YraYBmlz6k08+cc+/+uqrvTPPPLPKGDXZu7bZo0cP75577vEmT57sJpPWZN9bbLGFN3To0GqbgGhier22Jo5XMwQ1eujdu7drEBE+puomxQ7f5rRp09zk25qE+7nnnvNef/11b/Dgwe752mZog4HqaJ918xs1nH322cFlkajpgY516GT6oebOnesm/z7llFOqLNdx1vZPP/10N5m3jmXTpk29fffdt8p6OqZ6/nXXXVdluRouqFmMmitoHU2ergYFmlg+1MSJE93z9f/w7fr7pWM2YMCA4H3/mgulc6/x/vbbb9Ueu2j3SbRMjQG0jiZa17j13CeffLLKer/88ovXpEkTb4899nCTsut61vWm90GkcYaqrtlAcXGxt80227jzpsn3dc1qMnxdyzouNYmlCYiaWOhaVNOI22+/3b2OmhTofa3rMpR/rYXTtVtbgxZ/TOeee65r0KAJ+HWsNJG9mndov8aOHVvlOddcc427fvR/vRfvvfde95mk9fWa0e7v0qVL3Xa0Tug1quvNbwDwww8/VHlOdU1AonmPR/Lrr7+6z0ZN1P/GG2+4YxB6q+06qa4JiN6zeu/oPexTU5MddtjBy8vLc80PdE4vv/xyt94555xT5fma8F/LQ2ks7dq187bddlvvlVdecedJ17auEV3rtdE6aWlp7v3qvx/0XvI/N/W+Cz12us7DVXdOq2sqEOl9pCZVem9369bNfXa/9dZb7j2ka6GmpgTVba860V6novsaj343ats1NX1S4w01wVADBn3+hF8zfsOTWD4v1GCnS5cu7nNYn2Ph25w/f35wXTWk0PWiY6fjrsYT+h0dSyOPaH9fxTKu+jhe48ePd2PZf//9vVdffdX9ftd7RMcrtAlZqNo+Z6J938T6WRCpMYc+s/VvGD1f51qfo7rW9TsntOmUf/x1feqzS0069O8O/X7S50N4I7dIrxVJdZ+F4SK9X9UEaLPNNnOvpd/H4fvv38LHpt8d4c3XgA2BACAAoFHafffdq3zh1z+K9Q83dV2sjjrKaR3/i7v/ZU5fOPr06eP+Ma9/ECsApIBi+D+k9YVAX8g7duzovjBuv/327otRqEgBQFHQT/8A1T+iFaxQh1vdj/TFTkE3fYHeZJNN3Ovoi7ReS1/YQv+xHemL/KOPPuq+sGlf9AVFXfUeeeSROgcA/S8qO+64o9umviheeumlwS9HK1eu9GrjBy0i3cL5XWq1r9Xxz0ekII46GOrLho6bxnreeee5roCR/pEfqbulAhDqrqvn6/hrnfBOrf45Dv9S6XcIjXQLDSLImjVr3BcafeGqTTT7JFqmx7SO1tVzInX7lSlTpriun1lZWa7jogLL4V9gYg00qCPpiSee6K5xBUDVgVNf9moTSwBQli1b5oKneq/qC7CuZXV8VFChvgOAoR03FVxVQF0dXGfMmLHWc0pKSrxLLrnEvbe1/wpq6XNJrxVLAFD0ftc6ej+Ed+6M9KWyvgOA/nmu7lZbQKW6AKCWR/p81DlVV1h1BdXno96DOj7hfwTw32PhdO3qGta1rGta1/b333/vRUuBCXXw1XnT+dNnnLp3bsgAoKgbqc6ZgjD+e0hjq00sAcBor1P58MMP3bWoz/7qPnPDr8FoPwOj+bzwj191t9DPcP2e69evn9uePhf0flVn9PDf0fXx+yqWcdXX8VI3XP0BsmXLlu69pevwhhtu8AoLCyNuP5rPmWjeN7F+FmhZ+OfL0Ucf7f6AqXHr/a3rTJ/h4cE/n65HBW91Xej3pLpoR/rMjfRa9R0ArO1c+7fQ94Y+n/WaCgICG1pA/9kwuYYAAGw4KnXUXCyag6e67qm1UfmOSls1F0xNVJKleXvUdfGSSy6p44gbFzUb0XEJ75AJAACwsVKjEP0bacaMGcEpa4ANhSYgAIBGSXOVaW6oUaNG2d133x3v4TRqF110kW2//fbWqVMnN7G1uhRqHqBo58IBAADYGGjeU3UZJ/iHeCAACABolDSRuSZpVwMPNaWorTsc6k6TcV9zzTWuU6eOuya1VmOR448/nsMKAADwf52D1TztrLPO4nggLigBBgAAAAAAABox0iEAAAAAAACARowAIAAAAAAAANCIEQAEAAAAAAAAGjECgAAAAAAAAEAjRhdgAA2aurf++++/lpOT47qLAgAAAACwsfE8z1atWmXt27e3pKTY8/kIAAJo0BT869SpU7yHAQAAAABA3M2fP986duwY8/MIAAJo0JT553/I5ebmxns4AAAAAABscAUFBS45xv+OHCsCgAAaNL/sV8E/AoAAAAAAgI1ZoI5TY9EEBAAAAAAAAGjECAACAAAAAAAAjRgBQAAAAAAAAKARIwAIICFMnf69zZ37p5WXl8d7KAAAAAAAJBQCgAASwiffvmfvffKm/fDjFIKAAAAAAADEgC7AABLCP0tm27IVf9u/C+ZbdkYT22abHvEeEgAAAAAACYEMQAAJYXX5aisoWml//DvDXnnj+XgPBwAAAACAhEEAEEBCaNk6xzJbZliZFdnkzz6K93AAAAAAAEgYBAABJITUDLO83Axr2TLTFixdEO/hAAAAAACQMAgAAkgIK1cW2qqiUkvJTraKyop4DwcAAAAAgIRBExAACSEzNcsqy8ts+YrVVuKVxHs4AAAAAAAkDDIAASSEispKq/AqraKs3EqKCAACAAAAABAtMgABJIRApZlnZVbmVVhFGSXAAAAAAABEiwxAAAkhLSfJki3TrCJgqVmp8R4OAAAAAAAJgwAggISQv6TQvECltWmXZxlqCQwAAAAAAKJCABBAQmjePNea52VbUnKSWaUX7+EAAAAAAJAwCAACSAypZoVFlbZs0RpLTmL6UgAAAAAAosW3aAAJYck/KyzJAla6usRa5bWK93AAAAAAAEgYBAABJITKioAleSkWqMy0XXfqG+/hAAAAAACQMCgBBjZSAwYMsPPOO88uu+wya968ubVt29auvfba4OPz5s2zIUOGWJMmTSw3N9eOPPJIW7RoUZVt3Hfffbb55ptbWlqadevWzZ544okqjwcCAbfO/vvvb5mZmbbZZpvZCy+8UKfx5mQ2t5SkLMtNamWXXnBlHfcaAAAAAICNDwFAYCM2ceJEy87Otm+++cbGjBlj119/vX3wwQfmeZ4NHTrUli9fbp988olbNnv2bDvqqKOCz33llVfs/PPPt4svvth+/vlnO+OMM+zkk0+2SZMmVXmNq6++2g477DD78ccf7fjjj7djjjnGfvnll5jHmr+g3NrndrUx14+3li1b1sv+AwAAAACwMQh4+qYPYKPMAKyoqLDPPvssuKxfv36211572d577+2y9ubMmWOdOnVyj82cOdO22WYb+/bbb61v37626667uvsPPvhg8PnKEly9erW99dZbwQzAM88802UB+nbaaSfbYYcd7N577404rpKSEnfzFRQUuDHk5+e7TEQAAAAAADY2BQUFlpeXV+fvxmQAAhux7bbbrsr9du3a2eLFi12GnoJufvBPtt56a2vatGkw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Xnu5AFqLFi3s9NNPr3K8qqN127ZtG7zl5eUFswOnTZtWbdah/q/7Ck726dPHHYdddtnFfvvttyrbf/31193j2q+WLVvaoYceGszA++uvv+zCCy8MZh9Wl4F333332eabb25paWnuXD/xxBNVHtdzH374YTvkkEPcOLbcckv3uvXljTfecOdP+6Bzfd1111l5eXnEdf1jp/Op46HnbLPNNmtla86cOdMGDx7srsE2bdrYCSecYEuXLg0+ruNzzjnn2EUXXeSO27777uuWX3vttbbJJptYenq6u3bPO++84HOSk5PdNp955pmY9q80p7lV5La05lv2soNPPMN23H33GI8QAAAAAAAbJwKA63oAk5Js/Pjx9vPPP7uAnubHU4lsqDVr1rh1FGx59913XZBFAaa3337b3RQoevDBB+3FF1+s8rxbb73VtttuO/vhhx9s+PDhLgjlB/lUPqltKJjy9ddf2/333++CfeEU2FOwSoGcO++80x566CEbN25c8PHjjjvOOnbsaN999519//33LoCXmppa7f5++umnLlAWiYI+CvCF70focVCZsAKeer0XXnjBZfYpgLS+qWR57NixLripbMVTTjkl+Nhbb73ljqUy06ZOnRoMFormqtPxuf7664PZh5G88sordv7559vFF1/sroUzzjjDBUTDMyIVlDvyyCPtp59+ckEwHf/ly5ev8/4pm05l0Qq06Vw/8MAD7rzfdNNNNT7v0ksvdWPWfisQePDBB9uyZcvcY9rX/v37W69evdxx07W7aNEiN/5Quu51TL/44gv3ujr/usb0s4LUmndQQfJQ/fr1s88++yzimEpKSqygoKDKTfoPPtwGHXWaHfafc22/gw91gVYAAAAAABAFDzUaNmyYN2TIkKiP0vPPP++1aNEieH/ChAnqXeDNmjUruOyMM87wsrKyvFWrVgWXDRw40C33de7c2Rs0aFCVbR911FHe/vvv735+7733vOTkZG/+/PnBx9955x33Wq+88kq14xszZozXu3fv4P2cnBzvsccei3r/8vLyvMcff7zKMu2jlssVV1zhde3a1SsrK/NWrFjhxjNp0iT32IMPPug1a9bMKywsDD73rbfe8pKSkryFCxdGfL05c+a4bWRmZnrZ2dnB2w8//BB8bOrUqcH1w19T/9f9Dz/8sMprallRUZG7v/POO3vHHXdctfus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zrLCwsLg44899pg1bdrU3nzzTevWrZtlZWXZ4YcfbqtXr7aJEye6Ut9mzZrZueeeaxUVFVW2vWrVKjv22GOtSZMm1r59e7vrrruqPP7HH3/YHnvsYRkZGbb11lvbBx98sNb4Lr/8cuvatat73S5dutjVV19tZWVlwcd//PFH23PPPS0nJ8dyc3Otd+/eNmXKlJiOQYdzTrIOgRTbOr2JHdWjr/3nmGNjej4AAAAAABsrMgCBBJCUlGTjx493gbw5c+a4AOBll11m9957b3CdNWvWuHWeffZZF9Q79NBD3U2Bwbffftv+/PNPO+yww2y33Xazo446Kvi8W2+91UaMGGHXXnutvffee3bhhRda9+7dbd9997XKykq3jZYtW9rXX39tBQUFdsEFF6w1PgX2FIRUAHH69Ol22mmnuWUaoxx33HG2/fbb23333WfJyck2bdo0S01NjbivJSUl7ubTa8qubTpZ84xM69dhMzvigANcwBIAAAAAANQu4HmeF8V6ADbAHIArV66MqrnGCy+8YP/9739t6dKl7r6CbyeffLLNmjXLNt98c7fszDPPtCeeeMIWLVoUDJYNGjTIBRHvv/9+d18/b7XVVvbOO+8Et3300Ue7oJuChu+//74NHjzY5s6dax07/m/OvXfffdf2339/e+WVV6qds1BBxeeeey6Y5aesP2UWDhs2rNZ9UyDyuuuuW2v5ipUrrWleXq3PBwAAAACgsSkoKLC8vDzLz89337FjRQkwkAAmTZrkMvI6dOjgMutOPPFEW7ZsmSvx9an81g/+SZs2bVyALzRTTssWL15cZds777zzWvd/+eUX97P+v8kmmwSDf5HWlxdffNFlFrZt29a9nkqA582bF3z8oosusv/85z+2zz772OjRo2327NnV7uvw4cPdB5p/mz9/fgxHCgAAAAAAhCMACDRwf/31l8vC69Gjh7300kv2/fff2z333OMeC51nL7ykNhAIRFymst7aaD2JlCDsP+ZTabCyBpUVqDkIp06daldeeaWVlpZWyeqbMWOGHXDAAfbxxx+7uQSVQRhJenq6+2tG6E3+KS2qddwAAAAAAGBtzAEINHAqoy0vL7exY8e6uQDl+eefr7ftK4AXfl9zAIoCdcrk+/fff938fvLVV19VWf+LL76wzp07u6BfaNAynJqE6KY5Bo855hibMGGCHXLIIVGP85pnHrPWqZnWr3VbO2IgcwACAAAAABAtAoBAA6KSVzXICNWqVSsXANQcegcddJALuPlz+NUHbW/MmDFuPj91+NX8gm+99ZZ7TCW76iqskmMFIDXnQGigT7bYYgsXJFTzkb59+7rnhmb3FRUV2aWXXuq6Em+22Wb2999/23fffecaksTi5QuvtM5Xnmdfzf/Tps6bazefdjaNQAAAAAAAiAIlwEADMnnyZNctN/T26KOP2u2332633HKLKwN+6qmnbNSoUfX2mhdffLErK9Zr3XDDDS7QN3DgQPeYMg4VzFNX3n79+rl5/G666aYqzx8yZIjL6jvnnHOsV69e9uWXX7o5AH3q+qv5ChVEVAbgkUce6cqFIzX6qFHAbFmn1jarRRN7YdZMe+i5p+vnAAAAAAAA0MjRBRhAQnQ6suQkszGXm5VXmK0qti1+nWN/vPB6vIcHAAAAAMB6RxdgABuPpk3M0tPM0ips1sql8R4NAAAAAAAJgTkAASSOzBSztCyzsiKzisJ4jwYAAAAAgITAHIAAEkMgYNY0738BwKwss+J4DwgAAAAAgMRABiCAxOB5ZvkF//u/F4j3aAAAAAAASBgEAAEkjqIis4IKs4JVBAEBAAAAAIgSJcAAEkdyillGillpxf/mAQQAAAAAALUiAAggceYAbNXCrEmqWXKlWVllvEcEAAAAAEBCoAQYQGLQ3H+LlpmVl5vlZpo1yYr3iAAAAAAASAhkAAJIHOr9kZJklpHzvyAgAAAAAACoFQFAAIn1iaUAoFWaVfDxBQAAAABANPgGDSBBBMyaNHexP1u4xDbXzwAAAAAAoFbMAQggMYy61FLmz7eKpaut+ZJ8u+CQI+I9IgAAAAAAEgIBQAAJoXXBakuzZGtWXmn7bdPHTj6UACAAAAAAANEgAAggIQxsv5m1TMuwPq3a2pC997Ps7Ox4DwkAAAAAgIRAABBAQhh/7CnWNC8v3sMAAAAAACDh0AQEQEJICgTiPQQAAAAAABISAUAAAAAAAACgESMACAAAAAAAADRiBAABJATPq4z3EAAAAAAASEgEAAEkhNLVK+I9BAAAAAAAEhJdgAEkhM8+fMOym7ayZm07W8+evS09PT3eQwIAAAAAICEQAASQEP6Y9pkFUtItJT3PFv491wYecBhBQAAAAAAAokAJMICEMOLOFy25aKGtWjLTvnj3Bfv8s8nxHhIAAAAAAAmBACCAhBAws6ZZyZaXVmkVRfPs5WcfiveQAAAAAABICJQAA0gIAQtY26bJlpOZYeVlpfbBdz/Ee0gAAAAAACQEMgABJATPPFtZUGTllRXWJi/LvPLieA8JAAAAAICEQAAQQMJITUszK0+ywqIiK68oj/dwAAAAAABICAQAASSM5KQKqwh4VrCqxApWrYn3cAAAAAAASAjMAQggYawpqrRVJRVWWFJq5WVkAAIAAAAAEA0CgAASRv6aMisqK7Oy8jILBLx4DwcAAAAAgIRAABBAwsjLzLCklICtzki3zMzseA8HAAAAAICEQAAQQMJIT0uyjNRMs6SAJXnz4z0cAAAAAAASAk1AACSEgJnlZqkTcKUFyj1Lz+LvFwAAAAAARIMAILCeTJ482QKBgK1cuTKhjvHcuXPduKdNm2YNiWb8W5xfbssLKq2swiytSW68hwQAAAAAQEIgAIgG76STTnIBqdGjR1dZ/uqrr7rliWzTTTd1+xB669ix4wY9tkOHDq2yrFOnTrZgwQLr0aOHNTiBFCtPSrIKS7O8vGbxHg0AAAAAAAmBACASQkZGht1yyy22YsWKet1uaWmpxdv111/vAm7+berUqXEdT3JysrVt29ZSUhpaiW3AAinZ7pZfFrCttt8l3gMCAAAAACAhEABEQthnn31cUGrUqFE1rvfSSy/ZNttsY+np6S67buzYsVUe17Ibb7zRZb7l5eXZaaedZo899pg1bdrU3nzzTevWrZtlZWXZ4YcfbqtXr7aJEye65zRr1szOPfdcq6ioCG7rySeftD59+lhOTo4b27HHHmuLFy+Oed/85/u3Vq1aBcd6xx13VFm3V69edu211wbvK2Pw4YcftkMOOcSNe8stt7TXX3+9ynNmzJhhBxxwgOXm5rrX2n333W327NluO9q/1157LZh9qLLlSCXAn3zyifXr188d13bt2tkVV1xh5eXlwccHDBhg5513nl122WXWvHlztx+h4xTd32STTdw22rdv79aPxV2XDbHSQJrlF5uVp7WxE0+L7fkAAAAAAGysCAAiISgr7eabb7a77rrL/v7774jrfP/993bkkUfa0UcfbdOnT3cBp6uvvtoF+ELdeuutrrxV6+txWbNmjY0fP96effZZe/fdd10g7NBDD7W3337b3Z544gl78MEH7cUXX6ySPXjDDTfY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779/VNmD+F8QRgGp0aNHVzkcr776qlueyDbddFO3D6G3jh07xjXA1alTJ1uwYIH16NHD4unNN9+0hQsX2tFHHx1cNnXqVDvwwAOtdevW7v2k43fUUUfZ0qVL1ynoWl3Q884777THHnssqm1oTCeccIKNHDnS6qKiuNxKi9dYwYp8a9u+XZ22AQAAAADAxma9BwBFQYiBAwdW+/h3331nZ5xxxlrLO3To4IIbiP44K4tyxYoV9XrISktL434KVEqugJt/U5ArnpKTk61t27aWkhLfMtTx48fbySefbElJScEMu3322cdatmxp7733nv3yyy/26KOPWrt27WzNmjXrZQx5eXnWtGnTqNfXeJ966qnYr1PPbEnBIltatMy8JM8OHnpg7IMFAAAAAGAjVG8BwM8++8yOP/5423nnnYPlfU888YR9/vnnUQWuCgoK1lr+22+/uXJBREeBHwWlRo0aVeN6L730km2zzTaWnp7ussPGjh1b5XEtu/HGG13mm4I7p512msvwUpBHGWfdunWzrKwsO/zww2316tU2ceJE95xmzZrZueeeaxUVFcFtPfnkk9anTx/LyclxYzv22GNdkCpW/vP9m39d6HXvuOOOKuv26tXLrr322uB9Za1pfslDDjnEjXvLLbe0119/vcpzZsyYYQcccIDl5ua619p9991t9uzZbjvav9deey2YfagMukjZcJ988on169fPHVcF3K644gorLy8PPj5gwAA777zz7LLLLrPmzZu7/Qgdp+j+Jpts4rbRvn17t351lNH34Ycf2sEHHxxc9uWXX7r3kvZ3++23t80228z22msvd4y0XY17zz33dOvqfGkfdJ7l3Xfftd12282d5xYtWrgsQh0Dn7Yl2q6ep/2JlCFZWVnpAtFbbLGF2w+97k033RR8fNttt3X7rhL/WFx8+ghr1iTPcnKb2JbbbWbHn3hcTM8HAAAAAGBjVS8BQAWUlOGXmZnpMrNKSkrc8lWrVtnNN99c6/OHDBniMrzKysrcfQUX5s2b5wIohx12WH0McaOgrDQd77vuusv+/vvviOt8//33duSRR7qS0enTp7uA09VXX71WCeett97qylu1vh4XZZAp4+zZZ591wSIFwg499FB7++233U0B3wcffNBefPHFKtmDN9xwg/3444+uHFkl4X7AaUO67rrr3H5rvsnBgwfbcccdF2w2o4C15tFTIPrjjz92+3zKKae44N0ll1zinqd5LP3sw1122WWt7Wsb2m7fvn3dvt533332yCOPuEBqKAUTs7Oz7ZtvvrExY8a46/6DDz5wj+m4jRs3zh544AFXDq/jpWBZdRRcV0Bzq622Ci5TYE3jVnDN89bukqvSZb1f/QC79kclvKJgrsrxlZH70UcfuaxCBU0V0JNvv/3W/V9BRz3v5ZdfjjguzdupAKCum5kzZ7r5Cdu0aVNlHQVK9UeDSPT5oSBm6E2yW6RbTqts67ljDzvvgnNcoBYAAAAAAETBqwe9evXyJk6c6H5u0qSJN3v2bPfz1KlTvTZt2tT6/Pz8fG/XXXf1mjZt6iUnJ3udOnXyUlNTvT322MMrLCysjyE2esOGDfOGDBnift5pp528U045xf38yiuvKAoUXO/YY4/19t133yrPvfTSS72tt946eL9z587e0KFDq6wzYcIEt51Zs2YFl51xxhleVlaWt2rVquCygQMHuuXV+fbbb912/OdMmjTJ3V+xYkW1z9F40tLSvOzs7ODtzjvvDD42bty4Kuv37NnTGzlyZPC+tn/VVVcF7+uaCgQC3jvvvOPuDx8+3Ntss8280tLSWo+tb86cOW67usZlxIgRXrdu3bzKysrgOvfcc497P1RUVLj7/fv393bbbbcq2+nbt693+eWXu5/Hjh3rde3atdpxhNN+d+nSZa3lGktKSorXvHlzb9CgQd6YMWO8hQsXBh+P5pjL4sWL3XrTp0+PuM+Rjk9BQYGXnp7uPfTQQzVu+8ILL/QGDBgQ8TGdu/8V/Fa9rVy5ssZtAgAAAADQWOXn57vvxvp/XdRLBqAyiZRBFU7llNE0GtB6ymZSZpKaWKhhiDLKVFKpbCnERtlXyjRT9lU4zQm36667Vlmm+8o4Cy3dVdluOGWbbb755sH7yupSCW6TJk2qLAst8VVGqDI8O3fu7DK2/LJRZXjG4tJLL3Xltv7txBNPjOn52223XfBnXVMaiz9ObU8lv6mpqVZXOq4qfw9tuKLjWlhYWCUbM3QcolJhfxxHHHGEFRUVWZcuXVzZtbL4QkuIw2nd0KY5PpXbau7M+++/37beemv3/+7du7uMz5qo3Fcl2np9vSf9kt9YzpWOgzL49t577xrXU7ZwdXMSKoMwPz8/eJs/f37Urw8AAAAAANZWLwFABTFmzZq11nIF9RRMiJbmKlPJpeZI03x2qBsFY1WSPWLEiLUeU0JceFfgSKWikQKv4QEybSfSMr9kVCWl++23nwsQai5AlZb6877F2lhETS00p5x/85tOqEw1fPx+KXltY/fHqWDUuqrpuIYur2kcKs9VMP2ee+5xYzrrrLPcuYy0P/4xqa6RhubwU0BR8zsqKKf5BG+77bYa9+Gggw6yZcuW2UMPPeRKlHWL9VxFeyxVfl3d/J6aN1AByNCbG0dR9cFQAAAAAABQvXppYaoOvueff77rNqqAxr///mtfffWVC+Zdc801UW1D84tpTjllQ/kBEd/tt99eH8PcqCiTUs0wunbtWmW5MsLCG7OocYTW0xyC9enXX391jSo0FgW3ZMqUKfX6GgoiaT46n+aL0zyDsVBWnjImFWiLlAWYlpZWJTsyEh1XZbCGBgJ1XJVpqG7WsQTQ1NRDt7PPPjuYubfDDjusta6acSjTT0FANfSojsavzE0FZP37ErpPCvwpUKj5B5UNKeHXSaTnhVODFe2D5hD8z3/+U+16P//8czAbNFovPvuypaWnWqu2LWzv/fYiOxgAAAAAgA2ZAaiMPXUBVXdRlTwqa0lf/hUYVDlvbdS4YqeddrIJEya4AJHKRv1baJdVRE/NI9ToQg1BQl188cUuOKPGHL///rsLfN19990uWFvf1P1VQSON4c8//3Sdd/W69UlZo2o+ooYSCioNGzYs5kCmrlEFDtUYRdefyqG1TWXjicqc1TxE9xXQjJSRp2w9laqqC7ICn+oaPHLkSNdUQ1mK0VAjFjUO0X7oeGkMCqapfDoSBQAVAP3iiy+Cy9SlWd249X+dX41ZmX8qqVcptmh7ClJqnSVLlrj3rAKIyhpUExdl86oZisYeqnXr1m48agCzaNEiV54bTiXJl19+uftMePzxx11Z8ddff+32y6fSXzVaUXZoLM65+L+25J9lNu3b6TZxwpPBgCYAAAAAANgAAUB/3jEFR5TJpy/8CixEG+xRF1JlDyoDSVmAkyZNCt4UiEDd6PiHl8cqk+z55593nXzV5VcZmupEuz468yo4paDWCy+84DLklAlYWxlqrDRfnALOBx54oOvCq0B06DyF0VDgS9eZAmH9+/e33r17uzJYPxtQ8/F169bNzYsYHnDzKctPQTZd/z179rQzzzzTTj31VLvqqquiHofKmvW6mjtQWYkK1L7xxhtufJEo0KluxU899VRwmY6z5mpUoFcZoAqs63w//PDDdsIJJwTHqq7I6rKtORsVAFWQUteEAnO6Li688ELXCTpUSkqK6wKtLEGVFPsBxXDq/qvX17WlDsVHHXVUlXkhFRxVcNjPNIyW8iozA1lm5cn2+4xZ9torr8f0fAAAAAAANlYBdQKJ9yA0h+Cnn37qygcBRE+ZeNtss40L3FWXKdjQ9OvXzy644ALXcCQays7My8uz5KRkm3DbM1awao0tWDLH5iyYbU+9+MR6Hy8AAAAAAPHmfzdWNZ4/V/4GnwOwuLjYlXkqYy/SHH4//PBDjc9XtpEaH9xxxx31MRxgo6EMPpXXqlNvIgQA9flw+OGH2zHHHFOn5+cXrbKKCs/y8prZkmlL6n18AAAAAAA0RvUSAFQZ4gcffOC+2Cu7J7wbam00/9wBBxzgSjdVwhjeiOHll1+uj2ECjVJ1pbgNkeYR1PyAdZWb3tRKk0qsPL/ISour/qEBAAAAAACsxwDgW2+95eY/09xldaHGCcoeVBMRzXcWawARwEYgEHB/HEi2JFuVnG4l5eXxHhEAAAAAABtPAFBNBXJycur8fHULfemll1wWIABUJz091Uq9gFV4JVZRUcGBAgAAAABgQ3UBHjt2rF1++eX2119/1en5zZs3j7lzK4CNjWclpcVWVFRkZeVrLJAc7/EAAAAAALARBQD79OnjGoF06dLFZQIqoBd6q821115rI0eOtDVr1tTHcAA0Rp5ZaXGFVVi5pSerK3DVuUIBAAAAAMB6LAFWR89//vnHbr75ZteVNNY5/MaPH2+zZ892z910003XagJSWxdhABuBQMCa5GZZyZpUW5NaZJUVNAEBAAAAAGCDBQC//PJL++qrr6xnz551ev7QoUPrYxgAGrnkZNX9lllZeZmlGs2CAAAAAADYYAHA7t27u3m56krlvwBQI8+zFStWWnlZhXlWaWkp9TKDAQAAAAAAjV69fIMePXq0XXzxxTZ58mRbtmyZFRQUVLkBQH3wzLPy8nIrLF5pGc0yOagAAAAAAGyoDMBBgwa5/++9995Vlnue5+YDrKioWOs5ag7y+++/W8uWLa1Zs2Y1zhu4fPny+hgmgAS3pqTAiouKrGh1ofXu1zvewwEAAAAAYOMJAE6aNCnm54wbN851DPZ/jrVxCICNy40X32KrilZbuZVYi3Ytbff9don3kAAAAAAASAgBT2l6ANBAaRqBvLw8u//2RywtPc2SU5KsY5d2ttseu1paWlq8hwcAAAAAwAb7bpyfn2+5ubkbLgPwp59+sh49elhSUpL7uSbbbbddrZ09FyxYYK1bt66yXPMJalmkEmIAG5eOm7a3JnnZ1rRFrm211VYE/wAAAAAAWN8BwF69etnChQtdgE4/q4Q3UjJhdXMAhqouCbGkpIQv+QCc3fba2f21AwAAAAAAbKAA4Jw5c6xVq1bBn+ti/PjxwSDhww8/bE2aNAk+pqDhp59+at27d6/rEAE0IswTCgAAAADABg4Adu7cOfjzX3/9ZbvssoulpFTdXHl5uX355ZdV1g2l5h9+BuD999/vSoF9mttr0003dcsBAAAAAAAAxLEJyLrO4bfnnnvayy+/bM2aNVvXoQBoZNZ1olMAAAAAABJd3JqAhFIMMVJ5ngKA2dnZtT5/0qRJ9TEMAAAAAAAAAPUZADz00EPd/xX8O+mkkyw9PT34mLL+1B1YpcEAsK68ykoOIgAAAAAAGzoA6HfkVAZgTk6OZWZmVpnDb6eddrLTTjttXV4CAJx3nnjCMps1sxabbGJ9+vWzjIwMjgwAAAAAAOs7ADhhwgT3fzXruOSSS6Iq9wWAupg95TtLzcyy8pQU++3HH+3oU07hMwcAAAAAgA3VBAQA1vdEp8mBgLXKy7VLDjzICpICtuWAPe2YE0+s0j0cAAAAAIDGqKAhNAFZV59++mmNj++xxx4bbCwAGq6AZ5ZaVmpeSYl998H7tvfAgdaufft4DwsAAAAAgAatQQQABwwYsNay0K7CaigCAJKelmZNS0vt99mzbfmiRQQAAQAAAACoRZI1ACtWrKhyW7x4sb377rvWt29fe//99+M9PAANREogYE3U/CMQsNVFxVawYkW8hwQAAAAAQIPXIDIA/W7Cofbdd19LT0+3Cy+80L7//vu4jAtAAxMIWE5SkpXm5lplZaUVFhTEe0QAAAAAADTeAOD48eOjXve8886r02u0atXKfvvttzo9F0DjU+l5trKszFYVFrqfLalBJDEDAAAAANA4A4Djxo2Laj3N5VdbAPCnn36qcl+NiRcsWGCjR4+2nj171nWIABqRiv9rWF5WXm4rV62ycnVAatYs3sMCAAAAAKDxBgDnzJlTb4Po1auXCxQq8Bdqp512skcffbTeXgdAYlPZb0FhoZWUlVlFZYVlZmfHe0gAAAAAADR4DWIOwPBgYlJSkiv/zdBk/wBgZsmBgPtsaNmkiZWVllmFZwQAAQAAAADYkAHAv//+215//XWbN2+elZaWVnns9ttvr/G5nTt3rq9hAGjElClsnllyWqplpKVZSdhnDQAAAAAAWE8BwI8++sgOPvhg22yzzVzTjh49etjcuXNdSe8OO+wQ9TY0r+Avv/zivuR3797dLrjgAttnn33qY4gAGgF9pnipKdY8I8NSc3Ossrg43kMCAAAAAKDBq5cWmsOHD7eLL77Yfv75Z1e2+9JLL9n8+fOtf//+dsQRR9T6/LvvvtsGDRpkOTk5dv7557umIbm5uTZ48GD3GNafTTfd1O64446Yn6cg7auvvmrr08cff+wCwZr3Ld77rMDT6aefbs2bN3f7Pm3aNIsXBdfjPYZoLVy40Pbdd1/Lzs62pk2bWklJiW2yySb2/fff12l7SgBMTk21ovJyS0pJtbS0tHofMwAAAAAAjU29BACVtTds2DD3c0pKihUVFVmTJk3s+uuvt1tuuaXW548aNcpl/z3zzDMu+Kfb008/7ZbdfPPNtjE46aSTbOjQofEeRoNy2WWX2ZVXXunmfavNY4895gJM68u7777rXuPNN990HaqV5Rqv66JTp04bdAzrQu9hjVXByt9//93S09Ptkksuscsvv7xO2/MsYEXFxba0uMRatGhhKQQAAQAAAADYMAFAZfcos0fat29vs2fPDj62dOnSWp9fUFDgMgDD7bfffu4xbHy+/PJL++OPP6LKIN0QdE23a9fOdtllF2vbtq0LdMdLcnJy3MdQVlYW9XHr3bu3bbnllta6dWu37LjjjrPPPvvM/eEgVuUVFbZo9WrzMtJtux13tOz1GPQFAAAAAKCxqJcA4E477WRffPGF+/mAAw5w5cA33XSTnXLKKe6x2mj+wFdeeWWt5a+99poddNBB9THEhKdGKttuu60LtioD7KyzzrLCwsK1MuCUodatWzfLysqyww8/3FavXm0TJ050Za/NmjWzc8891yoqKqpse9WqVXbssce6rE0FcO+6664qjysQt8cee7jy7q233to++OCDtcanjK6uXbu61+3SpYtdffXVVYJEP/74o+25556uzFvl3QoKTZkypdr9ffbZZ10AOLQTdHXbmDx5sp188smWn5/vSmN1u/baa91zFi9e7K6hzMxMN0flU089VacsPB03NbjRtnUsqysl7tWrV/C1Res//PDDdsghh7hjo0CYmuWEmjFjhnvfaJ+0b7vvvrsLnGk7Ond6H/j7pX2NVAL8ySefWL9+/VyGnQKVV1xxhZWXlwcfHzBggMusVValypgVQAwdZ230evfff78NGTLEXYM33nijW/7GG2+486DzpPN+3XXXBV9Xx0fTATz++OPu+TqOosw9BVKV8RuLu04/zW488QTLbdXacjptYjvvP8ha/V9QEQAAAAAAVC+lvoJTfjBKQQX9/Nxzz9kWW2zhSgBrs9VWW7mAoYIbO++8s1v29ddfu6Cigonjx48PrqsgxsZIZbA6DgqqzJkzxwUAFcy59957g+usWbPGraPgmYJ6hx56qLspMPj222/bn3/+aYcddpjttttudtRRRwWfd+utt9qIESPcuXvvvffswgsvdHPvae42zb+nbbRs2dKdE2VkqjlLOAWuFIRUAHH69Ol22mmnuWUao5/1tf3229t9993nMtgUvEpNTa12fz/99FM75phjqiyrbhsKJikQd80117gmNKJgpijopPkoNZ+g5ovT9aOgYCito6Carj+fAlYTJkxwj9155522+eab24MPPmjfffede+1YKCg2ZswYd5wVXNV+/PXXXy4Q988//7jgqgJ0GqOCgLruFURTqayy5HTMNRbRc/79998q29c2NF+mxqpg26+//uqOv4JyoUE+BRMvuugi++abb+yrr75y6++6667uPEdj5MiRwXJ9HQNdK8cff7y75vygpeZJ9NfVsTrxxBPdPukYKgjrU7BSWYCxWGEBS09Ns4zWzWy3vfe27fv2jflcAAAAAACwUfIagE033TSq22abbeY1VsOGDfOGDBkS9frPP/+816JFi+D9CRMmeDqds2bNCi4744wzvKysLG/VqlXBZQMHDnTLfZ07d/YGDRpUZdtHHXWUt//++7uf33vvPS85OdmbP39+8PF33nnHvdYrr7xS7fjGjBnj9e7dO3g/JyfHe+yxx6Lev7y8PO/xxx+vsqymbWj/9ZxQv/32mxvn119/HVz2yy+/uGXjxo0LLrviiiu8E044ocpzu3Xr5r388svB+1pfxyqU7oduR3r27OmNHDkyeF+vddVVVwXvFxYWeoFAwB1DGT58uLuuS0tLo74u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NdU2b9PGfp0/34qKi23NqlUEAAEAAAAAWN8BwJSUFJclpDJNAIknJyfH3Ro6P1W5eVqatW/RwgJlZZa/fLl1irHxCgAAAAAAG5t66QKsbqPqiLp8+fL62BwArKW8stIqKistv6jIslNSLCMz00qKijhSAAAAAABsiCYg48ePt1mzZln79u1dNmB2dnaVxzUvIACsq6SkJPOSkm3h8uVW4nkNqkQZAAAAAIBGHQAcOnRofWwGAKqVouCffvAqLSU52QqLiy2QUi8fYQAAAAAANGr18u1Z3Xrrk+YTnD59ussmbNasWb1uG0BiCvyvbbllpKZaRlq6VZaXW1JycryHBQAAAADAxjEH4Lq64IIL7JFHHgkG//r372877LCDderUySZPnhzv4QFoKAIBW15UZIvz861FTo7l5uXFe0QAAAAAADR4DSIA+OKLL1rPnj3dz2+88YbNmTPHfv31VxcYvPLKK+M9PAANQKXnWVFZmS1cscLat2huaRkZrhEIAAAAAABIgADg0qVLrW3btu7nt99+24444gjr2rWrnXrqqa4UGAACgYAr/92qc2crLq+wysxMS6YJCAAAAAAAiREAbNOmjc2cOdOV/7777ru2zz77uOVr1qyxZOb4AhBiceFqm7ZokXXddRfLbNKEYwMAAAAAQC3WSwvNWJt4nHzyyXbkkUdau3btXJbPvvvu65Z/88031r179/UxRAAJ5t5TTjHzPPt2wb9W3rKlnXLGmZaRkRHvYQEAAAAAsHEEADVX37bbbutKdv0mHl9++aVlZWXZm2++aQMGDKjx+ddee6316NHD5s+f78p/09PT3XJl/11xxRX1MUQACa5AnwtpadasQwcbetxx1rpNG/cHAwAAAAAAULOA53meraOOHTvaq6++an369HH/P/vss23SpEn2+OOPu/9/8cUX6/oSADZSBQUFlpeXZytXrnT/BwAAAABgY/1unJ+fb7m5ufHJAKypicf48eMjPkfLTz/9dFfCV906vvPOO68+hgkggZHtBwAAAABA3aTUZxMPzeGnJh733ntvrU08xo0bZ8cdd5wLAOrnmr70EwAEAAAAAAAA4hgArEsTjzlz5kT8GQAAAAAAAEADCwDSxAMAAAAAAABoxE1AAGB9T3T6529/WectOlpSUhIHGwAAAACwUSmIVxMQmngA2JBuueBJu/GRs6xlu6Yc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e0yQmophIgO1zz77zFSusVLvzTffNPex3a677jrccccdJoxjezFYas6HH35owjsGU81ht18eJ1YCejye5O08Bl988YUJQj/55BOzHLc/Go2a+1lFFw6H8f7775vzhJWlDNGIbbD55puboJXr4LnAUI3tRAz+xowZY4Jju83YPZfBM02ZMsXcxuWIITKDu88//9x032U1I8PaRCKRdZ943Pic3Ea2ZSYGifa+s+s2l2cgyXZmsLjPPv90sX3iiSdM191LLrnE7AuD28xw76677sI555xjlmE78jXG1wSPZSqGvx988EHWbWZb1tbWpl3okqe/x4T/m4TLH/4Ap114lcI/ERERERERkVxZ3dAhhxxi7bLLLubfG264oXXYYYeZfz/77LMc+C253P77729tu+22aY897bTTrNVXXz15fdCgQdauu+6atsx9991n1vPbb78lb/vPf/5jBYNBq66uLnnbdtttZ25vzqRJk8x67MdMnDjRXK+qqmr2Mdwer9drFRQUJC833HBD8r7rrrsubfkRI0ZYEyZMSF7n+s8999zk9fr6esvhcFivvvqquX7WWWdZgwcPtiKRSKtta5s6dapZ79dff22un3322daqq65qJRKJ5DK33HKLVVhYaMXjcXN98803tzbZZJO09YwaNco644wzzL+vueYaa5VVVml2OzJxv4cMGdJie3k8HrOdfr/f+uijj8z9v/zyi7nNvk7z58+3AoGA9cQTT5jra621lnXBBRdkfd7zzjvPGjt2bNpt06dPN+ucMmVKcl9POOGEtGVyOdY0d+5cs9zkyZOz3v/ZZ5+Z+5955pkW1/PGG29YLpfLmjZtWvK2H374wTyW5yGNGTPGGj9+fNrjRo8ebc4h24ABA6xHHnkkbZmLLrrIPDbVSSedZG2xxRZZt4XnI58381Lz1/eWtfj8EBEREREREelOampqFv02rqlp1+O7bQWgjdVarE5iN81MrGDaeOON027jdVacpXbdZbfdTKw2Gzp0aPI6u02yi6ldGWbfltrFl2P1sQvmoEGDTBdLdoO1u2a2xWmnnWa629oXdl9tC3aBtbFqjNtibyfXxy6/qRVybcV2ZdVb6oQrbNf6+vq0aszU7SBWnNnbsddee6GpqclMasHqOXYnTe1CnInLsmqxpfZi5Ru73rKCza5c5LZy7MLRo0cnl2e3U3bt5n3E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ERFSACgi+acY8Lg9wKLevoaDqWACcLpccJWaQQA7cgtFREREREREOg0FgLJCrLTSSrj++uvb/Dh283zuueewPL3zzjtYbbXVkEj8M6FER+0zx6076qijUF5ebvb9m2++QUf5888/l/k2hMNhDBw4EF9++eVSrcfJdy7v4pmAF3NHXfB5g/AW+1DqLWVjLv0Gi4iIiIiIiHQBCgC7mUMPPRS77rprR29Gp3L66afjnHPOgdOkSi27//77UVrK8rLl47XXXjPP8dJLL2HWrFlYc8010VHnxYABA5b5Nvh8Ppx66qk444wzlmo9LqcL8doE4GFf4EXFfoU9gvD5vHDVu1Be1gM+r38ZbbWIiIiIiIhIflMAKN3axx9/jF9//RV77bUXOoPff/8dffr0wUYbbYTevXvD7XZ32La4XK7lsg0HHHAAPvjgA/z000/tXkevVSoRqY/BmhtD5b4VGHbYYKAOsBosBEI+7D92f/h9CgBFRERERERESAGgpLn22mux1lproaCgwFSAHXPMMaivr1+iAo4VaquuuiqCwSD23HNPNDQ04IEHHjDdXsvKynDcccchHo+nrbuurg77778/CgsL0bdvX9x0001p9zOI22yzzeD3+7H66qvjzTffXOLosHJslVVWMc87ZMgQnHfeeYhG/xkI7ttvv8WWW26JoqIiFBcXY7311sMXX3zR7FF+7LHHMHbsWPOcra3j3Xffxb///W/U1NQsmoHW4cAFF1xgHjN37lzstNNOCAQCGDx4MB5++OF2VeGx3aZNm2bWzbZsrivxyJEjk89NXP7uu+/GbrvtZtpm5ZVXxgsvvJD2mB9++AH/+te/zD5x3zbddFMTOHI9PHbPP/98cr+4r9m6AL/33nvYYIMNTCUfg8ozzzwTsVgsef8WW2yB448/3lRVshszA8TU7aSKigoTcD766KNor1XGDENRQTHQ5AIaHAjGggjEClFmVWCzVbfCSeNPNtsuIiIiIiIiIkDHlRdJp8RusDfeeKMJnaZOnWoCQIY5t956a3KZxsZGswzDM4Z6u+++u7kwGHzllVfwxx9/YI899sAmm2yCffbZJ/m4q666CmeffbYJhF5//XWcdNJJZuy9bbfd1oy/x3X06NEDn376KWpra3HiiScusX0MrhhCMkCcPHkyjjzySHMbt9GuLltnnXVw2223mQo2hlcej6fZ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C7d18803N128uQ6enwzVGK4Rg78xY8aYoJXL8sKA1a4W5TnB27gcMXRlcPf555+b/WY1I4PkRCKxVK8J7hODVC7PQJJtyWBxn332SS77xBNPmK67l1xyidmXPn36LBHu3XXXXeYc5DJsx0svvdQc1wceeCBtuQ022AAffPAB2iIRi+d0KSooxB4jt0NFeTmizhg8Q8vgWbUCq+2xLk6+6mwTbIuIiIiIiIh0K1YX8tlnn7G3n/XMM8+0+bF83NSpU3NaduLEidagQYOavX/llVe2LrnkkrTbPvroI/Mcf//9d/K26upqq6CgwHK73ZbP57PuueeeFp93rbXWsi644IJmt4nrf+utt5K3vfzyy+a2pqamZte5+uqrWzfddFPyOvdr1113TVvmoIMOso466qi02z744APL6XSadU+ZMsU8z6effpq8/6effjK3XXfddVYuuOz48ePTbhs9erR19NFHm3/z2HCZr7/+Om2ZQw45xOrVq5cVDodbXD+3Y8iQIUvczv31er3mOHg8HvMcfr/fHC/65ZdfzG32dZo/f74VCASsJ554otXjct5551ljx45Nu2369OlmnWw32nzzza0TTjgh6/Gsqqpqcb/mzp1rlps8efJSvSbeeOMNy+VyWdOmTUve9sMPP5jHTpo0yVwfM2ZM1mM0YsSI5PUBAwZYjzzySNoyF110kXlsqpNOOsnaYostsm5LKBSyampqkhe7veb8NsNqmlPb5ksinmhx30VEREREREQ6O/4+5m9j/rc9ulQFoD1xQy7je7EbJ6u07AuxW2TmbbbU2/lYVs1l3pYqcxuybRu7UXJSC1ZzsWKKlV2sQGsOu92ye+7GG29sKrFYjZeJ3VdtrNAiuxKP1WOnn346Vl99dVP5xe3++eefl6gAZBfiVKwEvP/++9P2lxWBrDrjeIes9GK1Yerj2PWzrRWXrITLvG5XALaEXUq93iUng0jV1NRkuqRmc9ppp5njwMo3dr1lBRu7T5O9b6NHj04uz663q666anLbWjoubLuJEyemtR3bhlrrupsNH7P//vubyTzYTdfuGp15DNv6muC+sPKQF5t9ntj7yf9mO0a2efPmYfr06aZrcOr+sm0y95XdvBsbG7NuC7tzs0rPvtjb5HV62nURERERERER6e7c6EJWXnllE3QwqGB3xpbcfffdJhRKfSzHbevXr1/W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ERFpI4Z3nJwjHomYyTlMSOf1IrDSSibAi4dC/9zeTHjH68lJPjKW5xiBXSnsWx4UAIpIXnD37Qt3O/7KISIiIiIiIh3P08ztnPnXnrSjNZmTfEju1J9ORERERERERESkC1MAKCIiIiIiIiIi0oUpABQREREREREREenCNAagiHRq9kTlnPFIREREREREpDuqXfyb2P6N3FYKAEWkU1uwYIH574ABAzp6U0REREREREQ6VF1dHUpKStr8OAWAItKplZeXm/9OmzatXW9y0r6/LDFwnT59Ooo18/Jyp/Ze8dTmavOuTue42ryr0zmuNu/qdI5LNqz8Y/jXt29ftIcCQBHp1JzORUOVMvxTGLVisb3V5mrvrkznuNq8q9M5rjbv6nSOq827Op3jkmlpimI0CYiIiIiIiIiIiEgXpgBQRERERERERESkC1MAKCKdms/nw4QJE8x/RW3eFekcV5t3BzrP1d5dnc5xtXdXp3Nc7S35z2G1d/5gERERERERERER6fRUASgiIiIiIiIiItKFKQAUERERERERERHpwhQAioiIiIiIiIiIdGEKAEVERERERERERLowBYAi0qndeuutGDx4MPx+P9Zbbz188MEHHb1JndJll10Gh8OBE088MXkb53i64IIL0LdvXwQCAWyxxRb44Ycfkvf/+eef5jHZLk8++WSzz8V1Zi7fu3fvtGXq6+tx7LHHon///ua5hw8fjttuuw35LBaL4dxzzzXnI/dpyJAh+N///odEIpFc5plnnsF2222HHj16mHb55ptvllgPj0Nm++27774tPvf777+PnXbayRxLLv/cc89lXe6nn37CzjvvjJKSEhQVFWHDDTfEtGnTkC9a2s9oNIozzjgDa621FgoKCswyBx98MP7+++/kMgsXLsRxxx2HVVddFcFgEAMHDsTxxx+PmpqatPP+8MMPTx7HoUOHmpnGI5FIi9vW3GvlqquuSi7zn//8x6yP6+3Zsyd22WUX/Pzzz+iscjmvWjunctnnqqoqHHTQQWYdvPDf1dXVLW4b32dWW201c6zLysqwzTbb4LPPPktb5s477zSvp+LiYrP9ra2zM7xPjxo1yrRjZWUldt11V0yZMiVtmdbet3Np83fffbfZ8/Xzzz9vdvtyed/+/fffsdtuu2lf67QAACEmSURBVJnnZbvvvffemDNnDvK5zTPblu10/fXXZ72fx2eHHXbI+npZaaWVlmjvM888M+dtzfbc7f2c7sztnct5lsvnJN+X+B7P74d9+vQx7yupnwfZ5PL6as9ndEdi26299trm9cjLmDFj8Oqrr+b8uWn75JNPsNVWW5nlSktLTTs0NTUt1ft4a58huXxm51N7t+W7WGvt/csvv5j3dn6f5PNsvPHGmDhxYrPbleuxDofDps25Xi7H7ZwxY8Yyax/p/BQAikin9fjjj5tA65xzzsHXX3+NTTfd1HzxzqdAY0XgDzr+EOYXklRXXnklrr32Wtx8881mGYZ02267Lerq6sz9AwYMwKxZs9IuF154oflCwHZuyRprrJH2uMmTJ6fdf9JJJ+G1117D//3f/5kvQrzOLxzPP/888tUVV1yB22+/3bQn94nty/DnpptuSi7T0NBgvqRdfvnlLa7ryCOPTGu/O+64o8Xlud4RI0aY524Of5hvsskmJjRhAPDtt9/ivPPOMz+O8kVL+9nY2IivvvrK7BP/y7CVX5D55dXGL7q8XH311eacvP/++815yMDPxqCEoS3bnD/8rrvuOnNczz777Ba3LfO1cu+995ofhnvssUdyGf6R4r777jPnx+uvv25+bI4dOxbxeBydUWvnVS7nVC77vP/++5swnMeCF/6bPx5bssoqq5jt4nH88MMPTbjC9c6bNy/tnNh+++1bPXadxXvvvYf//ve/+PTTT/Hmm2+aPypwn3gccn3fzqXNN9pooyXO1yOOOMK04frrr9/s9rX2vs3t5PPwvH/nnXfw0UcfmeCcIXLqH0Lyrc1tDPQYMvOHc3MYznH/m8M/CqW2O/9olIvmnntpPqc7a3vn+v2gtc/JLbfcEk888YQJGJ9++mnzfrXnnnu2uH25vL5yee7OhEEqv3N88cUX5sJQicERP99y+dy0wyi+l/JYTZo0ybQNQ1qn07lU7+OtfYbk8pmdT+2d6+dmLu39r3/9y7x++F775ZdfYuTIkRg3bhxmz56ddbtyPdb8XfXss8/iscceM5+tDOS53s76PUWWA0tEpJPaYIMNrPHjx6fdttpqq1lnnnlmh21TZ1NXV2etvPLK1ptvvmltvvnm1gknnGBuTyQSVu/eva3LL788uWwoFLJKSkqs22+/vdn1jRw50jrssMNafM4JEyZYI0aMaHGZNdZYw/rf//6Xdtu6665rnXvuuVa++te//rVE2+y+++7WgQceuMSyU6dOtfgR+/XXXy9xX+pxag+u99lnn13i9n322SfrtuSr5vYz1aRJk8xyf/31V7PLPPHEE5bX67Wi0Wizy1x55ZXW4MGD27R9u+yyi7XVVlu1uMy3335rtu+3336z8rG923NOZe7zjz/+aK5/+umnyWU++eQTc9vPP/+c83pramrMY956660l7ps4caK5r6qqysonc+fONdv93nvvLdX7dmvnWSQSsSorK5d4T27r+/brr79uOZ1OcyxsCxcuNM/Nz6B8bHPbjBkzrH79+lnff/+9NWjQIOu6665b4rHffPON1b9/f2vWrFlZXy/NPa41uTx3Wz+nO3N75/L9oD2fk88//7zlcDjM+Z5Nrq+vpf2M7gzKysqsu+++O+fPzdGjR7f4/ay97+Pt+QzJ5TO7M7d3LvvcWnvPmzfPtO3777+fvK22trbZz8DmZB7r6upqy+PxWI899lhymZkzZ5r39ddeey3n9Up+UwWgiHRKrCrgX7z417FUvP7xxx932HZ1NvxLO/9KyO5xqaZOnWr+Spjafj6fD5tvvnmz7cf25l90c/nL66+//moqFdiNkl1j/vjjj7T7+dfPF154ATNnzjTVKey2wL9EsntsvuI+vf3222Y/iH/V5V9Pd9xxxzav6+GHHzbdL1hJeeqppy5RfdBWrL55+eWXTdUU25hdr0aPHt1sV+Gugt2EWI3D7jMtLcPuM263u8VlysvLc35ednlke7f0WmHFC6u0+BphFU++ac85lW2fWenAblB8rI3doXhbru/l/DxglTMfw4rFrsLu5mafe+15387lPON78fz583HooYe2uD2tvW+z6xhfb9wmG6taWLXC98J8bHP7XGcl02mnnWbek5urrtlvv/1M5VjmkBeZleIVFRWmWueSSy5pdWiBXJ67vZ/TnbW9c/1+0JbPSXYl5fKsfvV4PFmXacvra1l/Rq8orOJiZRffF9g1NZfPzblz55rqU77Hs/169epl2iT1Nd2e9/H2fi/J5TO7s7Z3LvucS3vzPYRd4x988EGzblYCsgqVy7ICPFeZx5rvH+wqnPoa4Hf5NddcU7+tupOOTiBFRLLhX6T4FvXRRx+l3X7JJZdYq6yyihrNsqxHH33UWnPNNa2mpqYl/mrNdmP7sR1THXnkkdbYsWOztt/RRx9tDR8+vNW2feWVV6yn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ynOMf+Rid9zMPx629X08l8+QXD6z86m92/JdrLX2ZgjNyWl4LrK9OckNJ+Frrr1zPdb8fGUXfa6X32cY4vK8l+7Dwf/X0VWIIiIiIiIiIiIisnxoDEAREREREREREZEuTAGgiIiIiIiIiIhIF6YAUEREREREREREpAtTACgiIiIiIiIiItKFKQAUERERERERERHpwhQAioiIiIiIiIiIdGEKAEVERERERERERLowBYAiIiIi0iW9++67cDgcqK6ubnYZ3v/cc89hRbvgggswcuTIFf68+WBFtM1KK62E66+/Hl25Lf78809zfn/zzTfLfLtERCT/KAAUERERkW5r1qxZ2GGHHVb485566ql4++23V/jzSn7pDOfJFltsgRNPPLHN4bqIiHQu7o7eABERERGR5liWhXg8Drd7+Xxt7d27d4c0fmFhobm0VzQahcfjWabbJB0nEonA6/Uu8/Oku7++RUTkH6oAFBEREemCWLVz3HHHmcqdsrIy9OrVC3feeScaGhrw73//G0VFRRg6dCheffXVtMf9+OOP2HHHHU3owMccdNBBmD9/fvL+1157DZtssglKS0tRUVGBcePG4ffff08LMo499lj06dMHfr/fdLW87LLLmu2SyAoi3saKotTKotdffx3rr78+fD4fPvjgAxMUXHnllRgyZAgCgQBGjBiBp556Km3bX3nlFayyyirm/i233NI8X2tSuwDb2/fMM8+YxweDQfM8n3zySavruOOOO0xb8DHDhw83j/ntt9/McSgoKMCYMWPS2ilb1857770Xa6yxhtlnth/bMfU5br/9duyyyy5mfRdffLG5/bbbbjPHkeHRqquuioceeihtnXyegQMHmnX27dsXxx9/fNqxOv3009GvXz+zztGjRyePg+2jjz7C5ptvbvaL59F2222Hqqoqc184HDbrq6ysNMea58Xnn3+efKx9LFnBxmPJdWy00UaYMmVK2nNcfvnl5lzjOXn44YcjFAql3c/1bLDBBmYbed5tvPHG+Ouvv7AsTZs2zbQtz/vi4mLsvffemDNnjrmvpqYGLpcLX375pbnOc7G8vByjRo1KPv7RRx81x8w2c+ZM7LPPPqbN+DrhulPPx0MPPRS77rqreW3wuPC8zSbzPGlPW/z888+m3XmMeH5lHuOWXvPczvfeew833HCDOZa8cD/4+iDuH2/jcnbbtPQ6be71LSIiy58CQBEREZEu6oEHHkCPHj0wadIkEwYeffTR2GuvvUwY8NVXX5kwhz/2Gxsbk91hGfYwcPjiiy9M2McQhGGIjQHiySefbIIeBjtOpxO77bYbEomEuf/GG2/ECy+8gCeeeMIEPf/3f/9nQsC2YjDFcOSnn37C2muvjXPPPRf33XefCbx++OEHnHTSSTjwwANNOEHTp0/H7rvvboIMBoxHHHEEzjzzzHa12znnnGO6XnI9DGb2228/xGKxFh9z0UUX4eCDDzaPWW211bD//vvjP//5D8466yzTlpQa6GXifv33v//FUUcdhcmTJ5s2HDZsWNoyEyZMMEES7z/ssMPw7LPP4oQTTsApp5yC77//3jwfw92JEyea5Rm8XHfddSac/PXXX03QudZaayXXx2UZ8D322GP47rvvzLmx/fbbm2WJ+7L11lub0IiB5ocffoiddtrJVGzZx+jpp5825xnPJ24vz6mFCxcu0Z7XXHONaQdWenHbbTxPuF+XXHKJuZ8h2q233pq8n+3OoIznJbeR28E2Yoi0rDC04nNwu3k+vfnmmyasZYBHJSUl5jVhB2fcDvu/tbW15t+8j9tIfD0xIGOg9v7775t247/ZtgxdbXz98Pzm87300kutbmd72+K0004z58jXX39tXvs777wzFixYkNNrnsEfw+sjjzzSLMvLgAEDzHEnvsZ5G5ej1l6nzb2+RURkBbBEREREpMvZfPPNrU022SR5PRaLWQUFBdZBBx2UvG3WrFkWvw5+8skn5vp5551njR07Nm0906dPN8tMmTIl6/PMnTvX3D958mRz/bjjjrO22morK5FILLHs1KlTzbJff/118raqqipz28SJE811/pfXn3vuueQy9fX1lt/vtz7++OO09R1++OHWfvvtZ/591llnWcOHD0973jPOOMOsi8/RHN7/7LPPpm3f3Xffnbz/hx9+MLf99NNPLa7j3HPPTV5ne/K2e+65J3nbo48+avbBNmHCBGvEiBHJ63379rXOOeecFp/jxBNPTLtto402so488si02/baay9rxx13NP++5pprrFVWWcWKRCJLrO+3336zHA6HNXPmzLTbt956a9OWxLbdeOONs24Pj4nH47Eefvjh5G18Hu7HlVdemXYs33rrreQyL7/8srmtqanJXB8zZow1fvz4tHWPHj062TYLFiwwy7/77rvWsjRo0CDruuuuM/9+4403LJfLZU2bNm2J4z5p0iRz/eSTT7bGjRtn/n399ddbe+65p7Xuuuua/SG282233Wb+zeO+6qqrpp2L4XDYCgQC1uuvv26uH3LIIVavXr3M7S1JPU/a2hb2+Xz55Zcnb4tGo1b//v2tK664IufXPN9LTjjhhLRl7GOb+trK5XWa7fUtIiIrhioARURERLqo1MoadmFkV8TUCjB296O5c+ea/7KLI6vH7HHHeGE1G9ndV/lfVrexix+7Sg4ePDjZhZLYFZCVY+yOyu6hb7zxRru2nd0DU7soslvotttum7ZtDz74YHK7WEm04YYbplVDsXJpadvN7tZpt1Euj7HbNbOtuQ92xVgqrvvvv/821Xa5tom9z+wCmorXeTuxoq+pqckcK1ZwsWLQrmRkxR5zRVY4prYpK7XsNrUrALPhMhyHMPX5OSYhu6faz59Le3LZzOOUep1dbXlOsbKQ1YesNGPFWXM4oYu9L6xczAW3gVVtvNhWX31108XW3hd25WZXVVa6so14nRf+e/bs2fjll1+SFYB8HbH7N7s029vC/eDxT+0GzvMj27h/zWlrW2RrT1Zg8jyy9yuX13yucnmdNncui4jI8qfRVkVERES6qMxJIhiOpd5mh2V2913+l8HCFVdcscS67OCG9zMoueuuu8zYZXzMmmuumezauO6662Lq1KlmbMG33nrLdCXcZpttTHdUdhemRQVtizBEyoZjnNns7Xv55ZfNeHWpOIZY5jqXVktt1JbH5LoejpWWi9Q2yVyvje1g38bjxC6a7GLKY3HMMcfgqquuMqEVt8Me147/TWVPOtHSdtnt3dLzL017pmKXUobJ7J76+OOPm26m3CcGvpnuvvtuE3pmPm9Lsm1z5u2bbbYZ6urqTHDKIJBdvtm+l156qek+y3EQOfajvW/rrbceHn744SXW2bNnzxaP57Jsi5akHofWXvO5yuV1ujT7LiIiS0cVgCIiIiKSDO84bhfH7ON4bqkX/mDnuGGsHGLowMowBh72hBCpWBnI8dMYEjKk4HhhHF/NDj9Sq5ZSJwRpDquxGCCwyjBzu+yqLS7z6aefpj0u83pnxUoxtjnHhGsLtj/Hl0v18ccfJ4MoO8TjmG8cm5Hj1HHcOI4huM4665ix/FiJl9mm9szIrNxrbpu4HKvXUp+fYS7HkUt9/lz2IZfjxu3leIrcPwbOjzzySNb1MXiy92PQoEE5bQPPHZ5bHEcytZqNk3/Y+2KPA3jzzTeb8IyP2XTTTc24ehy/z67+s19HHEeRoWBm23I9SyvXtsjWnqwAZehrV/m19ponHmd73EebXbmYensur1MREek4CgBFRERExOAkFAzqOOkFJw75448/TBdeTtrAH/r2jKacTZhdHN955x0zIUgqTjrBSSU48yi7RT755JMmUGJ3SoZRrFTirK8MWDhBAsPEXAIyTsrBCQU44QS7EzJ4ueWWW8x1Gj9+vLmd28OqN4Yi999/f94cWc72yokyGNQxPGKl2U033dTq5A7cR84OzMdce+21ZgZjthXxvnvuucdMEMJjyRmCeQwYjLHr7wEHHGAmLuFjWLXJiV1YCcbZlIkhE29j5SAnneAx5eQOnCGW4RAnleE2sBqNx5PdjDkBBmfyzRUnMeHsx7zwfOGEIAykbNwubgeDS852y/ORy7UlZGwNK1QZdrI92O4899kuDPVSu6qyyy8nteHtDAH5emDoxZCb99m4Hk6+wwlbWC3IfWDVJfd1xowZ7d7O9rYFXyfs/s3jx9c4Q3t7IpbWXvPEcPCzzz4zs//y2LPSj+cQ24Dh57x581BfX5/T61RERDqOAkARERERMdill7PC8oc/xxljdRFDC1YtsfsuLwz3WEHE+/hDn11KM7uPMkRicDJq1CgTGjBQsrv/MuhhpRjv57ovvvjinFqfXS7PP/98M3MoAw9u34svvpgcg3DgwIGm0pC3jRgxwoRi7J6ZLw455BBcf/31ZgZcjl03bty45Gy8zeGMsBwHjseAj+Fsv+wiaodRDF1Zhclx+uxqPrYPQ1zisgy6OEMsx2xkpSCDHrtaiyEhw6Bvv/3WjO3HseSef/55M44cMcjdY489zEzSrCRjKPz666+bYCxXrBTlcT3jjDNMt1kGWwwWbcFg0ARXfB5uD2e95WzKnPF4WWGQxRmSud3s6stAkOMmMthLxZl9+dpIDfsYBvK21ApAbjPDbZ6TnJma5ysDNXZNZnVse7W3LXic+Jrk64KBJI8hA8pcXvPEUI/dxBl2soqXFX6stLzwwgvNTNsc39Ke4bq116mIiHQcB2cC6cDnFxERERERERERkeVIFYAiIiIiIiIiIiJdmAJAERERERERERGRLkwBoIiIiIiIiIiISBemAFBERERERERERKQLUwAoIiIiIiIiIiLShSkAFBERERERERER6cIUAIqIiIiIiIiIiHRhCgBFRERERERERES6MAWAIiIiIiIiIiIiXZgCQBERERERERERkS5MAaCIiIiIiIiIiEgXpgBQRERERERERESkC1MAKCIiIiIiIiIi0oUpABQREREREREREenCFACKiIiIiIiIiIh0YQoARUREREREREREujAFgCIiIiIiIiIiIl2YAkAREREREREREZEuTAGgiIiIiIiIiIhIF6YAUEREREREREREpAtTACgiIiIiIiIiItKFKQAUERERERERERHpwhQAioiIiIiIiIiIdGEKAEVERERERERERLowBYAiIiIiIiIiIiJdmAJAERERERERERGRLkwBoIiIiIiIiIiISBemAFBERERERERERKQLUwAoIiIiIiIiIiLShSkAFBERERERERER6cIUAIqIiIiIiIiIiKDr+n+67i7N9kGbMgAAAABJRU5ErkJggg==" width="854"></p>
   <p><img height="480" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABQAAAALQCAYAAADPfd1WAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjgsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvwVt1zgAAAAlwSFlzAAAPYQAAD2EBqD+naQABAABJREFUeJzs3Qd4FGX39/GTHhIIvYMoIFUFRRQUxQ5iARXsir33QhPEiohix66oiB2xdwEVKyp2RFAEFJBOAqRn3ut3P+/sf7JsyoZA2PD9XNc+ZGd3Z++5Z7I+e3LOfeI8z/MMAAAAAAAAQLUUX9UDAAAAAAAAALDlEAAEAAAAAAAAqjECgAAAAAAAAEA1RgAQAAAAAAAAqMYIAAIAAAAAAADVGAFAAAAAAAAAoBojAAgAAAAAAABUYwQAAQAAAAAAgGqMACAAAAAAAABQjREABAAAAAAAAKoxAoAAAAAAAABANUYAEAAAAAAAAKjGCAACAAAAAAAA1RgBQAAAAAAAAKAaIwAIAACAqD311FMWFxdn3377bbHtK1eutD333NNq1qxpH3744Rab2XfeecduuOGGiI9pXJdccslm7f+///6zYcOG2a677uqOJTU11XbeeWe7/PLLbd68eaHnaQx6v+pIx1We24wZMzb7vTZu3OjmsjL2FckBBxzgxtq6dWvzPG+Txz/99NPQ8ejari7+/vvvTc5XRkaGdenSxe655x4rLCys6iECALaSxK31RgAAAKje/vnnHzv00ENd8Oyjjz6yHj16bNEA4IQJE0oMAm6Ob775xo488kgXKFIgsWfPnpacnGxz5861Z5991vbaay9bs2aNVXdffvllsfs333yzTZ8+3aZNm1Zse6dOnSolAHjjjTeGgnVbQq1atWzBggVu/AcffHCxx5588kkXGMvMzLTq6NJLL7WTTz7Z/bx27Vp744037Morr7TFixfb+PHjq3p4AICtgAAgAAAANpuy4g455BDLz8+3Tz75xGXOxSIFgPr37+8y/r744gtr0aJF6DEFps4//3x75ZVXLBYoqJaWllbh14cHcBs2bGjx8fFbNLC7Je2www4uCKhgXzAAmJWVZS+//LKdcsop9thjj1msyc7OdtdraZmoOvbgeevbt6/98ssv9vzzzxMABIDtBCXAAAAA2Cw//PCD9erVyxITE23mzJmbBP/OOOMMV0Y7f/5869evn/u5ZcuWdvXVV1tubm7oeSr/jFRS6pcx+qWZ2p+y/yRY2qjnBU2aNMk6duzogmAqeXzrrbfKPBYFgJYtW2bjxo0rFvwLGjhwYKn7KCoqcq/v0KGDpaSkWKNGjez00093GZJBs2fPdpmGelzPa9asmR1xxBGh54Ufd5C2B7Mf/VLk77//3o2vbt261qZNG/eYMhkffPBB69q1q9WoUcM9puf89ddftrny8vLslltuCR2rgoRnnnmmrVixotjzlHWnAGr9+vXdGBSQOu6441yQUsep14myAP3zqfNc2c466yx79dVXXRac74UXXnD/nnjiiZs8X9esjkfl37qOmjdvbkcddZT9/PPPxZ7nX7sKqF133XXuXCqjUEFxZY6Wh353FJhUkFLvtc8++9jbb78dsfT+gw8+cMeiedNzg79H5VW7dm1LSkqK+tpVJqh+15U9GE5j0jnOycmJejwAgC2LACAAAAAqTEELBXYUKNDPWmMtEmUGHn300S7A8frrr7tAwd13322333571O85atSoUBBOZar+rWnTpqHnKHDywAMP2E033WRTpkyxevXq2THHHFNm0EuBlYSEBBfkqagLL7zQhg4d6sqhVWqpgMl7773nAjpaI1E2bNgQKpdWMFPrJWpNNgXGlJFWUccee6y1bdvWZbQ9/PDDbpuyFq+44goXjHrttddcMPDXX39149H7V5SCRcqWHDt2rCsv1ZzrZx2LrgllpokCfApsqoxa2XeaCz0vPT3dBRB13rRNzj777ND51HmubAry6fwqUOd74okn3PWkgF24JUuWuICWxqsx6lwp+LX33ntHDOyNGDHCFi5caI8//rg9+uijLjNW11JZa+0pa/aggw6ydevWufFofAoE6rUvvvjiJs/X74+CdwpyKyM1PJAX6VwVFBS426pVq0Ln4bTTTov62tX1pDl45JFHir129erVLpiqc6iMRADANsYDAAAAojRx4kR1UnC32rVre8uXLy/xuYMHD3bPe+mll4pt79evn9e+ffvQ/enTp7vn6d+gBQsWuO16T9/FF1/stkWi7Y0bN/YyMzND25YtW+bFx8d7t912W6nH1aFDB69JkyZeeY0ePbrYOObMmePuX3TRRcWe9/XXX7vtI0aMcPe//fZbd/+1114rcd+Rjjt4jHrv8HFcf/31xZ735Zdfuu3jx48vtn3x4sVejRo1vCFDhpT7WHUe09PTQ/eff/55t+8pU6YUe96sWbPc9gcffNDdf+WVV9z9H374ocR9r1ixYpNjqky9e/f2OnfuHDqOPffc0/3866+/uvedMWNGaNyR5ttXUFDg5eXleTvvvLN35ZVXbnLt6poO0jWv7ToPpenRo4fXqFEjLysrq9h77bLLLl6LFi28oqKiYr93p59+ermO27+GIt3OOOMM9x7RXrv+HGq8ubm5oW233367+x3TewIAtj1kAAIAAKDClNWnrCVlmJWW5aSyxfCsut12281lS20JBx54oMug8jVu3NhlKW6p9/OpSYaEl6+qcYjKkT/++GN3X1l6KsVVtpUy9X777bdKeX+V1Qap7Flzf+qpp4YywHRr0qSJK4venK672nedOnXceQ3uW6XG2r+/b91X9t95551nTz/9dKWUHutaC76nMtzKS9lz6l6tMl5l26lUev/994/4XO17zJgxrtGJjkGZb/pXmX1z5syJ+PsQfo1LadedskG//vprl4Wo8nifMhWVoafy2/Bsw/DzXBZ1r541a5a76RrVMb300kt20kknRX3t+vtbvny5yzQVzf9DDz3kMj133HHHqMYGANg6CAACAACgwlSmef3119tzzz3ngkwlBQG1Tll4WaDWGNtSa4WpbDOc3s8vSy2JSnC1fp2CMhWh8koJliP7tC6c/7jWX1PZp4JjKhvt3Lmze3z06NGuXLqiwt9XJb5KGFQAVGWiwdtXX30VKuusCO1ba+kpIBa+b62j6O9bATZ1hVYA9uKLL3b3dbv33nsr/N56ffD9VOpdXgr2aU0/lbCqhFYBwZIaaFx11VXuGh8wYIC9+eabLlCnIJqCp5GupfDrTteclHbdqaO0zlFJ14z4140v0nNLo/Us99xzT3dTefbw4cPdcSmA9/7770d17cruu+9u++23X2gtTgWDVeqtrtkAgG0TXYABAACwWfzGDfpXmUCTJ092mVLR8gOE4Q0NNidIFa0+ffq4dQAV7InUFKIsfgBo6dKlmzQR0XpyDRo0CN1XsxStmabgz08//eQaPCiQpSYZw4YNK3E+woNBQeGBLL2ftn322WehYFRQpG3lpX3reP31+8IFMzAVLNJNAWJl391///0ua1SByYrMs85PcF78QFl5qbHHyJEj3dwMHjy4xOc9++yzrgmGMubCr0llP1YGZYKqu7KumXC6ZiR43UhpHX/Ly89O/PHHH911H821K5dddpkNGjTINZ7Repvt2rVzawcCALZNZAACAABgs6kLrQKAKitUQwiVTkbLLx1UMCxIzQjClSezqiLUwEDlq0OGDLF///034nPURbYkauTgB46ClDWmklE1QQmnYI4yytQURUElBVREwTEFAcPnQ01UyktdhhVg1LH4GWDBW3jH5mho3wpGKqgXad/t27ff5DUqa1UDDT9zzD/WaM+nxh18r2gDgAr6qXT52muvdZ19S6JzEx4kVbOTkq6NilAzFM2Jrqvg8SuYrutIwTgF17ZE925RZmZFrl011VHGrLp5K8PzoosuqpTAJABgyyADEAAAAJVCpcDKZFJpoYJO6mQaTSagAm/qVHvbbbe5rKhWrVq5dcciBdz8wJW6CB9++OEusKSMJpWjbg6V5irApuCWyhxV0tizZ8/Qum8KjihjSt12I1HQS2vdKcNNc6GxqTRSc9KyZUu78sorQyWT6sar0lJ1TtZ86ThVUutnUflr96ljq0peFST85ptvXLl1ee27775uPMp4U+adyl8VcFKWl7o2ax7V+bUilLmnbM9+/fq5NeG0VpzKcbVmndaTU4dgBYm0xuG0adPc+nAKGKnsW8ckOt9+tqDOt+ZegSZ1bVbG2ZZaT04BQ3VELouuA2VmdujQwV1f3333nd1xxx2bZMhtLl3zOu9au/Kaa65x15uuj19++cX9Hm1uYG3RokWu5FtU3q4uy3pPzbl/LZf32vXpd04l3VrHUtdU+NqBAIBtCwFAAAAAVBqVVSp4cN1117kMJpW4RkNrsl166aUuqKDMMmVpKQCiLK8gZRl+/vnnLkiislkF0BYsWFApASMFstQgQhl5ymhUkFFjURBEwSmVO5ZGzRAUsFODCWW6KajYt29fF3Dxyyy1Bp2y/caNG+fKKxXwUQBGwaZgSer48ePdv3re+vXrXZaWgofRHKfWuuvRo4f7V/Ol86IAmIKDOtaKUgBI2Zlay0/nTcengK+CY7179w4FabXOocqqtb6h1gZUo4tddtnFvfawww4L7U/zpYw8NdJQea/mQfNRlXRsCmrq2DT/e+yxhwvU6jqvTJovBUk1Rwqk6Rwp4Ks5UhBycymop5soq1SBWAX79HuWkZER1bUbdMIJJ7h9qFmJngsA2HbFqRVwVQ8CAAAAABBbFFTUWoDKVFQjGwDAtosAIAAAAACg3GbPnu0ybs8//3yXSVqecmoAQNUiAAgAAAAAKDeVoKucW52dVf6t9TsBANs2AoAAAAAAAABANRZf1QMAAAAAAAAAsOUQAAQAAAAAAACqMQKAAAAgajfddJN16tTJioqKim3PzMy0sWPH2t5772116tSxpKQka9y4sfXt29eee+45y83NDT3377//tri4OHd74YUXNnmPG264wT22cuXK0LYDDjjAdtlll4hj0vP0fL2uLPfcc48de+yxttNOO7nXaL+RPPXUU6Exht+0/lVZHn/8cRswYIBbL6tGjRrWtm1bu/DCC23p0qVWXt9//70dcsghVrNmTTenGvdff/1l25LgvCQkJFjdunWtS5curkHAV199ZdsS/5zq+qsMuuZvvfVWdw1pHTSdp1133dVuv/12y8nJKfW1H330UWjegtd5WWbOnGn9+vVz86zrauedd7abb765XK9dvny5nXHGGdagQQNLS0uznj172scff2yxxvM8mzhxou21116Wnp5uGRkZtscee9jrr79e4mv+++8/q1+/vpvvV155pVLHM2bMmHI3wtDv/8iRI93c6zxo7N26dbNHH33UCgsLN3n++vXr7YorrrBmzZpZamqqde3adZPPTL3urrvucp+1LVq0cOe2Y8eONmzYMFu7du0m+yzpc02f3+WRlZVlQ4YMscMOO8waNmxY4mdvtOOqjPlSgxJ97mq+9H4dOnRw/83auHFjmZ/rwZs+tzfn9yY7O9vatWvn9nXnnXeW61j/+ecfd6579+7tPu/1Wo23LBV5r/IeVzSfcZqzsuZV7yf5+fnWpk0b999jAFsHAUAAABCVJUuW2Lhx49wXqvj4//u/EvPmzbPdd9/dfVHo1auXPfPMMzZt2jS7//77rXnz5nbWWWfZLbfcEnGf1113nfsysLU8/PDDtnDhQjvooIPcl9eyKNDw5ZdfFrspkFCW0aNHuy9LCg6899577gvzW2+95b68KhhRlt9//9196crLy7OXXnrJnnzySfvjjz/cwvsrVqywbcnAgQPdvCg4peDE6aef7oJ/+kJ5+eWX27biiCOOcONs2rRppexv0aJF7gusgk8KSLzxxhtuLhQMOfLII12gKhIFdc4991wXpIiGAukKDtSuXdv9jr3zzjs2dOjQEt8nSAH4gw8+2H3Bv/fee12wzA/Qf/LJJxZLFEjXTcejOX/55Zft5JNPDgV5Irn44otdAG1LiCYA+N1337lzp7Hr3ylTprhzquPRNRFOQf+nn37afZ68++671r17dzvppJPctRAMAOmaa9WqlbsedV1oX7om1aVXj5f0Oxu86fe2PFatWuX2rWtKwbaSVGRcmzNfv/32m+2zzz4uwK/30+ftiSee6P57pTkLfgYEb5HmY+rUqZv1ezNq1CjbsGGDRWP+/Pk2efJkS05OdkH+8qrIe5X3uKL5jNOchc+tf9N1qwCgf73oD4TXX3+9Oze6ngBsBR4AAEAUhgwZ4jVv3twrLCwMbcvPz/c6derk1alTx/vtt98ivu7vv//2pk6dGrq/YMECfWvwDj/8cPfvfffdV+z5o0ePdttXrFgR2ta7d2+vc+fOEfev5+n5el1ZgmPX/rTfSCZOnOj2OWvWLK8i/vvvv022aV/a580331zm6wcNGuQ1aNDAW7duXbF5TEpKcudhW6HjufjiizfZXlBQ4J111lnu8QcffLBS3quoqMjbuHGjt61Yv369u4W744473HF/9tlnEV+n+dp99929kSNHbnKdl+Sff/7x0tPTvQsvvLBCY50wYYJ7ry+++GKT39299trL29I2bNhQKfvR54iO48UXXyz3a1555RWvZs2a3tNPP+1e+/LLL3uVSedl8ODB5Xru6tWrvby8vIjXhMa2aNGi0La3337bbXvuueeKPffQQw/1mjVr5n7HRP+uXLlyk33qOPX6SZMmlet3NprfQ93K+uyNdlybO1/XXXed2zZ//vxizz3vvPPcdu0rktLmoyK/N19//bWXnJwcOk59HpRH8L9N/n8r9N+h0lT0vcp7XBX9jAsaP368e+7w4cOLbc/NzfXq1avn3XrrreUaM4DNQwYgAAAoN2WiPfHEEy7TJpj9p7/6K/NCmXwq74pEGSCRMkWUhdenTx9Xwqiysq0hOPYtqVGjRptsU/afymQXL15c6msLCgpc9spxxx3nSt6C83jggQeGslNKo/Ks4cOHu1JnZZQoE1NZUOGldyrbUiaHshSV5aGyUpXNKeNwc+g4H3jgAVdedscddxQb19VXX+1KGZXJVq9ePZcpGKl8Uxkjl1xyicva1LWVkpLisqGUTaJMniCVpen5s2bNCm179dVX3baff/65xBJgv7Rcr1N2pUrhWrdu7cohw8vc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xx+3Y445xo1j5513du9bWd588013/nQMOtc33nijFRQURHyuP3c6n5oPvaZz586bZGv+9ttv1q9fP3cNNm7c2E477TRbuXJl6HHNzyWXXGJXXXWVm7dDDz3Ubb/hhhtshx12sJSUFHftXnbZZaHXJCQkuH0+//zzUR9jw2YtrGGzHa3Tvn3srPMuivr1AAAAAABsawgAxgCVwd533332yy+/uICe1sdTiWzQxo0b3XMUbHnvvfdckEUBpnfeecfdFCh69NFH7ZVXXin2ujvuuMN22203+/7772348OEuCOUH+VQ+qX0omPLVV1/Zww8/7IJ94RTYU7BKgZx7773XHnvsMbv77rtDj59yyinWokULmzVrln333XcugJdUSnvVTz/91AXKIlHQRwG+8OMIzoPKhBXw1Pu9/PLLLrNPAaQtTSXL48ePd8FNZSueddb/ZY+9/fbbbi6VmTZ79uxQsFC0Vp3m56abbgplH0YydepUu/zyy+3qq69218L555/vAqLhGZEKyh1//PH2008/uSCY5n/16tWbfXzKplNZtAJtOtePPPKIO++33nprqa+79tpr3Zh13AoEHn300bZq1Sr3mI61d+/e1rVrVzdvunb/++8/N/4gXfea088//9y9r86/rjH9rCC11h1UkDxor732ss8++6zEceXm5lpmZmaxm2TsuIt1G3CSXXvLHS5gDQAAAABAzPNQ5QYPHuz179+/3M9/6aWXvPr164fuT5w4US1Lvfnz54e2nX/++V5aWpqXlZUV2tanTx+33deqVSuvb9++xfZ9wgkneIcffrj7+f333/cSEhK8xYsXhx5/99133XtNnTq1xPGNGzfO69atW+h+rVq1vKeeeqrcx1e7dm3vmWeeKbZNx6jtMmzYMK9du3Zefn6+t2bNGjee6dOnu8ceffRRr27dut769etDr3377be9+Ph4b9myZRHfb8GCBW4fNWrU8NLT00O377//PvTY7NmzQ88Pf0/9q/sfffRRsffUtuzsbHe/Z8+e3imnnFLiMetc3H333SUes+yzzz7eueeeW+w5gwYN8vr16xe6r/ccOXJk6L7mIS4uzp23kvTu3dtLSkoqduy6paSkFHv//fbbzxszZkyx106aNMlr2rRpsff3rw1/7saOHRt6XOesRYsW3u233+7ujxo1yjvssMOK7VPXm143d+7c0Pi6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Y/+tK7S9ex9S1cMBAAAAAGCzEQAE/r9DDjnEBaVuu+22UudkypQp1rlzZ0tJSXHZdePHjy/2uLbdcsstLvOtdu3adu6559pTTz1lderUsbfeesvat29vaWlpNnDgQNuwYYM9/fTT7jV169a1Sy+91AoLC0P7evbZZ23PPfe0WrVqubGdfPLJtnz58qjPmf96/9awYcPQWO+5555iz+3atavdcMMNofvKGHz88cftmGOOcePeeeed7Y033ij2ml9//dWOOOIIy8jIcO+133772Z9//un2o+N7/fXXQ9mHKluOVAL8ySef2F577eXmtWnTpjZs2DArKCgIPX7AAQfYZZddZkOGDLF69eq54wiOU3R/hx12cPto1qyZe360/svMt9V5idaoZSc77dxLon49AAAAAADbGgKAQCArbcyYMXb//ffbP//8E3FevvvuOzv++OPtxBNPtJ9//tkFnEaNGuUCfEF33HGHK2/V8/W4bNy40e677z574YUX7L333nOBsGOPPdbeeecdd5s0aZI9+uij9sorrxTLHrz55pvtxx9/dOXICxYscIHFre3GG290x/3TTz9Zv3797JRTTrHVq1e7x/7991/bf//9XQbltGnT3DGfddZZLnh3zTXXuNf17ds3lH24zz77bLJ/7UP77d69uzvWhx56yJ544gkXSA1SMDE9Pd2+/vprGzdunMts/PDDD91jmre7777bHnnkEZs3b56br1133bXEY8rNzbXMzMxiN6ndqLW17byfnXjO1da2bftKnkkAAAAAALa+ba/+DqhCynJTBtzo0aNdACrcXXfdZQcffHAoqNeuXTv77bffXMAvGJg76KCDXPDLN3PmTMvPz3eBrTZt2rhtygBU0O+///6zmjVrWqdOnezAAw+06dOn2wknnOCeo0Car3Xr1i6AqCy59evXu9eU19ChQ23kyJGh+wp0RpMdp2M76aSTQq9VkPSbb75xgb0JEya4TEcFNpOSkkLz4qtRo4YLtiljryQPPvigWxfwgQcecJmBHTp0sCVLlrhxX3/99RYf/7+/Vey2227u3IgyEfX8jz/+2A499FBbtGiRew9lcmocygTUXJVEmZ4KbIY76tRLrEmzFtawYRMXFAYAAAAAINaRAQiE0TqAyjRTYC/cnDlzbN999y22TfeVcRYs3VXZbjiVz/rBP2ncuLErwQ0G8rQt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Jk2aWGJi1ZWfJiQkVPkY8vPzyz1v3bp1s5133tkaNWrktp1yyin22Wef2Zw5c6J+3/UFhZaTEG/Z8QnWsVu3qF8PAAAAAMC2hgAgQu666y7bddddXSmlMsAuuugiW79+/SYZcMpQa9++vaWlpdnAgQNtw4YN9vTTT7uy17p169qll17qSiiDsrKy7OSTT7aaNWtas2bN7P777y/2uAJx+++/v6WmplqnTp3sww8/3OTMKKOrXbt27n1bt25to0aNKhYk+vHHH+3AAw+0WrVqWUZGhgsKffvttyWe4RdeeMEOO+ww955l7WPGjBl25pln2rp161xprG433HCDe83y5cvtqKOOch1jd9ppJ5s8eXKFsvA0b4sWLXL71lyWVErctWvX0HuLnv/444/bMccc4+ZGgbA33nij2Gt+/fVXO+KII9wx6dj2228/FzjTfnTuXn/99dBx6VgjlQB/8sknttdee7kMOwUqhw0bZgUFBaHHDzjgALvssstcVqXKmBVADI6zLHq/hx9+2Pr37++uwVtuucVtf/PNN9150HnSeb/xxhtD76v5mTJlij3zzDPu9ZpHqV+/vgukPv/881GeCbOU9DQrTEy03NoZdsbFF0f9egAAAAAAtjWscI8QlcHed999LqiyYMECFwBUMOfBBx8MPWfjxo3uOQqeKah37LHHupsCg++884799ddfdtxxx1mvXr3shBNOCL3ujjvusBEjRriA0Pvvv29XXnmlW3tPa7dp/T3to0GDBvbVV19ZZmamXXHFFZucGQWuFIRUAPHnn3+2c889123TGP2sr913390eeughl8Gm4FVSUlKJZ/jTTz+1k046qdi2kvahYJICcddff73NnTvXPVfBTFHQafHixW49weTkZBcEU1AwSM9RUE3BNZ8CVhMnTnSP3XvvvdamTRt79NFHbdasWe69o6Gg2Lhx49w8K7iq41i4cKELxP37778uuKoAncaoIODnn3/ugmgqlVWWnOZcYxG9ZsmSJcX2r33069fPjVXBtt9//93Nv4JywSCfgolXXXWVff311/bll1+65++7777uPJfH6NGj7bbbbnNlvZoDXSunnnqqu+b8oKXWSfSfq7k6/fTT3TFpDhWE9SlYqSzAkmitQN18mgNZkpdv9Vu0sFOOO84FugEAAAAAiHkethuDBw/2+vfvX+7nv/TSS179+vVD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mlhiYtXWbN5333125plnWnx8fMT5mjNnjl1zzTU2YsQIe/TRR626UAZmt27dbNq0aTZu3Dj7+eef7b333rMDDzzQLr744q0+Hp2DyZMnV+h3Lzs+3TLj61h+o8520nlDtsj4AAAAAADYmggAbkGHHHKIC0rddtttpT5vypQp1rlzZ5c1pWyx8ePHF3tc22655RaX+Va7dm0799xz7amnnrI6deq4jLP27dtbWlqaDRw40DZs2GBPP/20e03dunVdRlZhYWFoX88++6ztueeeVqtWLTe2k08+2ZVMRst/vX9TyaU/1nvuuafYc1W+qTJOn7LOHn/8cTvmmGPcuHfeeWd74403ir3m119/tSOOOMIyMjLce+233372559/uv3o+F5//fVQVp0y2SKVAH/yySe21157uXlt2rSpDRs2zAoKCoplxV122WU2ZMgQq1evnjuO4DhF93fYYQe3j2bNmrnnl2TlypX20Ucf2dFHH13ifGl+zjnnHNttt93sgw8+CD2uQNXpp5/uzpnm5PDDD7d58+aFHl+4cKHLptPj6enp7np55513Qo//9ttv1q9fP6tZs6Y1btzYZcBpPKLrRnNx7733huZM86XgnGif2qbniQJ3vXr1ctdX/fr17cgjj3RzX5qLLrrI7eObb75x12G7du3cGK+66ir76quvQs9btGiR9e/f341T5/b444+3//77r9i+lDWrY9CcnX322ZaTk7PJ+02cONE6duzoguzKqHzwwQeLPb7rrru6+Z46dapFa016G0ts2dsOO32I9ejVO+rXAwAAAACwrSEAuIWz0saMGWP333+//fPPPxGf891337kgiEpGlTWlgNOoUaNcgC9IJaMqb9Xz9bhs3LjRZZy98MILLmijQNixxx7rAkO6TZo0yWWZvfLKK8WyB2+++Wb78ccfXTnyggULQoGfrenGG290x/3TTz+5wNUpp5xiq1evdo9p7Tato6fgjjLKdMxnnXWWC94pe06v69u3byj7cJ999tlk/9qH9tu9e3d3rA899JA98cQTLpAapGCiAmpff/21y1xTpt6HH37oHtO83X333fbII4+4YJzmS4GlksycOdMF7xSYKonKfnWelAmYlJQU2q5z8O2337pA6Jdffumep/Hn52s1OnNZdLm5ufbpp5+660SZpQqiieagd+/eLtCqfehaUFBN8yQK/PXs2dMFjv05U3muAs8yd+5ct03PEwWRFbibNWuWK99VNqOCtUVFRRGPSedN76kxai7DKZDoH7tKt/V8BSQ1zwosnnDCCaHnvvTSS65099Zbb3XHosBteHDvscces+uuu849R/Oo3zH9TuhcBin4+9lnn5V4LjSfmZmZxW6y33GXWr/zR9pBR5xgycmsAQgAAAAAqAY8bBGDBw/2+vfv737u0aOHd9ZZZ7mfp06dqoXfQs87+eSTvUMPPbTYa6+99lqvU6dOofutWrXyBgwYUOw5EydOdPuZP39+aNv555/vpaWleVlZWaFtffr0cdtL8s0337j9+K+ZPn26u79mzZoSX6PxJCcne+np6aHbvffeG3rs7rvvLvb8Ll26eKNHjw7d1/5HjhwZur9+/XovLi7Oe/fdd9394cOHezvttJOXl5dX5tz6FixY4PY7e/Zsd3/EiBFe+/btvaKiotBzJkyY4NWsWdMrLCx093v37u316tWr2H66d+/uDR061P08fvx4r127diWOI5yOu3Xr1qXOV1JSkhtnamqq9/nnn7vH//jjD7fNvy8rV670atSo4b300kvu/q677urdcMMNEd931KhR3mGHHVZs2+LFi90+586dGzrWyy+/vNhzynOuZfny5e55P//8c8THv/76a/f4q6++Wup+PvjgAy8hIcFbtGhRaNuvv/7qXqvrUHr27OldcMEFxV639957u2vI17JlS++5554r9pybb77ZvTboyiuv9A444IASx6NrUu8dflu3bl2pxwEAAAAAwNam76qb852VDMCtQNlayk5SmWY4ZTDtu+++xbbpvjLOgqW7KtsNp2yzNm3ahO6rbFIlpn5mmL8tWOKrtfpUgtmqVStXYqkyWL80MxrXXnutK7f1bypfjYZKYH3KGtNY/HFqfyr5DWbIRUvzqqy3YMMVzev69euLZWMGxyHKOPPHMWjQIMvOznZNLZQ9p3LSYAlxOD1XWYulzZcy31R6qww2P3NRY9XahXvvvXfo+Sq9VWm3HhOVHit7UcegDDllTvqUITl9+nR33v2bymKlrNLdSPQalYbruFWmu9NOO5V6jfjNTMpqbqNjUeahbr5OnTq5DEH/OP3zFhS8v2LFClu8eLErDQ4er+Ym/FjVcEVZsiUZPny4rVu3LnTTfgEAAAAAqI4IAG4FKmft06ePa/wQKXgSHjiJ1B02UmlleIBM+4m0zS/dVGnnYYcd5gImWgtQJZ7+GmnRNhZp0KCBtW3bNnTzyzxVLho+fr+Mtayx++NU4GZzlTavwe2ljUOBKpXHTpgwwY1J69zpXEY6Hn9OSmo64c+XglkqvVVpsdYLDI6rtGPQuoF//fWXW9tPJcAKCKu0XDRerQ8YDMjqpiCyxhst7WvVqlWu1Fal0bqVdo1oDUeN0w/iRXNOStseiX9uNLbgsf7yyy/F1hoUlRr7a1NGonUdFeAM3uTZMRfZlGcetqysrHKNCQAAAACAbR0BwK1EjQ3efPNN++KLL4ptVwaU1o4L0nPUREFrCFam33//3TWG0FiUYacssYo0ACmNAi5aT86nddW0zmA0lJWntdtKCrRpXbZgdmQkmlfNYzC4pvvKNGzevHm5x6LAn5p6aK1Frd2n9fkUgItk9913t2XLlpXZedZvzqL1DDU+jVWZhX6gTRSA++OPP4qtJ6iA5AUXXGCvvvqqXX311S4IJnvssYdrmqLsz2BQVjc/cBxpzvz17YLb9b4K5I0cOdIOPvhg9/5lHY8aqCjArUCpgszh1q5d6/7VcSqLMJhpp6xYZd/5x6l/wwN5wfvKaNX5UzA0/Fj9TEWfgoI6J9FqvPZLy/3qYZt81zCCgAAAAACAaoEA4Fai5hFqdOFnbfkUyFGjBTXmUMBHpcIPPPCACw5VNnWzVdBHY1AARQ0n9L6V6aCDDnLNRxTAUwBm8ODBUQcyL7nkEhc4VGMUNYJQJpv2qWw8UaBLJbC6r4BmpEChsvUUaFKgTYFPdQ1W6ayaWyhLsTzUiEWNQ3Qcmi+NQQFBlU9HomCTAqCff/55mftWwwyNX9mAyqBTWbbKjBUMVtOSU0891QW6tF2uuOIKe//9910w9fvvv3fNUfygmfalbLeTTjrJdeHVWNVhWI1T/OCe5kwBRnX/1Zwpk07Hocw7dZJWaa3KoxWcVPmxmsfMnz/fvY/mrCxq1KH3UuMNHZPOmQKJCpz6Jbzqiq3grn4PdAwaq0rH1cDEL3G//PLL7cknn3Q3/T7onCm4GaRGOeqsraYleo4CsuoKfNddd4Weo9JflUYr4zVaabkrrHb+ArO5U23qs49G/XoAAAAAALY1BAC3IgXbwss9lb2lzqfq5Ksuv9dff73rRLslOvMqOKWg1ssvv+yysZQJeOedd1bqe2hdNZWdHnnkka6Lrbq+BtcpLA8FoBR4UkBKwaFu3bq5bDe/XFeBMq2Pp6BRSQE3Bc/UCVlBpi5durjMOa0bp8y28lJZs95X6+4pcKVArbI4Nb5IFOhU0G3y5Mll7lvjVjmvglkKximApePUvClgputE4/ePWcE1BfoU9FMHZB2/3x23WbNmbg70HGXi6TpSIK127dqhYKcCyhqfzrveW5l4miN1Yx42bJjLrFPgVc/XtajgmfZz5ZVXug7UZVH2nYJ6Wt9QQW299tBDD3Vzpg7MomCjOikryKhrRAFBrTP44osvhvajjsD6HRg6dKibj4ULF9qFF15Y7L1UDv3444+7a1mBdV0j+jmYAaiArwLeynSNVt7GLLP1mVavcKnNeuvxqF8PAAAAAMC2Jk6dQKp6EEB18d9//1nnzp1dAK2kTEFsecpEVNakmpmUl7JOFTR9daBZSqJZ1gaztxeZPfMDH5EAAAAAgKrlf2fVMlr+GvbRIAMQqETKpFPZcLRdlVF5tK7lwIEDXUl0RTRNM8tINVNbkrWrOTMAAAAAgNiXWNUDAKobf90+VI1GjRrZkCFDKvx6Zf9lpJhtSDbLjtyHBgAAAACAmEIGIAAEJCWaFXhmBQVm/1uBEQAAAACA2EYGIAAEZOeYJcaZpaeaJagOGAAAAACAGLfFMwDV0fbTTz8t83lr1651nT3VRXb16v8tvKWuov/++++WHiIAhNRJNauTZuYVmNH+AwAAAABQHWzxAODEiROtb9++dtRRR5X4nJ9++snatWtnt99+u915550uGChTp051AUEA2FqyNpptLDSLTzQrIgIIAAAAAKgGtngAcMGCBS6j75JLLinxOVdddZWdccYZNm/ePEtNTQ1tP/zww8uVPQgAlaUo0WxDttmKbLPEBOYVAAAAABD7tsoagArq9enTp8THZ82aZY888sgm25s3b27Lli3bwqMDgP+zeL1ZasL/SoDjk5kZAAAAAEDsq7QMwM8++8xOPfVU69mzZ2jdvkmTJtnMmTPLFSDMzMzcZPvcuXOtYcOGlTVEAChTjUSzwgKzZblmtZo0ZsYAAAAAADGvUgKAU6ZMcRl+NWrUsNmzZ1tubq7bnpWVZWPGjCnz9f3793fNQvLz8939uLg4W7RokQ0bNsyOO+64yhgiAJTL8hyz/wrMMhPTrUf/c5g1AAAAAEDMq5QA4C233GIPP/ywPfbYY5aUlBTavs8++7hOvmVR448VK1ZYo0aNLDs723r37m1t27a1WrVq2a233loZQwSAcsmt0cRyMna0lE5H26kXXMusAQAAAABiXqWsAahS3f3333+T7RkZGaGOvqXR81QqPG3aNBcwLCoqsj322MMOOeSQyhgeAJTbugZ7WeMOvezUU86z2rVrM3MAAAAAgJhXKQHApk2b2vz5823HHXcstl1BvdatW5d7PwcddJC7AUBVOe+WSe6PEgAAAAAAVBeVEgA8//zz7fLLL7cnn3zSrd+3ZMkS+/LLL+2aa66x66+/vlz7+Oabb2zGjBm2fPlylwEYdNddd1XGMAEAAAAAAIDtTqUEAIcMGWLr1q2zAw880HJyclw5cEpKigsAXnLJJWW+Xo1CRo4cae3bt7fGjRu7IKIv+DMAAAAAAACA6MR5nudZJdm4caP99ttvLoOvU6dOVrNmzXK9TkG/22+/3c4444zKGgoARCUzM9Ot+ac/ZlACDAAAAACoTt9ZKyUD0JeWlmZ77rln1K+Lj4+3fffdtzKHAgAAAAAAAKCyAoAq+73//vtt+vTpEdfwU2ff0lx55ZU2YcIEu+eeezgpAKrUvD//tOZNm1rDhg0tISGBswEAAAAAiHmVEgA866yz7MMPP7SBAwfaXnvtFfW6fVor8IgjjrA2bdq40uGkpKRij7/66quVMUwAKNOTk1+yZk2bWL9DDrTddulMEBAAAAAAEPMqJQD49ttv2zvvvFPhMt5LL73UZQ+qiUj9+vVp/AGgyqzOzbO1fy20fyc+a5dfeLZrTgQAAAAAgG3vAcDmzZtbrVq1Kvz6Z555xqZMmeKyAAGgKmVkNLb8uBz759+l9vhTz9gdt93KCQEAAAAAxLT4ytjJ+PHjbejQobZw4cIKvb5evXqu/BcAqlquZ5aclG5pGQ3t86+/qerhAAAAAACwbQQA1flXjUBat27tMgEV0AveynLDDTfY6NGjbePGjZUxHACoOM+zAs+z1KRkW78hh5kEAAAAAMS8SikBPumkk+zff/+1MWPGWOPGjaNew+++++6zP//80712xx133KQJSFldhAGgsqTWSLZEi7f1CbmWU5DPxAIAAAAAYl6lBAC/+OIL+/LLL61Lly4Vev2AAQMqYxgAsNk2ZudacnKy5Rfm2/qsXGYUAAAAABDzKiUA2KFDB8vOzq7w61X+CwDbgoy69c3L3mjL1q+xvMK8qh4OAAAAAADbxhqAY8eOtauvvtpmzJhhq1atsszMzGI3AIgVa1b8a5mZayw+PtkS4yvlbyQAAAAAAFSpSvl227dvX/fvwQcfXGy753luPcDCwsJNXqPmIH/88Yc1aNDA6tatW+q6gatXr66MYQJAmVJT0yze8ywnP9/ikirlbyQAAAAAAMR+AHD69OlRv+buu+92HYP9n6NtHAIAW0KN9HRLSUi03LgCSy4iAAgAAAAAiH2VEgDs3bt31K8ZPHhw6OczzjijMoYBIMao6/cVV1zhbtsKr8iz/Lw8s7wiS0it6tEAAAAAALD5Kpze8tNPP1lRUVHo59JuZUlISLDly5dvsl3rCeoxoKKWLVtml156qbVu3dpSUlKsZcuWdtRRR9nHH39cKZP6999/u+zVH374oUpP0pQpU+yAAw6w2rVrW82aNW233Xazm266qUrL57X+53XXXeeaBKWmplqTJk3skEMOsVdffdUtD7Ct2pCVZRsL8qwgO98SE8gABAAAAABsxxmAXbt2dcGVRo0auZ8VBIn0pb6kNQCDSgoG5ObmWnJyckWHiO2cgnP77ruv1alTx8aNG+eCYvn5+fb+++/bxRdfbL///rtVBwqy3X777XbllVfamDFjrFmzZjZv3jx7+OGHbdKkSXb55Zdv8pobbrjBzc9TTz1VrvdQcFGZuuXN1l27dq316tXL1q1bZ7fccot1797dEhMT7ZNPPrEhQ4bYQQcd5M7Ltkjlv9kF6y1rzUpr12bnqh4OAAAAAABVFwBcsGCBNWzYMPRzRdx3332hIOHjjz/uMpd8Chp++umnLnsIqIiLLrrIXVvffPONpaenh7Z37tzZzjrrLPezgmA77bSTzZ492wWy/eCVGtNobUsFvtasWWOXXHKJffDBB7Z+/Xpr0aKFjRgxws4880z3Wtl9991D5fDqhq3sWAW+Hn30UVuxYoV17NjRdcv2G+b47/viiy/a/fffb99++63tsssuNnnyZBc0u/DCC12AUkE0BfH837VwOjYF/e65555igT6V1h566KHuWKqC5kfHqEY/Ckj62rVrZyeddJLLCIzkrrvusokTJ9pff/3lGgUpW1PBW/+zYeHChe5czJw50/Ly8txx3nHHHdavX79Sz1M0li9baIlJ8ZZeM9mOOOzIzZwJAAAAAABiOADYqlWr0M/6Ur7PPvu4DJ+ggoIC++KLL4o9N0jNP/wMQGUrBct9lfmnL/faDkRLpa/vvfee3XrrrcWCf75oss9GjRplv/32m7377ruua/X8+fMtOzs7FIDba6+97KOPPnKBRT9j9d5777Xx48fbI4884oKDTz75pB199NH266+/2s47/19W2ejRo13wbocddnBBSQXHMjIy3OvT0tLs+OOPt+uvv94eeuihiGNTwFDBMQU7I6mKLDsFP1944QU75ZRTigX/fMFAf7j4+Hj3hwH97usPCzouZQw++OCD7nFlbirwpz8O6LzqvPj7K+08RaNZw8aWlOTZDg0b2LHH9o/69QAAAAAAVMsmIAceeKAtXbrUlQMHKZNJj5VUAuxnDuo5WhdMWVdAZVDwR4HlysggXbRokQvi7bnnnu6+glM+PzOvfv36bo0735133mlDhw61E0880d1Xia4yChXsmzBhQuh511xzjfXp08f9rAw+BQC1PqFKl+Xss88utUxXpb5a3zApKcm2FStXrnTZeBWZ+2AzEGVI3nzzzS4b0g8A6lwcd9xxtuuuu7r7OvbynKeSlhjQLbhmobSoX9M6tNnJDjvs0IjBYwAAAAAAYk2lrHCvQItKLSM18SjPF2gFRgj+oTL560pGui6jpQCUMtpUIqxsNGW1lkaBpCVLloSCeD7dnzNnTrFtWpfQ17hxY/evH9zyt0VqkFPW7164zz77zGXK+TeVDfvZg8FtPv0cfEyvv+CCCzbZVtKYKjr3+ixQ6XLz5s2tVq1advrpp7vPkQ0bNrjHL7vsMldarblU9mSwyVC05+m2225zTVP8mxrEyMXnnW3HHDOA4B8AAAAAoNrYrAzAY489NvRFX80B1GXVp6w/fTlXaTCwtanMVtelAm4DBgwoteQ0vBGNGoUEHX744a7M/e2333alvgcffLArRVWWX2nCA2CRgnXBzD3/sfBtfrftSLSmntbD05hLywJUVlywU7HKbP/991+XmejTmns+BftUfuxTOa8y7/zfeVGQLhJlRSqgHx7sLIvmWGv56b2V+afx6NiUBemfk3POOcdlTOpcaK0/BfFUaq1Oz9Gep+HDh9tVV11VLHDrBwEBAAAAAKhONisD0M+cUWBD2TrBbBqVQ5533nn27LPPVt5ogXJS8EiBIpXb+tljQX5zDL+EVyXsvmCgzKfnKcit61llvGruIf6af8Eyd63hp7XvFLwKUkaamoFUppNPPtk1vPBLZEs6zho1aljbtm1DN82PfmfDt/n0c/AxvV4l/uHbSgqqnnDCCS7DUJmQ4XQ+tD5oODVC0XYF9Hr06OGCm5FeryCdgoRaNuDqq6+2xx57rMzzFIn+YKFzFbzJ7Q88bE9Oei5UEgwAAAAAwHadAahunf5aW1rLjPWysC1RUEwZqGrScdNNN7lyWwWYPvzwQ9dUQxlqCmIp2KQOvbqOtX7dyJEji+1HTTi6devmmnxozbi33norFMhTUEz7UMMRdZ1Vd1sFwK+99lpXotqmTRtXkqrfFQUWFRSrTHvvvbcrd1UgTBl9xxxzjAs+ag1ENdBRF+Fgd+CtRSXE6oas8akRizIQlaGosmFl7c2aNWuTBiWaK50fdUVW99/PP/98kyZAWiNQmX4KDmqdwWnTpoXORWnnKRobvST7+e9/7J8HH7ErLjo/FBgEAAAAAGC7XgNQgQ6Cf9jWqInE999/75rMKEC2yy67uPXl1GQj2FVXHXpVYqoglYJlWmMuSFl+KhdVAHH//fd33aq11pyo87XKadXtV4G3/v37h9aq03vqpjX9FCB84403inUAriwq433uuefs66+/dlmPCoCptFXjHTx4sFUFlQB/9dVXduqpp7r5VHOO/fbbz55//nm74447XJA0nAKld911lzsenSsFSxUsDFKmpcp6Fdjr27evtW/fPpT9WNp5ika+F2e5hYm24L819tTk5zdjFgAAAAAA2DbEecHFz6rIp59+Wurj+jIPAFuSSn4VmBz15Ktm+UW29J/fbdHPP9v7U6MPIgIAAAAAsCW+s65bt65ClWqbVQJcWQ444IBNtgWbJQTXVwOALWnjmrXmpaRarYY72Iqs0jsJAwAAAACw3ZQAby6t5RW8LV++3JVMdu/e3XX6BICtJa1uPatZs6YV5eVbUT5/fAAAAAAAxL5tIgMw0npgWqtNXTqvvPJK++6776pkXAC2Q4lJlpySakkp6y07v8pXSAAAAAAAoOoCgGp8UF5qiFARDRs2tLlz51botQBQETXTUq0gLtGK8nPMKypgEgEAAAAA228A8O677y7X87SWX1kBwJ9++qnYffUlWbp0qY0dO9a6dOlS0SECQNTWrV1rcYnJll9QaHFx28QqCQAAAAAAVE0AcMGCBVZZunbt6gKF4Q2Je/ToYU8++WSlvQ8AlCU1JcVc5W9iqsUnEgAEAAAAAMS+bWINwPBgYnx8vCv/TU1NrbIxAdg+FRR6llwjzWqlbbDCItYABAAAAADEvkoLAP7zzz/2xhtv2KJFiywvL6/YY3fddVepr23VqlVlDQMANkuNGqmWW1Rg6zdusNSUBGYTAAAAABDzKiUA+PHHH9vRRx9tO+20k2vascsuu9jff//tSnr32GOPcu9D6wrOmTPHlQN36NDBrrjiCjvkkEMqY4gAUC4rl/xjcXFJVpibbzWTk5k1AAAAAEDMq5QFroYPH25XX321/fLLL65sd8qUKbZ48WLr3bu3DRo0qMzXP/DAA9a3b1+rVauWXX755a5pSEZGhvXr1889BgBbS3xCgllCkRVlr7MdmzZk4gEAAAAAMS/OC++8UQEK3P3www/Wpk0bq1u3rs2cOdM6d+5sP/74o/Xv399lA5amefPmLoh4ySWXFNs+YcIEu/XWW23JkiWbO0QAKFVmZqbVrl3brh7/iBUWFVju6uW2/x672YkDj2XmAAAAAADbxHfWdevWuaS5KskATE9Pt9zcXPdzs2bN7M8//ww9tnLlynIdhDIAwx122GHuMQDYWuJys61WYZ51bbuTHd1v088lAAAAAABiTaUEAHv06GGff/65+/mII45w5cDK3DvrrLPcY2XR+oFTp07dZPvrr79uRx11VGUMEQDKZYcGGbZ3l8526omDLC0tjVkDAAAAAMS8SikB/uuvv2z9+vW222672caNG+2aa65xZcBt27Z1jT3K6vJ7yy232J133mn77ruv9ezZ02376quvXFBRwcRgaqPWBwSAbS2dGgAAAACAbfU7a6UEADeXugeXh7oDK9gIAJWNACAAAAAAoLp+Z02srIGsXbvWXnnlFbf+37XXXmv16tWz77//3ho3buyafJRmwYIFlTUMAAAAAAAAAJUdAPzpp5/skEMOcZFIdfw999xzXQBQ6/otXLjQnnnmmcp4GwAAAAAAAABV0QTkqquusjPOOMPmzZtnqampoe2HH364ffrpp2W+fuDAgTZ27NhNtt9xxx02aNCgyhgiAJTLNrAqAgAAAAAA214AcNasWXb++edvsl2lv8uWLSvz9Z988onrHhyub9++5QogAkBlWTD/b1vy71K3rEFRURETCwAAAACIeZVSAqysPy1GGG7u3LnWsGHDMl+vDsLJycmbbE9KSoq4XwDYUu6/+yGLjzdr0Ki+nXrmydaxY0eL1wYAAAAAAGJUpXyr7d+/v910002Wn58f6ta7aNEiGzZsmB133HFlvn6XXXaxF198cZPtL7zwgnXq1KkyhggA5fLU849Zw9pNbf2qbLvj5rtcYyMAAAAAAGx7zwC88847rV+/ftaoUSPLzs623r17u9Lfnj172q233lrm60eNGuUChfqifdBBB7ltH3/8sT3//PP28ssvV8YQAaDcEgriLCklxeIzE238nXfbw488yOwBAAAAALbvAGBGRobNnDnTpk2bZt9//71bN2uPPfZwnYHL4+ijj7bXXnvNxowZY6+88orVqFHDdtttN/voo49cMBEAtiYvJd5SslMsLaWmzf5uFpMPAAAAANi+A4AFBQVuDcAffvjBZe/5GXzRUhOQSI1AAGDrirM6NeraxpRMyy/Is43ZGzgBAAAAAIDtOwCYmJhorVq1ssLCwsoZEQBUMTX9SIurYbkp+ebl8tkGAAAAAIhtldIEZOTIkTZ8+HBbvXp1ZewOAKqQZyvWLrfVWZlWWJBv6wv+19wIAAAAAIDteg3A++67z+bPn2/NmjVz2YDp6enFHte6gAAQK2rWqmUb16yzf1csNS+PACAAAAAAILZVSgBwwIABlbEbAKh6ntmG1VnmxXmWnlTTzPOqekQAAAAAAFR9AHD06NFWmbSe4M8//+yyCevWrVup+waAUsXFWaNGTWzthjWWlLXR4hIr5WMSAAAAAIDYXgNwc11xxRX2xBNPhIJ/vXv3tj322MNatmxpM2bMqOrhAdiueJa1Icus0Cy9Vg1LT0mu6gEBAAAAABD7AcBXXnnFunTp4n5+8803bcGCBfb777+7wOB1111X1cMDsJ0piM+3oqIiS0pIscQ0AoAAAAAAgNi2TQQAV65caU2aNHE/v/POOzZo0CBr166dnX322a4UGNgcyiKNi4uztWvXxtRE/v33327cP/zwQ1UPxfbff3977rnnquz9zzjjjHKvNbp8+XJr2LCh/fvvvxV+v6SkZItLiresvCxLTKAEGAAAAAAQ27aJAGDjxo3tt99+c+W/7733nh1yyCFu+8aNGy0hIaGqh4dAEEYBqbFjxxabk9dee81tj2U77rijO4bgrUWLFlUa4FIJ/NKlS22XXXaxqvTWW2/ZsmXL7MQTTwxtmz17th155JHWqFEjS01NdfN3wgknuGD+5gRdSwp63nvvvfbUU0+Vax8a02mnnbZZa5MW5hRYUU6OrV6zytp3al/h/QAAAAAAUG0DgArk6Qv8mjVryvX8M888044//ngX6NCX/0MPPdRt//rrr61Dhw5bYoioIAV7br/99nKf2/LKy8ur8nNy0003uYCbf1OQqyop+K3M2MQqbkJx3333ud/R+Pj4UIadgvQNGjSw999/3+bMmWNPPvmkNW3a1AXtt4TatWtbnTp1yv18jXfy5MkVu049s9VZK2z5hlWWUiPRTh18cvT7AAAAAACgugUAN7eJxw033GCPP/64nXfeefb5559bSkpKKAAybNiwyhgiKokCPwpK3XbbbaU+b8qUKda5c2d3LpUdNn78+GKPa9stt9ziMt8U3Dn33HNdhpeCPMo4a9++vaWlpdnAgQNtw4YN9vTTT7vXqCv0pZde6q4z37PPPmt77rmn1apVy43t5JNPdkGqaPmv928qI/XHes899xR7bteuXd1161PgWtfwMccc48a988472xtvvFHsNb/++qsdccQRlpGR4d5rv/32sz///NPtR8f3+uuvh7IP9XsTKRvuk08+sb322svNqwJu+v0oKCgIPX7AAQfYZZddZkOGDLF69eq54wiOU3R/hx12cPto1qyZe35JlNH30Ucf2dFHHx3a9sUXX1hmZqY73t1339122mknO+igg9wcab8a94EHHuieq/OlY9B5FmX49urVy53n+vXruyxCzYFP+xLtV6/T8UTKkNT6fApEt23b1h2H3vfWW28NPb7rrru6Y586dapF6/Jzr7aU1GRr2LSu9Tn6UPd5BgAAAACAbe8BwMpo4qFAz5VXXlms7HLw4MHWv3//yhgiKomCsmPGjLH777/f/vnnn4jP+e6771xGp0pGtYajAk6jRo3apITzjjvucFmfer4eF2WQKePshRdecMEiBcKOPfZYtzakbpMmTbJHH33UXXPB7MGbb77ZfvzxR1eOrOvPDzhtTTfeeKM77p9++sn69etnp5xyiq1evdo9pvXotI6eMiinTZvmjvmss85ywbtrrrnGva5v376h7MN99tlnk/1rH9pv9+7d3bE+9NBDLvCuQGqQgonp6ekug3bcuHEus/HDDz90j2ne7r77bnvkkUds3rx5br4ULCvJzJkzXUCzY8eOoW0K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2i677GJV6a233rJly5bZiSeeGAqmlnZT8C8WRToHVWnIkCE2ceJEW7BgQYVeH5eSaAVevmXmr7V6jepV+vgAAAAAANiaCABuRampqXb77bfbmjVrKnW/eXl5VtVuuukmF3Dzb7Nnz67S8SQkJFiTJk0sMbFq07fuu+8+O/PMM1022T777FNsjo4//njr27dvsW0nnHBCzF4D25JGjRrZYYcdZg8//HCFXp+Z/Z9ttFUWnxJnx57Yr9LHBwAAAADA1kQAcCs65JBDXFDqtttuK/V5U6ZMsc6dO1tKSorLrhs/fnyxx7XtlltucVlXagF97rnnhspGlXHWvn17S0tLs4EDB9qGDRvs6aefdq+pW7euXXrppVZYWBja17PPPmt77rmn1apVy43t5JNPtuXLl0d9bP7r/VvDhg1DY73nnnuKPVelmirZ9Cnz7fHHH7djjjnGjXvnnXe2N954o9hrfv31VzviiCNcq2u913777Wd//vmn24+O7/XXXw9l0SnTLlIJ8CeffGJ77bWXm9emTZvasGHDrKCgIPT4AQcc4MpGlT1Wr149dxzBcYru77DDDm4fzZo1K7XMdOXKlfbRRx/Z0Ucf7e4nJycXm6MaNWq4/YRv873//vvWsWNHq1mzZihQGJ5xp2tJ42jXrp3b/u+//7ogos51/fr1rX///m4ufLNmzbJDDz3UGjRo4K6d3r172/fff19s3PPmzXNlywpYd+rUyT788EPbXGXNfVFRkQuOt23b1j1Hc3zrrbeGHh86dKg7Rl0frVu3tlGjRll+fn6p76l5f/7556Me68G7DLK6dWpZ3To1rUuPtnbN0Cuj3gcAAAAAANsSAoBbOSttzJgxdv/999s///wT8TnfffedywxTyejPP//sAk4KdoSXht5xxx2uvFXP1+OyceNGl3H2wgsv2HvvvecCYccee6y988477jZp0iR79NFH7ZVXXimWOXbzzTfbjz/+6MqRVTKp4NLWduONN7rj/umnn6xfv352yimn2OrVq0NBLT8gNW3aNHfMZ511lgsgaa238Ew6ZdqF0z603+7du7tjfeihh+yJJ55wgdQgBRPT09Pt66+/tnHjxrnMRj8Apnm7++677ZFHHnFBMs3XrrvuWuIxzZw50wWsFMSLls7lnXfe6c7Zp59+aosWLXLHGvTxxx/bnDlz3PgU+NVrDjzwQBcw1Gv0/n7w0M8QzMrKssGDB9tnn31mX331lQu2al603Q/E6ZrRtarHlUGn4NvmKM/cDx8+3AUAdS3/9ttvbs3Exo0bhx5X0Fe/A3rs3nvvtccee8ydi9Io4Lh48WJbuHBhxMdzc3MtMzOz2E3qtahljXfKsEMG7Wn3PDzWBVMBAAAAAIhpHraKwYMHe/3793c/9+jRwzvrrLPcz1OnTvWCp+Hkk0/2Dj300GKvvfbaa71OnTqF7rdq1cobMGBAsedMnDjR7Wf+/Pmhbeeff76XlpbmZWVlhbb16dPHbS/JN9984/bjv2b69Onu/po1a0p8jcaTnJzspaenh2733ntv6LG777672PO7dOnijR49OnRf+x85cmTo/vr16724uDjv3XffdfeHDx/u7bTTTl5eXl6Zc+tbsGCB2+/s2bPd/REjRnjt27f3ioqKQs+ZMGGCV7NmTa+wsNDd7927t9erV69i++nevbs3dOhQ9/P48eO9du3alTiOcDru1q1bl/h4pHGXdC411saNGxd7re7n5uaGtj3xxBObHKMer1Gjhvf+++9HHENBQYFXq1Yt780333T39byEhARv8eLFoefoPGg8ulajPZbyzH1mZqaXkpLiPfbYY155jRs3zuvWrVvovq4nXVdB69atc+OeMWNGxH3oNXo8/LZq1epyjwMAAAAAgK3B/46rfyuCDMAqoEwnZZopmymcMrr23XffYtt0XxlnwdJdle2GU7ZZmzZtQveVQaUSXGWBBbcFS3y1Vp/KRFu1auWyrFQGK8o4i8a1117rym392+mnnx7V63fbbbfQz8rA01j8cWp/KvlNSkqyitK89uzZs1jDFc3r+vXri2VjBschKlf1xzFo0CDLzs52Jagqu546dWqxMtZweq6yFisi/FwGx+FT9qHKin3KjJw/f76bO51z3VTKnJOT48qlRfu44IILXDmtSoB10xz451vzpPLbYBMXzdvmKGvu9biy8Q4++OAS96Hsy169erkyaR2XMgXLukb9cmplRkairMN169aFbsoWlMzV2RU8UgAAAAAAtk1V2yFhO6Vy1j59+tiIESM2KbdVQlx4V+D/JckVpyBZuPAAmfYTaZvKPEXrA6pRgm5aC1Dr9imoorFF21RCa8pp/bZwan4RPv5Ia7eVNs7gungVVdq8BreXNg51Fp47d64rudXafhdddJErxdb6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cOR2eO7++9//Jo+Lx5qtC/AHH3yADTbYwFTyMag899xzEYvFkvdvvvnmOPnkk01VJbsxM0BM3U+qqakxAecTTzxRcBsVeYvQf1g/VPeugh0CqjcuRY89u2Hwjv3hDnpQbVVj9Do74YA9Dix42yIiIiIiIiLLggJAWfoXncuFW2+9FT/99JMJhTg+HsOcVC0tLWYdhmfsssqwaPfdd8drr71mbo8++ijuuecePPvss2mPu/7667HGGmvgm2++wXnnnYfTTjstGfJx/D1ug1Vnn3/+Oe66666s3UQZXDGE/Pnnn3HLLbfg3nvvxU033ZRWXdavXz98+eWXZpw5BlRerzfn8X744YdYb7310pbl2gZDKwZxDNDYNZY3dmd1wjsGZmwvHvcdd9xhQsFUXIcBWSoGbDwe4vFcdtll5rm5bT5/IS699FLsvffe+OGHH7Djjjua45g3b565759//kmGq9xHHtfhhx9uwjseAx+3/fbbJ4+Lx5qJ2+B2119/fROS3nnnnbj//vtxxRVXpK3H64YB8hdffIHrrrvOHFNmmMsQkVWArY0V2NDQkHajaDwGj8+DIesPQfUK3eCK+pCYbaNbojtWLl4Vx+90IsacdokJmUVEREREREQ6g2XX90+WW6eeemrya1ayXX755TjuuONMoOVgxR3Dn6FD54+zxgpAhn4zZ840wQur91hB995772GfffZJPm7jjTc2YRqxiu+TTz4x4d0222yDd955x3QJZYjGAIyuuuoq7LDDDmn7d+GFFya/ZmXcGWecgaeeeioZUrJ67qyzzjKTehAr4VrD52M1YqrWtlFRUWFCO1a2OX777Te8/vrrJrgcMWKEWcZgbPjw4WnbZcVc5kQjrKLkNp1tM+B0ut4WigHjfvvtl2w7VliOGzfOBHv/+c9/zPYZ2jqBKM+Bg5WLDN1ae15eA6wKvf32200bsH2mTZtmgtqLL744OYYiQ94xY8Yk247rv/vuu+Y8O/r27WvaPperr77aBJqZbt3nDpSVly20vFd5L7gs/c1EREREREREOh/9NitLHUM7BjUMaBhGHXzwwZg7d67p4utgF1Mn/KOePXuaMC616orLMivgRo4cudD3zjhw/JezwzrhX7b1idV1m2yyiQmq+HzsAszAznH66afjyCOPxNZbb41rrrnGdHFtTTAYTOv+255tcN85Tl5qJSHD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26Yt22677fDVV18hGo1m7cLIrpgM6xiy5cLjCofD+PDDD00V17XXXmvCmlSsKrzhhhvMc3k8HhM8OpqamkwQxSCMlYncJwZXDH5SsQvsaqutZsLEiy66yDwX1919991NteJTTz1lgsoTTzwx+RgGVAyuWGX27LPPmtCHoWAh+Fx77LEHvv/+exx44IHYb7/9TFUeMbwi7jur9diF2sG243pvv/226eabDfeX4R2DqVx4HljdyW15vd60Y2N7vvTSS+bccj22o3MuWzsv3NdRo0aZLt7cBq9PhmoM14jB38iRI03QynV5Y8DqVIvymuAyrkcMXRncffnll+a4Wc3IIDnBEGwRXhM8JgapXJ+BJNuSweI+++yTXPfpp582XXevvPJKcyy9e/deKNy79957zTXIddiOV111lTmvDz/8cNp6G2ywAT766KOc54Lt2dDQkHajRCxubrGWKMJzmsx+e8r88PcshbvIC3exF8Xdy7Hx+iOx8cB1URaoMmMBdlu7HwZvswa2P3kf7HLIXiacFBEREREREekQbCnIF198wd5+9vPPP19wy/FxEydOzGvd9957zx44cGDO+1dccUX7yiuvTFv2ySefmOeYNm1aclldXZ1dUlJiezwe2+/32/fff3+rz7v66qvbl1xySc594vbfeeed5LJXX33VLAsGgzm3ucoqq9i33XZb8nse16677pq2zkEHHWQfffTRacs++ugj2+VymW1PmDDBPM/nn3+evP+XX34xy2666SY7H1z32GOPTVs2YsQI+7jjjjNf89xwnW+//TZtnUMOOcTu2bOnHQ6HW90+92PIkCELLefx+nw+cx68Xq95jkAgYM4X/fbbb2aZ8z3NmTPHLioqsp9++uk2z8tFF11kb7vttmnLpk6darbJdqNRo0bZp5xyStbzWVtb2+pxzZo1y6z3448/LtJr4q233rLdbrc9ZcqU5LLx48ebx44bN858P3LkyKznaM0110x+379/f/vxxx9PW+fyyy83j0112mmn2ZtvvnnO/RkzZox57szbzD/+toMzGwq+JeKJVo9fREREREREpL3q6+vN76z8tz1UAVh4YGr+ZXfHtrAbJ6u0nBuxW2TmMkfqcj6WVXOZy1Jl7kO2fWM3Sk5qwWouVkyxsosVaLmw2y2752688camEovVeJnYfdXBCi1yKvFYPXb22WdjlVVW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5ncHbkRpqd9sMx63UFlZhliM4wKy+s+Gy8XxAGHGCGT45/cHUFFRibKyiiV2nCIiIiIiItI1KQCUZW7GjBk45ZRTsMIKKyAQCKBnz57YZJNNcNddd6GlpSUtMGJY8vnnn6c9/tRTT8Xmm2+e/P7QQw/FrrvuutDzfPfdd+bxkyZNyrkv+T5HZwrt2B58vszbH3/8sVSe/6GHHkJlZeVCy7/88kscffTR6Ogyx/zz+cpbnR04d/jXsKDbL6v4KhYEgSGUlxeboC8cZpWhvWB9Gy0tDAI5IQhDRy8sy4PS0hqUllYt4SMWERERERGRrkZ9yWSZ+uuvv7DxxhubgOiqq67C6quvjlgsht9++w0PPPAA+vTpg5133jm5PgPCc845Bx988MES26el8RxL2/bbb48HH3wwbVn37t2X2f50hOfPR64JP5yuvE4AmNq1t7Xwb/44gPP/7sKvvd4oKioimD3bxoAB3TB9+ixT/efxuFFRUbog/APq6oIASjBgwAro1WvQUjl2ERERERER6TpUASjL1PHHHw+Px4OvvvoKe++9N4YPH25CwD322AOvvvoqdtppp7T1jznmGFOd99prry2xfcr3ORiocX8ZGK688sq44447kvdFIhGceOKJ6N27t7mflYVXX321uY9f02677WYq8Zzv6eWXX8a6665rHjNkyBBceumlJhB1/P7779hss83M/aussgrefvvtvI7J7/ejV69eaTe32521WjKz2pFfn3zyyTj77LNRXV1tHnvJJZekPaaurs5U87F6k/u22mqr4ZVXXsH777+Pww47DPX19cnKQ+exmV2Ap0yZgl122QWlpaUoLy8318PMmTOT9/Nxa621Fh599FHzWI6Ht++++6KxsTG5zrPPPmuun6KiItTU1GDrrbdGc3Mz2qOt2X4zZwcuJPwjfl1SUg2324uaGi/69KlhLIgDDlgP++23Dn76aRZOPnkrHHHE5mho8GKlldbA4MGrY9Cgwe06HhEREREREVl+qQJQlpm5c+firbfeMpV/JSUlWddhYJSKwc+xxx6L8847z1S1cZbUxS2f57j33nsxZswY3H777Vh77bXx7bff4qijjjLHccghh+DWW2/FSy+9hKeffhoDBgzA1KlTzc3p+tqjRw8TIHL7DOLozTffxIEHHmgeu+mmm+LPP/9MdpHlcyUSCey+++7o1q2b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/TLQ49dch0EgK/v4GHb5veuuu9CrVy9T+cexARn88T5OIJK5PREREREREZHWKAAUEcmCIRvDOSegy8QwjvcxAOS/2UJCPs7ZRmpox68Z/vExHM+ve/fuafcz9CspKTH/sltwt27dzPfU1NRkQkARERERERGRfCkAFBFZyhjqOTP8stsvuwJXVFQk73OCP2fcP67DsQIZGPJWWVmpcyYiIiIiIiJ58+S/qojI8oMBnc/nS87Em4kBHe93qvmcCTxSsesulzuBn4PbLC0tNWP5sSswsaqPVX5cl5WDnBjE6X7MINDpasygsHfv3kv46EVERERERKQrUQWgLIQBxIsvvtjpWmbQoEG4+eabl/Vu4KKLLsLRRx+9rHejy3j//ffNNcmusvlaf/318fzzzy/yczO0c0K8bBjMMcBzKvUy8XF8fGaA6FT/cVw/53uOAciZgZ3HMOjj1wwAOfOvs15NTQ169uy5yMcmIiIiIiIiy48uGQDOmDEDp5xyClZYYQVTVcNfljfZZBMzqL7zi7QTGPEX7M8//zzt8aeeeio233zz5PeHHnoodt1114We57vvvjOP5wydueT7HJ0ptGN7OFVNqbc//vhjqTz/Qw89lLUL5JdffrnMg7eZM2filltuwfnnn5+1vRjsDBgwAMcddxxqa2uX2n5dcsklWGuttZbodcNx7q677jqsueaaJsziuHUbb7wxHnzwQVO9trRD2HPPPTfn5BzLGisHWd3H/eP1wPZh4MduvlzGGysL+a9z3fBfrrP22mtnrUgUERERERERWW66AP/1118mdGBAdNVVV2H11Vc3v2j/9ttveOCBB9CnTx/svPPOyfUZEJ5zzjn44IMPltg+LY3nWNq23357E+yk4kQGy9Kyfn66//77MXLkSBP8ZmsvXos///wzDj/8cFPR9sQTT6ArYPi33Xbb4fvvv8fll19uXoOsbmPw/e9//9uEVtkCyCXlX//6F4466ii8+eab2GGHHdDRMMzj+wLbjaEev66vrzfLGWKzqpB/rLj44otNdSEn/mD34OHDh2PYsGHLevdFRERERESkk+lyFYDHH3+8qZb56quvsPfee5tfmBkC7rHHHnj11Vex0047pa1/zDHHmJDitddeW2L7lO9zMCDi/jIMWHnllXHHHXck72NQcOKJJ5qxv3g/A6arr77a3OeETbvttpsJEFLDp5dffhnrrruuecyQIUNw6aWXps1o+vvvv2OzzTYz96+yyip4++238zomVir16tUr7caqpGzVkpnVjvz65JNPxtlnn43q6mrzWFaopWI4xiCE1Zvct9VWWw2vvPKK6Q562GGHJcMS3pzHZnYBnjJlCnbZZRcz1hrDKF4PrNDLrIp79NFHzWMZxOy7776mG6bj2WefNdcPJ2lg18utt94azc3NOdvlySefTAuYM9urX79+2HbbbbHPPvvgrbfeSt7PSq/LLrvM3M91uV9vvPFGXuef2B5srx49ephj3XLLLU0Y51RM8rzze6fNuCzXdfPnn3+admPbs+3Ynfadd95Ba9juH374Id59912ccMIJZv95ve2///744osvsOKKKyYns+C5537yOFiZy8rNVHydrLTSSqbNt9hii6wVtp9++qm5brlO//79zTZTzwuvxR133LFdAatTgbekb+zay6CPbcxrjOeWX/O+6dOnm9fmxIkTMXnyZPOexnVGjRqVHDNQREREREREZLmsAJw7d64JVVj5x2qZbDLH8mLoceyxx+K8884zVVq5xvJaFPk8x7333osxY8bg9ttvN9VS3377ralg4nEccsghuPXWW/HSSy/h6aefNl0Gp06dam7EAIWBCgNEbt/pHsjqpwMPPNA8dtNNNzXBjtNFls/FoGH33Xc3XTUZUHJCAoZ1S8PDDz+M008/3YRDn332mQkOWTW2zTbbmP1i1RaDuMceewxDhw41VXM8ro022siETayMmjBhgtkWQ5NMDFcYRLL9WHnJ0JPhMIM3hogOtgm7wDJcZJdchoTXXHMNrrzyShPC7LfffqZbK0My7s9HH31ktp0NH//TTz9hvfXWa7NKleFeapDDbsM33HAD7r77bnP+Wa3KIHH8+PEmPGvt/HN/WPHGMJXhGYNMbmerrbYyla88Zu4Xn9MJ8rgOH5PtumG1GcOzK664woR0PFcMztnefO5sxo4da8JR7nsmHqdzrAx9n3vuObPNgQMHmrZl5SC7j3P/eUy8Jvl6YTdpBvlnnHFG2vZ+/PFH8xhWGrLikpNlMBzlLbUqdYMNNjDbz4VhJG8OXv/EINwZm29pYmjKIJfXEc8Bzyu7CnNfqqqqzDlbEu9PIiIiIiIishywu5DPP/+cyYz9/PPPpy2vqamxS0pKzO3ss89OLh84cKB900032bNmzbLLysrsRx55xCw/5ZRT7FGjRiXXO+SQQ+xddtlloef79ttvzfNNnDgx5z7l+xz9+/e3H3/88bTHXn755fbIkSPN1yeddJK95ZZb2olEIuvzcD9eeOGFtGWbbrqpfdVVV6Ute/TRR+3evXubr998803b7XbbU6dOTd7/+uuvZ91WKrYHH+e0KW977rlnzrbKPFZ+vckmm6Sts/7669vnnHNOcr9cLpc9YcKErM//4IMP2hUVFTnbmt566y2zj1OmTEneP378eHNs48aNM9+PGTPGLi4uthsaGpLrnHXWWfaIESPM119//bVZf9KkSXY+nOsh9Tkz2ysQCJh1eLvxxhuT6/Tp08e+8sorF2qT448/vs3z/+6779rl5eV2KBRKWz506FD77rvvTh7rmmuuudBj2zrXjlVWWcW+7bbbct5fVFRkn3zyya1uo6mpyfZ6vfbYsWOTyyKRiDn26667znx/3nnn2cOHD087Tl4X3M/a2lrz/UEHHWQfffTRadv+6KOPzDUTDAaTy/773/+aZfF4POv+sE2cc5F64/PwMcv6luu1LiIiIiIiIsuf+vp68zsr/22PLlUBmKvKb9y4caaq7IADDkir+EkdO+7MM880VWWslloSWnsOVjCx8umII44wVX8OVq2x6odYIcfqOI7/xWqt0aNHm66krfn6669NdSCr2RycWCAUCpnxxX755RdT0cVupw6OX5cPds288847k9/nqrjMZY011kj7nt0fZ82alZxchfvEbqDtxWNj11DeHKzs4tiQvI/dWp3qzLKysqz7wcksWEXHrpesOGN777nnnqYaK5tgMGj+ZdVcrvZiu993332mMu+kk05KVp5NmzbNVECm4vdON97Wzj/PMyvG2EU5c39Y4VgodqVll2FWRXK/eB1yW+xSnQuzxFwz5Tq4L5zsIvU4WRnISj2eE+K/G264Ydq2Mq9JHi8rBll1mPr8fI2zyyy70RO7B3MZX/P8OhMrclmF6uB54PXC1wcr75YFHge7e/N1yuuI7cDKTHYLb6t9RURERERERHLpUgEgZ/3lL8m//vpr2nKORUbZQgAHgwCOuZc67p6DXfA4DlcmjlNHTkjXllzP4cxUym7AI0aMSLvP6Za5zjrrmHDj9ddfN9042VWVXS45Rl0u3C6DHHapzMRwIVtX1nxDBgZ+bO9M7KKYud1sM8BmjmPG53Xa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M888EyeffLKaX0REREREZAmwYSHg8aAqEJgfBjLoY0Wg220mB6FGy0JTPI4Eu/FyfD4AM7jc40EpuwvX1KC0Z0/4amrg7dEDRQMHoGLgQPi6dcMKa60Ff1ERXD6f6fIbqKlGea/eKO7RAyU9eqCsWzdUVlejrKoKZdXV6N63LwatvDK6DxmCyr59UdKtGzxlZSjr1cvMKmxZFjyBgKlYdPBrzgCc+XVXpQBQFsmhhx6KXXfdVa2Y4uyzz8YFF1xgxj+ghx56yLzZOLeePXtip512wvjx45dau73//vvmuevq6tKWb7755jj11FMX2/M899xzZpsVFRUoLS3FGmusgcsuuwzz5nEOqKV7Dh588EFMnDhxqT6viIiIiIjI8oBj5oUTCdMdOOBym8q+bsXFpuqOlXT8/ZP1dg2AGduv0eWC2+1GldeLclYK+nzoNmAABqyxBgatszZ6DhqEqgED0WuNNdCNBTU+H8DHeL2Il1cgXlYOlJfDVV6Oin79UFJevnB3XssylX4MBUsZDFZVoaKqCgm32wR8fnYN5liAsZi58WsuS/26K1MAKLIYffrpp/j999+x1157pS0vLy/H9OnTMW3aNLz66qtm9qJ//etfiEQiXab9GXrus88+WH/99fH666/jp59+wg033IDvv/8ejz766FLdlx49emDbbbfFXXfdtVSfV0REREREZHlQygDQthFZMBagb8EkGy6Px3Tb5fh93UqKUVNaiu7l5SgJBEwQV1ZaiurSUvh9PsTKy+GuqjbdgeO9eqN0yGD0X2tN9FtlFUSrqkwAyO3VDBmMQWutif4rD0N1376m8i8z/MuF6xWXlQF+P0KxGFycHMTlMjMI82su431cJ99tdlYaA1CWqBtvvNFUYv3111+orq42lW/XXXedqQ5zquNYgfbYY4/hjDPOwNSpU7Hjjjvi4YcfxrPPPosxY8agvr4eBx54oOnyy78YOBobG7H//vvjpZdeMgHbeeedh5NOOil5P4O4I444AuPGjcOQIUNwyy23LLR/55xzDl544QX8/fff6NWrFw444ABcfPHF8Hq95n6GV9y/r776yrwZrLjiirj77rux3nrrZT3eJ5980gRPHHQ0FR/L7VPv3r1x2mmnYeedd8aECROw+uqrJ6vn+Nx//PGHWYfHwjZx3HHHHbjppptMG7HCbtNNNzVtRByA9frr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gwaZ58q8nXDCCcl1Dj300IXu33DDDTvlOYvFYrjwwgvN9VdUVIQhQ4bgsssuQyKRSK6TrT14u/766xeprXkOM7fZq1evtHWef/55bLfddujWrZu5/7vvvkNn8OGHH2KnnXZCnz59zH6/+OKLaffnc/3ec8892HzzzU17cht1dXULPc8333yDbbbZBpWVlaipqcHRRx+NpqamnPsVjUZxzjnnYPXVVzfPzf07+OCDMW3atIXW/eyzz7Dlllua9bh97kswGERnaud8rl0eV+b9++677yK1M3GOO55n7htfW3ye8ePHJ++fN28eTjrpJAwbNgzFxcUYMGAATj75ZNTX16Ojvf+uv/76KCsrQ48ePbDrrrtiwoQJBb9O83mP+O2337DLLruY7XCdjTfeGO+9916r+9fWOZ40aVLOdZ555hl0pnamX375BTvvvDMqKirMuvzsmTJlSvL+Y445BkOHDjXXHNua7fnrr78ucju39bnXWa5nuvPOO7HGGmuYY+dt5MiReP311/N+7eZ7TRXazvm+P8+YMQMHHXSQ+bzkeuussw6effZZdLZ2zudnqXw+B9tzPbd1jvN9LXWGdub7LNuax8rX5vbbb4/ff/89bRttfQ6+//77Oa/5L7/8Mue+LamfH6VzUwAoIsu1p556ygRbF1xwAb799ltsuumm2GGHHdJ+oF+e8QcL/gDIH25SrbTSSrj99tvx448/4uOPPzbB3bbbbovZs2eb+5ubm833/EHj//7v//DJJ58gEomYsCA13Mr2fNOnT0/e3n77bbN8r732SluPP0Clrvfaa6+hM7r22mtx1113mbbkL5bXXXed+cHstttuS66Tepy8PfDAA6Zd99hjj0Vqa1p11VXTts3zmYrb5g/z11xzDToT7veaa65p2jWbtq5famlpMdfZ+eefn3Ub/KWQweEKK6xgwsM33njD/ALDH/Rz4TYZZl100UXmXwY3/OWJgUJm+Mfn5j6NGzfOvC5OPPFEuFyuTtXObV27jqOOOiptvbvvvnuR2pn4WrrxxhvNvrH9+Ms6Q8TGxsbkdnn797//ba6Dhx56yGz7iCOOQEfywQcfmD+AfP755+b9kH804HXBts/3dZrve8S//vUvs32u8/XXX2OttdbC6NGjTeCRS1vnuH///gutc+mll5rghJ+1namd+YvyJptsYv54wF/Iv//+e/Na5h8PHfwj4oMPPmjez998800TdHA78Xh8kdq5rc+9znI9U79+/cy1+tVXX5kb/9DBcMcJgNp67eZ7TRXazvm+PzP8Yzj80ksvmbbefffdsc8++5ifITtTO+fzs1Rbn4PtvZ7bOsf5vpY6ejtzn/nHhL/++gv//e9/zTUycOBA85mW+t7S1ufgRhtttNA1f+SRR5qfXdZbb72c+7Ykf36UTswWEVmObbDBBvaxxx6btmzllVe2zz33XHt519jYaK+44or222+/bY8aNco+5ZRTcq5bX19v8yPlnXfeMd+/+eabtsvlMssd8+bNM+twe/nicw4dOtROJBLJZYcccoi9yy672F3Bv/71L/vwww9PW7b77rvbBx54YM7H8Ni33HLL5PftbesxY8bYa665Zl77OXHiRLO9b7/91u5suN8vvPBCq+tkXr+p3nvvPXNfbW1t2vK7777b7tGjhx2Px5PL2D5c9/fff897/8aNG2ceM3ny5OSyESNG2BdeeKHd1do589qltt5b2tPOfL/o1auXfc011ySXhUIhu6Kiwr7rrrtyPtfTTz9t+3w+OxqN2h3VrFmzzLF/8MEHeb9O83mPmD17tvn+ww8/TK7T0NCQ83VRyDnOtNZaay30vtcZ2nmfffZp9b05m++//95s548//likdm7P515nuJ4dVVVV9n333dfu127mNbW4ruds788lJSX2I488krZedXW12f/O0s6FXlO5Pgfb087tPceZr6XO0M4TJkww+/zTTz8l74vFYuZ6uffee/P+HMwUiUTM5+Jll11W0H4trp8fpXPrWH9KFhFZivhXLv61kn/9SsXvP/300+X+XLAagn/Z5V8q22pHVgmySxSrgSgcDpu/KPr9/uR6rJJgBRMrrvI9P4899hgOP/xws61UrL5gNy1WcvGvprNmzeqU54vVJO+++66pMiBWlLB9dtxxx6zrs1vGq6++mlbVsShtzW4o7JbCLsjsbsK/Ui9vsl2/+WC7+3y+tKo8dlWifK9xYhc9nj92byVey6x04/XNv/r37NkTo0aNKmibHVG2a9cxduxY032MFalnnnlmWhVIe9p54sSJpvok9b2drw+2Y2vv7TwX7ALl8XjQUTldOqurq/N+TD7vEexaPXz4cDzyyCOmKoQVPaxA4fXHSpxFPccOfuayi3JHrExrrZ1ZDcNj42cOu1vz9TlixIiFur2nYjuygonvr6xaW9R2LvRzrzNcz6zmevLJJ01bsOtke1672a6pxXE9Z3t/dj632XuE3a55XXD/+RpjN87O0s6L62ep9rRze85xttdSZ2hnXheUWiXsdrvNZ1rm51drn4OZWH06Z86cNivhl+TPj9KJLesEUkRkWfnnn3/MX7k++eSTtOVXXnmlvdJKK9nLsyeeeMJebbXV7GAwmPOvky+//LL5S7hlWXafPn3MX8pTqyfKy8vNY5qbm+2mpib7hBNOMO199NFH57UPTz31lO12u815SvXkk0/ar7zyiv3jjz/aL730kqliW3XVVc1fkDsb/iWc1aZsQ4/HY/696qqrcq5/7bXXmr8sO+dlUdr6tddes5999ln7hx9+SFZ59uzZ054zZ85yUQHY2vWbT+UD/6LPc3bdddfZ4XDY/NWc1Ztct7VzmIrncd1117UPOOCA5LLPPvvMbIMVAg888ID9zTff2Keeeqqp5Pntt9/szloBmO3apXvuucdcf3w9831n0KBB9tZbb71I7cz3dN6f+d5x1FFH2dtuu23Wx/C6HzBggH3BBRfYHfn9YqeddrI32WSTrPfnep3m+x7x999/m+uRrwm+9/J1UchrPtc5TnXcccfZw4cPtzuybO08ffp0017FxcX2jTfeaNrl6quvNm31/vvvpz3+P//5j3lv4frsUZBZsdSedi70c6+jX8/83GEb8fhZ+fXqq6+2+7Wb65pa1Os52/sz1dXV2dttt53ZT7438bX11ltv2Z2pnQu9pnJ9DrannQs5x229ljp6O7NSb+DAgfZee+1lPrv4Gcb3DR5P6rG29TmYaYcddjC3QizOnx+lc1MAKCL28h4Afvrpp2nLr7jiCnvYsGH28mrKlCmma8F3332XXJYtAOQPCuyCx8CCXW/4A8vMmTPTuhYMGTIk+UMhu06ts8465of1fPCHo9GjR7e53rRp02yv12s/99xzdmfDH/T69etn/uUPkOxWxODnoYceyro+r8sTTzxxoeWL2tbO+WQAeMMNNywXAWBb128+v/iMHTvWtBnbnAHdmWeeab7nD9pt4S8G7I6z9tprp3W/cX45Ou+889LWX3311Tv00ARtBYC5rt1MX331ldnW119/3e52dtqQ7w2pjjzySPOLeya2P7tdb7/99ua8dFTHH3+8+WVy6tSpWe9v7XXa1nsEQ6+d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2W3/119/XaR2zudzr7Ncz8QxV52fuXhM7C6ZOolGW6/dfK+pQts53/dnjknHz0ueZ74/53pP6sjtnO/PUvl8DrbnfaOtc5zva6kzXM/8YxX332ln/kEv9We8fD8HiUFpa0MOtOf9OZ/PBulaLP5vWVchioiIiIiIiIiIyJKhMQBFRERERERERES6MAWAIiIiIiIiIiIiXZgCQBERERERERERkS5MAaCIiIiIiIiIiEgXpgBQRERERERERESkC1MAKCIiIiIiIiIi0oUpABQREREREREREenCFACKiIiIiAB4//33YVkW6urqcrYH73/xxReXentdcsklWGuttZb683YGS6NtBg0ahJtvvhlduS0mTZpkru/vvvtuse+XiIgsewoARURERETyNH36dOywww5Lvb3OPPNMvPvuu0v9eaVz6QjXyeabb45TTz214HBdRESWLM8S3r6IiIiIyFJj2zbi8Tg8niXzY26vXr2wLJSWlppbe0WjUXi93sW6T7LsRCIR+Hy+xX6dLO+vbxGRrkwVgCIiIiJiqnZOOukkU7lTVVWFnj174p577kFzczMOO+wwlJWVYejQoXj99dfTWuvnn3/GjjvuaEIHPuaggw7CnDlzkve/8cYb2GSTTVBZWYmamhqMHj0af/75Z1qQceKJJ6J3794IBAKmq+XVV1+ds0siK4i4jBVFqZVFb775JtZbbz34/X589NFHJii47rrrMGTIEBQVFWHNNdfEs88+m7bvr732GlZaaSVz/xZbbGGery2pXYCd/Xv++efN44uLi83zfPbZZ21u4+677zZtwccMHz7cPOaPP/4w56GkpAQjR45Ma6dsXTsfeOABrLrqquaY2X5sx9TnuOuuu7DLLruY7V1xxRVm+Z133mnOI8OjYcOG4dFHH03bJp9nwIABZpt9+vTBySefnHauzj77bPTt29dsc8SIEcnz4Pjkk08watQoc1y8jrbbbjvU1taa+8LhsNlejx49zLnmdfHll18mH+ucS1aw8VxyGxtttBEmTJiQ9hzXXHONudZ4TR5xxBEIhUJp93M7G2ywgdlHXncbb7wxJk+ejMVpypQppm153ZeXl2PvvffGzJkzzX319fVwu934+uuvzfe8Fqurq7H++usnH//EE0+Yc+b4559/sM8++5g24+uE2069Hg899FDsuuuu5rXB88LrNpvM66Q9bfHrr7+aduc54vWVeY5be81zPz/44APccsst5lzyxuPg64N4fFzG9Zy2ae11muv1LSIihVMAKCIiIiLGww8/jG7dumHcuHEmDDzuuOOw1157mTDgm2++MWEOf9lvaWlJdodl2MPA4auvvjJhH0MQhiEOBoinn366CXoY7LhcLuy2225IJBLm/ltvvRUvvfQSnn76aRP0PPbYYyYELBSDKYYjv/zyC9ZYYw1ceOGFePDBB03gNX78eJx22mk48MADTThBU6dOxe67726CDAaMRx55JM4999x2XQkXXHCB6XrJ7TCY2W+//RCLxVp9zOWXX46DDz7YPGbllVfG/vvvj2OOOQbnnXeeaUtKDfQy8bhOOOEEHH300fjxxx9NG66wwgpp64wZM8YESbz/8MMPxwsvvIBTTjkFZ5xxBn766SfzfAx333vvPbM+g5ebbrrJhJO///67CTpXX3315Pa4LgO+J598Ej/88IO5NrbffnuzLvFYttpqKxMaMdD8+OOPsdNOO5mKLeccPffcc+Y64/XE/eU1NW/evIXa84YbbjDtwEov7ruD1wmP68orrzT3M0S74447kvez3RmU8brkPnI/2EYMkRYXhlZ8Du43r6e3337bhLUM8KiiosK8JpzgjPvh/NvQ0GC+5n3cR+LriQEZA7UPP/zQtBu/ZtsydHXw9cPrm8/3yiuvtLmf7W2Ls846y1wj3377rXnt77zzzpg7d25er3kGfwyvjzrqKLMub/379zfnnfga5zKuR229TnO9vkVEpB1sEREREVnujRo1yt5kk02S7RCLxeySkhL7oIMOSi6bPn26zR8fP/vsM/P9RRddZG+77bZpbTd16lSzzoQJE7K26axZs8z9P/74o/n+pJNOsrfccks7kUgstO7EiRPNut9++21yWW1trVn23nvvme/5L79/8cUXk+s0NTXZgUDA/vTTT9O2d8QRR9j77bef+fq8886zhw8fnva855xzjtkWnyMX3v/CCy+k7d99992XvH/8+PFm2S+//NLqNi688MLk92xPLrv//vuTy5544glzDI4xY8bYa665ZvL7Pn362BdccEGrz3HqqaemLdtoo43so446Km3ZXnvtZe+4447m6xtuuMFeaaWV7EgkstD2/vjjD9uyLPuff/5JW77VVluZtiS27cYbb5x1f3hOvF6vPXbs2OQyPg+P47rrrks7l++8805ynVdffdUsCwaD5vuRI0faxx57bNq2R4wYkWybuXPnmvXff/99e3EaOHCgfdNNN5mv33rrLdvtdttTpkxZ6LyPGzfOfH/66afbo0ePNl/ffPPN9p577mmvs8465niI7XznnXear3nehw0blnYthsNhu6ioyH7zzTfN94cccojds2dPs7w1qddJoW3hXM/XXHNNclk0GrX79etnX3vttXm/5vlecsopp6St45zb1NdWPq/TbK9vERFpH1UAioiIiIiRWlnDLozsiphaAcbufjRr1izzL7s4snrMGXeMN1azkdN9lf+yuo1d/NhVcvDgwckulMSugKwcY3dUdg9966232nU22D0wtYsiu4Vus802afv2yCOPJPeLlUQbbrhhWjUUK5cWtd2cbp1OG+XzGKddM9uax+BUjKXitqdNm2aq7fJtE+eY2QU0Fb/ncmJFXzAYNOeKFVysGHQqGVmxx1yRFY6pbcpKLadNnQrAbLgOxyFMfX6OScjuqc7z59OeXDfzPKV+z662vKZYWcjqQ1aaseIsF07o4hwLKxfzwX1gVRtvjlVWWcV0sXWOhV252VWVla5sI37PG7+eMWMGfvvtt2QFIF9H7P7NLs3OvvA4eP5Tu4Hz+sg27l8uhbZFtvZkBSavI+e48nnN5yuf12mua1lERAqn0VNFRERExMicJILhWOoyJyxzuu/yXwYL11577UIt6AQ3vJ9Byb333mvGLuNjVltttWTXxnXWWQcTJ040Ywu+8847pivh1ltvbbqjsrswzS9om48hUjYc48zh7N+rr75qxqtLxTHEMre5qFpro0Iek+92OFZaPlLbJHO7DraDs4zniV002cWU5+L444/H9ddfb0Ir7oczrh3/TeVMOtHafjnt3drzL0p7pmKXUobJ7J761FNPmW6mPCYGvpnuu+8+E3pmPm9rsu1z5vLNNtsMjY2NJjhlEMgu32zfq666ynSf5TiIHPvRObZ1110XY8eOXWib3bt3b/V8Ls62aE3qeWjrNZ+vfF6ni3LsIiKSThWAIiIiItIuDO84bhfH7ON4bqk3/sLOccNYOcTQgZVhDDycCSFSsTKQ46cxJGRIwfHCOL6aE36kVi2lTgiSC6uxGCCwyjBzv5yqLa7z+eefpz0u8/uOipVibHOOCVcItj/Hl0v16aefJoMoJ8TjmG8cm5Hj1HHcOI4huPbaa5ux/FiJl9mmzszIrNzLtU9cj9Vrqc/PMJfjyKU+fz7HkM954/5yPEUeHwPnxx9/POv2GDw5xzFw4MC89oHXDq8tjiOZWs3GyT+cY3HGAbz99ttNeMbHbLrppmZcPY7f51T/Oa8jjqPIUDCzbbmdRZVvW2RrT1aAMvR1qvzaes0Tz7Mz7qPDqVxMXZ7P61RERBYfBYAiIiIi0i6chIJBHSe94MQhf/31l+nCy0kb+Iu+M6MpZxNmF8f/+7//MxOCpOKkE5xUgjOPslvkM888YwIldqdkGMVKJc76yoCFEyQwTMwnIOOkHJxQgBNOsDshg5f//Oc/5ns69thjzXLuD6veGIo89NBDneZK4GyvnCiDQR3DI1aa3XbbbW1O7sBj5OzAfMyNN95oZjBmWxHvu//++80EITyXnCGY54DBGLv+HnDAAWbiEj6GVZuc2IWVYJxNmRgycRkrBznpBM8pJ3fgDLEMhzipDPeB1Wg8n+xmzAkwOJNvvjiJCWc/5o3XCycEYSDl4H5xPxhccrZbXo9cr5CQsS2sUGXYyfZgu/PaZ7sw1Evtqsouv5zUhssZAvL1wNCLITfvc3A7nHyHE7awWpDHwKpLHuvff//d7v1sb1vwdcLu3zx/fI0ztHcmYmnrNU8MB7/44gsz+y/PPSv9eA2xDRh+zp49G01NTXm9TkVEZPFRACgiIiIi7cIuvZwVlr/4c5wxVhcxtGDVErvv8sZwjxVEvI+/6LNLaWb3UYZIDE7WX399ExowUHK6/zLoYaUY7+e2r7jiirz2jV0uL774YjNzKAMP7t/LL7+cHINwwIABptKQy9Zcc00TirF7ZmdxyCGH4OabbzYz4HLsutGjRydn482FM8JyHDieAz6Gs/2yi6gTRjF0ZRUmx+lzqvnYPgxxiesy6OIMsRyzkZWCDHqcai2GhAyDvv/+ezO2H8eS++9//2vGkSMGuXvssYeZSZqVZAyF33zzTROM5YuVojyv55xzjuk2y2CLwaKjuLjYBFd8Hu4PZ73lbMqc8XhxYZDFGZK53+zqy0CQ4yYy2EvFmX352kgN+xgGcllqBSD3meE2r0nOTM3rlYEauyazOra92tsWPE98TfJ1wUCS55ABZT6veWKox27iDDtZxcsKP1ZaXnrppWambY5v6cxw3dbrVEREFh+LM4Esxu2JiIiIiIiIiIhIB6IKQBERERERERERkS5MAaCIiIiIiIiIiEgXpgBQRERERERERESkC1MAKCIiIiIiIiIi0oUpABQREREREREREenCFACKiIiIiIiIiIh0YQoARUREREREREREujAFgCIiIiIiIiIiIl2YAkAREREREREREZEuTAGgiIiIiIiIiIhIF6YAUEREREREREREpAtTACgiIiIiIiIiItKFKQAUERERERERERHpwhQAioiIiIiIiIiIdGEKAEVERERERERERLowBYAiIiIiIiIiIiJdmAJAERERERERERGRLkwBoIiIiIiIiIiISBemAFBERERERERERKQLUwAoIiIiIiIiIiLShSkAFBERERERERER6cIUAIqIiIiIiIiIiHRhCgBFRERERERERES6MAWAIiIiIiIiIiIiXZgCQBERERERERERkS5MAaCIiIiIiIiIiEgXpgBQRERERERERESkC1MAKCIiIiIiIiIi0oUpABQREREREREREenCFACKiIiIiIiIiIh0YQoARURERERERERE0HX9P5iN6pgVassdAAAAAElFTkSuQmCC" width="854"></p>
   <p>Because some of the checked categories perform so astronomically poorly, we have a version of the graphs that are logarithmic, which are the two following graphs:</p>
   <p><img height="480" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABQAAAALQCAYAAADPfd1WAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjgsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvwVt1zgAAAAlwSFlzAAAPYQAAD2EBqD+naQABAABJREFUeJzsnQV8G8fWxY8YTInDaaApc5syM2PK+JX7ysx9ZWZm7usrM74yM1PKbVIKg9ni/X5nnJXltWRLtszn36cXa3F2Zu7u7NG9c12WZVkQQgghhBBCCCGEEEL0S9w9XQAhhBBCCCGEEEIIIUTXIQFQCCGEEEIIIYQQQoh+jARAIYQQQgghhBBCCCH6MRIAhRBCCCGEEEIIIYTox0gAFEIIIYQQQgghhBCiHyMBUAghhBBCCCGEEEKIfowEQCGEEEIIIYQQQggh+jESAIUQQgghhBBCCCGE6MdIABRCCCGEEEIIIYQQoh8jAVAIIYQQQgghhBBCiH6MBEAhhBBCCCGEEEIIIfoxEgCFEEIIIYQQQgghhOjHSAAUQgghhBBCCCGEEKIfIwFQCCGEEEIIIYQQQoh+jARAIYQQQvRa7r33XrhcLnz22Wctls+ZMwerrroqSktL8eqrr3bZ+V988UWce+65WdexXEcddVSnjj9z5kycdtppWH755c21BINBLL744jj22GPxyy+/pLdjGXi+/givK5/PW2+91elzNTQ0mLosxrGyseGGG5qyLrLIIrAsq9X6d955J3097Nv9halTp7Zqr/Lycqy44oq49tprkUwme6xsBx54ILbccstWZb3yyivb3fell17CNttsg2HDhiEQCGDs2LHYb7/98P333+fc57333sOee+6JcePGmX1KSkqw7LLL4sQTT8SPP/6Yc7+ddtqpzXsK+2xm/Xo8HlOu7bbbrtX9key///7mnpJ5H23vs/DCC7e43/A+m43lllvO9PVM7GPwvNk4//zz09uwDbKVM5NUKoX7778fm266KYYOHQqfz4fhw4dj2223xXPPPWfWt0V9fT0uu+wy0wfZF8vKyrDoootit912w9tvv91q+99//93U/RJLLIFQKIRwOGza7cwzz8Q///zTqTZ7/PHH2yxrW22SWZ9nnXUWVl555XavXQghcuHNuUYIIYQQohfy999/Y7PNNjPi2WuvvYY111yzSwXAm266KacI2Bk++eQT8zJLoYgvkGuttRb8fj9++ukn/Pe//8Xqq6+O+fPno7/z4Ycftvh+wQUX4M0338Qbb7zRYvkyyyxTFAHwvPPOM387BYxiQaFhypQppvybbLJJi3V33323ESNqamrQHzn66KOx1157mb+rqqrw7LPP4vjjj8dff/2Fq666qtvL8+WXX+K+++7Dxx9/XPC+p5xyCq644gojHt58880YMWIEfv75Z1x99dVGhHnwwQeNAJQJxaKLLrrI2DL/ppifSCTwzTffmHJwX36neJfJrFmz8Pzzz5u/H3jgASNO8seAbFx88cXYaKONEI/HzfWxP2+wwQb46quvzPmyQRHTaWcs4y677GKESRsKlp3t+4899hhuuOEG87cN73EUIfPt+5FIBJMmTcIrr7yCPfbYA7fccgtGjhyJ2bNnG1F21113xSOPPIIddtgh6/4UnDfffHN8++23OPnkk829lPBHFYqH7777rqkzG9Y9z0OhkffiiRMnGvGN+9NmX3jhBVPXHW2zfHC2hQ1FXpuTTjoJN954o+lLBxxwQIfPJYQYwFhCCCGEEL2Ue+65h25U1qeffmq+//zzz9a4ceOsUaNGWd98802Xn//II480588Gl3N9R6iurrZGjhxpjR071vrrr7+ybvPYY4+l/z7nnHNylqOnqa+vL+rx9ttvP6ukpMTqCmbPnm3qkfXZFWywwQbWsssua6255prWXnvt1WJdTU2NFQ6HrUMOOcSUgX27L9HQ0GClUqms66ZMmWKu6Yorrmi1br311jP22hPstttupi3yLavNgw8+aLY5/PDDW62rq6uzVlllFdOWv/32W6t9DjvssKz1xGU33nijlUgkWq1jWbjvNttsY/594IEHWm3z5ptvmnWZ9wVy3333meVnn312QXbU1v3Lvt/QXrLBPs6+7jzePvvsY4VCIev2229vse61114z6+2+zzZoq5ysd27Ha8sGnwNff/11zmt74403zP5333131vXJZDL99++//27OP3HiRKuqqipruz3xxBNFbbPOPEuOOuooa4kllshpi0II0RYKARZCCCFEn4AeLuuuuy68Xq8Js2PYbCZ2KNmvv/6Krbfe2vzNkD16VUSj0VZhWc4wUDs00A7N5PHo/UcyQ7Iyw9cIw9SWXnppEzLGcDPbK6Qt7rjjDsyYMQOXX345xowZk9MjpC0YBsb9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caLZhteSb1sVmgU4F9myADOD60EHHWQy3rIfrLvuuta7775rjpeZbTVXVtG2Mjk74XE33njjdBsxA+pzzz2Xt93lmwWY7cS+edxxxxl7K7TvZmL3xcMOOyyv8tjnWHjhhVtlG24rY7GzDl988UWTcZl9ieVcaKGFrP/7v/8zWZ1zwSyzu+++u8mqzH3YnszSy6zEth3wfsW2XmmllXIeh9mDeYzll18+r4yytLvBgwdbVVVVRcsCnMvO2cdzZQFui3yyAGde/3333Wf6Ku/TXq/X3Ie32mor68EHHzTtmwv2ozPPPNNky2W2de5bVlZm6uiGG25okZXa5rfffjN9hfdf3htoG2y3E044wZS3M22W62Nnom9rG16DM7sx+xWfHUIIUSgu/p+UUCGEEEIIIURvhN6CDLulpyLnccuXq666ynjkMZSac+UJ0dfhHKf0cKZXtBBCFIoEQCGEEEIIIUSv48svvzQZWg899FATZp5POHUmDANfeumlTQhxb0mQIURHeeedd0xYNUOTM8PPhRAiXzQHoBBCCCGEEKLXwXnXZsyYYbyeOMdjoTC5Defeo5AoRF+H8/8xMYrEPyFER5EHoBBCCCGEEEIIIYQQ/Rh3TxdACCGEEEIIIYQQQgjRdUgAFEII0W85//zzscwyyyCVSrVaN2fOHAQCAbhcLnz22WfdVqZ7773XnHPq1KkdPsY333yDAw44ABMmTDAhbqWlpVh55ZVx+eWXY968eentNtxwQ/Ppzfz999847rjjsMEGG2DQoEGmblhHTlhfXJfrs+WWW+Z1vocffhgrrbSSqbfRo0ebc9fV1RWUjGCppZYyfYf1f9555yEej+e175lnnoltt90WCy20kCnz/vvvn3W7hRdeOOd1stwdvSYu4zpuw225D/fNxhdffIFNN93U9C22y0477YTff/+9zevjvFRt2dSsWbPMNQ8dOhThcBhrrbUWXn/99TaP2djYiCWWWMIc88orr0RvwdkffT4fhgwZgtVWWw3HH388Jk+ejN7Eueeea8pZLKZPn276M9uQ7VleXo5VVlkFt99+O5LJZJv73nnnnaYs7FuF8Mwzz5j7BM9VUlJikoHwfPnAvss+zL7M82622Wamj/c1eK+5+uqrsfzyy5ukJryetddeGx988EGH7bKjNDQ0mH711ltv5bX9zz//bOZhZD9huSsrK828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5XEyw2rJIYccYkKx/vjjjxahNAylbGxsTG9XU1NjVVZWWptuumnOEGCWh9swLM4ZarTiiiumw514Ldxvjz32yLse2gsB5jkYVnX++edbQ4YMaRFuxJAYhrza10h4bSzroYce2iJclKF8maE7PC5DtQoNdS4kBJghkQzfWWqppfI6NkN1eezp06e3WscwqSWWWKLN/dnmDLHKBvd1huG2RyEhwLvvvrsJ/f777787fE2LL764tcUWW7Tabtq0aeYYF198sfn+/vvvm+8PPfRQq225DddxH5sbbrjBGjx4cNrW7P7tDDVkKFlmv7FhiJ8zNPnLL78027/00ksFh+7deuutZttHH3006z3hlVdeSS/j9xEjRhg7teF10LYvueSSNs+TT5nYbtxm5syZOfsw7W+TTTaxdtxxx1bHXnTRRVuF1t15550twuouvPBCYwPbb7+9dcABB5hl3If964wzzmgVYpdJvjaeLy+//LKpu+OPP77Vup133tlae+210/eYQkKAaXdlZWWmn914443WG2+8Yf373/82NrHXXnu1ue8///xjrjtbe7LPOcNM88G+b/7nP/8xZcgMRbSfGa+//nqLfew25T09M4z02muvNcvZfpkcd9xxZrkdhs+wX37ns4v3VvZv1vcuu+xilt9+++0t9s/XLvMhVz8tNAQ4G3fccYc5BkOUO3q/cPL1119boVCoRVkJ71u8j7PuGILL8EuOA3g8lqNQCp2yIle5ilFf9r2bYxCu54d98/LLL+/QPayzdtPWvYDl2njjjVssoy3xecYpE2jfl156qbkP8f6c+dxjeWw7YCgwnxFPPPGEtcIKK5h7Geu4vXPV1tZaCy+8sHX66aenl+UKAX7++edNX/z222/N9zfffLPdEGDaBY83bNiwNsOfX331VXOs//3vfzm3EaIrkAegEEKIfgd/Aecvv/TMckLPN2boozeVDf+2wyydlJWVtfKgsCf9d3rJ0MMoM9yG+9K7g9vlyoZHDyF6XOy3337GU8j+8PicsJuTbRczCQJ/lWd2V4aZ8ZdveosxTIwek86QM050nhnywmvjr/n0RrNhSB+9kjLrmp6PDMvtSuh9wjAwep8UQq6J1/PJkNrWNsXMsJoJ+wbDi9kXGNJayLmdywspfz7bsh8wIQM9oeix0R75HJN9n/bIhCf0gO1I/2boHT11M7FDE51h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1VbDOuusY77ffvvt6f3pJVhfX48XXnjBfKegdNhhhxkvQJs111wTK6+8Mm6++eas5YpGo+ZjU1NTY8rw1/QpxhNR9AxloUEmjFgIIYQQQgghRPfDd+OKigpUV1d36N1YcwAKMYBZYYUVWnwfNWoUZs2aZTz0KLrZ4h9ZZpllMGjQILOOAiD//de//tVif4qC1113XYtla621VqvvX331Vc4yXXLJJTjvvPNaLff6veYjeobGZFO25JCnTF5/QgghhBBCCNHH0Nu0EAMYn8/X4js99uww0mzzujmXO7fJtZ+TtrY5/fTTccIJJ7TyAPx4xhMoqQ/B42qe08557qSVgNfd8poySaTi8Li8Oc+fNCGx0Dly1BXDiNcatTvCXnliCiGEEEIIIURfQgKgEKIV9PZjEpC//vqrRQgwXY2XXnpp853/vvfee9h3333T+33wwQfp9TYfffRRi234feLEiTlrPRAImI+TWLIe3mQSpb7KrPs1JKvNnHYed7kRrpxQHIylGkwm4VwCVkOi2vyrc7RfV5nE43H89vtvmF83G8w5wszAg0uHYdFFFm0lMgshhBBCCCGE6H4kAAohWrHpppua8OC9994b1157LRKJBI444ghssMEGWHXVVc02J598spnzj/P5cc7A5557Dk8++SRee+21Fsdi1l/us+666+KBBx4wcwjeddddBde6teC/WKoRHtAzzWOS16b4n5U03mn8L56KwHL54Tbr3UybYdYnrJhZDyQRT0XNerdZT+/BJJJImOMTnSN7XbGOs4l/n375AabO+BUJNMLjdSGZsOBFCPOqZ2K1iWu3KQLSc5NzPsaTMdOebAGfx29EYGUXFkIIIYQQQojiIAFQCNEKCi9PP/00jj76aKy//vpwu93YcsstccMNN6S3YZZgzvd3xRVX4JhjjsGECRNwzz33mOQimXA+v4cfftgIiCNHjjQiID0MC6cpC240WW+EPZ87AI/Lh0iyHhaaQncpIFEAjCNqvAADnhKzPb3/uK8RmKwkIslauOBB0FOCpBU3IheFQpvOnOPIza802938yklddo7uuI5s50ikmpOz2Ez+YTK+/e0zjBg3GEOHjALcbiCVwpy51WZ5OFiBlVZYySSMMdtPntzcopaFuvpa1DfUmbKz33EZy1sSLkVpieYbFEIIIYQQQohiIAFQiAHKW2+91WoZRT+b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KUyaNKnLyrbqqqvi2GOPxf/93/+lxbADDjgAW2yxBV566aX0dqy3wYMH480338SGG27YoXNNnToVEyZMaLV87733xn//+1/0VFs0NjaitrYWw4cP79Jzs95WWmmlVmIw65zlYR33pr6RD88++yxOOukk/Pjjj3Av+EWzLWpqalBRUYHbDtwUIX/rXzjr581CtL62xbJCMqtxAFM17Y8WGc2ajuHGoNHj07+6FpqZzQ6LKKnMr4/oOtQe6leyD92vdN/V80PPc41LNL7qy+PER17/GFa0FkPKg3hgcp1Z9q9VRiABD+otLyoXn4hTL74aYycs0u75hBC5342rq6tRXl6OQmnfX1iIDD744AP88ssv2HXXXVt2JK8Xr7/+uhH7Ntpoo6LX2WuvvYZll102/T3Uw9mjeP6eLkNvJBaLwe/3t7nNNttsg0MOOQQvv/wyttpqq06fkwMOf0mZmXyYv2hyEMRfIfMJhyAc8AxaaGGTGa2xpmkSZE6OHCityCskgvCcnEi5sWoeYpF6c0z+WtveL7K6DrWH+pXsQ/cr3Xf1/NDzXOMSja/6yzhx4iIL4avf/kRj3IX9lx+GIcNHIOX1Ip5MIVhaic0n7WKWCSF6BoUAd5Krr74ayy+/PEpKSjB27FgcccQRqKtr+rUjM1T0+eefx5JLLolwOIxddtkF9fX1uO+++4x3Gb3kjj76aCSTyRbHpofZXnvthdLSUowePRo33HBDi/UU4tZff30Eg0Ess8wyePXVV1uV79RTT8USSyxhzrvIIovgrLPOQnzBXA3k66+/NoJdWVmZUZBXWWUVfPbZZzmv9+GHH8bmm29uzpkJr59egKeddlqb9fXtt99i4403NuLZkCFD8K9//atFfeWC244cOTL9oepN70A+sL766qv0dvSI47K33nrLfOe//E5xkp6LrIe1114bP/30UyuvNK7ndQ0dOhQ77bRT2gPvjz/+wPHHH2+OYz8gs4UA33LLLVh00UWNAMa2vv/++1us57533nkndtxxR1OOxRdf3Jy3WDz33HOm/XgNbOvzzjsPiUQi67Z23bE9WR/chwKrXW8233//PbbeemvTB0eMGGG8PufMac5Wxvo56qijcMIJJ5h622yzzczyc889F+PGjUMgEDB995hjjknv4/F4zDEfeuihol27GZCMHIvBC00wGcnyHQzZsC6CZRVm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U3CzPxS5etpFfeTIkfB6e9YV/frrr8cBBxwAt9ud9rDbdNNNMXToULz88sv44YcfcPfdd2PUqFFoaGh2py8mFRUVGDRoUN7bs7wPPPBA0fupEEIIIYQQom8ycfmVEa1vxLx5s5r0PwuYXTMTcxrnwnJb2H7Stj1dRCH6PEUTAN99913ss88+WGuttdLhfffffz/ee++9vISrmpqaVst/+uknEy4o8oPCD0WpSy65pM3tnnjiCSy77LIIBALGO+yqq65qsZ7LLrzwQuP5RnHnkEMOMR5eFHnocbbkkksiHA5jl112QX19Pe677z6zz+DBg3H00UcjmUymj/Xf//4Xq666KsrKykzZ9tprLyNSFYq9v/2x+wXPe+2117bYdqWVVsK5556b/k6vNc4vueOOO5pyL7744nj22Wdb7DN58mRss802KC8vN+dab7318Ntvv5nj8PqeeeaZtPchPeiyecO9/fbbWH311U29UnA77bTTkEgk0us33HBDHHPMMTjllFNQWVlpriOznITfx40bZ44xevRos30u6NH32muvYfvtt08v++CDD4wt8XonTpyICRMmYOONNzZ1xOOy3BtttJHZlu3Fa2A7k5deegnrrruuaechQ4YYL0LWgQ2PRXhc7sfryeYhmUqljBC92GKLmevgeS+66KL0+uWXX95cO0P8hRBCCCGEEGKDtTZEWXkZ3HDjiH2Pw+lHnYfBpRUoKy/F4itMwD777q1KEqKTFMV9iYISw/r23ntv45kVjUbN8traWlx88cV48cUX29x/hx12MB5ejz76qPlOceHPP/80AsrOO+9cjCIOCOiVxvqmyEbhKFuY7Oeff47ddtvNCE0MC6VgdMQRRxjBxxaCyBVXXIGzzjoLZ555pvlOIZceZPQ4e/jhh03b7rTTTuZDwYht/Pvvv5v2oojEY9vegxdccIERDSn8HX/88eY87fWJYnPeeefh8ssvN9d1ww03mL76xx9/GCGOgjXn0aOg9cYbbxgR8P333zfi3UknnWS86CiqcT5Lwn2mTZvW4vg8xtZbb22u7T//+Q9+/PFHI5xS3M4U+SgmMuT9448/xocffmi2X2eddbDZZpvh8ccfxzXXXGPqlwItvV+//vrrnNfENqGgufTSS6eXUVhjuSmuUaB1hn8zdJn2ynaiwM5rDYVCZh3FXJaNAh3/Pvvss41oSpGT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VIN8iIiIiIhI1zbxn+9QVR1GQS77y7cAG6hYGEEMEZQuno5nn3oep5xxYrZnU6RDsuym0rtmMMTgSLAMAlNhpRH7PkvXDJThB6udRo4c2eh+ViSNHz8e//vf/zB27Nhmm5GKtBQH2mATVPY/ma5SUNrem2++aQJHVoamG6QlGatMGVJfctATCPjUB6CIiIiISGf19Ft3o7tnCHILc/H+X/ea+3YZeQaiiCKMKni6leOtL57L9myKZIXztzFb+TU3+GabNwFmuPfTTz+lfby56kD205aqbzs2fWV1UVtWvIkk4qjLbMqazebmXREHuHn00UczDv9ERERERKTrqKyqgAtuROvHezQs9lkejcEOu/DvlOlNZgwikt5y/RXOSh7+QZ8O+whrqh/APffc0zQHPPTQQ5d5jP3rcfTU++67b3lmUSQthsyycu23335a5SIiIiIiklI4VAfLFYPLHVh6p+WF7bIQjYVQUVuLYLAOOTkJj4vIiq8AZF99TfVBxj782DdcU/3QsQ+ydDgqKkNAEREREREREencwpEaxKKAx1oaVZif+HttBKGKaoTqlh1cUkRWcAAoIiIiIiIiItIW6lCHMMLItX3x+/woMr/XxUKI2BEODSIiraCOuEREREREREQk63KtPNMHYKVdFb8vGFuIIGJwWW544ePAwCLSCgoARaRDqKsJAWEdskREREREOis3fMjx+OFKaAJsWR54EEXAkwe3KwCf35vVeRTpqPTXtIh0COWlQfg9KvgXEREREemsInYdbJcXhVZh/D6/qxv8dhRB3wJEYtUIBPxZnUeRjkoBoIh0CD37FSDgy832bIiIiIiIyApjIeyLImJH4/fE7BDCdhBhOwx43LAsFQWItIYCQBHpEHii18leRERERKQTc1mwQnUIojx+VzBWCytaBysWgcevcUxFWkufHhERERERERHJOn8gB8FQGMGEKj83ogi6bcSsMAoLirI6fyIdmSoARURERERERCTrivNLAESBaA1s2LDYJNhdA8uOwedzY9SQ1bM9iyIdlgJAEREREREREcm6kQM3wLQ5k2G7C7DTiNNRWJQHyxVFKFqDmDeMI47fN9uzKNJhKQAUERERERERkawbMXRthKO1KKssR22kFiV5Fix3DIVFfmz4n/Ww/c7bZXsWRTosBYAi0iFEIlFErKWjgYmIiIiISOficXsxcvD6mLvwX9TUVWGLnUbDn+fFwGF9sfHmGyAQCGR7FkU6LAWAItIhHHfN9igsKMz2bIiIiIiIyEpS3DMPLtfSAUFEpPUUAIpIh1DSKx+FhfnZng0RERERERGRDseV7RkQERERERERERGRFUcBoIiIiIiIiIiISCemJsAi0iGElsxEKFKQ7dkQEREREZEs8xb3h+VSPZNISygAFJEO4Z/79kS+35328ViwCuGqhfB3HwhYrbsYCFfMM/96C/u0bibtGOoWT4c3vydcgdb1V6jl0PbQfqXPRyZ0vNJxV+cPfT50XaLrqy57/ohGMPzMD+ErWbVV7y/SVSkAFJEOweX2weVJHwDabg8sy4Ll8cFqZQBoueqn7/L4WvV6247Vz4Pb0/ppaDm0PbRf6fORAR2vdNzV+UOfD12X6Pqqq50/gsEg/ppTjfKaWkx77j7Ecnqi+6C1sP7GmyMQCLRqXkS6EgWAIiIiIiIiItJuMfz7/Pc5KK+qgokdf3gDEXc+pv34CeZPn4Rd9j9OIaBIMxQAioiIiIiIiEi79ePf8zFtRhUK8oArv2Qp40TcsEsxavAXfpo3FbndBmCn3fbM9myKtGvqNVNERERERERE2q0vfi83lX/dXIBlARaAnu4yFIaXILZgMsY/cRts2872bIq0awoARURERERERKTdmlMOdMsHcvyNw4wCL1CEEP796zvUBYPZnEWRdk8BoIiIiIiIiIi0W3YU4JjD/oROzCJhPgDkuQG7tA6RkAJAkaYoABQRERERERGRditiAzEb8HmX3lfgA3wuIBYFwpH6psEikp4GARERERERERGRdisUAywX4ElIMMzvDf0BBmOAugAUaZoqAEVERERERESk3bIiABv4RhJa+UYbfjd3RQCPL5DFORRp/1QBKCIiIiIiIiLtFsf3DdcBZe6l91VUA3V19ffbEcDnTxghRESWoQpAEREREREREWnXASDcQKFv6X35eUC+H7AYCnqBENNAEUlLAaCIiIiIiIiItFvs76/AAwTylt7Her9ALpDvqQ8BNQqwSNPUBFhERERERERE2i2/B3DZQCiy9D7TJ2AUcPmBPLdGARZpjgJAEREREREREWm3/G4gBKAuYRCQ2iBgW0AsBHhyNQqwSHPUBLgD+eSTT2BZFsrKytCR/Pvvv2a+f/nll2zPCrbcckv873//y/ZsdBqXX345xowZk/HzFyxYgJ49e2L27NkrdL5ERERERKRzNQGusYG68NL7POz3j/d5gNxu3TUKsEgzumQAeMQRR5hA6vrrr290//jx4839HdmgQYPMMiTe+vfvv1LX7R577NHovgEDBmDu3LlYc801kU1vvPEG5s2bhwMOOCDl+srJycGIESNw0003wbZNN7MrxdixY3H66aev0LCXy33KKadgyJAh8Pv9ZpuMGzcOH374IVamXr164dBDD8Vll122Ut9XREREREQ6riH9gcpqICH/Q9TyI+LxotzOxahN94A/EMjiHIq0f10yAKRAIIAbbrgBpaWlbTrdUIiFydl15ZVXmsDNuf38889ZnR+3240+ffrA48lui/M777wTRx55JFwuV8r19ccff+Dss8/GhRdeiAceeACdBSsw11tvPXz00Ue48cYbMXHiRLzzzjvYeuutcdJJJ630+eE2ePrpp9v8syciIiIiIp3TARutgiU2sCgC3LoN8N99uqPa3w2L7RJU9d4Ip196fYcv5hFZ0bpsALjtttuaUOq6665r8nkvvfQS1lhjDVM1xWqxW265pdHjvO/qq682lW9FRUU49thj8dhjj6G4uNhUnK2++urIzc3FPvvsg+rqajz++OPmNd26dTMVWdFoND6tp556Cuuvvz4KCgrMvB100EGmyWRLOa93bmxy6czr7bff3ui5bL7JZpwOHjQfeugh7Lnnnma+V1ttNbz22muNXvP7779jl112QWFhoXmvLbbYAlOmTDHT4fK9+uqr8ao6VrKlagL86aefYsMNNzTrtW/fvjj//PMRiUQaVcWdeuqpOPfcc1FSUmKWI3E+ib+vuuqqZhr9+vUzz09n0aJF+OCDD7DbbrulXV9cP8cccwzWXnttvPfee/HHGVQddthhZptxney00074+++/449Pnz7dVNPx8by8PLO/vPXWW/HHJ02ahJ133hn5+fno3bu3qYDj/BD3G66LO+64I77OuL4YzhGnyfv4PGJwt/nmm5v9q3v37th1113Num/KiSeeaKbx3Xffmf1w+PDhZh7PPPNMfPPNN/HnzZgxA7vvvruZT27b/fbbD/Pnz280LVbNchm4zo4++mgEgwmdcDR49NFHMXLkSBOys6LynnvuafT4WmutZdb3K6+8gpaIRUOIRdLf7GjEVG7aTTynuZsdi5pbq1/PG+chGmn9NLQc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9NNPseGGG5rX9u3bF+effz4ikUj88VgshhtuuAHDhg0zz1l11VVxzTXXpJwWn3vsscea5Zw+fXq8eTNfw9f269cPp556arPLISIiIiIikmzAkNXRbdBIeII18I7YFH22Ogy9N9oN3f0hbLDaqhi31YbYaMzaWnEiCTyJv4hIas899xxWX311czvkkENMJeAll1zS0N/EUueccw7uuOMOE7xdeOGF2G233TB58mR4vfUjUNXU1JjQ7PHHH4fP58OJJ56IAw44AF9++WXK933wwQdx2WWX4e6778Y666yDn3/+2QRreXl5OPzwwzPaXFVVVXj66adNcMfmwKnMnj0bO++8s2k+/MQTT+DPP/8078PQkcEdXXDBBWZ+brvtNmy++eamupDPSxYKhXDQQQdhypQpplqyV69eePHFF83rnn32WayxxhqYN28efv311xbtbuFIDLY7Gv89GoshZtsIR6Kpnx+Nwebj0RhcVurn8PWcTrpp6D20rrRf6fOhY4mOiTp/6FyrawZdX+k6sf1dU3tzC7Dq8DWwuLAQoZogxo4eiFy/F8V5OVhztf7YcoN10bNn6r99RLoqBYAiGXj44YdN8Oc0r2Woxqa12267baPnMaxjVR8x5Ovfvz9eeeUV7Lfffua+cDhswjxWBzrPYXXfd999Z6rvkl111VW45ZZbsNdee5nfBw8ejEmTJuH+++9vMgB84403kJ+fH69eZEUf73O5Uhf9sqpwwIABZt4YarLScM6cOaZy8NJLLzXTYLDJx533HTp0qAkCE3G97LLLLqitrTVVkUVF9SNvsck0Q1GuL4ahrARMtbxUV1dnbo6Kigrz70On7IKCgsK0yywiIiIiIl0HWx2VLinD7IULkedxw3JZKMgJmME/SkqK0/7tI9JVKQAUacZff/1lArqXX365/kPj8WD//fc3fQImB4CbbLJJ/OeSkhJTMfjHH38s/cB5PFh//fXjvzNoY7NgPic5EGNzXTbbPfroo001noPNcp1gLZ2tt94a9957r/l5yZIlJuDbaaedzHIMHDhwmefz/TnviRWNm222mQn0Zs2aZSr2GMr95z//afJ9DzzwQBN6MhzNzc2N37/vvvvi9ttvx5AhQ0yAymrDcePGmfWR7LrrrsMVV1yxzP2WywvLXQKHLtgAAGoWSURBVF9JKSIiIiIiXZvbDfTo3dvc+hYG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tphGe5iHtphGe5iHtphGe5iHtphGe5iHtphGe5iHtphGe5iHtphGe5iHtphGe5iHtphGe5iHtphGe5iHtphGe5iHtphGe5iHtphGe5iHtphGe5iH+DQ4GV9D+8qGnK8mGoLtCtffL9JOKAAUEREREREREWkNC7DrgNiSpU2AYzUh2CHbNA82AaFIO6A+AEVEREREREREWiMKhMJ1ZkASh+XmbxbCkbCpClTPa9IeKAAUEREREREREWkNu74psFXQ0BzYAnJyc8zvJhSMAsG6oNatZJ0CQBERERERERGR1nA3NPMNNvQBaAO1VUHzu+V2m34A60IKACX7FACKiIiIiIiIiLRGIeD1eIHw0rsspoIxwOV2w11sRgvRupWsUwAoK8WgQYNw++23t/h1LKUeP348VqSPPvoII0aMQCy2tNPWbC0z+4Y47rjjUFJSYpb9l19+Qbb8+++/bT4PdXV1WHXVVfHjjz+22TRFRERERESyxcVUhaP9+pfe5wm74fflwlfoR7GvmH/oaQNJ1ikA7GKOOOII7LHHHtmejXbl3HPPxUUXXQSXOXI37bHHHkNxMb/CWTHeeecd8x5vvPEG5s6dizXXXBPZ2i8GDBjQ5vPg9/tx9tln47zzzmuzaYqIiIiIiGSL2+VGtCIGeNkWuL7YL79HLvx+H9xVbpR06wG/L6ANJFmnAFC6tK+++gp///039t13X7QHU6ZMQd++fbHpppuiT58+8Hg8WZsXt9u9Qubh4IMPxueff44//vijTacrIiIiIiKysvUe3guhqgjsBRH0OqA7hh01GKgE7GobOUE/Dtr+IAT8CgAl+xQASiO33nor1lprLeTl5ZkKsBNPPBFVVVXLVMCxQm311VdHbm4u9tlnH1RXV+Pxxx83zV67deuGU045BdFotNG0KysrcdBBByE/Px/9+vXDXXfd1ehxBnFbbrklAoEARo0ahffff3+ZrcPKseHDh5v3HTJkCC655BKEw0s7W/j111+x9dZbo6CgAIWFhVhvvfXwww8/pN3Kzz77LLbffnvzns1N45NPPsGRRx6J8vLy+lGeLAuXX365ec2CBQswbtw45OTkYPDgwXj66adbVYXH9TZjxgwzba7LdE2Jx4wZE39v4vMfeugh7LnnnmbdrLbaanjttdcaveb333/HLrvsYpaJy7bFFluYwJHT4bZ79dVX48vF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fvsNt9xyC3799Vc8+eSTK3VeevXqhe233x733XffSn1fERERERER6dpGde8Ob1EReuXn46TCIlw9dBjOGj4crpJuCA4ZjF1POQW9+vRBZ6UAsIu69dZbsdZaayEvLw8DBgzAiSeeiKqqqvjjrI4rLi7GG2+8gdVXXx25ubnYZ599TED2+OOPm6a+3bp1wymnnIJolGPlLFVZWYmDDjrIVJr169cPd911V6PHGcRtueWWpsx21KhReP/995eZv/POOw/Dhw837ztkyBBccsklCIfD8ccZXm299dYoKCgwId56662HH374Ie3yPvvssyZ44nsmYvVdnz590LdvX6y//vo444wzMH36dPz111+NqufWWGMN+P1+s9wMzxLdc889WG211cy0WUXI9eSwbRs33nijWYacnByMHj0aL774onns33//NctAXJecF1Zu8vbpp5/ijjvuiFcn8rlcz0cffTQGDx5spsXtwuc05bvvvsO1115r5vmmm27CpptuapZhu+22M8t1+OGHx5977733YujQofD5fGbayeFgJttt9uzZJmzk8nTv3h277767mfdEu+22G5555pkm51tERERERESkLa3Wsyd6l5TAnZtr/u4tWWtNFI0eg75bb41Njz4aO+y9d7zFYGekQUC6KO7Ud955pwmD2ByTASCbZzLMctTU1JjnMDxjqLfXXnuZG4PBt956C1OnTsXee++NzTff3IQ+DgZNF154IS6//HK8++67JlRj33sMndj/HqfRo0cPfPPNN6ioqEjZ1JXBHkNIBogTJ07Esccea+7jPNLBBx+MddZZx4RWbrcbv/zyC7xejumT2meffYYDDzywyXXCZrj/+9//zM/OtH788Ufst99+Zlm4jKwk5LpiuMWgjqEj+7RjWMZwjU1qP//88/g0L774Yrz88stmPhkScj4OOeQQ9OzZ06w3hnBchwwcGWQy2KPJkydjzTXXNM10ic/nuuvfvz+ef/55s/44L8cdd5wJLzmPqTz99NMmiOU8p8JtSa+88gpOO+0003/jtttua4LfI4880rwfQ8pMthv3Fz53iy22MMvp8Xhw9dVXY8cdd8SECRPMAZY23HBDzJw50wStAwcOXGae6urqzM3B96JYOIxYw0hNqcQiERO48nkMTVvDbgizOY1WvZ5DynMeIpFWT0PLoe2h/Uqfj4yONzpe6bir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iooKFBUVYdKqg1DgUtGyiIiIiIiItFwsFsOsigp8H4mYvv+Kt9oKQb8P+cOGYd1ddsbAtdZCfnGxGRm4Pf9tXF5ejsLCwha/XhWAItIh9H73bRQWFGR7NkRERERERKSD6hOLYbWyMlQuXgwXQzSXC96CAnTr0wc5ubntNvxrCwoARaRD8PTrB08rvuUQERERERERcfQcMAA90fWoPZ2IiIiIiIiIiEgnpgBQRERERERERESkE1MAKCIiIiIiIiIi0ompD0ARadecgco54pGIiIiIiIhIV1TR8Dex8zdySykAFJF2rbKy0vw7YMCAbM+KiIiIiIiISNb/Ri4qKmrx6yy7tdGhiMhKEIvFMGfOHBQUFHTqIdk7yzdSDGpnzpyJQo3YLNrnpJPRMU60z0lnp+OcaJ9r3xjfMfzr168fXK6W9+inCkARadd4YOvfv3+2Z0NagOGfAkBZmbTPifY36cx0jBPtc9LZ6TiXudZU/jk0CIiIiIiIiIiIiEgnpgBQRERERERERESkE1MAKCIibcLv9+Oyyy4z/4qsDNrnZGXS/iYrm/Y50T4nnZ2OcyuXBgERERERERERERHpxFQBKCIiIiIiIiIi0okpABQREREREREREenEFACKiIiIiIiIiIh0YgoARUREREREREREOjEFgCIindBnn32GcePGoV+/frAsC+PHj2/2NZ9++inWW289BAIBDBkyBPfdd98yz3nppZcwatQoM2IX/33llVfaZH4nTpyIrbbaCjk5OVhllVVw5ZVXwrbt+ONffPEFNttsM3Tv3t08Z8SIEbjtttva5L2l6+xnHXG+pOvucy+//DLWX399FBcXIy8vD2PGjMGTTz65wudLuub+RmVlZTjppJPQt29f87yRI0firbfeWuHzJl1znwuHw+Z6b+jQoeY5o0ePxjvvvLPC50s65z43d+5cHHTQQVh99dXhcrlw+umnL/OcBx98EFtssQW6detmbttuuy2+++47dCUKAEVEOqHq6mpzIXX33Xdn9Pxp06Zh5513NifFn3/+GRdeeCFOPfVUc/J2fP3119h///1x6KGH4tdffzX/7rfffvj222+Xa14rKiqw3XbbmQuP77//HnfddRduvvlm3HrrrfHn8I/fk08+2Vyk/PHHH7j44ovN7YEHHliu95ausZ998sknGDRoULubL2m5rrTPlZSU4KKLLjLzN2HCBBx55JHm9u6777Z6vqRlutL+FgqFzLn433//xYsvvoi//vrL/LHML+Vk5elK+xyv4+6//35z3Tdp0iQcf/zx2HPPPc3zZeXpLPtcXV0devbsac6bXJ500zjwwAPx8ccfm3lcddVVsf3222P27NnoMmwREenUeKh/5ZVXmnzOueeea48YMaLRff/3f/9nb7zxxvHf99tvP3vHHXds9JwddtjBPuCAA+K/x2Ix+4YbbrAHDx5sBwIBe+2117ZfeOGFJt/7nnvusYuKiuxgMBi/77rrrrP79etnppfOnnvuaR9yyCFNTltWnva8n3388cf2wIEDV/h8ycrV2fe5VNZZZx374osvbvI5smJ09v3t3nvvtYcMGWKHQqEml1FWns6+z/Xt29e+++67Gz1n9913tw8++OAml1lWnI68zyXaaqut7NNOO63Z50UiEbugoMB+/PHH7a5CFYAiImK+BeM3YIl22GEH/PDDD6aJRlPP+eqrrxp9m/voo4/i3nvvxe+//44zzjgDhxxyiGkqkA6ny+a/bCKQON05c+aYSoRU+I0j35evk44jm/vZypgvaX868j6XiH+Xffjhh6Yqa8stt2zVe8qK15H3t9deew2bbLKJaQLcu3dvrLnmmrj22msRjUZb9Z6ycnTkfY4VW2xCmojdvLDbF2m/2us+1xo1NTVmnllx31V4sj0DIiKSffPmzTMX/In4eyQSwaJFi0x/QOmew/udJgRstvvRRx+ZPyKI/YLwQo5NPNKFdXx9ckm/8z58bPDgwfH7+/fvj4ULF5r5uvzyy3HMMce00RqQzr6frej5kvapI+9zVF5ebppg8g9lt9uNe+65xzTTlPapI+9vU6dONe958MEHm37//v77bxMG8jmXXnppK9aGrAwdeZ9jIMT35Zca7AeQX3K8+uqrCp3bufa6z7XG+eefb86x7Auwq1AAKCIiBjv+TeQMwpF4f6rnOPex/5ZgMLjMH6fsV2idddYxP6+xxhqYPn26+Zl9h7z99tsZvzd9/vnnqKqqwjfffGNO2sOGDTN9eUjHsTL2M8rPz4//zAoWBiiJ9yXuf20xX9J+deR9rqCgAL/88os57vGP4zPPPNP8kTR27NgWrwdZOTrq/haLxdCrVy/Tty7DZnbwz0r8m266SQFgO9dR97k77rgDxx57rBnYjfcxBGQ/p6wKk/atve5zLXHjjTfimWeeMf0CJleidmYKAEVEBH369FmmkmnBggXweDxm5N2mnuN8w8c/HujNN99cptNwp3kvqwqc5gFs5tHUdCn520OnGnCttdbC/PnzTRWgAsCOY2XtZ8TQxMFOp8877zxzkedw9r+2mi9pnzryPkccyZBfdBBHAeYgSNddd50CwHaqI+9vrNrxer0m/HNwFGC+jn+U+3y+Vq0TWbE68j7HARs44iyDoMWLF5vB4PjlbmLLD2l/2us+1xI333yz6eLggw8+wNprr42uRAGgiIiY8vvXX3+90Zp47733sP7665s/CJznvP/++6aPjsTnbLrppubnUaNGmZP2jBkz0pbuDxw4cJn7OF2OIJb4BwanywvBpkb74jeJ/CZQOo6VtZ+RE5rQrFmzzIVp4n1tPV/SPnXkfS4VHffat468v2222Wb43//+Z/4wZ/BMkydPNsGgwr/2qyPvcw5WXzEE4hfEHEmWo8VK+9Ve97lM3XTTTbj66qvx7rvvmnnucrI9ComIiLS9yspK++effzY3HupvvfVW8/P06dPN4+eff7596KGHxp8/depUOzc31z7jjDPsSZMm2Q8//LDt9XrtF198Mf6cL7/80na73fb1119v//HHH+Zfj8djf/PNN/HnXHTRRXb37t3txx57zP7nn3/sn376yYzwxt/TKSsrs3v37m0feOCB9sSJE+2XX37ZLiwstG+++eb4cziN1157zZ48ebK5PfLII+Y5fD/Jno6ynzU3clxbzZeseF1pn7v22mvt9957z54yZYqZr1tuucXM14MPPrjc61Ey05X2txkzZtj5+fn2ySefbP/111/2G2+8Yffq1cu++uqrtbusRF1pn+P7v/TSS+YY99lnn9nbbLONGRG2tLR0udejdL19jpzlWG+99eyDDjrI/Pz777/HH7/hhhtsn89n5nXu3LnxG9dBV6EAUESkE+JJkifx5Nvhhx9uHue/W221VaPXfPLJJ/Y666xjToyDBg2y77333mWm+8ILL9irr766OdGPGDHCXLglisVi9h133BF/Ts+ePe0ddtjB/vTTT5uc3wkTJthbbLGF7ff77T59+tiXX365mZbjzjvvtNdYYw1zwcHgj/N5zz332NFodDnXlHSF/SyTi8a2mC9Z8brSPsc/joYNG2YHAgG7W7du9iabbGI/++yzGa8rWX5daX+j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" width="854"></p>
   <p><img height="480" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABQAAAALQCAYAAADPfd1WAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjgsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvwVt1zgAAAAlwSFlzAAAPYQAAD2EBqD+naQABAABJREFUeJzsnQWcHFXWxU+7jMc9geDu7u7u7ra4BHfXZRd3WBaHD2dhcffFnQBJCPHJ+LTX9ztvUp2anu6e7pkeSXL+bO+kS1+9927Vq9P3vuuyLMuCEEIIIYQQQgghhBBiocTd1wUQQgghhBBCCCGEEEL0HBIAhRBCCCGEEEIIIYRYiJEAKIQQQgghhBBCCCHEQowEQCGEEEIIIYQQQgghFmIkAAohhBBCCCGEEEIIsRAjAVAIIYQQQgghhBBCiIUYCYBCCCGEEEIIIYQQQizESAAUQgghhBBCCCGEEGIhRgKgEEIIIYQQQgghhBALMRIAhRBCCCGEEEIIIYRYiJEAKIQQQgghhBBCCCHEQowEQCGEEEIIIYQQQgghFmIkAAohhBBCCCGEEEIIsRAjAVAIIYQQQgghhBBCiIUYCYBCCCGEWGC5//774XK58Nlnn7VbPnv2bKyxxhooLy/Hq6++2mPnf+mll3DRRRdlXcdyHX/88d06/owZM3DWWWdhxRVXNNcSDAax5JJL4qSTTsIvv/yS3o5l4PkWRnhdhXzeeuutbp+rpaXF1GUpjpWNTTbZxJR18cUXh2VZHda/88476eth315Y+OOPPzq0V2VlJVZeeWXceOONSCaTfVa2ww47DNtss02Hsl533XWd7vvyyy9j++23x+DBgxEIBDB69GgcfPDB+P7773Pu895772HffffFmDFjzD5lZWVYfvnlcdppp+HHH3/Mud9uu+2W957CPuusX4/HY8q14447drg/kkMOOcTcU5z30c4+48aNa3e/4X02GyussILp607sY/C82bjkkkvS27ANspXTSSqVwoMPPogtttgCgwYNgs/nw5AhQ7DDDjvg+eefN+vz0dzcjKuvvtr0QfbFiooKjB8/HnvttRfefvvtDtv/9ttvpu6XWmophEIhhMNh027nnXcepk6d2q02e/LJJ/OWNV+bOOvz/PPPx2qrrdbptQshFl28fV0AIYQQQohS8ueff2LLLbc04tlrr72GddZZp0cFwFtuuSWnCNgdPvnkE/MyS6GIL5Drrrsu/H4/fvrpJ/z73//GWmuthblz52Jh58MPP2z3/dJLL8Wbb76JN954o93y5ZZbriQC4MUXX2z+nSlglAoKDb///rsp/+abb95u3b333mvEiIaGBiyMnHDCCdhvv/3Mv+vq6vDcc8/hlFNOwZQpU3D99df3enm++OILPPDAA/j444+L3nfChAm49tprjXh46623YujQofj5559xww03GBHm4YcfNgKQE4pFl19+ubFl/ptifiKRwNdff23KwX35neKdk5kzZ+KFF14w/37ooYeMOMkfA7JxxRVXYNNNN0U8HjfXx/688cYb48svvzTnywZFzEw7Yxn32GMPI0zaULDsbt9/4okncNNNN5l/2/AeRxGy0L4fiUSwyy674L///S/22Wcf3HbbbRg2bBhmzZplRNk999wTjz32GHbeeees+1Nw3mqrrfDNN9/gjDPOMPdSwh9VKB6+++67ps5sWPc8D4VG3otXXXVVI75xf9rsiy++aOq6q21WCJltYUOR1+b000/HzTffbPrSoYce2uVzCSEWYiwhhBBCiAWU++67j25U1qeffmq+//zzz9aYMWOs4cOHW19//XWPn/9vf/ubOX82uJzru0J9fb01bNgwa/To0daUKVOybvPEE0+k/33hhRfmLEdf09zcXNLjHXzwwVZZWZnVE8yaNcvUI+uzJ9h4442t5Zdf3lpnnXWs/fbbr926hoYGKxwOW0ceeaQpA/v2gkRLS4uVSqWyrvv999/NNV177bUd1m244YbGXvuCvfbay7RFoWW1efjhh802xx57bId1TU1N1uqrr27acuLEiR32OeaYY7LWE5fdfPPNViKR6LCOZeG+22+/vfn70EMPddjmzTffNOuc9wXywAMPmOUXXHBBUXaU7/5l329oL9lgH2dfzzzeAQccYIVCIevOO+9st+61114z6+2+zzbIV07WO7fjtWWDz4Gvvvoq57W98cYbZv9777036/pkMpn+92+//WbOv+qqq1p1dXVZ2+2pp54qaZt151ly/PHHW0sttVROWxRCLNooBFgIIYQQCwX0cNlggw3g9XpNmB3DZp3YoWS//vortttuO/NvhuzRqyIajXYIy8oMA7VDA+3QTB6P3n/EGZLlDF8jDFNbdtllTcgYw81sr5B83HXXXZg+fTquueYajBo1KqdHSD4YBsb9l1lmGeO5w/C4gw46yHhIOqHnCj0NuZ7bjRgxwngE2dtlXrcTLnd6P9qhgf/73/9M+WpqakxYHeF7LD2lVlllFRNCx3XchqF13SUWi+Gyyy5LXyu9YugBQ48gJ/S6o2ffwIEDTRkYhrn77rsbzz9ep+1NQ6+pzkIWuxt2+n//93/GC87m0UcfNX/paZQJ+yyvhx5c7EcjR440oZ30QHJi991HHnkE5557rmlLelUxTJKeo4VA26FnIj20eK711lvPeDg5sUNG6YHFa2G9cVunHRVKVVWVCd8stu/SE5S2Tu/BTFgmtjE9xXJBD+Gnn34aBx54YNFlphcf+2+2MGGG9NLDjX3q73//e3o5+yc9yLgsW7g+l/3tb3/r4P1H6GVGD0N6drHf8nuhcCoE+3r7Grb1rrvu2qH8/L7++uub8NrO4H3x7rvvxtZbb236RDZoJyuttFLOY8yZM8f8HT58eNb1bvf8V2R6ZTJcmPculj9bu2V6ena3zboD+zM9UeklLYQQmUgAFEIIIcQCD0ULCjsUCvhvzrGWDYbF7bTTTkbgePbZZ41QwBdyzgVVLJxvyRbhGD5nf5wvlRROGJLF+a2eeuopDBgwwLwAdyZ6UVihEECRp6sce+yxOPPMM004NEMtKZgwPI6Cjj13F19s7XBpipmcL5FzslEYa2xs7PK5+UK8xBJLmHC/22+/3Sw7+uijcfLJJxsx6plnnjEv1N99950pT3fECYpFDPW76qqrTHgp65z/5rWwT7S2tprtKPBR2GQYNV/GWRfcjoINBUS2G5eRww8/PN2ebOdSQ5GP7Uuhzuaee+4x/YmCXSZ//fWXEbRYXpaRbUXxa+21184q7J1zzjmYNGmSEUruvPNOE9rIvtTZXHuc+2yzzTZDfX29KQ/LRyGQ+zKkMhPaD8U7itycxyxTyMvWVgxx5YcijN0OmSJcIX2X/Yl1cMcdd7Tbt7a21oipbMN8IZe0Md4PGC5bDNOmTTP9liGkFD2zwfBZ3ovs+UfZfpwXkNdTbBjoBx98gB9++MGIXewDFKwpZDOMvBDs7QoR14qF/cluT+cnH2yXjz76yFwToQhOMZzLC4HCFtuNIcBdhaIo+yrnUmV4Lts0Xz+hkFfMVBLdbbNs8AeUbHWdOZfo6quvbn7cyhTthRDCvpkIIYQQQizQIcD8VFVVWTNnzsy5LUPJuN3jjz/ebvl2221nLb300h3Csvg3W2igMzSzsxDgoUOHmtBOm+nTp1tut9u68sor817XMsssY0KACyUzBPiHH34w34877rh223388cdm+TnnnGO+f/bZZ+b7M888k/PY2a7beY3OcFm7HJnhhh9++KFZfv3117dbzvBmhgROmDCh4GvNDAl85JFHzLEzw/AYFs7lt956q/n+5JNPmu9ffvlln4cA29exxhprmH9/99135rxvvfVWutz5QoAZJhqLxawll1zSOuWUUzr0XfZpJ+zzXM52yAfDYYcMGWI1Nja2O9cKK6xgjRo1Kh1WaNvdQQcdVNB1230o2+eQQw5pF/ZaaN+165DljUaj6WVXX321sTFnGGk2GEbKvpcZKtlZCPBHH31k1p911ll5j7/22mub43e2D689Ho+nP5nlOeyww8y+rBdnG59//vnttrOXP/bYY+Y4DMl+//33zb1tueWWs+bOnVvyEOB8n2whwDwer2+xxRazTj/9dLP8lltuscrLy02fs8Nm84UAX3XVVWabl19+2eoO99xzjzmvXV6GobM/v/POO+22CwaDHcLEO6PYNiskBDjX58EHH+yw/frrr2/6nxBCZCIPQCGEEEIs8NCrj15L9DDL5+XEcK1MrzqGitFbqiegd5Fzsnt6ktAzqKfOZ2OHf2WGr3Kye4Yjv/766+Y7vfQYykhvK3rq5cteWgz0eHHCsGfW/QEHHNDOe4UT9zMsujtZd3ns6upq067OYzPUmMe3j83v9P476qijTFheKUKPMz2gism+Se85ZmdlGC+97RgqvdFGG2XdlsdmcgcmOuE10PONf+nZZ3tSZdqDEzscMl+/ozcok2HQC9GZdZWeivTQY/htprdhZjt3Bj2uPv30U/NhH+U1Pf744yYrbrF91z4eky3Q05Sw/pkQgp6edsbaXNArj6HLPZU9m7pNIcemhxi90ewPPYVtmpqaTP3Q85Hh0ITJKdhXGIadrb/tvffe5jj0TmRYLZNq0BuMNlJqmGTJbk/nxw77z4YdVk+vUfZr9n1m3s2W6bcnof2xTzNZy4knnmimg2ByJdYvk7t0la60WSGwjrLVNaezyITPmFyZiYUQizYSAIUQQgixwMMwzQsuuMC8zFFkyiUC8qU4MwSPc4zlmyusO/DlPhOezw5LzQVDcDl/HUWZrpBvjivOC2ev55xW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oa6ursMxc93XeP8uhMbGRkyYMMEkmBg8eHDOe2+x5SpFfXH+Rt53WV883zLLLGOeWS0tLZ3e150f3re7Yzetra1YaqmlzLGuu+66gq71zz//NG298cYbm/s992V5O6Mr5yr0uoq5x7HOOqtXno/E43GMHz/ePI+FEH2HBEAhhBBC5OSvv/7CNddcY16o3O75w4ZffvkFq666qnlR2GCDDczE42+88QZuuukmjBw5Eocddhguu+yyrMc899xzzctAb8HkAJMmTcJmm21mXl47g0LDhx9+2O5DIaEzLrzwQvOyRHHg5ZdfNi/ML7zwgnl5pRjRGT/++KN56YrFYnj88cdx77334ueffzYJDmbNmoX+xB577GHqheIUxYmDDjrIiH98oTzppJPQX9h+++1NOYcPH16S402ePNm8wFJ8oiDx3HPPmbqgGLLDDjsYoSobFHWOPPJII1IUA4V0igNVVVXGxl566SWceeaZOc/jhAL85ptvbl7w//GPfxixzBbo3377bSxIUEjnh9fDOn/iiSew3377pUWebDCzLwW0nqAYAfDzzz83bcey8+9TTz1l2pTXwz6RCUX/Bx54wNxP/vOf/2DNNdfEvvvua/qCUwBinxs7dqzpj+wXPBb7JLMhc30um3V+aLeFJpfgsdmnKLbloivl6k59MdvteuutZwR+no/323322cc8r1hnznuA85OtPp5++ulu2c3555+P5uZmFMOvv/6Khx56CH6/34j8hdKVcxV6XcXc41hnmXVrf9hvKQDa/YU/EF5wwQWmbdifhBB9hCWEEEIIkYMJEyZYI0eOtJLJZHpZPB63lltuOau6utr6/vvvs+73xx9/WE8//XT6+++//863Bmvbbbc1f//5z3+22/7CCy80y2fNmpVetvHGG1vLL7981uNzO27P/TrDWXYej8fNxn333WeO+emnn1pdYcaMGR2W8Vg85qWXXtrp/nvuuac1aNAgq76+vl09+nw+0w79BV7P3/72tw7LE4mEddhhh5n1t956a0nOlUqlrJaWFqu/0NTUZD6ZXHvttea633333az7sb5WXXVV67zzzuvQz3Px559/WmVlZdaxxx7bpbLecsst5lwffPBBB9tda621rJ6mubm5JMfhfYTX8dhjjxW8z5NPPmmVl5dbDzzwgNn3iSeesEoJ2+Xggw8uaNva2lorFotl7RMs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97+xxhproKKiwpRtv/32w8yZM4tuM3t/+zN48OB0WW+88cZ2266yyiq46KKL0t/pMXj33Xdj1113NeVecskl8dxzz7Xb57vvvsP222+PyspKc64NN9wQEydONMfh9T377LNp70OGLWcLAX777bex1lprmXodPnw4zjrrLCQSifT6TTbZBCeeeCImTJiAAQMGmOtwlpPw+5gxY8wxRowYYbYXQgghhBBClI4dNlkZIX8As+piOG3PlXH+4RthWn0ctTEvhoxeDgceebyqW4h+yILhfiNEL3mlXXHFFUZko3CULUz2888/x1577WWEpr333hsffPABjjvuOAwcONAIfjbXXnstzj//fJx33nnm+3vvvYeWlhb885//xKOPPorGxkbstttu5kNh8KWXXsJvv/2G3XffHRtssIE5tu09eOmllxrRkMLfKaecYs7D7XuTiy++GNdcc425rptuugn7778/Jk2aZIS4qVOnYqONNjIC3RtvvGFEwPfff9+Id6effjp++OEHNDQ04L777jPH4j5//fVXu+PzGNttt525tn/961/48ccfjXBKr0ynyEcx8dRTT8XHH3+MDz/80Gy//vrrY8stt8STTz6Jv//976Z+KdBOnz4dX331Vc5rikaj5mPDMpJUMoFU0tNuWysZR7y1Di63F95AGeKt9Yg1zYEvXNWLv6OkEG+ph5VKwBeqQiLajFjzHPhC1XB5em+elWS0GYlYM7z+MvM9HmmAlUrCE2j73huoPdQeHZF9yD46ovuV7EPPj9zIPmQf3bGP0cMHY9N1V8B3v85AItmKikGLIZRyY2TNSGy09c5YYomlCx7XCSF6DwmAQjiglxs94C688ELcc889HermhhtuwOabb27EPbLUUkvh+++/N8KYUwDcbLPNjPhlQwEwHo/jtttuw/jx480yegA++OCDmDFjBsrLy7Hccsth0003xZtvvpkWAA877LD0MRZffHEjINJLrqmpyexTKGeeeWZajCQUOovxjuO17bvvvul9KQJ+8skn2GabbXDLLbcYT0cKbz6fL10vNqFQyAht9NjLxa233mrmBbz55puNZ+AyyyxjREKW+4ILLoDb3TboWGmllUzbEHoicvvXX3/dCICTJ08256AnJ8tBT0DWVS7o6UlhM5Mltz4VlZUVBdeNEEIIIYQQixpLJ5NYc9YMtDY1IFBWjZTl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Cq2OuaybEklE/H5E3R4svuKKqOpBxwkhRNeQACjS3HDDDVhxxRVNKCU9wI477jg0NTV18ICjh9rSSy+NcDiMPfbYA83NzXjggQdM2GtNTQ1OOOEEJDOykjY2NmK//fZDeXk5RowYgZtuuqndegpxG220EYLBIJZbbjm8+uqrHVqGHl1LLbWUOe/iiy+O888/v51I9NVXX2HTTTdFRUUFKisrjSj02Wef5WzhRx99FFtttZU5Z2fHeOutt3DooYeivr6+bYJclwsXXXSR2WfmzJnYcccdEQqFsNhii+Ghhx7qkhce623y5Mnm2KzLXKHEq6yySvrchNvffffd2HXXXU3dUAh77rnn2u3z3XffYfvttzfXxGvbcMMNjXDG47Dtnn322fR18VqzhQC//fbbWGuttYyHHYXKs846CwnHQ3+TTTbBiSeeaLwqGcZMAdFZzs7g+W6//XbsvPPOpg9edtllZvnzzz9v2oHtxHa/+OKL0+dl/Tz11FP417/+ZfZnPZKBAwcaIfWRRx4psiWEEEIIIYQQ+dh+zTVQF48jkkrhxn32xp1HH4VAWRgJtxtNoRCOOvXUgiKshBC9i5KAiDS8Sf/zn/80osrvv/9uBECKObfeemt6m5aWFrMNxTOKervttpv5UBh86aWX8Ntvv2H33XfHBhtsgL333ju937XXXotzzjnHCEKvvPIKTjnlFDP3Hudu4/x7PMagQYPw0UcfoaGhASeffHKHlqFwRRGSAuI333yDI4880ixjGW2vr1VXXRW33Xab8WCjeMUJaHPxzjvvYN999223LNcxKCZRiLvgggvw008/mW0pZhKKTlOmTDHzCfr9fiOCURR0wm0oqlFcs6Fgdd9995l1//jHPzB+/Hjceeed+PTTT825i4Gi2DXXXGPqmeIqr2PSpElGiJs6daoRVynQsYwUAd9//30jojFUll5yrHOWhXCfv/76q93xeYztttvOlJVi248//mjqn6KcU+SjmHjqqafi448/xocffmi2X3/99U07F8KFF16IK6+80oT1sg7YVw444ADT52zRkvMk2tuyrg466CBzTaxDirA2FCvpBZgLzhXIjw3rgCQiEaT8fnQJyzIZ0ziHCro66EmlkIxETNKPrpKKxcxfJgnpEroOtYf6leyjoJuN7le67+r5Ifso4FahcclCN74aVV2NTVZaCZ//9hvq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uBA+T2a7lU0IIYQQQghRQ8HkPljhL0Ne1rJa+78aBTCCOKoiFSgoLsbgof1VXUK0ARIAOxCaK9988834v//7PxQWFrbZcWnp1Nlp0a+55hqccMIJdX+7XJ0bmJXn79+/8ycKWqAdc8wxcDqd2GKLLYwoaXHmmWeivLy8nuiXn5+Pl156qVveA12Jvn37YqeddsJDDz1k+lxzrR3lViCEEEIIIUT7M2zASEyb/S8WVC9GNBY226LxKMJYDl+WD8PWHIrNx22uphCiDXC2xUFEeuywww5GlKIVYGO89tprWHvtteHz+Yx13e23317vc2677rrrjNUVBSMKb3QbpYsuLc5GjhyJrKws7L///qiqqjKWh9yHouPpp59ek0Gplueeew4bbbQRcnNzTdnoprp48eJmN6m1v/UqKSmpK+tdd91V77t0yaXLpgXFlscee8xYQrLcq6++Ot566616+/z111/YfffdkZeXZ8619dZbY9q0aeY4vL7//ve/dcINLe3oAsz3lkso+eKLL7DJJpuYeh0wYICxxGQqeYttttkGZ5xxhrEeKyoqMtdhLyfh30OGDDHHGDhwoPl+KpYuXYqPP/4Ye+21l/mbAp29jjIzM81xErdZfPjhh1hrrbWQk5ODXXbZpZ54yLanOy7vJZZjjTXWMNvnzZuHgw46yLR1cXEx9t57b1MXFj/99BN23HFHYxnJe2fcuHH45Zdf6pV76tSpxm2ZgvWoUaPw0UcfobU0VfexWMwIdSNGjDDfYR1ff/31dZ9feOGF5hp5fwwfPhyXX345wuGaBUIqWO8vvPBCq8suhBBCCCGEaB9GDl8XA/r1h9fjwZr9xmLMoN2x1ag9kVOYiVWGF+GgI/fEmI3WU/UL0QbIArCDrdJuuOEGI7JROFpllVUafGfChAk48MADjdBEIefbb7/FKaecYsQcij4Wt956qxFBLrvsMvP3119/jerqamNx9uKLL6KiogL77ruveVEYfO+99zB9+nTst99+2GqrrcyxLcuxa6+91oiGFP7oMsnz8PsdydVXX41bbrnFXNe9996Lww47zLgVU4ijqEVBigLdp59+akTAb775xghIjPX2999/17Ok4z7z58+vd3weY7fddjPX9swzz+Cff/4xwilFLrvIRzHxnHPOwQ8//IDvvvvOfH/LLbc0otmrr76KO++809QvBVq69v7+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jBlGAKSY88ADD9R9p7q62nyH4hlFvX333de8KAy+9957mD59Ovbbbz9stdVWOOiglYPurbfeiksuucQIQh9++CHOPvtsE3tvxx13NPH3eIw+ffrg+++/R3l5Oc4666wG5aNwRRGSAuLEiRNxwgknmG0so2VdtsEGG+DBBx80FmwUrzweT8rr/fLLL3HIIYfU25bqGBStKMRdccUVmDx5svkuxUxLvJszZ46JJ+j1eo0IRlHQDr9DUY3imgVFoCeffNJ8dvfdd2O11VbDI488gp9++smcuzlcffXVuOWWW0w9U1zldcyaNcsIcfPmzTPiKgU6lpEi4DfffGPEO7rk0hqPdc6yEO4zf/78esfnMXbbbTdT1meeeQb//POPqX+Kp3aRj2LiOeecgx9++AHfffed+f6WW25p2tmCIuJXX33VaKxAvixYNhKORoD6urIQQgghhBCil+HxebDapsMxe9JcVM6rQtQfQ59+JSjJHYA9t9kDB+19sDFqEaK7IAFQdDh20Y2WbNdeey1OPvnkegIgLe4ojlGsIrQAfPbZZ7Fo0SIjiNF6jxZ0n332WT0BkCIQLcYIrfgoQN15551GGPr444+NCEWBbJVVVjHfueGGG7DrrrvWK99ll11W954i5bnnnouXXnqpTgCk9RzdSyksElrCNQbPRzHRTmPHoCm5ceW0ucZOmTIF77//vhEuN910U7Pt8ccfb+DeSou5xEQjtKLkMa1jU8xsqesthTZLzGTdUQT88ccfscsuu+D+++83x6doawmibAMLWi5ScGvsvLwHaBV63333mTpg/VAkpFUmRVErhuK6666LK6+8sq7u+P1PPvmkngA4aNAgU/epuPHGG42gmcg9Bz2A3LzcZteNEEIIIYQQomfTP68/nA45UoruiQRA0eFQtKN4NGnSJGN1RQuxQCBgXHytX1DoYmqJf6Rfv35GjLOs4axtiRZwm2++eYO/LddWin/MDmuJf8m+T1599VWzz7///mtck1k+WrNZ0PLs+OOPN4LkDjvsYGL72cuaiN/vr+f+25JjsOxutxsbbbRR3TaKY4nJQihqJUIruraCwpsF24piotUGtGKky29j1pBNwetkm9hdVynqsh3mzp1r2i+xHJbwmXgvUHCkJWkqLr74YtMOFrwXKT46XQ7zEkIIIYQQQgiLvtn9JP6Jbo0EQNGh0F2ULp4n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Q2/uE+0F22CTTTYxQmthYWGrjhX1hxFcWrUyg6gFRV2PC76SHDjdzsYXELWLByvjWG3OMMDpqMk2VpA62xiJRWImYxmDN5ud647hMMdgMGJXpkfXofbQfaX+ofFK467mD83nWpdofaV1Yhdbt2+eNwpTK+bA7fHWbALgd4SwPFSBOZFl2H73HTFkzWGNruWFaAtkAdgCKLSx0//444/Yf//9scYaa2DttdfGOeecg++//x4dAa39hgwZYtxf11prLRx//PE49thjcdttt9Wz+tpnn33M56utthrOPPNMI8x8/fXXKY87a9YsY7VF0YRWg7yu9957r953JkyYYCwLs7KysMUWW2Dy5Ml1n02bNg177703+vXrh5ycHGy88cZG8LJDAfS6664zAieTLlAYI99++61xn6WVHK3HzjjjDFRVVdVz7WTZ+PmwYcPw/PPPN6vO2GYPPvggdt1117pjvPLKK3Wf82+ywQYbmO+y/gjLOX78eNx4440YOHCgae9kLF261FzrXnvt1eCz3Nxc9O/f31w724rt8L///a/u8xUrVuDII4809c56ZRmnTp2adrtMmjTJCMKsc9Y9LeBYHqv8tBa9++676ywRKdhtu+225nMek9v4PfLBBx9gq622MmJecXEx9thjD9OubdEnZs+ebe4PlpMC6IEHHohFixbVO9ZNN91kroF1dtxxxxnRNJEnn3zS3Ne0fqXA/cADD9T7fJ111jH1/cYbb6A1RKpCCC6pBGIxM+l7irLgKcwykz8XEvFQBIEF5YhFarLuJltEhJZUIVzqNwsAk2GsKAvegkw4M2oEOy4y+J1Uvyry2DwHhUiekxnKWAZPfibgcpjFDcvIsuo61B66r9Q/NF5p3NX8oflc6xKtr7RO7Frr9m3X3RKrZJZgTmA+TltlT1y8wTGYh+UoywljxLjR2OmQPTBk+JBmP6sI0VxkAdhMli9fbgSS66+/3ggxiVA06Qi+++477LTTTvW20arv8ccfN5ZXHk99ayAOUp9++qkR626++eaUx6W1Fi3cvvzyS3N9FJYo1tihVeHtt99urA1POukkIzzSApFUVlYaIYoCH8WZp59+2ghXPC8FSwtaZl1++eW47LLLzN8TJ0405b/22mvNNSxZsgSnnXaaeVHsIRSo5syZY66DFngUCCkKNgeekwITxTC6Qx9yyCEYPXq0EZMo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XHJJ0vriID1kyBCcfPLJWLFiRYeV66qrrsL666/frvcNJ5xbbrkF6623nslQ1adPH2y55ZZ48sknza9UHS3CXnTRRQp8K4QQQgghhOjW0CqQ7r+M8UfvI0v443srjiwFQT7bUfwrKioyz2SpfmQSvZce5wI8ffp0IzpQILrhhhuwzjrrmM4yZcoUPPHEExg4cCD22muvuu9TILzwwgvxxRdftFuZOuIcHc0uu+xihB07JSUlnVaernB+8vjjj2PzzTc3wm+y+uK9OGnSJBx77LHGou2FF15AT4Di384774zff/8d1157remDNDun8H3bbbdhgw02SCpAthe77747TjjhBHz44YfYddddO+y8QgghhBBCCNGWUNijpsDnXRpZTJs2zTx/nXLKKcjPzzeJQZgghMZOFAsp/o0cOVKNIBrQ4yRhdgIq4j///DMOPPBArLXWWkYE3G+//fDuu+9izz33rPf9//u//zMixXvvvdduZUr3HBSIWF527jXXXBMPPPBA3Wfs4Keddpox5eXnFJhuvPFG85klNu2zzz5mcLCLT2+//TbGjBlj9hk+fDiuvvrqehmFpk6dirFjx5rPR40ahY8++iita/L5fOjfv3+9F3+FSGYtmWjtyPdnnHEGLrjgAvPrBPelhZodimO05qP1Jss2evRovPPOO8Yd9JhjjjGmzZZVnbVvogvw7Nmzsffee5t4CRSjeD/QQi/RKu7ZZ581+3LwPPjgg1FRUVH3nVdffdXcPxxU+YvLDjvsYAbXVLz44ov1BObE+lpllVWw00474aCDDsL//ve/us/5i80111xjPud3Wa4PPvggrfYnrA/WF+M88Fq32247I8ZZFpNsd/5t1Rm3pbpvOKGw3lj3rDu603788cdoDNb7l19+iU8++QSnnnqqKT/vt0MPPRQ//PADVl99dfO9YDBo2p7l5HXQMpeWm3bYT9ZYYw1T59tuu21SC9tvv/3W3Lf8zuDBg80x7e3Ce3G33XZrkcDKttBLdaB7QPeA7gHdA7oHdA/oHtA9oHtA90BXuQdo6cdnHxpW8NmYLFiwwDzj8TV37lyzbcMNN8SOO+6oBCCi51sALlu2zIgqtPzLzs5O+p3EmEsUPU466SRcfPHFxkqrPcxk0znHo48+iiuvvBL33Xef6dS//vqrsWDidRx11FG455578NZbb+Hll182LqRz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" width="854"></p>
   <p>This obscures some of the changes in performance because it skews towards big order-of-magnitude differences. To show the differences without the heavy skew due to the extremely poor performance of the bottom two/three categories, we also provide a "focused" graph which eliminates the poor performers and shows the linear performance of the more competitive top 12 performers.</p>
   <p><img height="480" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABQAAAALQCAYAAADPfd1WAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjgsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvwVt1zgAAAAlwSFlzAAAPYQAAD2EBqD+naQABAABJREFUeJzs3Qd4ZFXdx/H/9JK22b7LNpa29I406R3pIE0BC6IgINIEpFmo0qWIBRF9bRQLIEqXJk2KFFFwYZftNT2TKfd9fid7w2QySSbZbCab/X54hk1mbjn3zp1J5pf/OSfgeZ5nAAAAAAAAAIalYLkbAAAAAAAAAGDVIQAEAAAAAAAAhjECQAAAAAAAAGAYIwAEAAAAAAAAhjECQAAAAAAAAGAYIwAEAAAAAAAAhjECQAAAAAAAAGAYIwAEAAAAAAAAhjECQAAAAAAAAGAYIwAEAAAAAAAAhjECQAAAAAAAAGAYIwAEAAAAAAAAhjECQAAAAAAAAGAYIwAEAAAAAAAAhjECQAAAgDXMz3/+cwsEAvbKK690un/x4sW2zTbbWGVlpT366KOrbP8PP/ywXXbZZUUfU7u+/vWvr9T2FyxYYN/61rds0003dccSj8dtvfXWszPPPNP++9//diynNmh/w5GOq5TbU089tdL7am5ududyILZVzG677ebaOn36dPM8r8vjf//73zuOR9f2cPHhhx92eb6qq6tt8803txtvvNGy2Wy5mwgAWI2Ey90AAAAAlN/HH39se++9twvPHnvsMdt+++1XaQB46623dhsCroyXXnrJPvOZz7igSEHiDjvsYNFo1N577z375S9/adttt50tW7bMhrsXXnih0/ff/e537cknn7Qnnnii0/0bbbTRgASAl19+eUdYtypUVVXZzJkzXfv33HPPTo/97Gc/c8FYfX29DUenn366HXfcce7r5cuX25/+9Cc766yzbPbs2XbdddeVu3kAgNUEASAAAMAaTlVxe+21l6XTaXv66add5dzqSAHQIYcc4ir+nn/+eZs0aVLHYwqmTjnlFLv33nttdaBQLZlM9nv9wgB3zJgxFgwGV2mwuypNmTLFhYAK+/IDwIaGBvv9739vxx9/vP34xz+21U1LS4u7XnuqRNWx5z9v++23n7311lv261//mgAQAFAyugADAACswV5//XXbeeedLRwO27PPPtsl/DvppJNcN9r333/fDjjgAPf15MmT7eyzz7ZUKtWxnLp/FutS6ndj9Ltmanuq/pP8ro1aLt8999xjG264oQvB1OXxwQcf7PVYFADNnz/frrnmmk7hX74jjzyyx23kcjm3/owZMywWi9nYsWPthBNOcBWS+V577TVXaajHtdzEiRPtwAMP7Fiu8Ljz6f786ke/K/I///lP177a2lpbZ5113GOqZLzttttsiy22sEQi4R7TMv/73/9sZbW1tdn3vve9jmNVSPiFL3zBFi1a1Gk5Vd0pQB01apRrgwKpI444woWUOk6tJ6oC9J9PPc8D7Ytf/KLdf//9rgrO95vf/Mb9e8wxx3RZXtesjkfdv3UdrbXWWnbQQQfZv/71r07L+deuArWLLrrIPZeqKFQorsrRUui1o2BSIaX2teOOO9pDDz1UtOv93/72N3csOm9aNv91VKqamhqLRCJ9vnZVCarXuqoHC6lNeo5bW1v73B4AwNBHAAgAALCGUmihYEdBgb7WGGvFqDLw4IMPdgHHH//4RxcU3HDDDXb11Vf3eZ8XX3xxRwinbqr+bcKECR3LKDj54Q9/aN/5znfsvvvus5EjR9phhx3Wa+ilYCUUCrmQp7++9rWv2fnnn++6Q6urpQKTRx55xAU6GiNRmpqaOrpLK8zUeIkak03BmCrS+uvwww+3dddd11W03XHHHe4+VS1+4xvfcGHUH/7wBxcGvv3226492n9/KSxSteRVV13lupfqnOtrHYuuCVWmiQI+BZvqRq3qO50LLVdRUeECRD1vuk++9KUvdTyfep4HmkI+Pb8K6nw//elP3fWkwK7Q3LlzXaCl9qqNeq4Ufn3qU58qGuxdeOGF9tFHH9lPfvITu/POO11lrK6l3sbaU9XsHnvsYXV1da49ap+CQK3729/+tsvyev0ovFPIrYrUwiCv2HOVyWTcbcmSJR3Pw+c///k+X7u6nnQOfvSjH3Vad+nSpS5M1XOoikQAwDDkAQAAYI1y1113aSYFd6upqfEWLlzY7bInnniiW+53v/tdp/sPOOAAb4MNNuj4/sknn3TL6d98M2fOdPdrn77TTjvN3VeM7h83bpxXX1/fcd/8+fO9YDDoXXnllT0e14wZM7zx48d7pbr00ks7tePdd99135966qmdlnvxxRfd/RdeeKH7/pVXXnHf/+EPf+h228WOO/8Yte/CdlxyySWdlnvhhRfc/dddd12n+2fPnu0lEgnvvPPOK/lY9TxWVFR0fP/rX//abfu+++7rtNzLL7/s7r/tttvc9/fee6/7/vXXX+9224sWLepyTANp11139TbeeOOO49hmm23c12+//bbb71NPPdXR7mLn25fJZLy2tjZvvfXW884666wu166u6Xy65nW/noeebL/99t7YsWO9hoaGTvvaZJNNvEmTJnm5XK7T6+6EE04o6bj9a6jY7aSTTnL76Ou1659DtTeVSnXcd/XVV7vXmPYJABieqAAEAABYQ6mqT1VLqjDrqcpJ3RYLq+o222wzVy21Kuy+++6ugso3btw4V6W4qvbn0yQZUth9VROHqDvy448/7r5XlZ664qraSpV677zzzoDsX91q86nbs8795z73uY4KMN3Gjx/vukWvzKy72vaIESPc85q/bXU11vb9bet7Vf995StfsbvvvntAuh7rWsvfpyrcSqXqOc1erW68qrZTV+lddtml6LLa9hVXXOEmOtExqPJN/6qy79133y36eii8xqWn607VoC+++KKrQlT3eJ8qFVWhp+63hdWGhc9zbzR79csvv+xuukZ1TL/73e/s2GOP7fO1629v4cKFrtJUdP5vv/12V+k5bdq0PrUNALD6IAAEAABYQ6mb5iWXXGL/93//50Km7kJAjVNW2C1QY4ytqrHC1G2zkPbnd0vtjrrgavw6hTL9oe6Vkt8d2adx4fzHNf6aun0qHFO30Y033tg9fumll7ru0v1VuF918VXBoAJQdRPNv/3jH//o6NbZH9q2xtJTIFa4bY2j6G9bAZtmhVYAe9ppp7nvdbvpppv6vW+tn78/dfUulcI+jemnLqzqQqtAsLsJNL75zW+6a/zQQw+1P//5zy6oU4im8LTYtVR43emak56uO80oreeou2tG/OvGV2zZnmg8y2222cbd1D37ggsucMelAO+vf/1rn65d2XLLLe3Tn/50x1icCoPV1VuzZgMAhi9mAQYAAFiD+RM36F9VAv3qV79ylVJ95QeEhRMarExI1Vf77ruvGwdQYU+xSSF64wdA8+bN6zKJiMaTGz16dMf3mixFY6Yp/HnzzTfdBA8KsjRJxre+9a1uz0dhGJSvMMjS/nTfM8880xFG5St2X6m0bR2vP35fofwKTIVFuikgVvXdLbfc4qpGFUz25zzr+ck/L35QVipN7PHtb3/bnZsTTzyx2+V++ctfukkwVDFXeE2q+nEgqBJUsyvrmimka0byrxvpacbfUvnViW+88Ya77vty7coZZ5xhRx11lJt4RuNtrr/++m7sQADA8EUFIAAAwBpOs9AqAFS3Qk0Ioa6TfeV3HVQYlk+TERQqpbKqPzSBgbqvnnfeeTZnzpyiy2gW2e5oIgc/OMqnqjF1GdUkKIUU5qiiTJOiKFRSoCIKxxQCFp4PTaJSKs0yrIBRx+JXgOXfCmds7gttW2GkQr1i295ggw26rKNurZpAw68c84+1r8+n2p2/r74GgAr91HX53HPPdTP7dkfPTWFIqslOurs2+kOToeic6LrKP36F6bqOFMYpXFsVs3eLKjP7c+1qUh1VzGo2b1V4nnrqqQMSTAIAhi4qAAEAAOC6AquSSV0LFTppJtO+VAIqeNNMtVdeeaWripo6daobd6xY4OYHV5pFeP/993fBkiqa1B11ZahrrgI2hVvq5qgujTvssEPHuG8KR1Qxpdl2i1HopbHuVOGmc6G2qWukzsnkyZPtrLPO6ugyqdl41bVUMyfrfOk41aXWr6Lyx+7TjK3q8qqQ8KWXXnLdrUu10047ufao4k2Vd+r+qsBJVV6atVnnUTO/9ocq91TtecABB7gx4TRWnLrjasw6jSenGYIVEmmMwyeeeMKND6fASN2+dUyi59uvFtTzrXOvoEmzNqvibFWNJ6fAUDMi90bXgSozZ8yY4a6vV1991a699touFXIrS9e8nneNXXnOOee4603Xx1tvveVeRysbrM2aNct1+RZ1b9csy9qnzrl/LZd67fr0mlOXbo1jqWuqcOxAAMDwQwAIAAAAR90qFR5cdNFFroJJXVz7QmOynX766S5UUGWZqrQUgKjKK5+qDJ977jkXkqjbrAK0mTNnDkhgpCBLE0SoIk8VjQoZ1RaFIAqn1N2xJ5oMQYGdJphQpZtCxf32288FLn43S41Bp2q/a665xnWvVOCjAEZhU36X1Ouuu879q+UaGxtdlZbCw74cp8a623777d2/Ol96XhSAKRzUsfaXAiBVZ2osPz1vOj4FvgrHdt11146QVuMcqlu1xjfU2ICa6GKTTTZx6+6zzz4d29P5UkWeJtJQ916dB52PctKxKdTUsen8b7XVVi6o1XU+kHS+FJLqHClI03OkwFfnSCHkylKop5uoqlRBrMI+vc6qq6v7dO3mO/roo902NFmJlgUADG8BTQVc7kYAAAAAAAaPQkWNBahKRU1kAwAY3ggAAQAAAGAN8dprr7mK21NOOcVVkpbSnRoAsPojAAQAAACANYS6oKs7t2Z2Vvdvjd8JABj+CAABAAAAAACAYSxY7gYAAAAAAAAAWHUIAAEAw4ZmE91oo43cDIyFFi9ebLFYzAKBgL3yyiuD1ibNgql9fvjhh/3exptvvmlf+MIXbO2113YzQGoWTs1mqZlFly5d2rHcbrvt5m5D2ccff2zf+MY33KyZmkVV56bYTKE6X3qsu5tmtiyFZrHVLKY6b5o5VfvWbKB9GSR/xowZ7trR+b/88sstnU6XtK5mGtUMoGuttZZrs2YH7a47XnfHqXb395h0nx7TMlpW63Q3q+8///lP22uvvdy1pefl8MMPt//97389Ht8777zT42tq4cKF7phHjx5tyWTSdthhB3v88cd73GZLS4utv/76bps/+MEPbKgovB41s6xmVd12223trLPOsrffftuGkssuu8y1c6DMmzfPXc96DvV8aubZrbfe2u688043w3JPfvKTn7i26Nrqiz/+8Y/ufUL7qqiocJNUaH+l0LWra1jXsva79957u2t8daP3muuvv97NyJxIJNzx7Ljjjvb888/3+3XZX83Nze66euqpp0pa/j//+Y+dc8457jpRu0eOHOnGG7z33nuLLl/K+0V9fb19//vfdz/n1G1Zz63OjWb6bm1tLflnSKmzm5f686ov7Rqo8/Xkk0+663rs2LFuf5tttpndfPPNHa9H/z2gt1v+7wylvG5W5r3A113biv28839/O/PMM93PSl3b48aNs/3337/T7z+l+tznPuf21dvs3AsWLHDv8Vq28Dko5bzqGGXZsmXufDLOJoaKcLkbAADAQJg7d64LxPTLeTDY9e9bGueora3Nff3Tn/7Uttlmm9XixP/4xz+2U0891TbYYAM799xzXcCpD4X6YHfHHXfYCy+8YA888ICtLt5//3371a9+5cKoAw44wH79618XXW7ChAnu2Arpl2h9qDrssMN63Zf2o1/2v/zlL9sNN9zgPmCdf/757gPy3/72t17X1we6iy++2L71rW/ZPvvsYy+//LL74DNnzpySggjtUx/KDj74YPvZz37W7XJ6/lKpVKf7Zs2aZUcffXSX4+zLMemDnNp81VVXuVDt//7v/+zYY491Aflxxx3Xsdy///1v9yFQz8nvfvc794H1kksuceODvf766zZmzJgubdYHvS9+8YvuA6Bee4V0PHvuuactX77cbrrpJvch9dZbb3XB7WOPPeY+UBej893U1GRD1emnn+7Onc6hjk2TKei5VVB85ZVXutfoUKDro9SQvBSvvvqq/eIXv7ATTjjBPUcKQP/yl7/Y1772NfvHP/7R7fWt14pCDYXQdXV1Je9P1+xFF11kX/3qV+2CCy5w+9N16r+H92TRokXu2q2trXXtUqig50bXuF4Pei9dHeg1ptf/s88+a+edd54L/vTa0HPR3Wukt9flygaA+gOIlPKHJr0fPfTQQ/b5z3/eBeWZTMZ++9vf2lFHHeW2o/eYvr5f6H3xxhtvdNv85je/6UKqZ555xoUtjz76qLsVBt/+azbfeuutN6A/r/rTrpU5Xzon++67r+2yyy7udwQF5H/6059cSPbBBx+4c1j4HqDgTj8TCs+HAry+vG76+15QzCOPPGI1NTUd3xf73U3XsdoVDofd/vTcKRBUAFrK+0E+nV/9DuEfc09OO+20bgPJYr+biJ4znRe97+l6EZ1P/ZFIPxt0XzQa7VObgQHnAQAwDJx33nneWmut5WWz2aKPb7LJJt7YsWO9bbfd1qupqfGam5sHpV133XWXpx+3M2fO7PO6zz//vBcKhbz99tvPa21t7fJ4KpXy/vjHP3Z8v+uuu7rbUJb//Lz88svu3OgclWq33XbzksmkV1dX1+NymUzGmzBhgrfPPvt0uv9Xv/qV2+fDDz/c4/qLFy/24vG495WvfKXT/d///ve9QCDgvf3223061oqKCu/EE0/0SnXZZZe5dj722GP9OqaHHnrI3fd///d/nZbde++9vYkTJ7pt+Y466ihv9OjRnc7phx9+6EUiEfe6Kubaa691r7ebbrrJ7UfPZb5bb73V3a9r2JdOp72NNtrI22677Ypu88UXX/Si0aj3+9//3q2rfQwVev121ya9l+g1Wsp1VSo9P8Ve8+WydOlSr62trcv9p512mjvuWbNmFV3vM5/5jHfQQQe5a1+vgVK88sorXjAY9K6++up+tfXcc891166uYZ+ubV3jn/3sZ71VrampaUC2c8MNN7jz8MILL5S8Tm+vy5WxaNEit81LL7205OVzuVyX+w888ED3Hp5/fZf6ftHY2OhuxY5b6z/zzDMlvWYH+udVX9o1EOfr+OOP92KxWJd96mdDdXV10e33dj5Kfd30970gn64hLatj7s0hhxzirmntd2UsX77cbef666/3pk6d6s5rd+69916vsrLSu/vuu1079TOpFKeffrpb/kc/+lGn++fPn++Fw2H3sxooN7oAAwBWe/orsKr69FftYn9BfvHFF+2tt95yf1k/+eSTXSXKfffd12U5/aV7k002cX+533777V2XK3Xf1F+d87u2+F2LVHGoKrEpU6a4vxSrqrC3Lo75f8FXxYP+Eq3uTurqU7juFVdc4fajajN1eymkvySruqwnqhz41Kc+5boTaV/qOqxz5Xn6PfUT6lqjLjH6i7yW0bGr62uxv+arIkXdf3TM/vnxu/n11tW52PNTKlU2PP300/bZz36217/gqxJBFQ/qOp1P1RSqzuitalLnQZVwhevre527Urrz9PdYtf277rrLpk+fbnvssUe/jklf6z49Vth+VVToNeFXLDz44IN2xBFHdDqnU6dOtd13373oefrvf//rqlFuu+22bp8HraeKEV0nPlVwqHrxpZdechUSha9hVS6p6qKv1bnqBqYqWV2Lek3ovKl6rLCqUtfn17/+dVcNvOGGG7rX3eabb+6Of2XotaLXlCphrr322o77VVGjdqlqV8+Fqpr0fOr9JV/++8n3vvc919Vcr/cnnnjCdXXTOfHpfUgVJbq21EXNp26iOr+qoOquC3BfXuOFtE8dX6Htttuuo6tkoV/+8pfu9arrpC9++MMfuuNXpVJ/6NrTedY17NN1quqnP//5z+6a742qz1RdpedM1VXqzqnnp7D7v/8z4+9//7ur0NM1pevYf051PahiWede51vLq2pX21FlsSojVQGlSj91gc2nKi61QT+LSlHK67KYUq5THY9fCayfKX43x+6GNRBVIRaretM1o2rC/O6bpb5f6LnQrdg2Zfbs2TaQSn0PH4h29eV86bWo9zpdU/nU1bS7qrWBet30572gv3TdqbJRv7dpvyvj7LPPdj0LzjjjjB6X03nWe67/u12p9HNFleBf+tKX7Ctf+Uqnx/Q+ru7U6rUBlBsBIABgtacwY8mSJS6wKEYfzkUfzI455hj3Ic2/r9D8+fPdMscff7wbg+rII490H8rVtabYB1V9mFbXH33Y1YcFjUvTXfcQn5ZVl1L9cn33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53ix9yP9kU3r6mt/+Ai9vxYup3BQVFWp7/0/7Or1ofd8BdPdTShXyK/KzP/jHVAWgzLSIAAAq5AGXtaPtB/96Ecd92kQ8/Hjx3sbbrhht+sdfvjhbsDnhQsXdgzorskxNLC2BlXXwNZnnnmm2/bXvva1LoNpT5482dt55529+++/37v33nu9bbfd1guHw96zzz7b7SQgcs8997gBszVpgAaXfvrpp936F198sffVr361Uxs12Lu2uckmm3i33nqr99RTT7nBpDXY97rrrusdeuih3U4CooHptW8NHK/JEDTRw9Zbb+0miChsU3eDYhdu8/XXX3eDb2sQ7t/+9rfen/70J++AAw5w62ub+RMMdEfHrJs/UcNpp53WcV8xmvRA5zp/MP18H374oRv8+4tf/GKn+3Wetf2vfOUrbjBvncsRI0Z4e++9d6fldE61/uWXX97pfk24oMliNLmCltHg6ZqgQAPL57v77rvd+vq3cLv+cemc7bbbbh3f+9dcPj33au97773X7bkr9ZhE92liAC2jgdbVbq37y1/+stNy7777rldZWentsssublB2Xc+63vQ6KNbOfN1NNtDa2uptvPHG7nnT4Pu6ZjUYvq5lnZee9GUSEE1ioWtRk0Zcf/31bj+apECva12X+fxrrZCu3d4maPHbdPrpp7sJGjQAv86VBrLX5B06ruuuu67TOpdccom7fvSvXou33Xabe0/S8tpnqce7ePFitx0tk3+N6nrzJwD45z//2Wmd7iYBKeU1Xsy///1v996ogfr//Oc/u3OQf+vtOuluEhC9ZvXa0WvYp0lNttpqK6+mpsZNfqDn9Pzzz3fLff3rX++0vgb81/351JYJEyZ4m266qffAAw+450nXtq4RXeu90TLRaNS9Xv3Xg15L/vumXnf5507XeaHuntPuJhUo9jrSJFV6bW+wwQbuvfuhhx5yryFdCz1NStDd9rpT6nUq+l7t0c9GbbunSZ808YYmwdAEDHr/Kbxm/AlP+vJ+oQl2pk+f7t6H9T5WuM3Zs2d3LKsJKXS96NzpvGviCf2M7stEHqX+vOpLuwbifN18882uLfvvv7/3hz/8wf1812tE5yt/ErJ8vb3PlPq66et7QbGJOfSerd9htL6ea72P6lrXz5z8Saf886/rU+9dmqRDv3fo55PeHwonciu2r2K6ey8sVOz1qkmA1l57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s846Fo1G3XN9zz33dHpc6/7kJz+xww47zLVjvfXWc/sdKH/+85/d86dj0HN9+eWXWyZTPAzzz52eT50PrbPxxht3qdZ855137IADDnDX4Lhx4+zzn/+8LV68uONxnZ+vf/3r9s1vftOdt7333tvdf9lll9mUKVMsFou5a/eMM87oWCcUCrlt/vrXvx6wY19dQ8BIPG61a020MdOnWE00bpH6Bhs9b7lVfrTIpjdmbLdJa9sBW2xjG01fx503AAAAAABWFQLAnk5OMGg333yzvfXWWy7Q0/h46iKbr7m52S2jsOWRRx5xIYsCpocfftjdFBTdeeeddu+993Za79prr7XNNtvM/vnPf9oFF1zgQig/5FP3SW1DocA//vEPu+OOO1zYV0jBnsIqBTk33XST/fjHP7Ybbrih4/Hjjz/eJk2aZC+//LK9+uqrLsCLRCLdHu/f//53F5QVo9BHAV/hceSfB3UTVuCp/f3+9793lX0KkFY1dVm+7rrrXLipasUvfvGLHY899NBD7lyqMu21117rCAtFY9Xp/HznO9/pqD4s5oEHHrAzzzzTzj77bHctnHLKKS4QLayIVCj32c9+1t58800Xgun8L126dKWPT9V06hatoE3P9Y9+9CP3vH//+9/vcb1zzz3XtVnHrSDw4IMPtiVLlrjHdKy77rqrbbHFFu686dpdsGCBa38+Xfc6p88995zbr55/XWP6WiG1xh1USJ5vu+22s2eeeaZPx9iWy/Z4y3g5GxNPWiQYtFmN9daQbut1nVVxq4pErSYSs8WtzbagpanHZdOa+CMRs+T4MTZqg3Vt/JZb2GUnfcXu/Ma5duMZ59pJBx9q0yZPJvwDAAAAAKx63hrsxBNP9A455JCSl//d737njRo1quP7u+66S6P7e++//37HfaeccoqXTCa9hoaGjvv23Xdfd79v6tSp3n777ddp20cffbS3//77u6//+te/eqFQyJs9e3bH43/5y1/cvh544IFu23fNNdd4W2+9dcf3VVVV3s9//vOSj6+mpsb7xS9+0ek+HaPul29961ve+uuv76XTaW/ZsmWuPU8++aR77M477/Rqa2u9xsbGjnUfeughLxgMevPnzy+6v5kzZ7ptJBIJr6KiouP2z3/+s+Ox1157rWP5wn3qX33/2GOPddqn7mtpaXHf77DDDt7xxx/f7THrubjhhhu6PWbZcccdvZNPPrnTMkcddZR3wAEHdHyvfX7729/u+F7nIRAIuOetO7vuuqsXiUQ6HbtusVis0/4//elPe1dccUWnde+55x5vwoQJnfbvXxv+ubvqqqs6HtdzNmnSJO/qq69231988cXePvvs02mbut603nvvvdfRvi222KLTMtddd527Btra2ro9rj/+8Y/uec9ms10ea21t9erq6jpu/j7fmjPb+6ihbtjfsrlct+cNAAAAAIDu6DO0Pj/r3/6gArAHqvBSt8e11lrLVdudcMIJroJKXXx96u6prqE+daVU1191q8y/b+HChZ22vcMOO3T5/t1333Vf6191sVR1WnfLi6qxdt55Z9dtVvtTF+BZs2Z1PK6um1/+8pdtr732squuuso++OCDHsPglpaWLt1/86kKcdGiRfazn/2sy2Nq8+abb+66C/t22mknV81Y2CW30G9/+1vX1de/qctzX6iS0jdhwgT3r3++tb0999zTVoaOTceST9/7z1exdug86JopfN4LqUow/9h1U0ViPlVv6j49x/7t5JNPdlV8qrzsTv41oyo+VT76bdY2dX3nb1OzP0v+dVJYEarxIXWdqBuy2qDqyMKuyOoCruc9lUp1adOVV17punj7N3WtdyLhNeMGAAAAAEAZ8Im0GxobTt04v/rVr9p3v/tdGzlypD377LP2pS99qdM4e4VdajX2WrH7SpkV1R+Drr2gq/hjPnUNPuaYY1y303333deFKeqGrK6w+d12Nc6gusH+5S9/sUsvvdQto3HqitE4b8uWLeu2fRoXT92Vtc/PfOYznR5Tmwvb2F3bCykEWnfddTvd589CnH8u8s97vvzz7e/LP98KowZC4TEUO97+PO963gqPvXACEm1D59wfuzBfT4FtMfnn56CDDrKrr766yzJ+iCr5ga7/XCnQVXd1dfHWuJjqzv700093HL+6PSsYL3budf0omPbV19e7bR72n+ctVNl5Xz3JmWcL0q2W8nI2IRK3WKA8Y+gty7bZ8kybjQhHrTYU7XHZjOXs8Rm72pRYctDaBwAAAACAUAHYDY2LpsomBWrbb7+9m2xj7ty5A3bVKMAr/N6vwFIFnCr58vf3wgsvdFpeY7JNnTrVjX+nKi1NOqHQspDarfEF//a3v7kA6a677uq2TVtuuaUbY64nmtBE4ZzGHMynNqt6Lb86Um3UsmpDX41ZMStq/rh8+ROClEpVeRr3rzua1KNwgpZCG264oQt/C2dM1v2DYauttnKhm4LCwpsflPZ2jelaVtWff41pm2+//barVi3cZmHoV0jBnsYT1NiXGvNS16bGh/RpnERtvxhNHKIJafJvEg0G+3SLB0M2OZq0RDBkCzIpFwj2dRsDcRsXidvoSNzqsmlryGV6XDbM2y0AAAAAoEzW+ArAurq6LsGSqv3UrVehiWbnVaWUwixNxjFQtL1rrrnGDj30UFdNpUkzVKkn6rKrmWbV5VgBpKqkFPTlU1CjkFAVfdtuu61bV90xfeqmqUkgNCvx2muvbR9//LGbnOOII47otk2qJNSkDz1RxZmq0U477bQuXVlVYXjiiSe6ykN1FVZYqJll1QW6rxQyKXhV12WFVJqd9tvf/naft6M2qQuwnk9VTOo5VTWkP5mLtq3JT/SYwilVQRbSedTkGAq1tC3NyKsJRFQBNxguueQSV3GpSjl1wVXop4lGFLp973vf63a9W2+91QXDCio1cYeqO/0JUvT8adKYY4891h2fjvv9999315Pu725WWk0+osD0U5/6lKvy0yQ3eq4URvs0AYhmk17V3OzAkYTNSbfYx+kWmxRJuGBwsI0Kt1f+LcmkOn3v0zXXumCRtdQ32N9aYjYmGLVJFdW2/tRpVllR0WuFLAAAAAAAK2uNrwBUBZMq3/JvClw0O+r111/vukhusskm9qtf/cqNXzZQNDurKrK0P3UxVtCnAM49KcGgC/M0hppmVNU4foUzvh5yyCGusk+z7KqtqkjTGIA+BTgar1AhoirwFGDtv//+LrzrjmaaVQVgb2P2KeTTGHD5FAZptlp1/1QgqeBRYdkPf/jDfp4hc2MNqtuvKhw1C29PYVd3dtttNxeu/ulPf3LnaY899rAXX3yx43GNrffhhx+6gNCvOiykkFYVj+rquvHGG7sZcFVJqW0PBl0XDz74oAuKdW4VjOrazA/dilF4qutXYzMqlPvjH//YEXBOnDjRhdAK87R9XeM6x+qS3FNVobqBKyDUGIh+daUC0VGjRrnH58yZ465FzZI8GPwQMBYIuhCwNddzNeeqotBvVDjmQsAlmbaO+zVG47y/v2Qfv/qmLfjgf3bXM0/aXS8+Yz/+5z/s54/+xWbNnVvS8AAAAAAAAKyMgGYCWaktYFhRZZyqIhVyYfWkQFNVn6+99poLPQeTqgl1/dx5550lLa/qVoWOGz//QJ/GACyU8zxXCagxActVCSgK/xQCKgysypnNe/o5q8vmzKIRs3DIplVWW6QtY1WNLbb26DG2c/UYO2qHXWzimLFUAgIAAAAAev38rM/c/nBafbHGdwFGZ+pqrK6jqgzrrhso0B1NYHLOOecM+gkait2Bl38w25oamsziEbMrfqJG2oem7r6eRc74vNXNbrVATbNtPOsjG1ldY4k+TugCAAAAAECp1vguwOhMafKFF15I+Id+VwD2Z8zH4dgduOmjWWZqQyJqFgmZhcOuCtBCIUsnYvbB/Nn29qIF9spH71tL+pNuwwAAAAAADDQCQGCY0cQm6tk/2N1/h4KhFALa0gazULA9+FM3YM02rZvG/IslzNpSNnvJAvvXnI+tubW1LO0EAAAAAKwZCAABDCtDJQS0hgazdNp1+TVNrBJacQsGzNRTONVmjY2NNrepweYvXVKeNgIAAAAA1ggEgACGnSERAtbVtXcBDkTaQ0DNt+RpDMCA+9YCevsN2NLmBlvW2DT47QMAAAAArDEIAAEMS2UPATNZs7oGs1SrWUDBnygEzJktWWqWSZtVJyzVlralDXWD2zYAAAAAwBqFABDAsFXWEDCriT+CZk3N7WMAzlloNmeBWdZrr/7Tv55ngWTSljU3Dl67AAAAAABrHAJAAMNa2ULAaMAsHjOrSraP/efT15oVWHdVVJoXNIuF1U0YAAAAAIBVgwAQwLBXnhDQM6sY0f4uqzH/Joxpv6k3cFV1+2zAFrRoLmAV8eQgtAcAAAAAsKYiAASwRhj0EDAcNQuZWSTWPgZgJNx+U/ffdKb93TebtvGJCltrxIhV2xYAAAAAwBqNABDAGmNQQ8DKSrOMxvoLtI8BqNBPt2zWrC1tFgxZRdps7eqRNmXc+FXXDgAAAADAGo8AEMAaZbBCwLCq+jKtKvMzCwW0409mA06lzMIJGxGJ2KfXnm6jqmtWSRsAAAAAABACQABrnMEIAasnjzdLtZmls+0VgDnN+tv+WDwSt5Hjxti0QNg+tdEmlojHB3z/AAAAAAD4CAABlF3OW5GMDaMQsGrtKWaRqFljU3vlXyDg3nBDObPquiabFozaIdt8yiaNHmsBvzIQAAAAAIBVILwqNgoAfTEv3WqTvAoXypUjBJyTbnEh4KRIwuJBzdyx8pIjR9ioGevYkg8/NjvlOLN42DasGGG1FrLxlVW2Ue0Y22/DLaj+AwAAAACscgSAAMou5eVcCKcwbriEgOF43EatPdWi0YilGposnc3ap0ZOstHhsE2MJmz7KevYhtPXofoPAAAAALDKEQACKLuJkbjNG2YhoLr1xqoqLTh1iqWWLrO2VJvtM22GTY5U2JSRI23C2LEWCg1MtSEAAAAAAD0hAARQdkEL2LhwzHUFnt3WbOMicXffYBsTjtmCdKvNamu2CZG4xQIDENDFYxabON5ClrMdZmxiU2LJgWgqAAAAAAAlIwAEUHYPrL+jVVVX23A3KZoodxMAAAAAAGsgAkAAZTc5lrRqKuMAAAAAAFglgqtmswAAAAAAAACGAgJAAAAAAAAAYBgjAAQAAAAAAACGMcYABFB2rYsaLNo6+LP+DhWx0ZUWCK65xw8AAAAAWLUIAAGU3TuXPWKV0aT7OlPfaun6VovUJCxcFetxvUxDytJ1LRapTli4+pNlW+bWm+U8i42rsmCk50LnYsvm2nKWWthgFgxYYmLPsxPnMjlLze+6bKnH4WVytum1B1t8bFWP+wEAAAAAoL8IAAGUXTAccjcJhEMWCAQsEA523Ne9gFmRZbW+BjgIRrTdngNALarwTuFfp22oIi8Q6LUNXtZz29DyndYv8ThyvRwhAAAAAAAriwAQwJASjIVd8Jaua7VwZaw9zOtGpillAQu0r5MnlIhYtqnNsi1tFqyKd7u+l82Zee0pYCD0SVDovtZ+Pc9V+PUUInptWRdEhiqiJR+H53nW0tZqi+uX2Pzli+2jX2YsOiJhyVFVNm3GujZ1nakWDvP2DAAAAAAYGHzCBDCkBKOh9vAtm3PdaNWFtphMY8p13XXVe1onT6QmbtnmNksva7FQLGzBaNe3Oi/nWWpxkwsA1X04P6DT15HqmKWXt1hqQYPFJ1QXHaMvl85a2/IWV4iokK+U41D419DSZB8tnGML6hdaJOVZ03uLrCURtubqiDXPX25Ny+tso603IwQEAAAAAAwIAkAAQ4rCt9joCkstanTVcwr4whWxjgBOAZqCuUx9ygVvWrawSlBdf8OVUUs3pKx1QaPFxla6QM5fzo3bt6DBBXiq9osUGaNPgV66PuWWUVuioyo6VQJmW9KWWtzoQshQRczts5TjaM2kbPbCuTZr0WzzWjKWzgUs+9+5lguY5SKeBUfFrH7JMrNg0Kavt46FYxGLxXuuhAQAAAAAoCcEgACGHHXhVeDWtqTJ0ktbXCVf+2B9K+Ry7nsto2WLidQmzct47UHdggYXFq74n+vaq5vCv/j4qk7df33+Y63zGyzXmrHWuXWd27BiG6Fk1KKjkiUfx4Kmpfb+gg+suaXVfrHgkfZgb7Y6Mpudsfmx1tLYbB+15axy3AjbcKMNLZvOWnOmyZKVXYNOAAAAAABKQQAIYEgKV0RdVZ2q/bKt6fbuvhJQsBa1yIhEl66/+RSWRcdUuAAwvbTZdfl1oZ0yNHXxrYm3j81XJPzzaf+a2dfNNtyQWhH6rcgRtf3R7QFkT8Fc4XEsblxqS1uWW6WXME//qRfziqYFGzOWDaat1ZbarHdmWmtLqyWSCbNMxlKtKYsnuh/PEAAAAACA7hAAAhiyFPCp+67COzdhx4rKvGLj8RWjYC6cjLqb1nchYGDFNkqspnNdhEckLFwT75g0RPvvKTjs7jhy2ZwtWtxgkUjUIoGIBQNBC7p2qFFm8VDcljc1W85rsyUfLbKG5fUuANSEIK2plBkBIAAAAACgH0r/BAsAZaLATVV0upUa/nXZRijYvo3wJ2MB9mn9QMCt69rQh/AvX9rTmH85a8tlLZRp30bQQhZy/w/aqGCN1YSiVt/YZJnmVlu+uC5v//3aJQAAAAAABIAAMFhyXs6VXbe2NVu4Y1KTnOm/rJezutRyC3hRC6RTlmpttXRrS8e66iIMAAAAAEB/0AUYQNmpa22uLev+JNGX7rkd63srughrbpBQ37rndmyjn92MO21D3YyzXvfH4QWsLZC1TC5tdemmjrsDXsB1BY7ForYs02whL2pNTa2u669kMhk3GzAAAAAAAP1BAAig7Frn1VsolO6YXCNcFbNIVc8TdPiBW6YxZen6IhN0jExaKNnzBB2i4LFtebOb6detLwGzYCxs0dpkjxONuDZ47TMNty1p7tKGLscR8FzY15BL24RgyDT379zUEvfQhNhIW9LabJbxrNmaLdvqWbwi6cK/bCBnyXiiL6cUAAAAAIAOjAEIYAhQ4tY+EYZCtExdq7XMrbdcOtvtGnpMy2h23fbZfTtvo21xk7UtanIBXXcyTW3WOr/eci3pT9ZfUfmXS2XcY1qmO17HfhqLtqHwODTpRzQUtZCb/zfrugT7sronm7LWbMpacp41pJosUh03iwQtWVnRr3ELAQAAAAAQKgABlF1iUo0lo8mOqr7U4iZXVdc6v8ESE6u7VAJqGT2mfzUpR2xclQXDwU+6A6ez1rqg0TItbRZYpmrAii77bK/aa3IVe+HquJvp1w/ZtI1MY5ullzW7ZdQdOJTo2gVXj2Wb21zoFxtd2WmZYscRDUWszctYZThhGcu4wHBcrNaC1t5duDpWZXVtDZbMBS0VSVntmJEWZ+ZfAAAAAMBKogIQwJCisC82ptIFe5Zr7+JbKN2Q0owaLnCLT6juCP86ZuuNhi0+rtJ9rSCvsJJQAZ/COYmOSrquvvkVdvpaXXcjNXFXyadlCysJtc1sc9osGLT4+OouAWGx49B21dR4KOLm/tW4g6oK9HedDMcsEYybFwnZqKqxtnDOgoE5qQAAAACANRoBIIAhRxV3qupTMqbx/fLDN1edpwAwYBYbXdHtZB0KASO1CVfhl65r7fSYm3Akp8k6AhaujHXbDlUGmqoPPa99nTyuDZ5ZdESiPeQr8Thi4bjFoxUWsIiFgq72zwIr/q9RAcORqI2tGGmVFVXWsqyhj2cOAAAAAICuCAABDEmuqk+lcf4Mvyu4r914e+1Vdj0JJaJuOXXDzafx/TQKX0/hX0cl4IoqQK2Tz3X9Nc8CvUwSUngcNfEqq4zHLJ3TqH/tM4boYbdIIGKBWNBG1oywiniyXzMRAwAAAABQiAAQwNCmjCy/923O/76EcMyflbfI/W6i3lICNj97LNiOK0oMBCwQCvTpOKqTVeaFAxaPRds37+UsZ57p/83BZqtOJC2cjFt17QizUM/hIgAAAAAApSAABIapadOm2Y033tjn9VT19oc//MHKrb3b74pKv7ygzgVupWZurnLQ6xLSBYJ66wu0dwPubRuZ9q6/3QZ9Xt+OY2RltVXFq60519yRbQY1bmEwZFWVlRaMRi06MmmJMRU2csLo0g4UAAAAAIAeMAswMAhOOukkW758+ZAI1lYXmsnXOqrs8ib5CH3SpVZde4vNzuvLNqmbrib0iHe6360TaJ9MJFwV67YrsRtvUBN9BLrOAqyuwellLZZe3mJRjUWYN4lIT8cxqqLWpo2ZaAvrl9jJax1k8WjUKsdUWTAYtrm5ZZYcXWXVa42w6i0n29gJY/t41gAAAAAA6IoKQABDTq4tY60LGtsn2RiV7PK4u8/NztvYZYZfP7hLN7RaRgFg0CxU0d7d1hcIBy0YC7sKwdTCxi4z/Lpt5Dz3mGbwDURCXUJCN35gsH0swGIzFXd3HKFQyKaNnWLbTt3EGqItVp9usbaREUuNCdqoGROtZr1xlthktO17+AFuWQAAAAAAVhYBIFBm119/vW266aZWUVFhkydPtlNPPdUaGxs7Hv/5z39uI0aMsAcffNA22GADSyaTduSRR1pTU5PdfffdrqtvbW2tnX766ZbNdg7DGhoa7LjjjrPKykqbOHGi3XLLLZ0e/+9//2u77LKLxeNx22ijjezRRx/t0r7zzz/f1l9/fbff6dOn28UXX2zp9CeTarzxxhu2++67W1VVlVVXV9vWW29tr7zySp/OQbY1bblMzt0U3LXObzAvl3NVd8Uq/Nz9yajrwqtl0/WtbpZeT9tIZ61tcZOllza7ZaOjis8U7O4PBdtDujl1lmlus1ymfRtqT8ucuvbJQ4JBi42p7LK+tqltuBl+l7VYaklTyccRDodt3cnT7dCt9rHpYyfZ9E9vbBvts42N+9Q6tsFntrNDTvysO98AAAAAAAwEugADZRYMBu3mm292Qd7MmTNdAHjeeefZbbfd1rFMc3OzW+Y3v/mNC/UOP/xwd1Mw+PDDD9v//vc/O+KII2znnXe2o48+umO9a6+91i688EK77LLL7K9//audddZZNmPGDNt7770tl8u5bYwePdr+8Y9/WH19vX3jG9/o0j4FewohFSD+61//spNPPtndpzbK8ccfb1tuuaXdfvvtrmLt9ddft0ikeLfcVCrlbj7t092/sMHCkRXhZfvEuBauiFq4Ju6q9IoNsxceEXcTcWRb2qxtaVP7Sn7O5wbWM4vWJiwYDblgr5jomIr2CkBXCdjQ3rXYp2H7QgG3jL4ptg1tO1KbsLZlzZZpSFmmofWTbZRwHFXxCttq3U1ts88fbPGxVUXbCAAAAADAygp4xfq+ASjbGIC///3v7Wtf+5otXrzYfa/w7Qtf+IK9//77ts4667j7vvrVr9o999xjCxYscNV9st9++7kQ8Y477nDf6+sNN9zQ/vKXv3Rs+5hjjnGhm0LDv/3tb3bAAQfYhx9+aJMmTXKPP/LII7b//vvbAw88YIceemjR9ilU/O1vf9tR5aeqP1UWnnjiib0em4LIyy+/vMv9C97/2Kqrqm1NFRtdWdqMxAAAAACANVJ9fb3V1NRYXV2d+xzeV1QAAmX25JNP2hVXXGHvvPOOe0FnMhlrbW11XXzVLVjUHdQP/2TcuHEu4PPDP/++hQsXdtr2Djvs0OV7f2bgd99916ZMmdIR/hVbXu699163jgJIdU1W+/LfbL75zW/al7/8ZRdI7rXXXnbUUUd1amu+Cy64wC3v0/Gq23M0GHE3AAAAAAAw8AgAgTL66KOPXBWeKvq++93v2siRI+3ZZ5+1L33pS53G2SvsUqsZZ4vdp269vfFnqy1W/Fs4k626BqtqUFV7++67r/trg7ohX3fddZ2q+jTO4EMPPeSqDS+99FK3zGGHHdZl+7FYzN0KNV/7hoVj7WHnGifrWfKSrS0wuvNMxQAAAAAADBQCQKCM1I1WFXUK1DQWoPzud78bsO0rwCv8XmMAiib9mDVrls2dO9eN7ycvvPBCp+Wfe+45mzp1ql100UWdQstCmiREN40xeOyxx9pdd91VNADsjmbl1W1N5FnvoS0AAAAAACuDABAYJOqnrwky8o0ZM8YFgBpD76CDDnKBmz+G30DQ9q655ho3np9m+NX4gqrUE3XX1azCJ5xwggsg1R03P+iTdddd14WEqujbdttt3boaH9DX0tJi5557rpuVeO2117aPP/7YXn75ZTchyUBxlYqtWbPMiorFcMAsHupSrdjjNrI5s5asmzXYTdIRC5pFgiVvw7UhnTNL5fSNmcbrS4TcLMJ9PQ4vnbPWdKstal5m/2mYbfUtzZa46W0Ljk3YuPUm2qbbb23VNdV9Oj4AAAAAAHpCAAgMkqeeesrNlptPE2dcf/31dvXVV7vx8XbZZRe78sorXSg3EM4++2x79dVXXRdezdyroE9deUUVhwrz1N14u+22c2MKaqZhTSbiO+SQQ1xV39e//nU3e++BBx5oF198sev2K5r1d8mSJa69mpBEMwprZuFiE330lQvMGtLmNaTbZ9TNm1nX3SojZtWRHoMyL5Mzb1mbWVu26zYU4o2MWSAe6rkdCu2WptrDQ399qTPzVLk4KtZj9WL+cXg5z5rSLTZv+SJ7u+4Dq4pGbFx0hAUWRCxTl7b6BbPs2TlLbYeDd7fa0SMJAQEAAAAAA4JZgAGUfRajuac/ZtV5YwAqNPOWpNqr9pStqeIvFnIhnKcqPD/Q0/0K4IqEgC78W9jixthT2BeoirRX/2kbTZmOQC+gEDBZ/G8hXnOmPfwTbaM64varbXdUFAbNAmMTRUPAwuNoDaVtUWudvfrxOxa1oJ3/5u3taWQ4YJ55duNnzrPWESEbs8e6ttP+u1simRi4kw0AAAAAWGNnAV4zB90CMLTVp9u7/SpcGx234Ki4BSojFqiOWnBM3AVuropPwZoqBIsFbwtbzbJmFg1ZYHzSrasQMFATteDEpAVqo+3LLku5brldtpFW9WB7+KfgLzAh0d6GqogFa2Pue9eVONu+r2KTqhQeR0ulZ4uyddaQarIx8eoVxYRee5CY9axtUYvZ/JS9+9Qb1rCsfuDPKwAAAABgjUQACGBIceFdY9oFfK6yTpV/BQIav0+z5gatvWttYfimKkGFauGABcbGLRDqWiEYqIi4QM9V9NW1dW3H8jb3WGBEtD08LKgy1PeBUXEzjQOofWmfvRxHKttmdS2NFvJytrypaUW7Axb0Aha0oFVmopZZ1mwtHy+zhR/P6f9JBAAAAAAgDwEggKFFFXPeisq9SPdvUS4Y1Ph93op18rjgzVaEdz1NplGjbsEKDLNufL6O9fW1uhnrsYruh0oNqFvwqFj7OstTvR5HNpuzuuZ6W9Lc6MYC9NuWU1joeZZOtVprY5Ol6lpt0YfzezxNAAAAAACUigAQwNCi2X5Veafutb3oqA70Zwj2KbyTXmbpdQGcblpdYwX69PWKb3udjdevLswLELs7jmAoZAubl1tTqsk8y7TvY0X1ouflLJPKWqo1bXV1yy3T0rUqEQAAAACA/iAABDD0+LP09kahW5Gh9/r0Dlds7L6OdpTYhhKPIx6K2OL6xRYJRC2Qi1g4ELRgIGQBdQMOBK0tl7GP6+dZJBey1rauYxsCAAAAANAfBIAAhpZwe2DmpTp36y3GzQgc+GSdDn7oll/VV2x9P/zT4vnjBOprfbuia26P/H1EQ70eRzKasIwmBFHgZ56lc1mb2TzXPmye52YBHhuvtNHJUdbQUse7MwAAAABgwBAAAhhaNK6fsrPWbI8hoJu51x+nT+vkCYxYMS7fklSnsf26aMp8Mk5fXqWe+1rdi70VM/l21wYFhJosROtoQpFejiMailgkEDTPy1pFLGrh4CdvwYoEQ6GEJcIxyzS1WSTZPksxAAAAAAAriwAQwJDiZtetipjlzLzFre1BXwEFat7ClvYx9iojXcfp07h7CvGyOfOWtHap4nPBXX1be3inYr8RXcO2QE3UPeZmGW7qGgJ6Wc+8ha3tY/25wDDY63E0pprcOICqBPTagpYzz6Ylx9vayYkWCgQtEQlbay7tZgRuWFLXe/UhAAAAAAAl6H56SwAoFwVnbbn26rmFLeZFghZItr9duWo6zbCrXDARMqsuqLzzJ+4YG28PCVM58+Y1m5cId8zG66mqb0VlYKA2VnS2YXdfbcy8pSnzlrWZV5e2QGW4PezLeS4YdNsIBSwwNl58spCC40ilGy2byVjIi1skrJq/oOsOrCRTMwEvb2uy5lSrJeNx81rNUq0piyfiA39+AQAAAABrFAJAAEOOC9NGxVz3W68x7UI0ry1vVlxV7dVEXMDW3Sy9gXDQbGzCdQO2TM519+1UTxcMWGBkzAIF3Yc7bUOhYzDgQkAX+uV3B3Zdj8MWqI2276uE4whmzGLZiDVnm60x2+bmGGkPANtDwEgoaDHNXJzxTJvMtmXMEn0/fwAAAAAA5CMABDAkufBM3XBV4aeKP3W19SfXiIe6Df46bSMctMC4hHnZ9iq89qq/Fd11VVVYyjYUEE5ImKkrsiYdUYwYXNEGhXV9OI7ckmYbkaiwxrp6q880WNbzLBho7+Ks7r4pN/NvwCKJuOseXMIcxAAAAAAA9IoAEMCQ5gK0xMq9VbmgriK4cm3QLL+FM/32cRuxZMxClXGrygUt5IUsk8u0dwNeMQFJIBy2YDhk0WSF1Y4e2bliEQAAAACAfmISEAAYJFXxSquNV1l9ptGqExUWDoYsGGwfB1AVgPOal1g0HrVEbYWNHD/KQlH+RgMAAAAAWHl8ugSAQaKwb9MJ69l/539k81PL7JINvmTJUMTCFTGzoGe5QMBCiQoLTgla5cSRFovHeG4AAAAAACuNABBA2eXmN1vOTeYbMEuGLFAZ6XZijUJeJtc+OYfG+HPj8wXbZ+tNhju61va4vue1zxS8vH2iDyfa3gaNFVjKOIGe1tMkI5oZ2HXc7f44JtaOs22nbmLvL5hpyUjYEpG4eTVR84KetQbT1pz0bJM9t7KJa08uad8AAAAAAPSGABBA+SlAc3NheGaNGfMUpiVWzLDbTQim4M5b3uaCt87bUpjXZlbXZlYba5/Jt6fwcGHrJ8GfrzVrngJFBYhj4z2GkV5Lpn2W4E6b6P44ErGEbTl1I9ftd379ImvJ1Fu8drRlowGLjB5hm2y7jm26yzaWrEiWcOIAAAAAAOgdASCA8hsZM4vFlOqZtXlmDW1mjWk3e683omsI6Kr2lrW1V/0pm6uKmsWD7SGiHmvJmjVnzFvSal4u1j6Tb5Hwz5a0mqlwMBQwq422B34K8rKeWX2bmQLCBc3mjSoeAnrajyoHJRYyq4q44r/ejqM6VmnbTN3YPl6+0BqWLrfY3htYqDZm1eNH2qT1plpFZQXVfwAAAACAAUMACKDsKi7Y0iqqqm1NUmFmY1Z8HRgZK6m7MgAAAAAA/UEACKDsgqPiFqyOl7sZAAAAAAAMS6WNsg8AAAAAAABgtUQACAAAAAAAAAxjBIAAAAAAAADAMEYACAAAAAAAAAxjTAICoOxSy5dbKpcrdzNQgmh1tQWC/O0IAAAAAFYnBIAAyu6tO263ESNGWK6tzbKplJnnWbiiwkLJZI/rZZubLdPUZBYIWCgWs2A0apnWVvPSafd4dMQIC4R7fptrW768fflQyMKJhLsv09Jils1aIBJx2+iJl8m4bYiWD8fjw/c4YjGb8cUvWayXbQEAAAAAhhYCQABlFxtRa+FkwiyZtFwm48Iwz/MsGAr1uF7G8yyUSLhwKrgiINP3uVTKMs3NLrjqaRvah4Srqlxo5le2hZNJF55lW1vdfYFAoNttZNNpCyowSyYtGIu1LztMj0PhIgAAAABg9UMACKDs8nMpBWDRmhoXPPXGhVUFlXEKrkLxuAuxvN66FXueq2YLFARbCssiFRWuCk7LdGpgYdtVXVdb2yVcG07HkY1G7a3//c/qm1vsP6GwebGYjZ42zXbYeWdLrKg2BAAAAAAMXQSAAIakwkCsr8soyCoMxLos08tYdr2t79rQyzKr+3E0NTXZ46++arlszuLhkC2f+T+zcNgaZs2yhbNn2yHHHksICAAAAABDHAEgAKCoXC5nT/3zn7Zw0SKrTibt8kf+6u6/8vjjLRAJ29KlS+2J0aPtwIMP5gwCAAAAwBDGVI4AgKLqGhrtzf/NtNpYzKaqi7GqCc1sfCJugbY2a16yxJ598EHOHgAAAAAMcQSAAFYLmoTCn+yi39vI5VZqG64NvY3HN4yOY/7Spa4KcFR1tev26wsGgzYyGrWKdJv974MP+t0OAAAAAMDgIAAEsFpILVnibv2Vy2YttXSpZRob+70NratteNnsGnEcDU2N2qFVRaNWk0y6+1QBGDezqMYmDASscdmyfrcDAAAAADA4CAABDHkKvdwstp7X/nV/tpFKuaq3XFtbv6rntI5bN5ezbCq1RhxHYyplgUDQwtmsZVa0V3tsbWtzX7el05ZuaurXcQAAAAAABg8BIIAhL9vc3N7tVaFVc3O/Qq9MS0tH8JZLp/u8Da3jB3jaVn/Ct9XtOFpTbdaWSdvHqhjM6zKcCAZNe160fLm1tPUvDAUAAAAADB5mAQYw5LiQLJvt+Dfb2uq6m4r7OhT65BYMulun9RVqrQjatL6reMtm3fK6L9PU1PG9W1//rth+/jYK2yBuG6qIa2iwYDTasQ3Tdgq3sZofRzwes9bWlLW2ttqyvK6+c5cvt+Z02lJtbZZu63sICQAAAAAYXASAAMouvwhN3VLTDQ3twVfeMn44piArvWL8OxdTBYMWqaqyUCy2YlueC7W0nWLVbQq3XBXciuo5fa/wK1pT4/5128hmra2urj04y9tGfriWUZDmh2mBgNt/uKrqk4BvGBxHbTJpjU2N1pzN2ti8SUBqIhFrzWQsEApbbiUnNAEAAAAArHp0AQZQdvlFawqgIpWVHXcWVsZ1+j4QcMv6oVn7XQEXYAVX3OeCsYJ1Or73PPdvJC80c4uEQhapru60jPu6oE1+kBYsCP+Gy3FEXOgXsOpItNOYhfWZjMVDIRtXWWHBYOeKQwAAAADA0EMACGDICcXjrhpOQZQq5QrpPj3mKubimpO2M/+xcDzeXvlWpEpN2whGIhYZMcKCeaGZLxgOtz8WDhdtg7apbYfz2jrcjiO4ImQcWVNtlTU1HfcnKyrc/TWVVRYP8GMEAAAAAIY6PrkBGJIUiIWTyaKhl+7TY8VCsy4VdJFI1+BL1XAK16qri4ZmPj3mquoUihW0ww/eCiv/htNxaL1wOGytqZSF8x4bGY/b6JEjLZ3NWvd7BQAAAAAMFQSAAIYsV/XmB08Kv/wATBV1JYw911F5t2Ib7usV63VXUVekEZ/sS1/nt2FFBd9wPQ7dFwwGLRSNWjQScWMV6hbVALKqDgyYZSKR3vcNAAAAACgrJgEBMGRp8go/rAoUhF/usd7W98O2vG10CsG0jV4CrFwm075sYRiXN0Nv4ey9w+Y4VnQB1mOaCdhfd1kqZZlg0FKeZ9GKil7bDwAAAAAoLyoAgX546qmnXICyfPny1er8ffjhh67dr7/+uq0OFFq5mWnjcYvW1rqbvnbhlQKtXvjhmpsMo6LCYqNGuVlyNR6em0W3xG24Srhw2K2rbWhb+TPtDtfjSEZjNrKq0pY3NFjTipmCnWDQ6pqbbUlTk601dWqv+wYAAAAAlBcBIMrqpJNOcqHEVVdd1en+P/zhDyV1rRzKpk2b1j5za95t0qRJg3puDz300E73TZ482ebNm2ebbLKJDXVubDqFVQrMNMZdONz+fXW1uy/Q3aQW+dvQGHXJpMVGjrTwiokrNNOu1te4eaV2ndWyLrSLxdw2tC1tM5RI9BoArs7HMWpEjY0ZPdoCgaAtrqu37x50kF1zxOE2a/lyW9TSYtXjxtnWO+7Y+74BAAAAAGVFF2CUXTwet6uvvtpOOeUUq62tHbDttrW1WTSq0crK5zvf+Y6dfPLJHd+HepioYTBo/+PHj7fVQiDgKtWK0aQVeqy38fOCsZiFuhnbThV4erw34crK4uPjBYMWqazsfQy/1fg4ErGYbbv++vb+Rx9ZOBq1eDhsidqRFg0ErDIStvio0bbN/vv3um8AAAAAQHlRAYiy22uvvVwodeWVV/a43H333Wcbb7yxxWIxV1133XXXdXpc933ve99zlW81NTUuePv5z39uI0aMsAcffNA22GADSyaTduSRR1pTU5Pdfffdbh2Fjqeffrpl8yqgfvnLX9o222xjVVVVrm3HHXecLVy4sM/H5q/v38aMGdPR1htvvLHTsltssYVddtllHd8rrPnJT35ihx12mGv3euutZ3/60586rfP222/bgQceaNXV1W5fn/70p+2DDz5w29Hx/fGPf+yoPlS35WJdgJ9++mnbbrvt3HmdMGGCfetb37JMXpfS3Xbbzc444ww777zzbOTIke448tsp+n7KlCluGxMnTnTLr6xSKkB7W2ZlH1/T96H7Npo+3aZPmWqVlZUWjseteupUq11nHZuwyaa28W672carQTUpAAAAAKzpqABE2akq7YorrnAhm4KjYt1kX331VfvsZz/rgqajjz7ann/+eTv11FNt1KhRLvDzXXvttXbxxRfbt7/9bff9s88+a83NzXbzzTfbb37zG2toaLDDDz/c3RQMPvzww/a///3PjjjiCNt5553dtv3qwe9+97suNFTwd9ZZZ7n9aPnBdPnll9s111zjjuuWW26x448/3j766CMXxM2ZM8d22WUXF9A98cQTLgR87rnnXHh3zjnn2Lvvvmv19fV21113uW1pnblz53bavrZxwAEHuGP7xS9+Yf/+979dcKqqzPyQT2HiN7/5TXvxxRfthRdecMvvtNNOtvfee9u9995rN9xwgzu/Cmjnz59vb7zxRp+OM5fLWa6EsfQw+MKhkG289jSbu3ixNbe22rQttrBAMmk1Y8faOuuuaxFmAQYAAACAIY8AEEOCqtxUAXfppZfaT3/60y6PX3/99bbnnnu6cE/WX399e+edd1wwlh8A7rHHHi788ikATKfTdvvtt9s666zj7lMF4D333GMLFixwVU0bbbSR7b777vbkk092BIBf/OIXO7Yxffp0FyCqSq6xsdGtU6rzzz+/I4wUBZ19qY7TsR177LEd6yoEfOmll2y//fazW2+91VU6KnjzQxidF18ikbBUKtVjl9/bbrvNjQv4wx/+0FV7zZgxw4WEavcll1xiwRWzwm622WbuuRFVImr5xx9/3AWAs2bNcvtQJafaoUpAnati1B7dfAooXbuPPc4FmBi6Nl3xr8Yu7G3WYwAAAADA0EIAiCFD4wAqwDv77LO7PKZqtkMOOaTTfapAUzdadd31x9ZTt91C6j7rh38ybtw41wU3P8jTffldfF977TVXAaeuskuXLnUVaqKwS4Fhqc4999xOAeXo0aOtLxS8+SoqKlw3X7+dapu6/K5MBZbO6w477NCp+6fOq4LOjz/+2IV5he0QdRX223HUUUe550FBqYJJVRQedNBBFg53fXtRN29VNRaKalKMIstjCFrNJ+cBAAAAgDURn7gxZKg767777msXXnhhp9BMNEFB4RhlxSYtUEhWqDAg03aK3eeHfBofcJ999nE3jQWocfsU/Klt6hrcFwr81l133S73q7KusP2qVCyl7X47VeG3sno6r/n399QOVRC+99579uijj9pjjz3mumarMlNjCxaud8EFF7iuxPkVgFo/+5eHLav9Ksgt8hyWpKnJTN2ItX5/J1tpaGj/t6qqf+tr/2rHcD0Oz7PQgZ8x60MVLAAAAACg/AgAMaRcddVVritwfldWUdWduvPm0ziAWm6gZ9bVOHiLFy92bVE4Ja+88sqA7kOh4rx58zoFYTNnzuzTNlSVp7H5FBwWqwLUDMj5E5sUo/OqyVXyg0CdV1UarrXWWiW3RWHkwQcf7G6nnXaa60r8r3/9y7baaqtO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HreK2kqrCAQ0/J/rlhsNB2z8mNE2dswYSyYS7taf7roKDTVZSGEIWOokIgAAAACATxAAAmugadOm2Y033mjDCeHfqgn/pGZErVXXjLBEPG7BoMI+z1qa66yubqktnzvPltctM2V82teM9abaelMn2/SpUyyiCT+i0X7tU6GhuhCHAuYm/GhLtbp/9b3uZwxAAAAAACgdASBWifnz59vpp59u06dPd5U6kydPtoMOOsgef/zxAdn+hx9+6AKA119/3crpvvvus912281qamqssrLSNttsM/vOd75jS5cuLVub6uvr7aKLLrIZM2a4WVLHjx9ve+21l91///3Ddtw0wr9VF/5JKBSy9Tbc2KqqK22vI4+3zxz3Zcu0tFomm7Yxo0fY+FE19u3v/8B+es9vbNzIkTZx4gRLJhMrXamn17iu4eqqKjeJiP7V94R/AAAAANA3BIAYcArntt56a3viiSfsmmuusX/961/2yCOP2O67726nnXbasDnjCtmOPvpo23bbbe0vf/mLvfXWW3bdddfZG2+8Yffcc0/RdS677DI76aSTSt6HwsWf//znJS+/fPly23HHHe0Xv/iFXXDBBfbPf/7T/v73v7t2nnfeeVZXV2fDDeHfqg3/fAreNt92e5u+/oYWjkXNvIC1NCy3QFuLTZ883taZMt4qK6I2prbaKhIxq0jEqdQDAAAAgCGCABAD7tRTT3UVOi+99JIdeeSRtv7669vGG29s3/zmN+0f//hHtxV8Cq9031NPPeW+X7ZsmR1//PE2ZswYSyQStt5669ldd93lHlt77bXdv1tuuaVbR0GZ5HI5V4E3adIkV3m0xRZbuPDR5+/3d7/7nX36059221WA95///Mdefvll22abbVwl33777WeLFi3q9hh1bFdccYUL/K699loXuqlb7d577+2qAk888cSyXFkXXnihO8YXX3zRtWGjjTZy5//kk09251rHVsz1119vm266qVVUVLhqTT2HjY2NHY9/9NFHroKztrbWLaPn8+GHH+71eVrVCP8GJ/zzRaNRW2+DDW27nT5t2+y4k22xzQ520F572Ke22NQ20et8vXVtnWlTba0JE9y1QKUeAAAAAAwN4XI3AMOLur4qcPv+97/vgqJCI0aMKHlbF198sb3zzjuuum706NH2/vvvW0tLS0cAt91229ljjz3mwigFE3LTTTe5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xb2uX19f7yoAC+2zzz7usTWdQhgFUldddVWn+//whz+s9h+wp02b5o4h/zZp0qSyBlyTJ0+2efPmua7s5fTggw/a/Pnz7Zhjjum477XXXrPPfOYzNnbsWFdtq/N39NFHd7zO+hu6dhd63nTTTfbzn/+8pG2oTZ///Oft0ksvtXLrLQRc1eFfqSHgqgz/Sg0B+zP78jabTLdkMmkLG9qsKZOztBewbLDCQolaGztpXdtsux1tvY03XSXHAwAAAAAoUwC4/fbb23PPPee+PvDAA1134O9///v2xS9+0T3WG40f+MADD3S5/49//KMddNBBA9HE1Z7CHlVTLlu2bEC3WzhhSzmoUlSBm39TyFVOoVDIxo8f76pZy+nmm2+2L3zhC25WbL/CTmNijh492v7617+6ytuf/exnNmHCBGtubl4lbaipqbERI0aUvLza+6tf/WrAr9OBDAEHK/zrLQQcjPCvtxCwP+GfjB41wnbZZmOrqKi0plbPmto8y0ZGWMXIabbxNrvaehtvb9OmrbtKjwkAAAAAMMgBoGb5/dSnPuW+vuyyy2zvvfe23/72t25235/+9Ke9rr/hhhu6wFDh4fe+9z13U5WT7tt4441dEOLf1lQKfhRKqbt0TzT+os5ZLBZz1WHXXXddp8d1n86vKt8U7px88smuwkshjyrONthgA1fZc+SRR1pTU5Pdfffdbp3a2lo7/fTTLZvNdmzrl7/8pW2zzTZu7Ea17bjjjnMhVV/56/s3dSP123rjjTd2WnaLLbZw15hPVWs/+clP7LDDDnPtXm+99dxs1Pnefvttd21pXEnt69Of/rSrUtV2dHwKmv3qQ1XQFauGe/rpp2277bZz51WB27e+9S3LZDIdj++2226u6/p5551nI0eOdMeR307R91OmTHHbUKWslu+OKvoee+wxF477nn/+eVcRq+Pdcsst3aQ7e+yxhztH2q7avfvuu7tl9XzpGPQ8yyOPPGI777yze55HjRrlXl/5lbralmi7Wk/HU6xCMpfLuSB63XXXdceh/ep16tt0003dsRcL9HuSy2ZWyc3L5SycqDILhKytaYll25qtrXGJ5bJtFo7XaPaRVbbv/FswErdQJGnp1npLN9e131rr3X16bDDaoGPVMevYdQ7cuWha4s6NzpHOVcnb8nI2YexI23Wr9W2T9abY1LXG2hY77m2b73SgbbLtrrbhpluWPUAHAAAAAHxiQD6hTZ8+veNrhTC33XZbn9ZXSKjA4p133nE3n8KK/ABRwURPoclwpqo0jYeokE3noFg32VdffdU++9nPuqBJ3UIVGJ166qku8PGDILn22mvt4osvtm9/+9vu+2effdZVkClg/c1vfmMNDQ12+OGHu5ueg4cfftj+97//2RFHHOFCJG3brx787ne/60JDBX9nnXWW24+WH0yXX365XXPNNe64brnlFjv++OPto48+ckGcxqPTOHoKtJ544gkXAqpaVeHdOeec46roFKrdddddbltaZ+7cuZ22r21oQhod2y9+8Qv797//7YJTVWXmh3wKE7/5zW/aiy++aC+88IJbfqeddnKB+L333uvGtNT5VUCrrr1vvPFGt8ek50SvJYXjPgVrarfCNQW0hd2/1XVZAbCeJ83GrWNNJBLuMYW5apsCOn19ySWXuNBUIacqDF966SUXcCp0VPui0Wi3E/78+Mc/dseia0EVmzof+bSdZ555xlUAF9JQAf5wAeJ38V9v329adXVVt+cDQ1+0YuSAjuUIAAAAABg4A1aioTHHFHKoqujcc891Qco///lPGzdunK211lo9rjtz5syBasawpsBGFXAaY61YZaUqMffcc08X7sn666/vAlUFY/kBoKrGFH7lh03pdNpuv/12W2edddx9CpjuueceW7BggZvQZaONNnLVZU8++WRHAJgf8CgEVoCo8KexsdGtU6rzzz+/I4wUBZ19CXp1bMcee2zHugoBFWhpXMlbb73VVToqeItEIh3nxaeATIGUwrXuKNBWuKYZqRW6zZgxw4WEareCNL+L7mabbdYx/p0qEbX8448/7gLAWbNmuX2oklPtUOWczlV3VM2n146/bVF3+gsvvNCFwF/96lfd+nouTzjhBLesQmK97vzx+PK77ioUzKfrR8vo+tBYh37VpcLi7s6FgmGNCajj8if90fWiIDCfXu/ddeNWBasC20LRcNCi4VC35wNDXKyG8A8AAAAAhnsA+Oabb7pgQ0GLggtVRymIUKWSKrFUNYWBoe6XCn00zmIhVbMdcsghne5TBZq6iKrrrgIiUbfdQqo288M/UaCkLrj5QZ7uy+/iq5BHFXCqIlu6dKnrHioKuxQYlkqBcX5AqTHu+kLBW/6ENOrm67dTbVOXXz/86w+d1x122KFTxZ3Oq4LOjz/+2IV5he0QdRX223HUUUe550FBqYJJVRRqfMvuuklqJm1VGBZSd1tV8qma8R//+IfdcccdLvT8+9//7qr7uqNgXsGw1lH34vznqtTJTnQeFJYqZO6JQtXuxiRUBaHan18BqHDVe+un5lV0Pd4B4Xlm6Xr1MzaLVpllmld8Xa3B8WzQZFra9x1Orvh+xdfh9irNQZHLmLXVmwVD7ftua2j/OlKtEuv+bdPLWWCL08zitQPdWgAAAADAABmQ/lr6QK8A57///W+n0GL//fd3wURvVG1WOMOtqHJNwQk+oe6s++67r6sEK+R5XpduobqvkEKyQoUBmbZT7D4/OFI3Us3SrIBQYwG+/PLLHeO+9XViEQV+GlPOv/mVa6p+K2y/KhVLabvfTr8L7Mro6bzm399TOxRyqVuuKhLVJnXN1nNZ7Hj8c9LdRBqq0tPrQuM7KpTTeII/+MEPejwGhY1Llixx3XfVRVm3vj5XpZ5LhcF+RWEhjRuorsn5NycQbg/jBvqmLqmZRhdSuYBKYVus1iwUMUs36JlcNfstvGVTZtkWs0hlewipm77WfXpsMNqgY9Ux69hjK86FzonOjc6RzlV/zzEAAAAAYEgbkE9uCn9OOeWULverK6DGOuuNJljQJA2FVClVSoC4plFY+uc//9mN8ZdPVXfqzptPy6jLq1/9N1A07psqydQWVdipW2x/JgDpiUIkjTGXXy3W1+7iqsrTeHTdBW0a6y5/YpP/Z+8+4Fsr6zeAP9mrSffdg3HZe8hGhuy9lyxlCIKIyJLtQASVJaIsURQFBEFFhD8ge+99mfdy9+xudnL+n+dtT0lz0zbJ7W3T9vnyCbdNk5Ozcs7Jk9/7voVwvXI95oaR/J2VhgM1b88P0DioB5tKc7AR9hP43nvvFXwsB+Pge2eg0XQ5/6zcZCBr/065y8Tgj0Ehm1mzeo/9CuZPt9Dz8rFZM5eBzZr78/7775v5H3YMtpKtXVVvvhrA2R3QMrDyVneFV4kWIFt43xg0qU4g3Qm4Q4AnJ3znz7yPf+NjViUuI5eVy8xlt0M7rhOuG1MZ2Nq1zorEfWXR4ia8/eFsvP78/+HVZx7Gmy89i4Xz5w74nhIREREREZERGACy6s/uzD8XK576qgTKxaaUhQYdYEVVoemOdWzqyYEu2NddLjYLZjjDgTk++eQTMygF+2vL7e9vsLDZK7cZ54EDhHDkXb7uYGJTZ/ZDyACPoRL7nSs1yDzzzDPNPnTUUUfh9ddfN1WqnCb3TWIzZzZh5+8MNAsFhazWmzt3rhkFmcEnRw1mX3+sfM3to68/HGmZ/e5xObi+OA8M0zhSdiEM0Pje4YAlNo7SfOyxx5p/uX05z6z846ArdtNvTo+Vh3zM0qVLzXuLA+ywavDWW2/FZ599ZpoP5zbDJfYHyPnhaMHs97G1tbXg+5z9HnKkYzbrZ7NiNinO7Y+STX85GA2rQysy/LMNVQjYV/g3lCFgX+GfrYwQkAHfrLkL8fqHs7BwWTM6Fs9E87x3sWz2m5j9wauY88UnCgFFRERERERGWwDI8OEnP/lJT3jCAIJ9i1144YUrDD5QCPsgu/fee1e4nwM3lNKX3FjCsC2/eezmm2+O++67z6w3rlMOUMHtktu/3mBhOMVQ6+9//7vZRqwEHKgZaqnYXxybye63336mz7yDDjqoVz+FxWDwxcCLQdhOO+2ELbbYwjSDtZvrsr9KjmLMfhHzAzcbq/wYsnFgkU022cQMwHHSSSf1GrhkIGzWzNdl34GsSmRQyypOzl8hDDo5yMrdd9/dcx/XM/tqZNDLwWA4KAi39+23347jjjuuZ145yAbfe+yzkQEoQ0ruEwzmuF9wtGY2r8/FvghZmXjLLbeYJsX5fUna2I8gX5/7FisJOSBMbuUnw1GGw6wKLUkJlWcrHf4NVQg4UPg3FCHgQOFfmSHgwsXL8c4HX8JKJxDyAX6rDf5UEzLts7Dgk1fw5UdvYN6Xswp2QSAiIiIiIiJDz2ENwic0VlgxoPnggw/MSKEMENh8kQMnMDgp1OdcLlaPMSjk6Kas+iIGJH/7299MwMTgR2SsYSXeBhtsYIK7vioFKw1HJj777LPNe7nYYwcHD2p+9AeI1I5b+f7kig3/VvY5gxX+rexzBiP8K+M5Dz/1FlqaF6OhOoDvXv8cFizvxKSGMG4+d190JDxIV43H+l/bE2tvvBUCwdAKfWiKiIiIiIhIaezPz2yx19OffgkGZQhMvjD7nmOl1ZtvvmkGPmA1GkcGLgb7RXvooYfMaKb333+/aYrIKqknnnjCVG2JjEWs4GPzWlbTjoQAkJWAHNDn6KOPLv3JduVZsUHVYAZ5diUgn8vwa2VDwHKDPPuxfG7u70MV/uVWAvK5/WyPT2cvRkM4i6DPCWd3tudyANV+IJlqxcyPlmD62l+DxwUkEnH4/UM40rGIiIiIiIgMfgCYTqdN32Bvv/22qd6zK/hKxUFACg0EIjKW9dUUtxKxH0H2D1gWXzWQjZcfAq5sFd9ghYArW8U3GCFgueFfCSHg/KVNmN7IJsMZWBxdmC9rZZFKxRBypdC8fAkWLJhtmpYn4xxpWgGgiIiIiIjIiO4DkB/wWJ2kUR9FpGyO8kejHbQmvCvbJ+BgNeFdmT4BVzb8K7JPwLbWdmSygNfjg7P7NZwOB0JeN7LpDNrb2tCyfLm5X41/RURERERERskgIBwMgQM2NDU1DcbkRGQsKmM02kHvv6/cEHCw++8rJwQcrPCviO3REY2bwM/pzsLu3o//Zh0pJNNpxDriiCU7zP0aBkRERERERGT4DUofgBw99LPPPjODf7AaMH/QD/YLKCIyWH3QrbLBO8ppDjzY4V85zYEHO/wbYHsksxmkMxnEY5mekX75T8ZKI5FMoD2dQDaRNF1EuNyDtF1ERERERERkeANAjdIrIkMaAq6q8K/UEHBVhX+lhICrKvzrZ3s4Mk5kslm4fZYZ4TeV7qoETGfcSGQd8MCJeCqFVAYIBP2DOz8iIiIiIiIyPAHg5ZdfjsHE/gTfe+89U01YW1s7qNMWkREeAq7q8K/YEHBVh3/FhICrOvzrY3u4vU40hv1IJLJIszNAzl6Gg4AkMLUmBL/fA8vhRiAYMgGhiIiIiIiIDK9V9GmxNGeffTbuuOOOnvBvp512wuabb46pU6fi6aefHu7ZE5HhUKgPuqEK/wbqE3Cowr/++gQcqvCvwPZwWml0JjOojnjhcTnhcTvhcblQHfagNZ1ENpVBwK/wT0REREREpFJURAB4//33Y5NNNjE///vf/8asWbMwc+ZMEwxefPHFwz17IlIJISDDLhPCDVH411cImGgd2vCvUAjIeRjK8C9ve6SyWSSTaQThh9PpMCP9Op1AyFGFVNJCysrCcqryT0REREREpFJURAC4bNkyTJgwwfz8yCOP4PDDD8faa6+Nk046yTQFFpExjKETQy4r3XUzYdwQDyxhh4Ac0zabAJy+oQ3/bHxNvjbngfMylOGfzemBy+FF2OdFZ4xNgC0z0i//7YwlEQr44fd4h3aeREREREREpPIDwPHjx+PDDz80zX8fffRR7Lbbbub+aDQKl8s13LMnIsOJzX7t/u+IP/O+oZaOffVzNvlVc+ChxNfkaxeap6FiZREJupB2Aqksoz/rqz85AUcmA5/Xi5qqyNDPm4iIiIiIiAxdAMgg7+2330Zzc3NRj//Wt76FI444AhtuuKHpMH733Xc397/yyitYd911V8UsishI0KvPv9quW26fgEMlt88/f8OKfQIOhdw+/zgP+X0CDuH2CAQCSGYy6EzGYDJAzh4stMWSiFlu+KqqUF2nAZxERERERERGVQC4soN4XHHFFbj99ttx6qmn4oUXXoDP5zP3s/rvwgsvHIxZFJGRptCAH4UGBlnV8gf86GtgkFWp0IAfhQYGGaLtUVNbbfr6s5wuWFZXAmhZDsDtBywXqmoaUDdu6qqfJxERERERESmKG4M0iMexxx67wiAed911lxnEg6HeQA477LAV7jvhhBMGY/ZEZKTpb7RfOwRkIMbHrMp+8Poa7dcOAfn6nI9VOShJf6P92vNkN5FeVf0S5m2Pr2++Ft7+8DOEQ0nc/5O94PbWIm1ZaGntxKxmYMYGm2O1GRuumnkRERERERGR4QkA+xvE48Ybbyz4HN7Pij+/39/nY2xnnXXWYMymiIz08G8oQ8C+wr+hDAH7C/+GKgQssD2223xtdHTG8Nn85VjSkkGoxoNkBuhMuRBqXBtb7XIQpqy2xuDOh4iIiIiIiAxvAGgP4jFx4kQziMfNN9884CAe1113Hb75zW+aAJA/94V9AioAFBkjign/hiIEHCj8G4oQsJjwb1WHgH1sDx6399hxE7z10RzMWbgMjpoZcMGL+ppGbLbFjlh9xtpwuwfl9CIiIiIiIiKDYFA+odmDeDAALHYQDzYTLvSziIxBVhrIpIBUG5DNAF6OIOvoCp765QA8YSDZBiSaAU+E3xqs3LxwZN10FHAHAZeviHngkbSqa97jzV3zztBuZZg+DtsAp6tr2gziBurvkPPKx6Q6uv51B1ZuHti3Xz/bw+91Y9tN1sC2G68Gx6ZnwOHXoB8iIiIiIiKjOgDkIB4cwXfu3Lmm+a8G8RCRUjg2PAmOCEMmGZF81cM9ByIiIiIiItIPh2UP4SgiMsTa2tpQXV2N1tZWRBQAioiIiIiIiKySz89lVwBqEA8REREREREREZFRXAG4+uqr4/XXX0d9fb35uc8XcDjwxRdfrMw8isgopQpAERERERERkQquANQgHiIiIiIiIiIiImNkEJByvPvuu0U/duONN16l8yIiw2th60J0WB3aDKPAhMgEOB3O4Z4NERERERERqYQAcNNNNzXNg9kCmf/2J5PJDNl8icjQO+ve78Ltdw14LBhIMceTgZ5PKzuNsboc6Wwafzj+z5hUPans1xUREREREZFRFADmNiF+6623cO655+K8887Dtttua+576aWX8Otf/xrXXHPNcM2iiAyRpmgTkvE43E4PxkfGw+f2lfT8RDqBxW2Lkc6mEPSGMC48ruQqtNZYK5o6l5uf60L1qA5Ul/T8rJXFkvYliCY7x/xyiIiIiIiISGUZtgBw+vTpPT8ffvjhZlThffbZp1ez36lTp+LSSy/FQQcdNExzKSJDoTPeDnfAjWQ6gSVtizG1blpJz2f4x+eyYq0j3g6vy4u6UF1JAeKyjqWw0FU5x5/9Hn9JQWRLtMW8NudhrC1HMplE68I2dHZ04p6H70F9oBbTxq+GzTfaHJFwZKUrIkVERERERKQCAsA5c+aYsC7/Qx6bkM2dOxfTpvX/4fG9994rOJIw7/vwww8HYxZFpMK5nC5kshmksqmSmp/ysaz84+M5jXQmbZqiloLPYWjmcrjM7xkrY+4rJTizX3OsLQfDv3kfz0dHayeymRSefv8p+Jxe1HhqMHPWTBy616ForG9UCCgiIiIiIjKMBqWndgZ1S5cuXeH+pqamgsFevvXWWw8/+9nPEI/He+5LJBLmPv5NREY3hksmvLIshLyhksIiPpbNfk2Alkmb3wOeQEmvz4DM7XSbwIs3/lxqM2S+5lhcjsWzFmPhrEVoX96OaCKJL5Z8ik/nf4K35ryFf7/4IB747/2Yv3g+WtqaEYvHevonFBERERERkRFWAdhXdUhHRwf8fv+Az//973+P/fff31QRbrLJJua+d955x0zz4YcfHoxZFJEK1hgeh5QrZQKrmmBNyc9nn39sLsvqNQZYVb6qkp7vdrkxqXoyWuOt5vdqf7W5rxT2a8ZSsTG1HHM/mI9kJoHglCCW/bsZS9uWw1vjxeqHT8ZnS1vxxCuP4+vbfR21tTWmSXGqM4VwKKyKQBERERERkZESAJ5zzjnmXwZ17KsvGAz2Grn3lVdeMaP9DmSrrbYyg4L85S9/wcyZM02geOSRR+KYY45BKBRamVkUkRGAoZMn4Cn7+Rzwo5S+8grxur1orGos+/k8Dob9YXMbS8vRubgTntVdyCCDbNYyx+9MOo1oRxxZdwZvfvAWljYvxfTJ0+F2u5FOpxFPxBHwl1bdKCIiIiIiIsMUAHL0XuIHPvbj5/V6e/7Gn1nNx9F9i8Hw8NRTT12Z2RERkSEWTcdR74jA8mZhD7zscDqAKguZFgstbcuQyqTQ0dmOqlDYhIAJBYAiIiIiIiIjJwB86qmnzL/f+ta3cMMNNyASiZQ9rU8++QRPP/00lixZgmw22+tvl1122crMpoiIrCJWArC8FssXYXfvZ/7NOpByx5FMxpFIJpF1WF9V/mlUYBERERERkZHXB+Cdd97Z6/e2tjb873//w7rrrmtuA7nttttw+umno6GhARMmTOjVNxR/VgAoIlKhOGhwGnCksoCjOwF0WEg4U7ASFpKpDOYvmoe1V18LLssFv8/fnRCKiIiIiIjIiAoAjzjiCHz961/HmWeeiVgshi233BKzZ882TYPvueceHHroof0+n6P9XnnllbjgggsGY3ZERGSoWEAmlYHL7QLs724czPhScGQcQAaIWVFkHVlkMxm0tLagLlKv7SMiIiIiIjKEuntsWjnPPvssdtxxR/Pzgw8+aIK/lpYW3HjjjSbcG0hzczMOP/zwwZgVEREZSlkgiRQQ4+hPXb9bGQtoA1LxlPmaadnSJYglYswKYa04YLyIiIiIiIiMhACwtbUVdXVdI1c++uijpuKPg3rsu++++PTTTwd8PsO///u//xuMWRERkSGWymaRacmYakCD/zoBl98Flx9o6WjDvLnzEPSGUBupQTKV0DYSEREREREZaU2Ap06dipdeesmEgAwA2ezXruzz+/0DPn/GjBm49NJL8fLLL2OjjTaCx+Pp9fezzjprMGZTREQGmwVYHRZcE7ubAPNrJZcD8AHOTiccbhYFpuH2uszYH6aPVw0CIiIiIiIiMvICwLPPPhvf/OY3UVVVhenTp2PnnXfuaRrMQG8gt956q3nuM888Y265+GFRAaCISOVy8zsbV84drADMoLvfP8DvDiIUqkJHtAP1tfUaBERERERERGQkBoDf/e53sfXWW2POnDnYfffd4XR2tSxeY401iuoDcNasWYMxGyIiMtRcQCAQgBWyuir7HIDT6YA3FEAm1YGgx4+a2mpzH/+cTqfh8w5cGS4iIiIiIiIVFgDSFltsYW652AegiIiMXo4I4PQ4YaXYFri7+i8LIJ2F1+uHFQIikVrA6UAqnYbDcsLvUwAoIiIiIiIy4gYB6cvcuXPx7W9/u9/HxGIxPP/88/jwww9X+Fs8Hsddd921CudQREYCjiweTUbNjT+XI51JozPRiUS6/AEo+FxOg9Mqx2hcDp/bA6fXCUeCp5PuZXI44PMEUBUOwuMKoD5Ug0RHAvXhBoRD4a5+AEVERERERGR0BIBNTU3405/+1OffP/nkE6y33nr4+te/bvoKZN+BCxcu7DW68Le+9a1VOYuj2mqrrYbrr7++5Ofxw/lDDz2EVel///sf1l13XWSzLBUa3mVmmHHqqaeaQWy47G+//TaGy+zZs4d9Hoq1aNEi0+Q/FAqhpqYGiUQC06ZNwxtvvDGor8Pts6htIRa0LjA3/lxqeJZMJzGvZS4Wti3AvOa5aI21ljwffA6fa6bRMtdMsxSjdTksTxbZTsBhcZCPrma+DifgcbqQabYwPjwekxunYHrjdEwcN1Hhn4iIiIiIyEhrAvyvf/2r379/8cUX/f79ggsuMMHf66+/jpaWFpxzzjnYfvvt8fTTT5sgYbQ48cQTzfKt6lBtJDn//PNx8cUX9/QX2Z8//vGPZqAZrsNVgSNX8zW437HfyoaGBgzXfsERtRmCD9U8rIzrrrvOzCvDyurqavh8Ppx77rnmff3EE08M2uvEUjF0JqNwdleN8WfeF/QGi55Ga7zVVLu5GEpZGTR1LkfEHyk6jGLoxedYsOByuMy0OM3GqsYxvxxV08JIt6fg8jpRt0c1wr4InFkgtTgNbyKAvbbaC6uNWwPTJ08v6v0uIiIiIiIiFRYAHnTQQeYDdH9VLP19wH7xxRdNUMCwgzcGimeccQZ23HFHPPXUU6aySEYfbvdPP/0Uhx9+OCrB559/jokTJ2K77bYb7lmBy+XChAkThnUeUqkUPB4O6zrwemO/n2uttVbPfRwN/LzzzsNHH31kqntl9KteK4zU591NiR0WJlVPhhdOeK0gNp2yOc455RzU19Wr8k9ERERERGQYrVQ5BkOTBx54wDTjLHR78803B+z/z+3unUH+9re/xQEHHICddtrJNBEeC6699lpTCcnAkxVgHFW5o6Oj5++sTmMTy4cffhjrrLMOgsEgDjvsMHR2dpom1mz2Wltbi+9973vIZDK9pt3e3o5jjjkGVVVVmDRpEn7zm9/0+juDODbB9vv9WH/99fH444+vMH+s6Fp77bXN67JC7tJLLzUhke2dd97BLrvsgnA4jEgkYkIhVnX25Z577sEee+xhXnOgabAqj83A2Ry8q3mhA1dccYV5zpIlS7D//vubEUhXX3113H333WVV4XG9cQRrTpvrsq+mxJtuumnPaxMff/vtt+Pggw8264ZBWH5V7AcffGAGw+EycdkYbjM443S47f75z3/2LBeXtVAT4GeeeQZbbbWVqbDje+7CCy80I6na2HT+rLPOMlWVbMbMADF3PgfC1/v973+PAw880OyD9sjd//73v8124Hbidv/xj3/c87pcP3zvs49OPp/rkerr602Q+re//Q2DJeAJIOQNImtZ5safeV8pqv3VcLvcpvrPAQfqQqUFUnyseQ4cZhqcFqep5bDQWNOAdbdeB/WN9Qj6Qthuze2w8zrfwEl7n4JLzroEDfUNCv9ERERERERGcgUgwwGGfKwELGSg6kD2AceQJ79SiCEVn8cgcCxgs7gbb7zRhCqzZs0yASDDnJtvvrnnMdFo1DyG4RlDvUMOOcTcGAw+8sgjprn1oYceih122AFHHnlkz/N++ctf4qKLLjKB0GOPPYYf/OAHZr2z7zaGtJwGqy9ffvlltLW1maa2+RhcMYRkgPjee+/hlFNOMfdxHu2qr8022wy/+93vTAUbw6v+KsieffZZHH300b3u62saDJMYxF122WX4+OOPzWMZZhJDJw40w/4EvV6vCcEYCubiYxiqMVzL3S/vvPNO87cbbrgBa665Jm699Va89tpr5rVLwVDsmmuuMeuZ+y2X48svvzRB3Pz58024yoCO88gQ8IUXXjAhGpvKskqO65zzQnzOggULek2f09hnn33MvDJsmzlzpln/DOVyQz6GiWxC/8orr+Cll14yj2dzem7nYlx++eW46qqrTLNergPuK8cee6zZ5+zQkv0k2o/lujr++OPNMnEdMoS1Max87rnnCr4O+wnkzcblpxQHo+idXfdSH2pAyBc3P/vdfqSzpQ1ewW0+PjwByUwSbqcbXrcXqcxXIXYx2OR4QmSieW2vy2umWeo0RutycBqT159kpnnW8WdjUvWkkqYnIiIiIiIiFRwAsqkfq9D6MmPGDNOUty+snGKl0HHHHbfC32666SYTULEyabTLDd1YyfbTn/4Up59+eq8AkBV3DMcYVhErAP/85z9j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x9prr23unz9/Po488kizrevr63HggQeadWF77bXXsPvuu6OhocHsOzvttBPefPPNXvP96aefmmbLDKzXX399PP7441hZA637bDZrgroZM2aYx3AdX3nllT1/v+CCC8wycv9YY401cOmllyKVSvX7mlzvf/vb30qeVyuThGVZsDJpZNPJsm58rplGmc8308hmzK3s5/Om5ehzezisDCbX+bHGuGqs1hDBetvti412PQyb7Xgg1lx3Y4V/IiIiIiIiq8iorwBkNcnPf/5zE7IxOCrUTPaNN97AEUccYYImBjkvvvgivvvd75owh6GP7Ze//KUJQS655BLz+/PPP49oNGoqzu655x60t7fjkEMOMTcGg4888gi++OILHHroodhhhx3MtO3KsZ/+9KcmNGTw94Mf/MC8Dh8/lH784x/jmmuuMcv1m9/8Bt/85jfx5ZdfmiCOoRYDKQZ0//vf/0wI+MILL5gAiX29ffTRR70q6ficBQsW9Jo+p7HPPvuYZbvrrrswc+ZME5wy5MoN+RgmnnPOOXjllVfw0ksvmcdvv/32JjS7//77cd1115n1y4CWTXvfeeedPpeJ24SBFUO8UnFb/upXv8Kf//xnUz147LHHmmW9++67ex7z5JNPmnXBgI7hBp+zyy67mHD02WefhdvtNkExw8N3333XBJDcL0444QSznxDDZa4Xhn4MVhnEcZ9hQPjyyy+b9Xr22WdjZRSz7n/0ox/htttuM+uX+yfDTj7OxnljyM2w87333jPP530Ma/vCwHHu3LlmP5o+ffoKf08kEuZm47LSjNP/iUgkvFLLLCOPp2YKHM5R/z2UiIiIiIjIsBv1ASCxyo0VcJdffjnuuOOOFf5+7bXX4hvf+IYJ94hVTx9++KEJxnIDwF133dUEQrlhEyuifve732HNNdc097ECkAHS4sWLTRUZq7kYED311FM9AeC3v/3tnmmwsorBEIOTjo4O85xisULLDiOJQWcpgzBw2Y4++uie5zIEfPXVV0149dvf/tZUqzF483g8PevFxqo5Bjn9Nfm9+eabTb+AN910k6kMXHfddU1IyPm+7LLLTMhGG2+8sdk2xEpEPp5BGwPAOXPmmNdgJSfng1VqXFd9YeXd+PHje6ZdCm5LNl+1t+WZZ55pmlnnCoVCpnLSbvr7hz/8wbwW77P7KWMoygCYVZFsEsv9Jtct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r38df/3rX4d7NkaNK664AptuumnRj1+yZAkaGxsxf/78VTpfIoPB5XQh7HShk8WA3ffZ/QCmnU60u1wINdSjcf31EamrgzfAekEREREREZGRadQFgCeeeKIJpH7xi1/0uv+hhx7qqvIYwVZbbbWefqrs25QpU4Z03R500EG97ps6dSoWLlyIDTfcEMPp4YcfxqJFi3DUUUcVXF+BQADrrrsufvnLX8Ky8hv8rTo777wzzj777FUa9nK5v/e972GNNdaAz+cz22T//ffHk08+iaE0btw4HHfccbj88suH9HVFylHl9WJCdbUJ/E7x+XGaP4Cz6xtwekMDWv0+ZBvqseEBB2D6mmvCcrs1CIiIiIiIiIxoo7IPQL/fj6uvvhrf+c53UFtbO2jTTSaT8HrZaGz4/OQnP8Epp5zS87vL5RrW+eHrT5gwAcPtxhtvxLe+9S04nc6C6ysej+OJJ57A6aefjkgkYvaN0YAVmNtvvz1qampwzTXXYOONN0YqlcJjjz2GM844AzNnzhzS+eE22GqrrUzQWsp7L93RAU/3v+Wyn5tuby877M90dvZMoxx2uKzlqPzt4bYsbFddjWeSCfjSGQTcbrgnT0LI60O70wHvOuvi6O99D65g0IR/I/0LJBERERERGdtGXQUg7bbbbiaUuuqqq/p93AMPPIANNtjAVE2xWuzXv/51r7/zvp/97Gem8q26utoESX/84x9N2MKKs3XWWQfBYBCHHXYYOjs78ac//ck8h8EHK7IymUzPtP7yl79gyy23RDgcNvN2zDHHmCaTpbKfb9/Y5NKe1+uvv77XY9l8k804bfwAe/vtt+Pggw82873WWmvhX//6V6/nfPDBB9h3331NSMbX2nHHHfH555+b6XD5/vnPf/ZU1bGSrVAT4GeeecaEQFyvEydOxIUXXoh0Ot2rKu6ss87C+eefj7q6OrMcufNJ/H3atGlmGpMmTTKP78uyZctMuHfAAQf0ub64fk4++WQTkP3f//1fz9+bm5tx/PHHm23GdbL33nvj008/7fn7l19+aarp+PdQKGT2l0ceeaTn7x9++CH22WcfVFVVYfz48aYCjvND3G+4Lm644Yaedcb1tcsuu5i/c5q8j4+jRx99FDvssIPZv+rr67HffvuZdd+f7373u2Yar776qtkP1157bTOP55xzDl5++eWex82ZMwcHHnigmU9u2yOOOAKLFy/uNS1WzXIZuM5OOukkE5rmu/POO7HeeuuZkJ0VlTfffHOvv2+00UZmfT/44IMoRbJ7nWWiUSSWLCnrxueaaS1dWvY0bOU+n6+t5RgZ24N/q06lsKPTZfr7W5BKITljBlIbrI8Zxx2Hc2+8AVNWWw3+QEDhn4iIiIiIjHijsgKQVWk///nPTcjG4KhQM9k33njDhCAMmo488ki8+OKLJkxh8GIHMsRKpksvvRSXXHKJ+f35559HNBo1FWf33HMP2tvbccghh5gbgxuGQ1988QUOPfRQE+Zw2nb14E9/+lMTGjL4+8EPfmBeJzdMGgo//vGPTaUYl+s3v/kNvvnNb5qQi0Ec+25jP3oM6P73v/+ZoOiFF14w4d25556Ljz76CG1tbSYEIj5nwYIFvabPaTAQ47LdddddpgKNwSkDo9yQj2EiQ6pXXnkFL730knk8K9l233133H///bjuuuvM+mWYxSau77zzTp/LxG3C8I7BVH+VQAzjuAwMPm18XQZ+DEK5vBdccIGZfwZ7Ho/HVNFx2z377LMmAOT9DNGITZ932mkns3zXXnstYrGYeT73K64/Bn+ffPKJaR7NSkRiYMvgmfvHxx9/bF6TzZOJITLXCUM0/nzZZZeZsJbhan5lIzU1NZnQ8MorrzTzlo/7o73sbLrNx3AdcHtyX+e+yRCX7rvvPtN097e//a0Jff/85z+bfZzNim233XabecxNN92EzTbbDG+99ZZZdk73hBNO6Hkcw9/nnnsO3/72t1eYp0QiYW427k/knzQJ1sKF8NbVwdW9fkuV6ehAsqkJgalTuwZzKIMdGHm7g/WSWRZic+dqOUbQ9uC7bxIfmk5j62uvRWAIu1UQEREREREZKqMyACQGJ6yAY2Bxxx13rPB3Bjbf+MY3TLhHrJxiuMNgLDcA3HXXXU34lRs2sYnl7373O6y55prmPlZeMTBhRRXDofXXX99UeT311FM9AWBuGMJQheEKg5KOjo6eQKkYDJjsMJIYdPZXHZePy3b00Uf3PJchIKvH9tprLxP+sNKRwRvDL3u92BhUMbzpr8kvK8LYBx1DIlamsUqMISHnm4GWHWSxEs/uK46BHB/PPusYALJaja/BSk7OBysBua76wqo6Vq4VCsns9cUQj9uNQaS9vuzgjyHndtttZ+67++67zfyzz8jDDz/czAvDOoZylBuIcR/YfPPNzXq0/eEPfzDPZ/DHdccm4wwnc9cZg1O7zzw7pCO+Ti7ut3wM98tCfSx+9tlnJtzjOu4PqyPfffddzJo1y8wbcX9luPraa6/ha1/7mqke5T7KKkli5Sufl1sFyACbVbIMu2n11Vc383bLLbf0CgAnT55swsFCWJXLEDrfFnf9CZFwuN/lEFnVGESLiIiIiIiMRqOyCbCN/QCy0owhRT5WgrHiLBd/ZyiU23SXzXbzMdCxwz9i+MQmprlBHu/LbeLLQIRNMKdPn26aWLLKjhgwleK8884zFWH2jc1XS8HgzcbKLc6LPZ+cHqu/7PCvHFyv2267ba8mc1yvDDrnzZtXcD6ITYXt+WDwxmo6hm2sMGNz0twmxPn4WAZ7/a0vVr4xlL344ot7wj7Oq9vtxtZbb93zeFaAskqTfyOGhQzDuAwMLBmk5VaRMuTldrdvdhg3UNPdQvgcVq1yuVkZyICtv33E7t9soL7JuCwM/uzwjxhSM3y0l9Pebrlyf1+6dCnmzp1rmgbnLi/XTf6yMihmlWwhP/rRj9Da2tpz4zTJ43DopnUw7PuAiIiIiIjIaDVqKwCJzVn33HNPXHTRRb2q+uzwJD84KTQ6bKGmlfkBGadT6L5sNmt+ZnPOPfbYw9zYFyCbgTLU4byxMq0UDQ0NmDFjxgr3s/otf/5Z8VbMvNvzaTdFXRn9rdfc+/ubDwZVbB77+OOPmyo0NldlZSZDvELhJNcJ+/Lrb33xxqa3/HebbbYx1YV9jQacuwysiON2+s9//mP6DmQFG6vg2Mcj55f9AzJozsdAs1ScFpedTW3Z7yGnz8q/vvYRVk5yPhne5Y/O3NfyFHN/Ifa24bzlBqaFBqJh02S7b8p87NORt3zLvn0yogsXwllXB2eZTYCzHR3INjXBNXVq+YNOdDc5dZXZ5JTrNDN3rpZjBG4PNgFuvO8euCdPLuu1REREREREKtmoDgDtgQ3YFDi3KatdAcXmvLnYDyAfN9gj67IfPA4MwXmxq7Bef/31QX0NBi7sky63bzU2+SwFq/JYMcngsFDQxuasudWRhXC9MmjLDZe4XllpyKahxWIYyUE9eGM/fKyse++990yT23zsj479BDIE7G/kWXtwFjbpZkUm55WVheyH0K4KXL58uWm+m9ufILfZaaedZm6sYGMIxulwXrisrP5kJWEhhdaZPZJ07v18XQZ5bE7LKkzK3z/zsSkxw0k23WalYn5Y3dLSYqr8uJwMnFltZ+9/rIplBZ69nPyXg4bkVpTmDiLCilZuP/ZvyX4j+/P+++/3VLgWy8H9jQOluN1dP5eBzzXT8HjKDpwc3c3Iy50H9jmn5Rhd20NERERERGQ0GNVNgIl9tzGwYF93uX74wx+aPufYrxkDHwZf7Icut7+/wcI+7Bj6cB4YoLDfOb7uYGJfhezXjYMvMIBhn2ylBplnnnmmCQ6POuooE1CyOTSnyWo8YtDFJrD8nYFmoQpDVusxaGJAxuCTowaz6SwHtyjUR18hHGmZ/d9xObi+OA8MBNl8uhAGgAxA2ZffQBgmcv4Z3LGCjs2y2cyYYRsHGjn22GNN0MX76eyzz8Zjjz1mwtQ333zTDO5hh2acFqvd2Kci+1HkvLJKkH3p2eEe1xkDRvZTyHXGSjouBwMRjiTNprVsHs1wks2Pb731VtO3H1+H62wg7HORr8U+ErlM3GYMEtnHpN2El9WODHf5PuAycF4Z9HEAE7uJ+/e//33TfyFvfD9wm3FE6FwcxIUVkPbgJgxkOSAM+9O0sekvm0az2lWk0vH9uLC5GQ998jHu/ngm7vjBObjp1FNx/+9+hyXz5iEei/VZKSwiIiIiIjKSjPoAkBi25X+IY/UWRz7lgBdsZskBKjhSa35T4cHAcIqh1t///ndTjcVKwF/96leD+hqsTGOT5/3228+MYssmobn9FBaDARSDJwZSDIe22GILU+1mVwMyKGP/eAyN+grcGJ5xZGOGTJtssompmmO/cbkDlwyEVWt8Xfa7x+CKQe2///1vM3+FMOhk6MYBPAbC+T7uuONMmMUP/wywuJxcbwzMuJ9w/u1lZrjGoI+hHwdK4fIzdCM20+U64GNYicf9iEEaB1Kxw04Gypw/bne76TfXEQfCuPDCC01lHYNXPp77IsMzToejRLPZ80DYTyBDPfZvyFCbz+VAKlxnHKSEGDZyUBOGjNxHGAiyn8F77723ZzocrIbvAQ6awvXBkaFPP/30Xq/F5tC333672ZcZrHMf4c92X4XEwJeBt13FKFKp+P6f39KCp7/8EhYHY0qnEfh4Jjyvv4Ev/vhH/O2nP8XyuXMRbWtTCCgiIiIiIiOew1J5g4wCHIGZo9oyQOurUlBWPVYismqSg5kUgxWnDEw/+frOCMyda/p6c5Y5GnC2vd30GedeffXy+5xbtMj86+pnpOv+8HCanjVLyzECtkdrMomnPvkYbe0duCEehRMOOF1O8KuiayZNxkyXC7X77I2DTzoJgcZxqKqrhc/vL3tZREREREREVob9+ZndeXHg0FKNiQpAGf1YScdmw6WOqiyDh6M4H3bYYaZJtEilS2UyeL+9DbXsyqC7QtzKWubmjsUxqaUVnz72f0guXQarswPORAKx9nZVA4qIiIiIyIg06gcBkbHD7rdPhse4ceNw/vnna/XLiODIZtEZjcLr9cPR822YZX4OZTKIWRZii5egac4ceOpqUT9pEpBOIxGPwz8II6aLiIiIiIgMJVUAiojImBPPZhHliOMMA03011UFmLWAZDoNXyKBRCyKbFMT4u3t5m8c7TsTjw/znIuIiIiIiJROFYAiIjImmwDHALTbA0RZQLY7BIzFYmhmHxupJBKdnRwxpOd56gFQRERERERGIlUAiojImJNic14AiWy650TodjjMt2Icb9zJAUQANKVS8FVV9Tyv93jyIiIiIiIiI4MqAEVEZMxpYbBnvgVzIANgnpUFf1jN6QQcDrgA+AF4An44/V19/qXTabj8vFdERERERGRkUQWgiIiMORlYJgD0sulvTllf0rKwkM2C2Q8gBwSJROAP+E34l3Y64VMAKCIiIiIiI5AqAEVk2GUXLzb/ZpYuhcU+18qZRpRDOgDZRYtMBdfKTAOcRjm6+5PTclT+9nC3tCAFYEk2A6cDmM7e/RwO08dfBMDMbAYc7sMdDsNyuZD1+RDw++Eoc1lERERERESGkyoARURkzPE7nWAkGHawEfBXLDjgdzhQ43SZPgC9NTUI1tTAHwgo/BMRERERkRFLFYAiMuyc48cDc+fC1dgIZzhc1jQc7e2m0ss5YUL5QU13pZlrwoSynm5ZFrKzZmk5RsD2qAsG4Z43Fz63E0hnTfWf0+Ewg3x43W7U8d9EGj632wSBIiIiIiIiI5kqAEVEZMxxOp1gJBhyuEzox34As92thtssCw6XE2G3B8G6On1TJiIiIiIiI54qAEVEZMxJWRZCrC7srk5kCMjRgNkeOOXzIcnRgAN+VEUipjJQRERERERkJFMFoIiIjDkuKwuX14+YZZkQ0O10wM1/HQ40BAPIuN0ITJgIj99vwkEREREREZGRTBWAIiIy5mQcTmxTHcFnbW24OhTGOL8PweoaZF0uLE8m8LEjhe2POBxOtxsuv3+4Z1dERERERGSlKAAUEZExx+92Y8uJE9GWSWN2IoVFySRC2QxSLgc6An407LgDdjv0UCAYhE8BoIiIiIiIjHAKAEVEZMyp83qxOBDELpOn4IPmZnSkUqjaYgu0u5wYt8aa2OXII+FpaEBNY2P5oxiLiIiIiIhUCAWAIjLsrFTKDL9qpdNdP5czjXS6axp8fpmBjZXNfjU/5TyfQ8hqOUbE9mAHuOPcbjT5A1ir0YNMOoWqI49AaL310DBuHLyhkKn8U/gnIiIiIiKjgQJAERl2DX+4HZFweLhnQ8ag8Tk/uyZOhIOj/4qIiIiIiIwyCgBFZNi5J02COxIZ7tkQERERERERGZVU6iAiIiIiIiIiIjKKKQAUEREREREREREZxRQAioiIiIiIiIiIjGIKAEVEREREREREREYxDQIiIsMumWxBMpkd7tkQqRgeTwQOh76jExERERGRwaEAUESG3Ucf3YJg0GV+9vlqyihOziKRaDE/OZ0eeDzhkufBspJIJjvMz15vFRwOb8nTSKXakc2mzM9aDm2P8verDNZe+yR4vXwviIiIiIiIrDwFgCJSAbJwOLoORwzQ3O5gSc9OpxNwOBzdv2XM9BgEFsuysr2mkckk4PH4SqrA6gr+Mj3T0HJoe5S7X2VVDCsiIiIiIoNMAaCIDDsGIj5fHTKZONLpqLmv2BCQj+eNj3e5/Eil2syNTSiLCQEZ0vDxlpWB11tt7sudRjEhIMM+Pt7hcMHrjWg5tD2K3q/S6TQWL25Ga2sU2WwGqVQaDoeFTOZ9+P3V5j7y+4Nwu33w+30IBAJ818Dt9sDn8+eE3yIiIiIiIoUpABSRYWcHInboV2wImBv+2Y/ltIoNAXNDmtzH5k+jvxAwN/zTcmh7lLJfZTJZzJ27GNlsGslkFJlMGtFoEi0t7WhufgQzZqyLqqo61NbWYvnyZfD7/YhGg/B6A6irq0cy2Ylo1I2amno4neovUERERERE+qZPDCIy7HIrmOwwzw73Sgn/uqbl7A7iXCZosfvkKzak+aofwYj5W9djskWHf1oObY9i96tFi5YjkYjj/fdn4wc/+AvOO+8etLU1Ixh0wO/vwJIlM3H00Sdjzz0PRXPzl1iw4Eu0ti6Gy5VGPN6JUIjr2kJLSxMsyyrxXSciIiIiImOJAkARqTgDhYB9hX/FhoD9hX/FhoD9hX9aDm2PYvarpUsXYebMOfD7HfB4XHC7XZgwoRahkB+JRBuWLJlv+rN0uRiQJ+BytaOlZT4+++wDLF++CK2tLfD5fLCslAkSRURERERE+qIAUERGVAg4UPg3UAhYTPg3UAhYTPin5dD2GGi/mjdvOdLpGKZMqQEL+FjF53Y7kckk4XRm4fdnTbNg3pqa5mPp0gWwrChaWhZg8eIvMWfOTMybNwepFPfHZBHvKhERERERGavUB6CIVKz8PgHtnwcK//JDwK/6XQub5xcT/uWHNfY0+LqpVHtR4Z+WQ9ujv/2qqSmBhgYvEgmGdxay2SwWLmwxYaDD0YlAwA22jmf3fpEIg2yXqQwMharg9VqorQ3A58uirW05nE4Xqqq4P2pAEBERERERWZEqAEVkRFUCFhv+5YeAPNwlk6wETBcd/uWHgF2DNbSZaRUb/mk5tD36kkymEYvF0draiXQ6g2zWQiDgQCDgQl1dCKGQ11QF8v7W1nbE43HTVLi5mfugw1SkJpNx+HwepNNJNQMWEREREZE+qQJQRERkGESjcWQyFoJBX899DPVaWuKIxZKoqekKulnU194eM3391daGWQdrbi0traiqcqO2ls93IZ1mM/eAtqWIiIiIiKxAAaCIVLTcyj/7dyq2CtDu84+DKXi9EfP8rubAxVcB2n3+OZ3unibA9jSKrQLUcmh75OvsjMPv9yIWS5v9aPHiNpxxxkMrPG7ixBpkMim4XBaWLWtFLAbT75/bnekOARsQDgdMUCgiIiIiIlKImgCLSMXKb/Y70OjA+VYc8MPb7+jAheQP+GFPo6/RgbUc2h7F7lcORxqW5UQgwCDa6vfxbW1RUwUYj8eQTqcRCgXgcmWRzWZMFSGbCrPvQBERERERkUJUASgiFamvPv+KrQTsa7TfFQcG6bsSsK/RfvMHBumvElDLoe3R134VCPgQDnu6+//LoqEhiIsu2hNOp4VkMgu324Grr/6fqewLBr2maXAolMXkyePQ3t6KUKgagN+MGMyBRPx+Ng8WERERERFZkSoARaTiDDTgx0CVgH2FfzY7BOyvErCv8M9mh4D9VQJqObQ9+tuv0mknXC4H3G7A5XLC7ebgH17U1UUwcWIEtbVBOJ1s1+tAKBTEuHF1qKoKmekkElF4vUEEgxwUpGvkYJ/PX9T7S0RERERExh4FgCIy7Nh80VbsaL99hYADhX/FhIADhX/FhIBaDm2PgfYrj8eDRCINv5/993V14Od2V5lQkGFeNMrKQPv94YHfX4VJkyYhnXYhEKgxowc7HH54vQG43Z6eaYiIiIiIiORTE2ARGXZd4ZkfmUy8qPCvr+bALpe/qPDPVqg5sD0/A4V/tkLNgbUc2h7F7FfjxlWhpaXd9Olnh3fRaAKdnTEEg26k01k4nawMdCMSqUZVVbUJAD2edtTXj0c0aqGhoREuV6B7BGAREREREZHCFACKyLBj5Vwi0WR+Ljb8KxQC8sYgpZQRfnNDwGSy1dzH0X5LGeE3NwTUcmh7FLtfNTTUmkE9EgnL9AHYte8mEQi4EQiEkEp1dL8/WD3oMlV+HR0xM3rwpElViEY7zb7ndLrgcnmLfs+IiIiIiMjYoybAIkPkiiuuwKabbrrKX2f27NkmSHj77bcrcnqFOBxffRfBKr5S5T7H4fAUHf599RznCgONFBv+2fiafO1C81QsLcfY2h4TJ9abisCaGj7GYQb7iMctxGJp8/eu5uWcjssM8MFKv7a2BOrqJpqBQ5xOP3w+Nh/2wOv1lbx8IiIiIiIydigAFAHw4osvwuVyYa+99qro9XHiiSeaMM6+1dfXm3l+9913MZKxbzSn02uWqa8BNfpi9/nH53Ia2Wyy4MAgA71+KtVugpauPgHbCw4M0h++Jl9by6HtUex+NXlyI0KhEOLxDH72s4Pwi18cipqaCCKRAJqaLMTjwI9+dCxuu+0KBAK1SKUYKNbA748gFnOgtnYCMhkXqqrYn6AqAEVEREREpG8KAEUA/OEPf8D3vvc9PP/885gzZ05FrxMGfgsXLjS3J5980vQPtt9++2Ekc7sD8HojA46qmy9/wA9Oo7/RgQvJHZjB6602t/5GBy4kd8APLYe2R7H7VXV1FbbYYi20t6fQ3p4wg340NyeRzToRDtchnWaffxsjm42Ym883CTU1UxAIjENDw1Q0NExEOFwNy+oaNERERERERKQvCgBlzOvs7MR9992H008/3QRpf/zjH3utk6efftpUl/3nP//BJptsAr/fj6233hrvvfdez2P4nJqaGjz00ENYe+21zWN23313zJ07t9/1e+edd2K99dYzj1933XVx8803D7g9fD4fJkyYYG5sUnzBBReY11m6dGmfz3nmmWew1VZbmedOnDgRF154oRl4wMb+x66++mrMmDHDPGbatGm48sorC06Ljz3llFPMcn755Zc9zZv5HD6XgxScddZZJQeAA42qm6+v0X77Gh248LKsONpvf6MDF1JotF8th7ZHMfsVB/iYPn0Svva1deF2+9HcHEVraxTz57fB7Z6MXXc9AjvuuB+22WYvbLvt7th88+0xceIaqKkZj+rqhu5TOEcEDmkEYBERERER6ZcGAZEx795778U666xjbscee6ypBLz00ktX+EB93nnn4YYbbjDB20UXXYQDDjgAn3zyCTyeruApGo2a0OxPf/oTvF4vvvvd7+Koo47CCy+8UHAd33bbbbj88stx0003YbPNNsNbb71lgjU2CTzhhBOK2i4dHR24++67TXDH5sCFzJ8/H/vss49pPnzXXXdh5syZ5nUYOjK4ox/96Edmfq677jrssMMOprqQj8uXTCZxzDHH4PPPPzfVkuPGjcP9999vnnfPPfdggw02wKJFi/DOO++UtF8xVMxmM92/sZlj1wAIHDzB46kq8F0Fw7+O7vCv6+9fPZ8BnA8uFx/TaYJC9p2Wz7IY/nWYQIavZ1mWmZ4tfx5y+5OzZTIxpNMxE2DyNXPnQcuh7VHsfjVpUqMZECST4UAgHC24ExtueDTC4fErHIc4ErCIiIiIiEipFADKmHfHHXeY4M9uXstQjU1rd9ttt17rhmEdq/qIId+UKVPw4IMP4ogjjjD3pVIpE+axOtB+DKv7Xn31VVN9l++nP/0pfv3rX+OQQw4xv6+++ur48MMPccstt/QbAD788MOoqmLoBVO9yIo+3sdqokJYVTh16lQzbwwTWGm4YMECUzl42WWXmWkw2OTf7dddc801TRCYi+tl3333RSwWM1WR1dVdQQSbTDMU5fpiGMpKwELLS4lEwtxsbW1t5t8ZM45BJBIZ8/uiiK2rWrB3+CciIiIiIlIuBYAypn388ccmoPvHP/5hfmd/ekceeaTpEzA/ANx22217fq6rqzMVgx999FHPfXzulltu2fM7gzY2C+Zj8gMxNtdls92TTjrJVOPZ2CzXDtb6sssuu+B3v/ud+bmpqckEfHvvvbdZjunTp6/weL4+5z03TNh+++1NoDdv3jxTscdQ7hvf+Ea/r3v00bB7I0kAAFY8SURBVEeb0JPhaDD41cimhx9+OK6//nqsscYaJkBlteH+++9v1ke+q666Cj/+8Y9XuN/rrTF954mIiIiIiIjI4FMAKBjr1X8M3SZPntxzH5vssZKtubkZtbW1/T4/v0KnUMVOofvY5JXY7NauGLRxNOL+sIkwm/zatthiCxMaclo/+9nPVng8lyd/HnifPW+BwIrNYwthsPeXv/wFL7/8Mnbdddee+1ldyCD18ccfxxNPPGGaPv/yl780/Q7azaNtbGp8zjnn9KoA5POBDnVJKvLVu5zvTq0PEREREREZNAoAZcxi8Mc+8dgMd4899uj1t0MPPdT0rXfmmWf23Mfgi81bieEg+/9jlV/u9F5//fWeaj+GYi0tLb0eYxs/frwJHb/44gt885vfXKnlYIjH5r9smlvI+uuvjwceeKBXEPjiiy8iHA6beWhsbDQhICv7Tj755D5fh4OkbLjhhqbvQw6IstNOO/X8jc/n/bydccYZZpk5SMrmm2/eaxocJIS3FT0G4KuqwhWxDzV7QA8+rv+QtDCuH3vgkzDK055z6CwuOO1Ny6HtMdB+xdF8Oap3VzN/ERERERGRwaAAUMYs9pvHII/NcPOb3R522GGmOjA3APzJT35iBtpgeHfxxRejoaEBBx10UM/fWe3GAURuvPFG8zOfu8022/TZHx4H4OBouez7jk142QyXASLnKbdKLh8fx2a7xMey7z4252Wz20JYkccmupw3zhODSfZnyNdgcMjBQNgf4Pnnn28GL2HzYDZR/uCDD8y6ycVpZDIZM1ryf//7X9NPIEdA5n2sZGTT4D//+c8mECzUHLlvrn5CPas7vLMropJlVEgx+MvmPCfVHbSUIp7z/Gz3fJVyCNVyaHsU2DPTHVi0qAmdnQlT/ZvJuBEKfYnx49c2g8pkMikzMAiLdl0uD7xen/oGFBERERGRkikAlDGLAR/7+SvU5x4rAH/+85/jzTff7LnvF7/4Bb7//e/j008/xSabbIJ//etfJjCzMfxikMZRctm3HsMx9iXYF1bb8TlsLsvwjU17N9poI5x99tn9zvejjz5qBv4gVvGx2u7vf/87dt5554KPZ5XfI488YkYx5nyz/0IGe5dccknPYzjqMfvs46AgHCCE0z/ttNMKTo/zxybMbBLMeWE/h1w3DBQZBHIZ/v3vf/c5KnFpGJp1dgduDP3QXQnYWUIImO5+jrP7ORyExB6IxF9C+Mfn+Lpvnd3TDBZ5GNVyaHsU2DPTHZg583MsXNiJeDyLdDqOjo4YotFmBALjsPba66GurgE1NeNQX99oRrSOx6Pw+4MKAUVEREREpCQOy+4MTEQK4oi3HHiD1XYMuwphFRyDMTb5leKxD0AGsK2tf0IkEuwnNMsN2vIDvf5CwL4emxvoDRQCFnpsX/NWiJZD26PwfvXpp5/jo48WY401xiMYDMCynMhkOtDUFEBTUxTV1asjHG6A0+k3A+VMnDgNTqcbLlcAfn85TdBFRERERGTkf35uNS0JS6UKQBGpQP0FbO7u+waqBOwvKLSDvIEqAfsKCh3d0xyoElDLoe3R9371xhvzscEGk3DAATeZqtrbbz8OqVQGHk8YZ5xxO9LpLP7xj18hmXTAspYhnU6irq4esZiFadPWGnDAIBERERERERs/GYuIVJBiquvsEDDb/dj8QuZiqgT93cFeojuQyTdQlaAdAjq7X8seYETLoe1R3H7V0RFHNJoy4Z/H4wLzvNpaPyIRt+n3z+GwwB4KXK4OBAJJLF8+FzU1AYRCwJIl83tGExcRERERERmIAkCRAbBvPbaU76v5L5144olq/rtS0mU0re0rBCyliXBfIWCxTYT7CgG1HNoeA+9Xzc2dcLuzcDodpvKvtbVrJG+HI2nCP67DWKwN9fVhhEJutLYuRlvbciSTfFwM7e2t/b6rREREREREbAoARaQCxLrDs2LDv75CwFLCv75CwFL6B+wrBNRyaHsMvF+1tETR3Bw14R+r+RgG8ssGd/euzypABoBNTcvh9zvh8aSxcOEcMxJ2MtmBpUsXqApQRERERESKoj4ARaQCOLpDM3SHaaUcmuwQsLP7Vkr411efgMWGf/khYIeWQ9uj6P0qHo9j5syF3aGfG+FwCIGAF9XVXSNeu1xOJJNxtLa2mxGA3W4XwmG/aQbc0pKAx8OOgJtRXV2nUYFFRERERKRfCgBFRESGQSyWRDbb1Ww8nU5j6dIWdHQkEI8nTGWfZQGZTBpebxrxeBpVVVWIRjuRSqVNUJhIAE5nBslkAj5fKYG1iIiIiIiMNQoARaQCsL+zUHczyf5G1S3EbvbLEVH9RYwOXEhu88xiRgcuNP92P4RaDm2P4varVCqFSMRvgr7581tx+OF/6rVXTZlSY0YCjsfZxD2FqVNrkEikMWfOXNTVjYNlhUxVYCaTKrFiVURERERExhr1ASgiFSDQHfj1N6puIfl9/g00OnAh+X2zDTQ6cL5CA35oObQ9ituv2tv73sc4OIjX27WPtbe3Y9GiJgSDfsRiLWhr64DP5zYVgcXt5yIiIiIiMpapAlBEKuhQZPel11lEJWBfA37YIWAxlYB9DfiR33dbX9VVfY32q+XQ9hh4v4rHk6irC5m+/iZMiODWW4+Gw5FFLJbGD3/4kHlMa2vUNPWNRtNIp2OIRmPw+0OYOHGcafprWQHTl2AwGOnn/SUiIiIiImOdAkARqTDFhGcDjfZbTAg40Gi/A4WAfYV/Wg5tj2L3q4wZ8MPpBNxuJ+rr/QiFvKiq8sPjcZrmv7W1YcTjDng8DtTUVCGbdaKxsQ6pFAcBCZvwkH0GioiIiIiI9EdNgEWkgkPAQs2BBwr/bP01Bx4o/LP11Rx4oPBPy6HtMfB+FQr50doaMyP4srlvZ2cCra1JtLaysg/mfpfLi3A4bMI/t9trqv6SSQuZDOD1+pHJcARh9n8pIiIiIiLSNwWAIjKCQsBiw7/+QsBiw7++QsBiwz8th7ZH//uV2+2HI2cX9nhcSCYzyGa/Cqstyw2XK4i6ulq4XG60tCTgcgXg94dNhWAg0HsaIiIiIiIihagJsIiMkObAvJGrxBF+c5sDt3XfV2z4V6jZZqL7tUsZqVjLoe2xomAwgHS6q7qV1X7BYAiWlUZVVdhUBLK6L512we/3mH4Ag8EqTJrUgKqqGtTW1ps+BFOpDJxOM1KIiIiIiIhIn1QBKCIVzlFgIIVSS54Y1OU2k2QAWKrc57jK+P5Ey6Ht0dvmm6+B5cvjJuhj1V9ra4dp/jt79lKkUqwwdcLvr0MoVAePpwqxWBbBYBg+X8AEhrFY3DQHDgSqytifRURERERkLHFYFnsaEhEZem1tbaiurkZr658QibCirhC72a8d+lklVt8hp9kvn5MpoQmxLbfZr6t7nkqtItRyaHv0NnfuAjz++CsIhdxIJh3w+9nnH/fNMMLhOlRXT4DXG4LPF0ZHRwpVVdWoqxsHny+IbBaIxYCamvGmMpCBoIiIiIiIjIXPz62IRCIlP18VgCJSwXL7/KvqvhUaGKQ/uX3+hfoZGKQv+X3+hfoYGETLoe1R2n41aVIIO+ywNrzeKowfX4uqqiq4XB54POMRi/HE7kI2G0Qi4UJNzWT4/Q1IJt1mVOB43I26ukkK/0REREREpCjqA1BEKlRfA37YfQJGi6gELDTgR26fgJ0DVAL2NeBHbp+Aub9rObQ9it+vXC4H1lxzBiKRcVi4sAWpVBrRaDtSqakIh1nZFzKjAPv9Afh8foRCYTPyL0cD9np9qvoTEREREZGiKQAUkQqQ6b7l/h7rDv8C3QFcrkBO0BLI698POeFcEgAHSPDkTd/uj4+v0dEd7hUS7X7tQPdzcqfh6f5bvPvfQv0Kajm0Pfrfr1wuFyZMqDO3r8LB/bqrXUVERERERAaHAkARqQB7Aii9DwOR0YnVgyIiIiIiIoNHAaCIVAC7fz8RERERERERGWwaBERERERERERERGQUUwAoIiIiIiIiIiIyiikAFBERERERERERGcXUB6CIDLu2pQuAePtwz4aIiIiIiIisIuGGiXA4VYc2XBQAisiw+/dPTkPAq8ORiIiIiIjIaJRNp3HY1XcjMm7ycM/KmKVP3CIy7FxuD1zu/g9HlmWZfx0OR9mvs7LTqIR5GIxpVMI8DMY0KmEeBmMalTAPgzGNSpiHwZhGJczDYEyjEuZhMKZRCfMwGNOohHkYjGlUwjwMxjQqYR4GYxqVMA+DMY1KmIfBmEYlzMNgTKMS5mEwplEJ8zAY06iEeRiMafD59jRk+CgAFJGKlk4m0L5kASwra35nyXi4cSLcXn9Rz+eJJtHRilhrk/mZJy2Xx4tw46Siy8+tbBYdyxchnYj3TMMfqYU/XFP0SVDLoe2h/UrvDx2vdNzV+UPnc12X6PpK14m6bh/tnz/M81JpdCZSSKUS6GhaikQ8AacD+PTjmXB+8SVcLid8Pq+Zl7rG8aiurYVTTYNXOYelGFZEhklbWxuqq6txy7d3K9gEOJ2Md5+0rK6TjMUTStacfMLjJsPt9Q34Gp084XS2dZ0oeev+9snhcKJm8moDnkD52Jb5s2FZGfOc3Gn4qiII1TYOOA9aDm0P7Vd6f+h4peOuzh86n+u6RNdXuk7Udfto//zBv8cSSbRF48gmE1iwYD46k0lkMkBnPI21tt8d02esg9px4zFx0mTU1Tcils7AH4pg8rTV4HS54PX54fP7V6picbR/fm5tbUUkEin5+aoAFJGK1b5koTmJVDVMgDcQMvclY53oWLYI7UsXoHby6v0+P5vNIBltNyeP6onT4HS5zfTal8w334jxGy1+i9afREebOVm6fYGub7scDmQzGbQu/BLJznYEquvgdLq0HNoe2q/0/tDxSsddnT90Ptd1ia6vdJ2o6/Yx/fmDlX9N7VFkEzEsWr4c8WQSXpcLltsDryeD9OJZmBPrQMekCYg3L0Pn5OkI10ZMlWFrSxPGj5tglt3lC6C2oQF+f1Bh4CDS8CsiUpG6+ongt1TOnpMW8Wd+i8Wy+IEKmNPxmHkMT048aRFPYlUNE83PsbbmAecj1tZk/q2qH9/zLRS/mWIJPqfN19ByaHtov9L7Q8crHXd1/tD5XNclur7SdaKu28fy549sNmvCv472dlz75Ef4y5sL4bSyyGT5min4nIAzk4Iz1QZ0tGPuZx9iwSfv4+hTvo/jTvs+rI5WZKLt8Huc8CKN5iWL0bJ0ERbPm4PW5ibEY13zJOVTBaCIVLZCld+lHvdXKB8v58SRN41STz5aDm0P7Vd6fxR1rNDxSsddnT/0/ijjwkLXJTnroqgVqOOu9qui317arwZeESb864ghFouhrbMD2e5jUjSZgs/tALIWkg4L8aYmuKMdaGppR6gqAittIZtJw7JcyKQTMC2es1nE4glY2QzcVSG43W44shlkUwl0plMIhqqQTCSQTMTNpuIrqdlwcVQBKCIVid8w8VsrfkPFcnUbfzbfaDmdA/YL4fYHzGPibc2mbJ74rVHH8sXm50CkbsD5CERqzb8dy7rK6IknqXh7i5k2X0PLoe2h/UrvDx2vdNzV+UPnc12X6PpK14m6bh+Lnz94Pwf8yKaSSCUSSKUy3f0FAmyoHHBm4HBn4fNacGaycCdS8CQ7kY5H0dq81Ew/nUph0fx5mD97FpYuXojW5UuALJCMx00AmEomeoLApmVLTRjo97JZsRvIpNG6bDEWqVJwQBoEREQqeBAQjlw1v6ezWX7FwxNZV+e1k4oawaqzeanpR6N357WchqvETni7XrdXJ7yhCEJ1xXTCq+XQ9tB+pfeHjlc67ur8ofO5rkt0faXrRF23j77PH8l0BolEAi3tnWhuaUFTWyce+GApHLCw/xoBhLwOpGHB5eI0fObflOVBMBxEyhnAP96ea+bx1p+eB1+kAY3jx8HhcMNfVYWsy4ua2jok0ylURWqQyXZVDNY1NHYFjx3tcMIy4WA6nYbT4zM/Zx1OhKrCo24gkbaVHAREFYAiUrE4OhVPUKavCivbddLi8PVm5Krihq8P1jSYjnKJzyePP4iaSdOLOiHwMXysPVKWPQ1ON1jboOXQ9tB+pfeHjlc67ur8ofO5rkt0faXrRF23j9nPH2z+mzXBnAUH/zNZIYNHB1wOJ5xuB8Z5nAhZQCqVRiyeQTqdRDKaQCYZM9V/WQ564nEjydGLW1vR1rIMzU3LTdWjlU3D6/HC5/Ug0dlumv9y+ol4vCf8M8vsdptmwfyXfQ/y79KbKgBFpGIrAHPZ5e8r8y3Oyk6jEuZhMKZRCfMwGNOohHkYjGlUwjwMxjQqYR4GYxqVMA+DMY1KmIfBmEYlzMNgTKMS5mEwplEJ8zAY06iEeRiMaVTCPAzGNCphHgZjGpUwD4MxjUqYh8GYRiXMw2BMoxLmYaBpJJIptHXGTHPdhcubEI3FcN97S+FwWPjGFC/8XsDvcpr++tKWE/GUG1UBL3w+D6Jw4t8fNcHr9eKaH56KhvET4Q9WIRCOwON2IVRTj1TWgfFTpsEfCGD54iWIx6II19UjlUqiKhTqNUowRyEOR6rNz/FkCpGarubUo0XbSlYAahAQERkRBqN8e2WnUQnzMBjTqIR5GIxpVMI8DMY0KmEeBmMalTAPgzGNSpiHwZhGJczDYEyjEuZhMKZRCfMwGNOohHkYjGlUwjwMxjQqYR4GYxqVMA+DMY1KmIfBmEYlzMNgTKMS5mEwplEJ8zDQNEw0aEbjYCVgGo5sV1jYmrDwj88TRU1/Yr0X7dFO1HCwD6cbbqcLLo8PHo8bHe2daDNVgc1ob25CTV29qfDzs6lvOoloRxrBqiozj7mjBI+25r+DQU2ARURERERERESk9FDJDCoCpLJAyO1GcyJV8jQymSziiQT84WokMhlEUxmkYJmKvpA/gEwiBo/DQjgSgQMZRKOdJng0A4Ogq7kv+wDkaMC23DBQuqgCUERERERERERESuZxcZARV1eff15v10AhAGr8Thw8I8g/gQ9pb7MQCTuRyLrgc7nhDwQR9wTwj7c4CAgQDobRWD8O7mDYVBSyv0D2Pcg+C6PRKMLV1Qh6vYhHO5GIxZC1QsikMyYE7IxFEfLWIuDr6jcxPwy0Wd19B7KvQFO0CJjH5TYjHs0UAIqIiIiIiIiISMkYnFX5vWjrYCWgC7Xs9I8DBzNc48i/DrvpaQrJtI+jhgAeD7IuoMoXhMvZFR5mMhaSqRScmRQC4Wpk0m3wBsOorasDli83IR15fQE43D4zMnCWkRaf4/YiFOpqBszwj6MAB7ofb7PsUYPZfNjr6bk/nUqgM50alaMG51MAKCIiIiIiIiIiZfF53GaU3njMCZ/XB6eD4wEDLpcHWYshYBoBnxdpeBH0u1Ad9MFbUw9/VQQOpwMcPzhQXY329ihcwWrUV1UjmcyYaWQyGbg9XWEeK/4shwORmhok0xlUhSNIJBJob283vzPkY0Ufw7/8MC/BUYM52nD3qME9oZjbbUJD/p0DjYxmCgBFRERERERERKQsDNvCQT+WNbeZgTsY/zF/C7i9sNIptGSdyFhZuFgR6PHA6Q/DGwyZSj6n0wWn24Mp09dAVW0tJk6ZinBNjZlmZ7QT8VQWHj+bAcfhDwYR7A73GPbxXwZ49eMmDBjeJRPxXpV/uTiNOP+uAFBERERERERERKQwNgP2srqObXsdAAcDZkjnCfgQSWXgdHnQ6vQhGK6DJ1wFpz8ChzcIp9ttBhKpHz8BTm8ACfbfl0wh63DB7Qtg/KTJZvqm+S5rBbub+bLSr6/mvoU4Bvr7KG/+SxoFWFbaaquthuuvv77k5/EN9tBDD63SLfC///0P6667LrLsZ2CYl5kHv1NPPRV1dXVm2d9++20Ml9mzZw/6PLD0etq0aXjjjTdKfm4mlUSisx2peKys0Zr4nFQ8aqbBaZUjm80gGe0wN/5cDi2Htof2K70/BqLjlY67On/o/aHrEl1f6XpX1+2j8fNHOh5FQ20IaaevK0xzAAsTGSxuj6E1nkJTOoWqhgmobWzExKmrYY0118R6G20Cl8sNp8uN+oZGBEIh1DWMQ7i6BjX19aiqqTNNgDk99tHHvv46ozHEUmwK7ITT4yu67z6riHUx2qkJ8Chy4oknoqWlZZWHaiPJ+eefj4svvth8ozCQP/7xjzj77LPNOlwVHn30UfMaTz/9NNZYYw00NDRguPaLqVOnYuHChYM6Dz6fD+eeey4uuOACPPHEEyU9t23xPPg9rq86kW2cCI+vuP4XUokYOpYu7HXAdjicqJ40zZSTD4TPi7YsQ7KzvWcanAd2OBusbSjqZMKTXuuCOWbEq6/mQcuh7aH9Su8PHa903NX5Q+dzXZfo+krXibpuHzufP7Lsl8/hwpk7r4dEMgkrm8TytoTpe8/jBsZPngxfuA4IeJH0BjF+wkTcfuM1mDx5GuKpFAKROjPYByv7LKcLdQ2NSCYSpnmuWS8uN6obxpc1aq+XFYOpxAp9APY3avBoowpAGbVefPFFfPrppzj88MNRCT7//HNMnDgR2223HSZMmFDwwDNUXC7XKpmHb37zm3juuefw0UcflfQ8h9OJUG0jvIGQOXnwRJTNpAd8Hh9jn7T4XHPCdDphWV0nxGLE21uQ6GgzPweq6xCI1JqfE51tSHS0FjWNrpNvRsuh7aH9Su8PHa903NX5Q+dzXZfo+krXibpuH7OfPzxuFzxIwoMMaiNh1NbUYsbkRtTVRuBwe1EzcU2MW20Gpq2/FdbZYjsE68Zj/NQ14AyE4QxUm4q/RCrdU9nHQh72yxepqTVVgfyXv5fTXNfn95vmwgz7ctnNiO1RhkczBYBjyLXXXouNNtoIoVDIVIB997vfRUdHR8/fWZ1WU1ODhx9+GOussw6CwSAOO+wwdHZ24k9/+pNp9lpbW4vvfe97pgw3F0fdOeaYY1BVVYVJkybhN7/5Ta+/M4j7+te/Dr/fj/XXXx+PP/74CvPHyrG1117bvC4r5C699FKkUqmev7/zzjvYZZddEA6HEYlEsMUWW+D111/vc3nvuece7LHHHuY1B5oGq/K+9a1vobW11RxMeLviiivMc5YsWYL9998fgUAAq6++Ou6+++6yqvC43ubMmWOmzXXZV1PiTTfdtOe1iY+//fbbcfDBB5t1s9Zaa+Ff//pXr+d88MEH2Hfffc0ycdl23HFHEzhyOtx2//znP3uWi8taqAnwM888g6222spU8jGovPDCC3sdHHfeeWecddZZpqqSzZgZIObOJ9XX15uA829/+1tJ66d64nT4qiKmJJwnH/NtUvOyAZ8XbVluHhuqazTP9VdVo2bSanA4XebbsGLK2ONtzWZdcB540uLJq3riNHNfrLVpwOfzNfhafE2+tpZD20P7ld4fOl7puKvzh87nui7R9ZWuE3XdPhY/f9RMmo6gzwtvOgY3AzenG0mHG4FgFRpra7HZTrti2z0OxHpf2waNU9fEGutvimkz1sX0tdbF6mutjeraupUK+frjsJsRe3yIJ1MmaOS/pTQjHunUBHgMYXp+4403mtBp1qxZJgBkmHPzzTf3PCYajZrHMDxjqHfIIYeYG4PBRx55BF988QUOPfRQ7LDDDjjyyCN7nvfLX/4SF110kQmEHnvsMfzgBz8wfe/tvvvupv89ToPNTV9++WW0tbWZprb5GFwxhGSA+N577+GUU04x93Ee7eqyzTbbDL/73e9MBRvDK4+n8Cg+9Oyzz+Loo4/udV9f02BoxSDusssuw8cff2weyzDTDu/mzp1r+hP0er0mBGMomIuPYajGcM3GA8idd95p/nbDDTdgzTXXxK233orXXnvNvHYpfvzjH+Oaa64x65nhKpfjyy+/NEHc/PnzTbjKgI7zyBDwhRdeMOEdm+SyGo/rnPNCfM6CBQt6TZ/T2Geffcy83nXXXZg5c6ZZ/wxPc0M+honnnHMOXnnlFbz00kvm8dtvv73ZzjaGiKwC7KufQN5snC/7Gyj7iyq3z29ORsl4FJn0VwFwIclYp3msy+Pr9ViewKKtTebv3n4O5Hwu98+ub7uyyKS/KqFnEbuVzSKdSvZ7MrDnga+Z+22blkPbQ/uV3h86Xum4q/OHzue6LtH1la4Tdd0+1j5/cPhfj9uJ6oAHjqC35+5sOo31N9oEkXFdg3oMB4fDYcLF0T7ab18UAI4huaEbK9l++tOf4vTTT+8VALLijuEYwypiBeCf//xnLF682ARirN5jBd1TTz3VKwBkCMSKMWIVHwOo6667zgRD7A+OIRQDsilTppjH/PznP8fee+/da/4uueSSnp8ZUv7whz/Evffe2xMAsnruvPPOM8EisRKuP3w9hom5+ptGdXW1OSCwss32ySef4L///a8JLrfeemtz3x133IH11luv13RZMZc/0AirKDlNe9oMM+2mt6Vi0GaHmVx3DAFfffVV7LXXXvjtb39rps/Q1g5EuQ1srFxk6Nbf63IfYFXoTTfdZNYB1w9DQlZlMhS1+1DceOONcfnll/esOz7+ySef7BUATp482az7Qq666ioTZubb/7LfIxIOl7xeREREREREZGQIN0wc7lkY0xQAjiEM7Rgeffjhh6byihVi8XjcNPFls2BiE1M7/KPx48ebMM6uhrPvy6+A23bbbVf43W7ayvCPo8Pa4V+hx9P9999vnvPZZ5+ZpsmcP1az2Vh5dvLJJ5tAcrfddjN9++XOa75YLNar+W850+C8s5+8Lbfcsuc+hmOsiMwPtvKxim6wMHizcVsxTLS3AasY2eS3v2rIgXA5uU1yv2liqMvtMG/ePLP98ufDDj7z9wUGjqwkLeRHP/qR2QY27ocMHt1Oh7mJiIiIiIjI6BOom2AqBmX4KAAcI9hclE08TzvtNFP5x2agzz//PE466aRe/ezlh0gMhArdl1/tVogdJhUaTju/pJkVdkcddZSpDttzzz17Ktp+/etf9zyGTVHZz+B//vMfU5XHSjQ+hn3jFcImx83Nzb3uK3UauaMyrQqsrMtfP7nbw9bfNmDgtrI4D/nLWGjZi9kXmpqa0NjYWPB12L8gb/mevvBgBL0ujhRvSt89/hB81fVFzXuidTnS8c5ew7o74IC/dhxc3hVfKx/L7KPL5q+wHbhswYbJRZ2kMsk44s1LYXXPhZZD20P7ld4fOl7puKvzh87nui7R9ZWuE3Xdrs8fXdhUebuL70SwoXcLPRlaCgDHCA50wYo6Bmp2c8777rtv0KbPAC//d7uZLZsNs+ktm5TaTXLZf1wuNhmePn06Lr744l6hZT42beWNfQyySSz7tesrvGNff6x2LHYa7N8vf3ATNvXleuP6Y992xD4CW1paMBgYlC1cuLBXRRz7ZywFq/LYNx+Dw0JVgIWWKx+30QMPPNArCOQoyqw0ZJPeUrz//vtm3ZfCE6yCM5s0H5a6grviR2AK1E9AJhFHonWZObG4fH74qhvgdBV/eKuauDpS0TYk27oCY2+4Fp5QpOjg1+n2wOULINnWhHQ8quXQ9tB+pfeHjlc67ur8ofO5rkt0faXrRF236/OHVBQFgKMMR7HNHdmVWO3HZq4Msth3HEe0ZeD2+9//ftBel9PjIBUHHXSQGeH373//u6myIza1ZX94xx9/vAkgGXLlBn00Y8YMExKyGu9rX/uaee6DDz7Yqzkv++5jn4Tsv5DNUjmYBgck6QsrCRmMFTsNNnVmk1f2abfJJpuY5tCcb/azxwExOIAHmwOzL8X8qjs2beVAGhxAw8YAlE2D+wooaddddzUDn3CbcIRljnxc6gAhZ555ptmurKDkfLB6kgEsA0vOP5eLA7MwuOQovXa/hLk4IAybX3OkYk6Pj2V1JJvr2oFxsTgACKtMS+GvaUTIV34TZoZ+wXFfNTEvFYM+b6ja3MrFwJEfdlaGlkPbQ/uV3h8D0fFKx12dP/T+KIauS3R9pfOH3h9D/fmDRSdN7VG0LlyGRDyFdg4AmUzD73PD73Yg9sRjqJswDXW1NUhn0nC7fahtaIAvEAQbYzmdDrBXKAsOeLw++Pz+MTEy71BSA+xRhqPQsvoq98ZBHDbddFNce+21uPrqq7Hhhhvi7rvvLthvXbk4YMcbb7xhXo/hD4M+BnDEAIlhHgeiYCjFPviuvPLKXs8/8MADTUUewyfOK6vPGIbZGIotX77chIis3jviiCPMICKFBpSwHXvssaYC0B7Vd6BpcCRgNpHm4CaszGOgSawQZD91O+20kxnN+NRTT8W4cb2DHlbxMcDMxddlINsfBnYcwXe//fYzTbQZoPbXJ2EhDPU4+i/DS87jFltsgdtuu62nGpDhJYNA9mPI5WJYm49VfhzlmQOLMPzkemDz8NyBWYrByk4uM0NWERERERERGf1YbLRgeRs6OqIIOrMIIANnKoagI4VUtB0Lljbh05efxqxXn8IHLz+JxNL5yLQuwdJ5s9C2bCmseDusVBw+jwcBrwdIJxHtaC/YnZiUz2FpjcooxhGEGUjdcsstwz0rYwIHVWEIfNFFFxX1eFaDsiLx4bP3WakKQBERERERERl67BN+7tIWWMkU/B4Ly1o7cMVjH4PFe9/9WiNaOpPIpoCaydPgDFZjwtSp+Plf/wu324M7fnU5ApFxWHujTUzFH1xe+Ltb2zFUhPur3wU9n5+ZceQOmFosVQDKqMamxuxbcKA+8GTlscKT1YOs5BQREREREZHRjfVkHbEkh0VE0OdCMpHBkrYO05SXN7/TiQkhP6oCLgTSHUDrIsz/5AOkkwlY2TS8SCHT2YR5s74wLQdTqUTPdNOpFJqXLkZHazPaW1sQj8VUEbiSFADKqMZ0nNVopfarJ6Xj6L5sMjwYoxKLiIiIiIhIZUumM6bSz+92IZZMoTMRRyaZhNPhAP+r9TjhcWfhcVpwZjOo9mUQzHbCaWVNwLd8zhxkEjE4Mwm0tbTC0R3+RTs6TDPggM8Dv9erZsGDRIOAiIiIiIiIiIhISbJWFm6nA1kLiCXTSKTSyPAXdN2i2YQJ9MJ+IJvJwJFwIZ5OIpPNwpXNwErFsGTRHATrx6Ozsw2+qipT6ZeKR5G0Mkgmk2ZKbo/XvF48FkWss8MMHKKBQkqnAFBERERERERERErisBzIwoLX5UI8mUA0mUA22dX9FsfvsDIWHBYQTfOeGDyeFJIZDvWbRTaTRTLOQC+NWMsyLMpYCFTVIBZbirpwyIwA7AmF4fO40dbabALFSHUN4sm0qQhMm4FCUghWhTVacJEUAIqIiIiIiIiISEkshwUnHAj6PGiOJ5HsiLMuENmsZSr3Evy/A/C4gaaOLOKpLJJwmIFD2Afg4mXNcIVqODot2pqXI9q6HMloB5pTcYRrGlDl9yERT8Dncprp8GdHd/debrebI4UgEY9roJAiKQAUkYrGkvFUZxuS7fzWB/CGa+EJRUr6liebSSPRugyZRBxOlxu+6nq4fKX1VZhJxhFvXgIrm4XbH4Q3UmempeXQ9tB+pfeHjlc67ur8ofO5rkt0faXrRF23j8XPH04H478sOjNA0OtBlL+xKtCysDyexcVPLetz2nVBDzxWAh6301TzBQM16GhpQbiqCm5kkUjEUYUwUslEVx+ArCFMJeB2BnumwRAwlkwoACySw+JeISIyjMOYP3z2Pgj5ug7quXiy61z85QqjPfGkFRo/HQ7nwOMYsVPZ2PJF6PoOqvv5PFkEquCvHVfUfPLEm4p1dHVK2zMNBwL1E4o6kWs5tD20X+n9oeOVjrs6f+h8rusSXV/pOlHX7aPt8wen3x5NmEE+Pp27BLMWLEI2mcLdHzWbALA/9UEPrj52D/gnTMUaG2yOcON4pJ1eTJkyHcimEE+lUVXTgHQybgYCoY5YDFW1jb0Cv3gyharqmt7Lb1mmMpDhocMsgWNU9Blof35ubW1FJBIp+fmqABSRihVbvhBW1oLL6zMnOx7IeTLkySjevBiB+on9Pp+PjzUtMqdNf3UD3MEqZNNpxJbNNydUfgPm8vr7nQZfK82Tr8OBQMNk881XOt6JRMtSM+3QhNUGPIloObQ9tF/p/aHjlY67On/ofK7rEl1f6TpR1+2j7fMH58PtdpoO/zKwTPWfw9kVuNX6nDh5vVo2CDbJYTYLM0BIVdiLW95qMgOHLG5uxdrT1obL6UA8nkA83Yl0cgKi0aiJ7bzBuAk+KZ1OIw2nCfF6zWuBeY92tMMFq6dysOv5yTHfZ+DAsa+IyDDggTubSsLh5IlvEhxOlzn58WTFb6xYhj5QATPL5vkYlz/YXe7uhMvjNSdSnkZ4EhxIonW5OanwOXwuX9sTDJtpmhNdMqbl0PbQfqX3h45XOu7q/KHzua5LdH2l60Rdt4/Jzx9sBMwgsDrog9Ptgt/rNoEeHxfyA5EqB8ZXO9FY40JDrRs1oa6/O50O1EVCZnmali9FoqMdVaFqEyjW1lSzg0G0tLQibXVV/qXhQHVNXa/wk6EgK/t6rb943IR/po/AHG6329zPv49VCgBFpGJ1lZt3nVBsXT93FXIP+PyMGW4Kbt9X/UQQT4BmYHp+DVVEvxfmOXknEJbem2lkBp6GlkPbQ/uV3h86Xum4q/OHzue6LtH1la4Tdd0+Gj9/cCCQrJVFOBCE3+VAouupcDiBgN8Bv98Jn9cJL4NBlwcOuOF0OODi/Dic8Pk88DnTaG9tQaS2Fhk4kUgmUF1bi3C4ClWRGhOAOjzeXk1/Gf5l4FihIpDNfvPDP5vb7TZ/H6sUAIpIReIJypyk+A1W9wmIrEzG3Nfz9344PT7zzVOiranXt1wsqSd2pjsQl6/rhJKOdnw1D5aFZFtXZ7qu7v4otBzaHtqv9P7Q8UrHXZ0/dD7XdYmur3SdqOv2sfb5gwOBZDMW3B4nIuEAQj63ad7LpyXigKu7Ca/F+jvLC4fDyydxRpH2euF0ueByuuDyuE01n9fnQ8btRzprwen2oqOzE8HqOgSr602/gOzzL5ZMAW4vglXhFZaFEWe/6wdjl/oAFJGK5Q3XmRL46JK58ISqzcE92dFivrXyVdUO+HyWqfPEYmUz6Fz0JbyRWtPvRSbO8akcZiStgfiqG5CJzzWjX6UTUfMtmDkRZjOmhJ4nJS2Htof2K70/dLzScVfnD53PdV2i6ytdJ+q6fSx+/vC6XYgmkyYI5GAd7qoA3E4HUhkH4sjCEXUh6QRcfgeyDP78bjMNztOESdOQcQbQmXIhXF+PdDoLh8uLSHUQWYcTwVAYiVQagaAdOA4coLL/wf7/PnZpFGARqdxRgDl6E0980fac0a8AdzBihqAvZgQnc9JaPKfnmyvzDHaoW1fcCFo9I2A1LVphGqHx00yfGgPOg5ZD20P7ld4fOl7puKvzh87nui7R9ZWuE3XdPko/f5iqvEQSi5a1YGlLK377wmxTAnjKJo0IedNw88neGmQ9TgSCVfj5Yx/C4XLht5d+H6H68ahrmIBIw0RU1dYjGInA4/lqxF5W+4XzRvntTzwWA9LJgs2A0+m0qRzMbUo8lkYBVgAoIhUbAOaefExntezM1Rco6qSXL5tOIpNMwuFywuUNlDz8O098pjPcTMZ8I+bkt2Il0nJoe2i/0vtDxysdd3X+0Plc1yW6vtJ1Yv903T7yPn+YUYaTabS0t6OlrQOtHR1IxJPs0BAZC0inkgiNmwink9V9NfBUVSHYOA2T19sEEyZPg9vjRcOkaYDL3SvsKyewyx0FODcETHf3GVio2fBIoQBQREZ9ACgiIiIiIiKVi8EbqwCXNHdgaUsLYrG4+Z0DT3icWYSmbwxPVRjhkB+OQA3W2HhLrL7W2qbJLysKgwE/PP5QT9i3MoGdqYCMx82AH3wmaxg93q+qCkeqlQ0A1QegiIiIiIiIiIiUjcFa0O/DtPEe1FQFsLytAx2xODpjcSTTKYxfeyN4a+uRcXiw2hozMHX6dPh8QdPk1+Vym7Aw63SZ5sR2YBcsM7DjcxgkjtSmvquKAkARGXbZdArZ0qvRRUREREREpMJEAh6E/TVIpDJm5N5MJo0t9j0E4fFTEQpHTEDHZsF2dZ7T60NdpGZEV+eNBAoARWTYfe2c3yASDg/3bIiIiIiIiMgqwMFDOIrxVwYe0VcGlwJAERl2wfqJpvRbRERERERERAZfbvwqIiIiIiIiIiIio4wCQBERERERERERkVFMAaCIiIiIiIiIiMgopgBQRERERERERERkFNMgICIybCyLg74DbW1t2goiIiIiIiIifbA/N9ufo0ulAFBEhs3y5cvNv1OnTtVWEBERERERERlAe3s7qqurUSoFgCIybOrq6sy/c+bMKesAJuV/c8TQde7cuYhEIlqNQ0DrfHhovWudjwXaz7Xexwrt61rnY4X2dekLK/8Y/k2aNAnlUAAoIsPG6ezqhpThn4Koocd1rvWudT4WaF/XOh8LtJ9rvY8V2te1zscK7etSyMoUzmgQEBERERERERERkVFMAaCIiIiIiIiIiMgopgBQRIaNz+fD5Zdfbv4VrffRTPu61vtYoX1d63ys0L6udT4WaD/XepfRxWGVO36wiIiIiIiIiIiIVDxVAIqIiIiIiIiIiIxiCgBFRERERERERERGMQWAIiIiIiIiIiIio5gCQBERERERERERkVFMAaCIDJubb74Zq6++Ovx+P7bYYgs899xzY3Zr/O53v8PGG2+MSCRibttuuy3++9//9nrMRx99hAMOOADV1dUIh8PYZpttMGfOnJ6/JxIJfO9730NDQwNCoZB57Lx583pN480338Tuu++Ompoa1NfX49RTT0VHR0ef85VKpXDBBRdgo402MtOcNGkSjj/+eCxYsKDX477zne9gzTXXRCAQQGNjIw488EDMnDkTlW611VaDw+FY4XbGGWcUvey33nordt55Z7Pd+NyWlpYVXueTTz4x64Tbho/bfvvt8dRTTxU9n1y/nPb111+/wt9eeukl7LrrrmYeuV05L7FYDJXi2Wefxf7772/WH5fhoYce6vV3jkV2xRVXmL9z/+H8f/DBB70es2jRIhx33HGYMGGCWc7NN98c999/f8/fZ8+ejZNOOskcTzgN7oscYTyZTPY85o9//GPBbc3bkiVL+l2GgdZxqe+r4V7nxe5b9vbZe++9C06Hx5hp06aZY/jEiRPNNsp/f9jrnsc3Po7b8Mwzz+x3/j///HMcfPDB5ljC98sRRxyBxYsXl7S9K3G9c5/gsk+ZMsXM93rrrWeO/bmKOY7nPnbTTTc1r/X222+v9Hov5lhW6Jh54YUXYjhcddVV+NrXvmbOh+PGjcNBBx2Ejz/+uNdj/vGPf2DPPfc067Ov9VTMe7yY5S50bPn973/f7zIUc+6stONLMev9xBNPXGFd8JrF1tTUZPbzddZZB8Fg0BxHzjrrLLS2tq7wev/5z3+w9dZbm3XE7XjIIYcUnK/ly5eb91Zf+24p27zSjjHFrPNiji8DnUuffvrpPs+Tr732Ws963muvvcxxjiMET5061bxuW1tbv8sw0GtX2vFloGvzYq8RizmXDnSNWO46L+Z8srLXpzLyKAAUkWFx77334uyzz8bFF1+Mt956CzvuuKM5MeYGWmMJL9h+8Ytf4PXXXzc3XpTyhGwHIfxAvMMOO2Ddddc1F2jvvPMOLr30UvPBzsb1+eCDD+Kee+7B888/by4G99tvP2QyGfN3XpTstttumDFjBl555RU8+uijZvq8UO9LNBo1Hz74WvyXH6Z4scCLiFwMcO+8804TUj722GPmQmePPfboee1KxQvahQsX9twef/xxc//hhx9e9LLzcbwwu+iii/p8nX333RfpdBr/+9//8MYbb5gP7dw2vCAeCC8Uub144VfoAwxfm+v61VdfNcvDi0Kns3JO752dndhkk01w0003Ffz7Nddcg2uvvdb8nfPPDwf8sNve3t7zGH5o4Iedf/3rX3jvvffMB8AjjzzSHDuIH5iz2SxuueUWs09fd9115oN37jbh43O3NW8MBnbaaSfzgaovA63jct5Xw73Oi9m3bAwG+YGlkF122QX33Xef2TYPPPCAOU4ddthhvR7DbcvjPD/Ecb08+eSTZr33N+9c13xNvl9eeOEF86GbwRq3cbHbuxLX+w9+8AOzf/zlL38xx0r+zg9n//znP4s+juc6//zz+9x2pa73Yo9l9JOf/KTX++iSSy7BcHjmmWfMlzUvv/yyOXbzGMt9h9vBxp/5gZbn174UexwtZrl5Hsx9zAknnNDvMgx07qzE40sx6524TnPXxSOPPNLzNy4Xb7/61a/MMZ1hNZeNoVsuHld4/P/Wt75lrnt4PDjmmGMKzhefy7CmGANt80o7xhSzzos5vgx0Lt1uu+1WOE+efPLJJpjbcsstzWO4jnh9ymnwmojb7oknnsBpp53W7zIM9NqVdnwZ6Nq82GvEYs6lA10jlrvOizmfrMz1qYxQlojIMNhqq62s0047rdd96667rnXhhRdqe3Srra21br/9dvPzkUceaR177LF9rpuWlhbL4/FY99xzT8998+fPt5xOp/Xoo4+a32+55RZr3LhxViaT6XnMW2+9ZfFU8Omnnxa93l999VXznC+//LLPx7zzzjvmMZ999tmI2p7f//73rTXXXNPKZrMlL/tTTz1l/tbc3Nzr/qVLl5r7n3322Z772trazH1PPPFEv/Mzb948a/Lkydb7779vTZ8+3bruuut6/X3rrbe2LrnkEmuk4DI/+OCDPb9zPU+YMMH6xS9+0XNfPB63qqurrd///vc994VCIeuuu+7qNa26urqe90ch11xzjbX66qv3+fclS5aY90z+dPMNtI4H6301VOu82H2L3n77bWvKlCnWwoUL+5xOrn/+85+Ww+Gwksmk+b2pqckKBAID7ue5HnvsMXPcam1t7bmP0+HrP/7442Vv76FWaH1tsMEG1k9+8pNe922++eY9+1cxx3HbI488Ys6ZH3zwgXkt7nO2ctZ7Mccy6mtfqQR8T3O+n3nmmRX+NmvWrBXWUynH0WKWu5j3yEDyz52Vfnzpa72fcMIJ1oEHHljSdO677z7L6/VaqVTK/M5/eYzq7zhvu/nmm62ddtrJevLJJ/vcd1f23FlJx5hC63yg40s551Iey7n/5U833w033GDOFf0p5rUr+fhS6Nq82GvE/s6l5V4jDrTOizmfrMz1qYxclVMiICJjBqs5+C0Tv73Mxd9ffPFFjHX8Zo7f1vGbXTY34LfQbAKz9tprmwoOViuxOUxuEwKuTzZHyF2nrAzZcMMNe9YpmwJ4vd5eVQ1sJkL8ZrBYbKLDbzHZZKYQzjcrGth0hs0URtJ+yW/Ov/3tb/f5Le1Ay14Im2yxKc5dd91l1g2/aWVVwfjx4031R1+43fmN+XnnnYcNNthghb+z2SorQrg/8Ft7To/VbKVsy+E2a9Ys8y1z7n7L5i1cjtxjAatfWTXMZmNcL3x/cH9mk62+cFvV1dX1+XduDzY9y69YK3UdD9b7aigNtG8RqxuOPvpoU83GqsyBcNvcfffdZj15PB5zHytV+Frz58837wFWU7A579y5c/ucDtcn32PcD2ysdOb67W99DrS9KwH3Y1ZwcH0wL2IzK1Zz2JV5xRzHic2hTznlFPz5z382+3C+ctZ7Ka6++mpzXGOlyJVXXjnsTa9tdvPRUvaDUo6jxSw3q8jYlI7NNVkxZletFqPQuXMkHF/6Wu9srcD1ymsX7q8DdbXA6bAJotvtNr+zqor7MJd9s802M90MsKVIfhcRH374oaka4zG9mOr3cs+dlXSMKbTOBzq+lHMu5fSWLVvWb8UpKzlZ/cZ12J9iX7tSjy/51+bFXiMOdC4t5xqxmHVezPmk3OtTGeGGO4EUkbGH30Dx8PPCCy/0uv/KK6+01l57bWusevfdd803pC6Xy1RA/ec//zH3298YBoNB69prrzXf/l911VWm0ubpp582j7n77rvNN+f5dt99d+vUU081P7PSx+12m2+xE4mEqRI55JBDzLR//vOfFzWPsVjM2mKLLaxvfvObK/ztt7/9rZl/To+VKSOt+u/ee+816577Z6nLPlDVDKut+FxuM77GpEmTClai5OI24fazqxHzvxl/6aWXzOvxG/Q//OEP1ptvvmmdffbZZj/45JNPrEqU/803jwG8L3+dn3LKKdYee+zR65vsPffc0zyW+3AkErH+7//+r8/X4b7Hx9x22219Pmb99de3Tj/99H7nt5h1PBjvq1WpUFXSQPsW8bhx0kkn9TsdOv/8882xiX/fZpttrGXLlvX8jccpViCss846puKA6/Mb3/iG+Z3rqq/KFm47VuN2dnZaHR0d1hlnnGGmbx/LytneQ63Q+uIyH3/88T37Mfej3IqYYo7j3GZ77bWX9dOf/rTPyrZy1nuxxzKeg3jeYaUa13dDQ0Ov/WS4cL3sv//+1g477FDw731VABZ7HC1mublNXnzxRfMav/rVr8z7wt5O/env3Fnpx5e+1jurjh5++GHrvffes/71r39Zm2yyialQY4V3ITxuTJs2zbr44ot77vvb3/5mlpP333///dbrr79uHX300VZ9fb21fPly8xhOb+ONN7b+/Oc/D7jvrsy5s5KOMX2t84GOL+WcS/fee29zK+Soo44ylcacFueH10j9Kea1K/H40te1ebHXiMWcS4u9RixlnRdzPinltWX0UAAoIsMWAPJCOdfPfvYz8wFlrOLFG5v0vPbaa6YpNC982LzLXl+88M3Fkz8vBvo70e+2227Wd77znZ7f+bjx48ebkzwff+6555rfr7766gHnj01B2KRns80269U8L/fijhfPbJLCeWPTk4EuCCsJA6f99tuvrGXv74MHL9YPOOAAcxH9/PPPW2+88YYJnti0acGCBQWnxQ863C65wVh+SGOHZz/60Y96PXejjTaq2Kb0fQWA+evh5JNPNh8UbGeeeabpNoBNUtiU5oorrjAX4rwwz8d1NmPGjH4/NPDYw9fleu5Pset4Zd5XQ73Oi9m32JSX67C9vb3P6djYhOjjjz82H+S23357a5999ukJFvmlDp/HZr25AV+hJq25+Pg11lij5wMJuz/g8aRQYFvM9h4OhdbXL3/5S/MlFwMRfsD9zW9+Y1VVVfU0bS7mOM5mX9ttt52VTqf7DLbKXe+2YkIUG4MZPjY3+B0O3/3ud81+PHfu3JICwHKPo8UsN0NAhhwDGejcWcnHl4HWu43HeIbSDzzwwAp/4zmVTXIZbNvdB9jLzXXMZtA2Bn68NrK7iPjBD35gukgpZd8tdZtX2jGmr3U+0PGl1HMpp89jBvf1Qvjl9EcffWQ99NBDRX2hVsprV9Lxpa9r82KuEYs5l5ZyjVjKOi/mfFLO9amMfAoARWRYTqa8kP3HP/7R6/6zzjrL+vrXv64t0o0VG/yWjuuL35bmVxKw8oYfBMnu94bVAbn4zfhll122wjpdtGiRuSBhdQ0v8Nj3Tn94cXPQQQeZ6RVzIcZ5ZvXDX//61xGxPWfPnm3WAy+qyl32vj548GI3v08z4kUhK3UKYRhjhx/2jdPmdHjhT1988YW5z658sB1xxBHWMcccY1Wi/Avfzz//3NzHCoxcvCBlJYNdecHHsBIm//2RG27bH9T4Aei4447r1WdWvm9/+9vWpptuOuD8lrqOS31fDcc6L2bfYvVdX49hP1t94QfG3C93WF3D3/M/qLJPqVtvvXXAeWe4aL+fGHiwCqqc7V0J6z0ajZoAhFVRuRgq2GF3McdxfsjkdsjfNvzXfs+s7HovJQBk9Qgf+/LLL1vDhcEC+8Li+7UvfQWA5R5Hi1lufqDmY3hcKFZ/585KO74Us97zz3m5/b3a/Y1tu+225nie/4Xh//73P7P+nnvuuV73M0S66KKLzM+sLMx9P/Bn+/1Q6Nqn1G1eaceYvtZ5MceXUs6lxH7/Ghsbe4WyfeE2KvRlnq3U166k40tf1+bFXCMWcy4t5xqxmHVezPmk3NeWkU19AIrIkGN/Nuxbwh5x1cbf2R+LdOFnSLv/H/YnxNHTcrFvl+nTp5ufuT7Z71buOuXoae+//37Bdcr+Paqqqkx/LOxfi6Ou9oV9iLD/qE8//dSMOsY+Q0qZ/5GA/S6xPyCOhjYYy56L/b9Qft9E/L2v/qHYP9u7776Lt99+u+fGvlvYZxtHiiSOysf7+tsvKh37umKfOLn7Lfv74YiH9n7b1/pzuVy91h/7PWJfQptvvrnZnn31BcVR8Dhybf5ok4WUuo5LeV8Nl2L2LY4cm/8Y4kiYXLd96cq9uvotI46+Srnrj/0/sU+pYvZR9qXGvpQ4OiH77codXbHY7V0peCzhrb/9uJjj+I033mhGQ7W3iz2yKvc59pc1GOu9FPYInuyfbahxf2Ofe+wLi/sIjyelKvc4Wsxy8zE8DpTSZ2x/585KOb6Us96XL19u+qDMXV9tbW2mfzJe47CvOS5TLr4f2Bdo7rbhe2j27Nk924ajBOe+H26//XZz/3PPPWdGzV2ZbV5Jx5iB1nkxx5diz6X263GZjz/++J4+XQeaP+rrmq+U166U40sx78+BrhGLOZeWc41oz0d/67yY80m5ry0j3HAnkCIyNrF/GH5beccdd1gffvih6X+FfWywEmssYlMUjsLFKgU2h+C32/xWzu4fhdWSXF+s3mBTBDbt4DeJud+Mc1RlfjPMb/RYUbXrrruab8ftpmLE57HEn032brrpJtOXCJuU5WIzbLs6k6PwsRqL02WTDTY/sG92X1Ks4mJfRGxayJHPWP3DKhX2r7N48WKr0vFbffYxdMEFF/S6v5hlJ/7OqhL2V2OPpsbf7T6KWMXEPovYbxOnw3XPJlzcnvy90HovpFA/bfydTcz+/ve/m/2Co/35/f6K6n+RFStcH/bIlXY/lvYoeawIYTMgLjv7i2JT94kTJ5rKEPvbdX4bveOOO1qvvPKKWTY2reO36nZfPHYTLe7zrBjI3Vb5OHof11H+t+LE53I78HVKWcfFvK8qaZ0PxginXEdcbk6Xx21W67BPKo6indvPF48F7PuLze64fdnMnk2X7KqSQuucFWzsp4vrmFU6PJacc845PX8vZXtX0npnxQfXBSvsWMFz5513mn2JI5iWchwvprKtnPU+0LGMx3Z7mTj/7DeV/UXxODkc2FSNxw72GZa7D7AaysZ55/zyWMFl4rUHf8/dVwZ6jxez3Gx2yfMz1zWfx3XIabJlgy1/nRd77qy048tA653vgx/+8Idmebh/cn9nlR+bFdrHdf7LZr9sdsv1lTud3H2dFVR8Hpuzz5w501S0sZK10PG7r+rVco7rlXaMKWZfH+j4Usy51MbjD9cjr8/z8bE8RnNf5/bl73xddgHR1zov5rUr7fgy0LV5sdeI+QqNAjzQNWI567yY80mx16cyuigAFJFhw46v+cGTfVSwzxv2fzNWsUmivS7Y5IJNDPI7R2ZYygsoXtDxBJ7fXJXNZ9g8hB8e+AGBH/jmzJnT6zFsxsK/83XYDCC/g2j74oQXjrkfLgvdeJFpXyiz/xBelPOigRcbbEbDi/WRgB8suDy88MlVzLLT5ZdfXvAx9jok9h3DPga57sPhsBks4ZFHHun1evnPKTakYTMNrnM2G+OHrPzmUsPN/kCWfzvhhBN6+qDhOpwwYYLl8/lMNwC8yM3F/rF4gcp9jMuZv+9yvfW1rfJxHfXVtM/e5rnbt5h1XMz7qpLW+WAEgPwwtMsuu5jl5nZbbbXVzIcNfgjJxaZFPL7V1NSYxx588MG9jkuF1jnDeDb55fFkrbXWsn7961/39CtY6vaupPXOD4Ynnnii+VDL4zg/rOUvWzHH8WICwHLW+0DHMoZQDG0YRNjzz+dwsJbh0Nc+kHsc7Wtf4XwX+x4vZrn/+9//mm4F2Ocap7Hhhhta119/vQkJ+lrnxZ47K+34MtB6ZyjF8x2vZbhc/IKN74Hc/a+v9wpvXE82BkcME7mOeO5k/2X5zUgHCgDLOa5X2jGmmH29mOPLQOdSG7+Is7uYyccve7i+7PcDj9E8Zg+0zgd67Uo7vgx0bV7sNeJA59JirhHLXefFnE+KuT6V0cXB/w13FaKIiIiIiIiIiIisGpXdYYqIiIiIiIiIiIisFAWAIiIiIiIiIiIio5gCQBERERERERERkVFMAaCIiIiIiIiIiMgopgBQRERERERERERkFFMAKCIiIiIiIiIiMoopABQRERERERERERnFFACKiIiIyKjx9NNPw+FwoKWlpc/H8O8PPfTQkM6X9Lbaaqvh+uuvH9b9YDSsiyuuuAKbbrrpoM+TiIiMPu7hngERERERkaG0cOFC1NbWaqVLRXjttdcQCoWG7fVnz56N1VdfHW+99VavMPHEE080AarCchGR0UEBoIiIiIhUFMv6//buBNin8o/j+BPKEipki7TYQ/tCJMqapWQZSibKSFnaGI2lKCrJtJniilImW6rLtURC1oTs+1oqS6aisj7/+Xybc+bc63J/V5n8T+/XjLl+5/zOOc95znNM99OzeHfs2DGXLduZ+U/VwoULn5HzAqdy5MgRd+65556w/eKLL451xR0+fNidd955/3YxAOA/jyHAAAAAMXH77be7Tp06ua5du1oPt0KFCrmhQ4e6gwcPugcffNDlyZPHXXnllW7KlCmpjluzZo2rX7++y507tx3TunVrt3fv3nD/1KlTXdWqVd2FF17o8ufP7xo0aOA2b96c6hf8xx57zBUpUsTlyJHDhjQOGDAg7F2koZjLly8Pv69eRdqmYZrR4ZrTpk1zN9xwg8uePbubO3euBYEvv/yyu+KKK1zOnDnd1Vdf7caPH5+q7CkpKa506dK2v0aNGna9jESHAAfl+/jjj+34XLly2XUWLFiQ4TmSkpLcPffcY8eUKlXKffbZZ+F+BZjt2rWznlUqW5kyZdxrr72W6hzqYXX33Xe7V155xepOdfvoo49aUBTYv3+/e+CBB+x56jr16tVzGzduDPdv377dNWzY0ParF9lVV11ldZLosz1+/Lh76aWXXMmSJa3eL730UvfCCy+E+1euXOlq1qxp96DytW/f3h04cCBT97B7924ro86h+vjwww/THcqqa6sMRYsWdZ07d3b/tAkTJlj96Bpqo4MGDQr3vfHGG65ixYrhZ7UPPeO33nor3FanTh3Xo0eP8HNycrK7/vrrrc2rjT733HPu6NGj4X4d//bbb7vGjRvbs3n++ecTGgJ8OnXxzjvvuOLFi1sbadas2QlDn0eMGOHKlStnZS1btqwbMmRIuE/PRK699lors/4dURnee+899+mnn9q26Pv6/fffuxYtWlib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" width="854"></p>
   <p><img height="480" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABQAAAALQCAYAAADPfd1WAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjgsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvwVt1zgAAAAlwSFlzAAAPYQAAD2EBqD+naQABAABJREFUeJzs3QWcW9W6xuEvybjWvZR6KcW1WIuXYsXd4eDuUvTgh+J+Ds5Fi7sUdytWpEDdddyS7Pt7V9khk2a0U5oZ/s+9uW12bO+194Q7b79vrYDneZ4BAAAAAAAAaJOCq3oHAAAAAAAAAKw8BIAAAAAAAABAG0YACAAAAAAAALRhBIAAAAAAAABAG0YACAAAAAAAALRhBIAAAAAAAABAG0YACAAAAAAAALRhBIAAAAAAAABAG0YACAAAAAAAALRhBIAAAAAAAABAG0YACAAAAAAAALRhBIAAAAAAAABAG0YACAAAAAAAALRhBIAAAAAAAABAG0YACAAAgCZ74IEHLBAI2Jdffllr+8KFC23DDTe0vLw8e/PNN1fayL7yyit26aWXJn1M+3XSSSet0PvPmzfPzjvvPFtrrbXcsWRlZdnAgQPt1FNPtcmTJ8eep33Q57VFOq7G3N59990V/qzy8nI3li3xXsmMHDnS7Wu/fv3M87zlHn///fdjx6Nru62YOnXqcueroKDA1llnHbvpppssEoms6l0EAPxN0v6uDwIAAEDbNnPmTNt+++1dePbWW2/ZpptuulIDwNtvv73OEHBFfP7557bLLru4oEhB4vDhwy0jI8N++eUXe+SRR2zjjTe2JUuWWFv3ySef1Lp/xRVX2DvvvGMTJkyotX3o0KEtEgBedtllsbBuZcjPz7cpU6a4/d92221rPXbfffe5YKy4uNjaopNPPtkOPPBA9/elS5faCy+8YKeffrrNmDHDbrjhhlW9ewCAvwEBIAAAAFaYquK22247q6mpsffee89VzrVGCoB23313V/H38ccfW69evWKPKZg69thj7emnn7bWQKFaTk5Os1+fGOB27tzZgsHgSg12V6bVVlvNhYAK++IDwJKSEnvqqafsoIMOsnvvvddam4qKCne91leJqmOPP2+jRo2yH374wR577DECQAD4h6AFGAAAACtk4sSJtsUWW1haWpp9+OGHy4V/hx9+uGuj/e2332z06NHu771797YzzzzTqqqqYs9T+2eyllK/jdFvzdT7qfpP4lsb9bx4Dz/8sK2xxhouBFPL40svvdTgsSgAmjt3rl133XW1wr94e++9d73vEY1G3euHDBlimZmZ1qVLFzv00ENdhWS8b775xlUa6nE9r0ePHrbzzjvHnpd43PG0Pb760W9F/vrrr93+tW/f3vr37+8eUyXjHXfcYeuuu65lZ2e7x/ScP/74w1ZUdXW1/fvf/44dq0LCI444whYsWFDreaq6U4DasWNHtw8KpPbaay8XUuo49TpRFaB/PnWeW9qRRx5pzzzzjKuC8z3++OPuz/3333+55+ua1fGo/VvXUc+ePW3XXXe177//vtbz/GtXgdqFF17ozqUqChWKq3K0MfSzo2BSIaU+a7PNNrOXX345aev9G2+84Y5F46bnxv8cNVZhYaGlp6c3+dpVJah+1lU9mEj7pHNcWVnZ5P0BAKxcBIAAAABoNoUWCnYUFOjvmmMtGVUG7rbbbi7geP75511QcOONN9q1117b5M8cO3ZsLIRTm6p/6969e+w5Ck5uu+02u/zyy238+PHWoUMH22OPPRoMvRSshEIhF/I01/HHH2/nnnuua4dWq6UCk9dee80FOpojUcrKymLt0gozNV+i5mRTMKaKtObac889bcCAAa6i7a677nLbVLV42mmnuTDqueeec2Hgjz/+6PZHn99cCotULXnNNde49lKNuf6uY9E1oco0UcCnYFNt1Kq+01joebm5uS5A1HnTNjnqqKNi51PnuaUp5NP5VVDn+9///ueuJwV2iWbPnu0CLe2v9lHnSuHXJptskjTYu+CCC2zatGn23//+1+655x5XGatrqaG59lQ1u80221hRUZHbH+2fgkC99oknnlju+fr5UXinkFsVqYlBXrJzFQ6H3W3RokWx83DIIYc0+drV9aQxuPvuu2u9dvHixS5M1TlURSIAIMV4AAAAQBPdf//9WknB3QoLC7358+fX+dzDDjvMPe/JJ5+stX306NHe4MGDY/ffeecd9zz9GW/KlCluuz7Td+KJJ7ptyWh7165dveLi4ti2uXPnesFg0Lv66qvrPa4hQ4Z43bp18xrrkksuqbUfP/30k7t/wgkn1HreZ5995rZfcMEF7v6XX37p7j/33HN1vney444/Rn124n5cfPHFtZ73ySefuO033HBDre0zZszwsrOzvXPOOafR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tZANACB1EQACAAAAABrtm2++cRW3xx57rKskbUw7NQBg1SIABAAAAAA0mlrQ1c6tlZ3V/q35OwEAqY0AEAAAAAAAAGjDgqt6BwAAAAAAAACsPASAAAAAAAAAQBtGAAgAAJrs8ssvt6FDh1o0Gq21vbi42K655hrbZJNNrF27dpaenm5du3a1UaNG2f/93/9ZVVVV7LlTp061QCDgbo8//vhyn3HppZe6xxYuXBjbNnLkSBs2bFjSfdLz9Hy9riE33XST7bnnnta3b1/3Gr1vMg888EBsHxNvmv+qIf/9739tzJgxbr6s7OxsGzBggB1//PE2Z84ca6yvv/7atttuO8vLy3Njqv3+448/LJXEj0soFLL27dvbOuus4xYI+PTTTy2V+OdU119L0DV/5ZVXumtI86DpPK211lp27bXXWmVlZb2vfeutt2LjFn+dN+TDDz+00aNHu3HWdTVw4EC74oorGvXa+fPn2+GHH26dOnWynJwcGz58uL399tvW2nieZ/fff79tvPHGlpubawUFBbb++uvb888/X+dr5s2bZx07dnTj/fTTT7fo/lx11VWNXghDP/8XXXSRG3udB+37BhtsYPfcc49FIpHlnl9aWmqnnXaa9ejRw7Kysmzddddd7jtTrxs3bpz7ru3Vq5c7t2ussYadd955tnTp0uXes67vNX1/N0ZJSYmdc845tsMOO1jnzp3r/O5t6n61xHhpgRJ972q89HlDhgxx/80qLy9v8Hs9/qbv7RX5uamoqLBBgwa59/rPf/7TqGOdOXOmO9cjRoxw3/d6rfa3Ic35rMYeV1O+4zRmDY2rPk9qamqsf//+7r/HAP4eBIAAAKBJZs+ebdddd537hSoY/Ov/lZg8ebKtt9567heFLbbYwh566CGbMGGC3XrrrdazZ0878sgj7d///nfS97zwwgvdLwN/l7vuusumTZtm22yzjfvltSEKGj755JNaNwUJDbnkkkvcL0sKB1577TX3C/NLL73kfnlVGNGQn3/+2f3SVV1dbU8++aTdd9999uuvv7qJ9xcsWGCpZO+993bjonBK4cShhx7qwj/9Qnnqqadaqth5553dfnbv3r1F3m/69OnuF1iFTwokXnjhBTcWCkN22WUXF1Qlo1DnmGOOcSFFUyhIVzhQWFjofsZeeeUVO/fcc+v8nHgK4Lfddlv3C/7NN9/swjI/oH/vvfesNVGQrpuOR2P+1FNP2YEHHhgLeZI58cQTXYC2MjQlAPzqq6/cudO+68/x48e7c6rj0TWRSKH/gw8+6L5PXn31Vdtoo43sgAMOcNdCfACka65Pnz7uetR1offSNalVevV4XT+z8Tf93DbGokWL3HvrmlLYVpfm7NeKjNekSZNss802cwG/Pk/ft/vvv7/775XGLP47IP6WbDyeffbZFfq5GTt2rJWVlVlT/Pbbb/boo49aRkaGC/kbqzmf1djjasp3nMYscWz9m65bBYD+9aJ/ILz44ovdudH1BOBv4AEAADTBOeec4/Xs2dOLRCKxbTU1Nd7QoUO9du3aeZMmTUr6uqlTp3rPPvts7P6UKVP0W4O30047uT9vueWWWs+/5JJL3PYFCxbEto0YMcJbc801k76/nqfn63UNid93vZ/eN5n777/fvecXX3zhNce8efOW26b30nteccUVDb5+n3328Tp16uQVFRXVGsf09HR3HlKFjufEE09cbns4HPaOPPJI9/gdd9zRIp8VjUa98vJyL1WUlpa6W6Lrr7/eHfcHH3yQ9HUar/XWW8+76KKLlrvO6zJz5kwvNzfXO/7445u1r7fffrv7rI8//ni5n92NN97YW9nKyspa5H30PaLjeOKJJxr9mqefftrLy8vzHnzwQffap556ymtJOi+HHXZYo567ePFir7q6Ouk1oX2bPn16bNvLL7/stv3f//1freduv/32Xo8ePdzPmOjPhQsXLveeOk69/uGHH27Uz2xTfg51a+i7t6n7taLjdeGFF7ptv/32W63n/utf/3Lb9V7J1Dcezfm5+eyzz7yMjIzYcer7oDHi/9vk/7dC/x2qT3M/q7HH1dzvuHg33HCDe+75559fa3tVVZXXoUMH78orr2zUPgNYMVQAAgCARlMl2v/+9z9XaRNf/ad/9VflhSr51N6VjCpAklWKqApvxx13dC2Maiv7O8Tv+8rUpUuX5bap+k9tsjNmzKj3teFw2FWv7LXXXq7lLX4ct95661h1Sn3UnnX++ee7VmdVlKgSU1VQia13attSJYeqFFXlobZStc2p4nBF6Dhvu+021152/fXX19qvM88807UyqpKtQ4cOrlIwWfumKkZOOukkV7WpayszM9NVQ6maRJU88dSWpud/8cUXsW3PPPOM2/b999/X2QLst5brdaquVCtcv379XDtkYpt7IrWf6pZIramS7Dx/8MEHrpJGLeIao8bS81Xlo4q/5tA1M3jwYDfWvrS0NDv44IPt888/t1mzZjX4Hk888YRr+1QFpa4Tv50zsfpIbX6qftW46/n5+fmu2ij+nKqyVvuj99lwww1dxaiyGF0rumb1en0/qCoqnqqVdM3uu+++jTruxYsXu+te1cmrrbZaI0er8depjkfHr+vSb3Osa1oBUeu2qp/qumbUBhp/zjQO++yzT63nHnHEEa4a+7PPPnP3dR0lq0qu7zpcEf5xNqQl9qsp4+U/T+crntpp9b2v78GV/XOj/06q4l3XnK7rlfnfphX5rMYeV3O+4+K988477jtL3wOJXQA6H/vtt5/7PmxMFTOAFUMACAAAGk2/bKpVRwFUvDfffNP9udtuuzVrNDWXkOZAiw+JUonCMf0iqwBA7Xg//PBDs99LrVWat2rNNdes93m///67a49be+21l3tM2xSK1DfHnH6ZUuCq+aAOOeQQe/nll+2MM85wIYVClfj5GOXbb791Ycfpp5/uAg59xlFHHWXvv/++rQiFO5rDcMqUKbFf1PXZCmXOOuss1zb52GOPubZxja1a/BLpOXfeeadrF3v99dddSKf31L75reNqqdZ50ef516M/z57a2hQO1kdzOh500EHul1+1uO20004uPH3kkUeaddxqf5fE86xzqnHVPF8KW5tCx6trUK3hCqX0y7pC5uOOO87N09UQjU9d15P8+OOPDb6HWv3Vmqh/CFBgrONQe/quu+6aNJzQd4KuN11Tl112WewxhdsKNBWy6vwr/Fegq2vwo48+csGxQgH9w4JCcD8cUDCudkJNN6C55RSI62dTga2u9WQhwimnnOICRYWOTdHY61T7o+tO4+K3O95xxx3WnGtG51RzucWfM4Ws2p7snDX0XVTXdShqIdZ+K1TXP0wokP271LdfKzJehx12mAv71B6suVJ1Xelau/vuu11IlizIaumfG7W0KhBuaF5Ohdjx8ww2x4p81op+HzTmHKp9WAGf5n/Uz0+ygFNhuabkWJH/rgJopBWsIAQAAP8g1157rWvjmTt3bq3to0aNctsrKytrbVeLmFqK/JvfrhbfAuy3Kx100EGujW7OnDkrvQU4Xn0twK+++qprKXvxxRe99957z7vtttu8Xr16uf2cOHGi11TFxcXeGmus4fXu3dsr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BQAAAAAgZc2YMcN69erV5NcRAAKAmav8879MCwoKGBMAAAAAQMooLi52RSv+765NRQAIAGaxtl+FfwSAAAAAAIBU1Nwpq1gEBAAAAAAAAGjDCAABAAAAAACANowAEAAAAAAAAGjDCAABAAAAAACANowAEADijB8/3t5++22rqKhgXAAAAAAAbQKrAANAnClTpticOXNs9uzZtvfee1t2djbjAwAAAABo1agABIA40WjUysrKbOLEifb6668zNgAAAACAVo8AEADidOvWzTp37uyCwOeff56xAQAAAAC0egSAABDH8zzLzMx0IeCMGTMYGwAAAABAq8ccgAAQp7Cw0IWAWgQkEokwNgAAAACAVo8KQACIU1pa6gLAjIwMCwQCjA0AAAAAoNUjAASAOOnp6bGFQBQGAgAAAADQ2hEAAkCcqqoqC4fDsT8BAAAAAGjtCAABIE5ubq6rAFQAqFZgAAAAAABaOwJAAIizaNEiq66utuzsbOYABAAAAAC0CawCDABxOnTo4CoAy8vLLTMzk7EBAAAAALR6VAACQBx/4Q+1AodCIcYGAAAAANDqEQACQJzCwkK3ErAqAAkAAQAAAABtAS3AABBn4cKFbu4/VQLm5OQwNgAAAACAVo8AEADihMNh96cWAhk4cCBjAwAAAABo9QgAASBOTU2NBYNBtwDI1ltvzdgAAAAAAFo95gAEsFKNHDnSTjnlFDvnnHPcCrvdunWzSy+9NPb49OnTbffdd7e8vDwrKCiwfffd1+bNm1frPe68807r37+/ZWRk2ODBg+3hhx+u9bhadvWcnXbaybKzs61v37721FNPNWt/Nf+f3mPttdd2+w4AAAAAQGtHAAhgpXvwwQfdqrqfffaZXXfddXb55Zfbm2++aZ7n2ZgxY2zx4sX23nvvuW2///677bfffrHXPvvss3bqqafamWeeaT/88IMde+yxdsQRR9g777xT6zPGjh1re+21l3377bd28MEH2wEHHGA//fRTk/e1d+/etuGGG9ouu+xiWVlZLXL8AAAAAACsSgFPv4EDwEqiKrpIJGIffPBBbNvGG29s22yzjW277bauam/KlCkueJNJkybZmmuuaZ9//rlttNFGtvnmm7v799xzT+z1qhIsKyuzl19+edkXWSBgxx13nKsC9G266aa2/vrr2x133JF0v6qqqtzNV1xc7PahqKjI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s7ffftveeeedlfK5b731ls2ZMyd2u/32221Vys7Oti5duqzSfUhF1dXVDT5n5513tqKiInv99deb/gFDVjerrjKrKjc7al/LPvlQyy1ebPlLy62HhezYnce4gBgAAAAAgNaCALAVGDdunK211lqWm5trvXv3thNOOMFKS0uXq9R66aWXbPDgwZaTk2N77723lZWV2YMPPuiqy9q3b28nn3yyRSKRWu9dUlJiBx54oOXl5VmPHj3s1ltvrfW4gritttrKLXowdOhQe/PNN5fbv3PPPdcGDRrkPrdfv36u+qqmRvOnLfPtt9/a1ltvbfn5+VZQUGAbbLCBffnll3Ue7+OPP2477LDDcgst6PiPOOIIV9lVn++//9622WYbF6B17NjR/vWvf9Uar7roud26dYvdCgsLY9WBEydOrLPqUH/qvsLJDTfc0I3DZpttZr/88kut93/hhRfc4zquTp062Z577hmrwJs2bZqdfvrpserDuirw7rzzTuvfv79lZGS4c/3www/Xelyv/e9//2t77LGH24+BAwe6z20pL774ojt/Ogad68suu8zC4XDS5/pjp/Op8dBr1lxzzeWqNSdNmmSjR49212DXrl3tkEMOsYULF8Ye1/icdNJJdsYZZ7hx23777d32Sy+91FZbbTXLzMx01+4pp5wSe00oFHLv+dhjjzX5GAuGb2iWk20WieqNrFdevvXJK7Q1CtrbPkPXt6P2P6DJ7wkAAAAAwKpEANgKqA32lltusR9++MEFepofTy2y8crLy91zFLa89tprLmRRwPTKK6+4m4Kie+65x55++ular7v++utt7bXXtq+//trOP/98F0L5IZ/aJ/UeClM+/fRTu+uuu1zYl0jBnsIqBTk333yz3XvvvXbjjTfGHj/ooIOsV69e9sUXX9hXX33lArz09PQ6j/f99993QVkyCn0U8CUeR/w4qE1Ygac+76mnnnKVfQqQVja1LN9www0u3FS14pFHHhl77OWXX3Zjqcq0b775JhYWiuaq0/hcfvnlserDZJ599lk79dRT7cwzz3TXwrHHHusC0cSKSIVy++67r3333XcuBNP4L168eIWPT9V0aotW0KZzfffdd7vzfuWVV9b7urPPPtvts45bQeBuu+1mixYtco/pWEeMGGHrrruuGzddu/PmzXP7H0/Xvcb0o48+cp+r869rTH9XSK15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42yttday3Nxc6927t51wwglWWloaG50HHnjA2rVrZy+99JINHjzYcnJybO+997aysjJ78MEHXatv+/bt7eSTT7ZI5K+KOSkpKbEDDzzQ8vLyrEePHnbrrbfWenzy5Mm21VZbWVZWlg0dOtTefPPN5c7Kueeea4MGDXKf269fPxs7dqzV1Pw1N9+3335rW2+9teXn51tBQYFtsMEG9uWXX67Q2d120KZWnelZdTBsaVkZltO9wPJ6t7Nop3RLX6Oj7X/kIVw9AAAAAICURwUgACcYDNott9zigrwpU6a4APCcc86xO+64IzZC5eXl7jmPP/64C/X23HNPd1Mw+Morr9gff/xhe+21l22xxRa23377xV53/fXX2wUXXGCXXnqpvf7663b66afbkCFDbPvtt7doNOreo1OnTvbpp59acXGxnXbaacudFQV7CiEVIH7//fd2zDHHuG3aRznooINsvfXWszvvvNNCoZBNnDjR0tPTm3x2ozUR89I8CwQDLkjcZc2t7aNp39i0svnWLSffwhlm3dbqY7sfuI97HAAAAACAVBfwPM9b1TsB4O+bA3Dp0qWNWlzjqaeesuOPP94WLlzo7it8O+KII+y3336z/v37u23HHXecPfzwwzZv3jxX3SejRo1yIeJdd93l7uvva6yxhr366qux995///1d0KfQ8I033rDRo0fb1KlTrVevXu7x1157zXbaaSd79tln65yzUKHiE088EavyUxinysLDDjusUWNRVVXlbj7tjyofX91mnOWmZ1swI83SC/XnskJpLxy1ta7fzbK65Dfq/QEAAAAAaCn6nbWwsNCKioqaVYxCBSAA55133rGrrrrKJk2a5L5YwuGwVVZWuhZftQWL2m/98E+6du3qAj4//PO3zZ8/v9aoDh8+fLn7/srAP/30k6222mqx8C/Z8+Xpp592r1EAqdZk7V/8l94ZZ5xhRx99tAskt9tuO9tnn31q7Wuiq6++2i677LLltq9/z75WkJ/8yzSz01/HCQAAAABAa8EcgABs2rRprgpv2LBhNn78ePvqq6/s9ttvdyMTP89eYkttIBBIuk1tvQ3R8yRZEbL/mE+twaoaVFWg5iD85ptv7MILL7Tq6urYc9Re/OOPP9rOO+9sEyZMcHMJqoKwLueff777lxP/NmPGDLc9I5he5w0AAAAAgNaICkAAro1WFXU33HCDmwtQnnzyyRYbGQV4ifc1B6AoqJs+fbrNnj3bze8nn3zySa3nf/TRR9anTx8X+sWHlom0SIhummPwgAMOsPvvv9/22GOPpPuUmZnpbonKr//W0jKXVTx6pTVmJTVmwYBZx0zLvWRDC3TKatYYAAAAAACwqhAAAv8wqnbTAhnxOnfu7AJAzaG36667usDNn8OvJej9rrvuOjefn1b41fyCL7/8sntM7bpaVfjQQw91AaTaj+ODPhkwYIALCbX4yEYbbeReG1/dV1FRYWeffbZblbhv3742c+ZM++KLL9yCJE0VSAu6m1OYYcXzltqEBV9Z8R8VVnD5V1aRGbUOa3azHfbaxS1CAgAAAABAqqMFGPiHeffdd91qufG3++67z8aNG2fXXnutawN+9NFH3Rx5LeXMM890bcX6rCuuuMIFfTvuuKN7TBWHCvO0IMfGG2/s5vG78sora71+9913d1V9J510kq277rr28ccf29ixY2OPa9XfRYsWuRBRFYD77ruvaxdONsdfU2iuwSdnTrCq6mrrklZoHYszrdPidCudMMMeufoetxIyAAAAAACpjlWAASBuRaXZJ79lBX+2AD/26UtWsnCJ5WTl2knfjnPbHhp5iZUEqq0yJ2Ltd+pvh5xwFOMHAAAAAEjpVYCpAASAOnw5/TsLBtOtX25HC/z5P4MCPaxftMACC6rskxc+ZOwAAAAAACmPABAA6lBcVWSrZ3QyLxjSkiDutqhyqUUjAVst1MEW/75s5WAAAAAAAFIZASAAJOFFPauuDFsgGLDcYLZmTHC3rlkd3P1gOGBVReWMHQAAAAAg5bEKMADE8SJR86oi5i2qsrJwtWWmhSwU+OvfSsojFe5+RiBoFeEwYwcAAAAASHlUAAJAHG9ehXkLKs2inoXD1ba4slLlgO4x1QC2C7Vz9xdXVFqkqoqxAwAAAACkPCoAASDxn0XSghZol2FWHbAar9KKrNo9pFkAF9csttJgjdserlwWDAIAAAAAkMoIAAEgTrBbrgUzNeefWVpGwCJe0AKRv1p9A4F0C0Qq3PasbL5CAQAAAACpj99eAaAOWv23R2aOZaYtCwQlHA27+z0yqyxqWh0YAAAAAIDUxhyAAFCH9LSAa/7NC2T8uQawWY+MTu5+dcgslMFXKAAAAAAg9VEBCAB1yM7IcH/Oj5Sa52YADNj06jlWFYy6CQGzM5c9DgAAAABAKqN8BQDqkB5MsyU1pRay8J/1fwoFM7VGiC0JVll2fg5jBwAAAABIeVQAAkAd8nMKrDRcYUvLy10FoCLAuV6Zhb0aK08LW+GAnowdAAAAACDlUQEIAEl4NVHbvP1aVlRZZjXBP1cBDgQsLTfTqjNrrKh92EbutS1jBwAAAABIeVQAAkAS3tJq26z7OvZJ1g+2yKu02zY6y/J6t7cFoWKr7pRmfYcOtS132o6xAwAAAACkPAJAAEjgRT2z6oh1KuhgG3Vd36Yumm0VNZWWv0lvq84KWG73XOu3/jDr0q0LYwcAAAAASHkEgAAQxwtHzYtGzKKeBQMB617Q2fIys626Jmy5O6xt1j7DMvKyrKBdgQWDzKIAAAAAAEh9BIAAECfn7HUsN7+g1pjk/flnoEOmBYLLVgMGAAAAAKC1IAAEgDjBjlkWLMhiTAAAAAAAbQb9awAAAAAAAEAbRgAIAAAAAAAAtGEEgAAAAAAAAEAbxhyAABCnaulSq4pGGxyTjIICC7AKMAAAAACgFSAABIA4vz72f5aX1cAiIJGIDTnyKMts146xAwAAAACkPAJAAIgTDAYtGAolHZNIJGJLSkqtsrLCsn/91UIFBZZbWGidu3SxUB2vAQAAAABgVSMABIBGUPg3ZcYM+2nWLKsor7BfysotGgpZdufOtsnWW9va669vaWl8pQIAAAAAUg+/rQJAI8yYPcc+/PZbCwVDNu6tt9y2aw452BYuWGAvzZhuofR0W3vddS0QCDCeAAAAAICUwirAABCnuqgo6XhM+OZrq66osIKMdFPEp1uW51lWTbWVz5xlzz36qFVWVDCWAAAAAICUQwAIAHGi4bB5nrfcmPw8Y6blZWZaRkaG+Y8qEAxXVlqoqtK++/RTKyspYSwBAAAAACmHABAA4njRqEWSVPJVVlZaZlqa5QRDrvpPurZrZ12zsi07FLKl8+dbTXU1YwkAAAAASDkEgAAQLxCwcEXFcpWAQc+zwpwca9++XWxbnpl1LMi39jk5lhYwK6qjfRgAAAAAgFWJRUAAIE4gGDQvHLbqxYtdGBgIhdwtEo1aWjBYqzpwQUmJZaSlWW4gYCEzqygrYywBAAAAACmHCkAASKDAT+GfKgCjNTXu79XV1bakosKCob/+3aRjXp5F0tJsZkmJVZVXWFZmJmMJAAAAAEg5VAACQH1fktnZlpafb+Fo1GoqK23W4kWxx2YVF1s4HLaAHotELBqNMpYAAAAAgJRDBSAA1LEYSCgry4V/Ac0LWF1tRZ5n2XFVfp3y8iwrLc2qo1HXOhxmJAEAAAAAKYgKQABIJhCwoOb/Cyxb8zc9GLTC9AzrkJ297GEzy83IMMvJsZKyMvOCAcvSfQAAAAAAUgwBIAAkVP7pZpr/LxKJbc/MybGe7dtZIG3Z16bWBy4uL7dIIGDtCwosM5RmaZo7EAAAAACAFEMACABx0nNz3Zx+XiTiVgP2ZWdnWTActoy4FuDMrCzTrH/BQMCycnMtnQpAAAAAAEAKIgAEgPgvxexsy8zMtHBFhUUqK91KwGoD1nyASyMRywxHYi3AmcGgmxdwcVW1pWdmWnZeHmMJAAAAAEg5LAICtGLvvvuuC6eWLl1qrcnUqVPdfk+cONFSkRb0UCVgZrt2rhVY0kNpFvE8W7R4sbuvrXNLSq2yqsqqImHL6tjR8vLzV/GeAwAAAACwPAJAwMwOP/xwF0hdc801tcbjueeeiy0C0Vqtvvrq7hjib7169fpbx3bMmDG1tvXu3dvmzJljw4YNs1QW0CIgwWVfkxsNGmgzXdDq2T0HHmD3H320q/gr9zybWV5hI0aPtqw/FwgBAAAAACCVEAACf8rKyrJrr73WlixZ0qJjUl1dvcrH+PLLL3eBm3/75ptvVun+hEIh69atm6X9uaBGa7Dt+utbu/wCm11aZr8vXmyzqqpsWkWFLQwGrfcGG9iBRx3V6sNiAAAAAEDbRAAI/Gm77bZzodTVV19d75iMHz/e1lxzTTdPnKrrbrjhhlqPa9u///1vV/lWWFhoxxxzjD3wwAPWrl07e+mll2zw4MGWk5Nje++9t5WVldmDDz7oXtO+fXs7+eSTLRK38uwjjzxiG264oeXn57t9O/DAA23+/PlNPmf+6/1b586dY/t600031Xruuuuua5deemnsvkKt//73v7bHHnu4/R44cKC98MILtV7z448/2s4772wFBQXus7bcckv7/fff3fvo+J5//vlY9aHalpO1AL/33nu28cYbu3Ht3r27nXfeeRaOW4Rj5MiRdsopp9g555xjHTp0cMcRv5+i+6uttpp7jx49erjnt5S8vDzbZYvNrVfPnpaenW0d+vWzDoMH2zo77GjHnXWWO24AAAAAAFJR6ym/Af6GqrSrrrrKhWwKjpK1yX711Ve27777uqBpv/32s48//thOOOEE69ixowv8fNdff72NHTvWLrroInf/ww8/tPLycrvlllvs8ccft5KSEttzzz3dTcHgK6+8Yn/88YfttddetsUWW7j39qsHr7jiChcaKvg7/fTT3efo+X+nyy67zK677jp3XLfeeqsddNBBNm3aNBfEzZo1y7baaisX0E2YMMGFgB999JEL78466yz76aefrLi42O6//373XnrN7Nmza72/3mP06NHu2B566CH7+eefXXCqqsz4kE9h4hlnnGGfffaZffLJJ+75m2++uW2//fb29NNP24033ujGVwHt3Llz7dtvv63zmKo0d19VVey+9lGi0ahF40LYeDlZWbb1WsPcvIBDjjxq2RyBAAAAAACkOAJAII6q3FQBd8kll9j//ve/5cZm3Lhxtu2227pwTwYNGmSTJk1ywVh8ALjNNtu48MunALCmpsbuvPNO69+/v9umCsCHH37Y5s2b56rLhg4daltvvbW98847sQDwyCOPjL1Hv379XICoKrnS0lL3msY699xzY2GkKOhsSnWcju2AAw6IvVYh4Oeff26jRo2y22+/3VU6KnhLT0+PjYsvOzvbBW2q2KvLHXfc4eYFvO2221xl4JAhQ1xIqP2++OKLLfjnPHxrr722OzeiSkQ9/+2333YB4PTp091nqJJT+6FKQI1VXVTpqWAz0aADDnQhZkMyGvEcAAAAAABSAS3AQALNA6hKMwV7iVTNpoqzeLo/efLkWq27attNpPZZP/yTrl27uhbc+CBP2+JbfDVX3+677259+vRxLaaqshOFXU1x9tlnu3Zb/3booYc26fUK3ny5ubluX/z91Pup5dcP/5pD4zp8+PBac+hpXBV0zpw5M+l+iFqF/f3YZ599rKKiwgWlqh589tlna7UQJzr//POtqKgodpsxY4bbnpGW1qibMd8fAAAAAKCVoAIQSKB21h133NEuuOCCWlV94nnecgs9aFsihWSJEgMyvU+ybWpBFc0PuMMOO7ib5gLUvH0K/rRvTV1YpFOnTjZgwIDltquyLnH/VanYmH3391MVfiuqvnGN317ffqiC8JdffrE333zT3nrrLdearcpMzS2YLJzUPIG6JYq88bpFcnKW30mFiWVly/4eDFpov/01MWAzjxgAAAAAgL8PASCQxDXXXONa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qJkq/iIK/paFgAoAw5URi6SFrSxaYtPmTGcsAQAAAAAphwAQABrBqzCzKjPLNgv435zBgIWzaswrj1pVacSKli5hLAEAAAAAKYcAEAAao9SssrTSokuj5kU80zogXiRqNYurrWJRhVmFWSS4bHEQAAAAAABSCQEgADRG2Ky4stK8cu+vb86gWSAacI/plp9RwFgCAAAAAFIOASAANEBz/Vm6maWZBQIBV/3nvj39gr/skAWyzCrL1ScMAAAAAEBqIQAEgAa40C/dLDM3zYIZtb82A8GAZeanWSAnYPMWzmUsAQAAAAAphwAQABojZJYTyTTrsOzvFjALhoIWbB8yq17WAry0upixBAAAAACkHAJAAGiMkL4w/a/MgPu/nnluWyAj6FqAo5EIYwkAAAAASDkEgADQCOmZZjVejXkly1YANm/ZHIDBcMgCQbPczGxrl9uesQQAAAAApBwCQKx0q6++ut10003Nmnftueees5VpwoQJNmTIEItG/dUcVt0xa6GJf/3rX9ahQwd37BMnTrRVZerUqat8Hxpr7ty5tv3221tubq61a9fOqqqqbLXVVrOvvvqqRT8nu1OeRauj5lV6fgGgm//P0wrAFWmWn1toaw4Y2qKfCQAAAABASyAA/Ac5/PDDbcyYMat6N1LKOeecYxdeeKEFgw3/KDzwwAMuYFpZXnvtNfcZL730ks2ZM8eGDRtmq+q66N2799+6DyvixhtvdPuqsPLXX3+1zMxMO+uss+zcc89t0c/p3LujhdIzzSv2rP2WudZpj3bWZduOFiwKWX56ng3ru6ZttsHmLfqZAAAAAAC0hLQWeRegFfr4449t8uTJts8++1gq+P3336179+622WabrepdsVAoZN26dVul+1BTU2Pp6emNGrcNNtjABg4cGNt20EEH2dlnn20//fSTrbHGGi2yP936dbPo7xGritSYpakEMGpdC7papmVYx1An23vkfjag74AW+SwAAAAAAFoSFYCIGTdunK211lqulVIVYCeccIKVlpYuVwGnCrXBgwdbTk6O7b333lZWVmYPPviga3tt3769nXzyyRZJWAyhpKTEDjzwQMvLy7MePXrYrbfeWutxBXFbbbWVZWVl2dChQ+3NN99c7syoomvQoEHuc/v162djx451IZHv22+/ta233try8/OtoKDAhUJffvllnWf48ccftx122MF9ZkPv8e6779oRRxxhRUVFrjVWt0svvdS9Zv78+bbrrrtadna29e3b1x599NFmVeFp3KZPn+7eW2NZVyvxuuuuG/ts0fP/+9//2h577OHGRkHYCy+8UOs1P/74o+28887umHRsW265pQvO9D46d88//3zsuHSsyVqA33vvPdt4441dhZ2CyvPOO8/CYfW/LjNy5Eg75ZRTXFWl2pgVIMbvZ0P0eXfddZftvvvu7hr897//7ba/+OKL7jzoPOm8X3bZZbHP1fiMHz/eHnroIfd6jaN07NjRBamPPfaYtZT2XdtZl95draAwz/Iysi07I9uGdh1qm/Xf0vbf7mAbvfXOlpuT22KfBwAAAABAS6ECEDFqg73llltcqDJlyhQXACrMueOOO2LPKS8vd89ReKZQb88993Q3BYOvvPKK/fHHH7bXXnvZFltsYfvtt1/sdddff71dcMEFLhB6/fXX7fTTT3dz72nuNs2/p/fo1KmTffrpp1ZcXGynnXbacmdGwZVCSAWI33//vR1zzDFum/bRr/pab7317M4773QVbAqv6qsge//99+2AAw6ota2u91CYpCDu4osvtl9++cU9V2GmKHSaMWOGm08wIyPDhWAKBePpOQrVFK75FFjdf//97rGbb77Z+vfvb/fcc4998cUX7rObQqHYdddd58ZZ4aqOY9q0aS6ImzVrlgtXFdBpHxUCfvTRRy5EU6usquQ05toX0Wtmz55d6/31HqNHj3b7qrDt559/duOvUC4+5FOYeMYZZ9hnn31mn3zyiXv+5ptv7s5zY1xyySV29dVXu7ZejYGulYMPPthdc35oqXkS/edqrA499FB3TBpDhbA+hZUffPBBnZ+luQJ182kMpCYSNku2mG/ArF2PQsvIyrDqimqLWMRGbbKzDem1hg3qO8jycvPcOQUAAAAAINUQACImPnRTJdsVV1xhxx9/fK0AUBV3CscUVokqAB9++GGbN2+eC8RUvacKunfeeadWAKgQSBVjoio+BVAKeRQMvfXWWy6EUkDWq1cv95yrrrrKdtppp1pn56KLLor9XSHlmWeeaU888UQsAFT1nNo+FSxKfEtoMvo8hYnx6nuPwsJCF/DEt8ZqzrlXX33VBZebbLKJ2/a///1vubZTVcwlLjSiKkq9p//eCjOb23qroM0PMzV2CgE///xzGzVqlN1+++3u/RXa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apdccomVl5e3xO4AwEqxrPIvYIVaDfjPW+ecHDcnoLbr8abOgQoAAAAAQKtoAT7ggANs1qxZdtVVV1nXrl2b/AvwLbfcYr///rt77eqrr77cIiANrSIMAH8HLe+RE1gW/Pn0zxaBUMhyImHL+GtqQAAAAAAA2lYA+PHHH9snn3xi66yzTrNeP2bMmJbYDQBYqbS8R7YFLE3/yPFn2JedlmYVGRmWW22WGVYTMAAAAAAAbTAAHDJkiFVUVDT79Wr/BYBW8YUZCFg0bluZ/k8oZNFQyLITqpcBAAAAAGgzcwBec801duaZZ9q7775rixYtsuLi4lo3tB46h2rhXrpUa5q2HlOnTnX7PXHixFW9K7bVVlvZ//3f/63q3WgzNEfouuuu2+jnz58/3zp37uymJVgZFYALzdxiH74chX5pISvOzrb2PXu0+GcCAAAAAJASAeCoUaNcC/C2225rXbp0sfbt27tbu3bt3J/JaHGQhQv1q7S55yQuHNKURURS0eGHH+4CKYWj8Z577rlWv0iA5mnUMcTfevXq9beObWLbeO/evW3OnDk2bNgwW5Veeuklmzt3ru2///5Jxys7O9tVzF5//fXmeX/fhHEjR4600047baWGvTruk08+2S0GlJmZ6c7Jrrvuam+//bb9nfQddMghh6yUyuIBhYVW6UWtJBj8c0EQs/nm2eK0dAu3a2eb7LVXi38mAAAAAAAp0QL8zjvvNPk1N954o1sx2P97aw/FksnKyrJrr73Wjj322DqD0Oaorq62jIwMW5Uuv/xyO+aYY2L3Q6HQKt0ffX63bt1sVdOCNkcccYQFg8Gk46XVst966y07/vjjraCgwF0bbYEqMDfffHMX+l933XW29tprW01Njb3++ut24okn2s8///y37o/OwcYbb+yC1pb82RvZq7e9O326VUUidklenuX37GnRtJBF09Itd/Ag2/+441rsswAAAAAASKkKwBEjRtR7S+awww5zVUJ+RZfu13VrrbbbbjsXSl199dX1Pm/8+PG25ppruvFQtdgNN9xQ63Ft+/e//+3GqbCw0AVJDzzwgAtbVHE2ePBgy8nJsb333tvKysrswQcfdK9R8KGKrEgkEnuvRx55xDbccEMXvmrfDjzwQNcy2VT+6/2bWi79fb3ppptqPVftm2rj9Cns/e9//2t77LGH2++BAwfaCy+8UOs1P/74o+28884uJNNnbbnllm6laL2Pju/555+PVdWpki1ZC/B7773nQiCNa/fu3e28886zcDhcqyrulFNOsXPOOcdVmuo44vdTdH+11VZz79GjRw/3/LqoolXh3m677VbneGl8jj76aBeQvfHGG7HHlyxZYoceeqg7ZxqTnXbaySZPnhx7fNq0aa6aTo/n5ua66+WVV16JPT5p0iQbPXq05eXludW0VQHnV9jqutFY3HzzzbEx03htvfXW7nG9p7bpefLaa6/ZFlts4a6vjh072i677OLGvj4nnHCCe4/PP//cXYeDBg1y+3jGGWfYp59+Gnve9OnTbffdd3f7qXO777772rx582q9l6pmdQwas6OOOsqFponuv/9+W2ONNVzIrorKO+64o9bja621lhvvZ5991lpStw4dbMvevS09L8+WBINW06+v1QwebN122dkOvugi67Xaai36eQAAAAAArNIA8LvvvrNoNBr7e323xlRvJQuhNJ/gqq4sWxHa96uuuspuvfVWmzlzZtLnfPXVVy4EUcvo999/7wKnsWPHuoAvniqZ1N6q5+txKS8vdxVnjz/+uAttFITtueeeLhjS7eGHH7Z77rnHnn766VrVg1dccYV9++23rh15ypQpseDn73TZZZe549b1oeDqoIMOssWLF7vHNHeb5tFTuDNhwgR3zEceeaQL78466yz3OrWdq+VXt80222y599d76H032mgjd6x33nmn/e9//3NBajyFiQrUPvvsM1e5pkq9N9980z2mcVN16t133+3COI2XgqW6fPjhhy68UzBVF7X96jz99NNPlh63YITOwZdffumCULXT63naf1XRiaroqqqq7P3333fXiSpLFaKJxkBBu4JWvYeuBYVqGidR8Dd8+HAXHPtjpvZcBc/yyy+/uG16nihEVnD3xRdfuPZdVTMqrPV/3hPpvOkztY8ay0QKEv1jV+u2nq9AUuOsYHG//faLPffJJ590rbtXXnmlOxYFt4nh3r333msXXnihe47GUT9j+pnQuYyn8PeDDz6o81xoPJPNVxouK7OKWbOS3qrmzLEOlZW2fk6ObZqba/ucf74des01ts8pp1jfwYOXq/wEAAAAACAleM0UCAS8efPmxf4eDAbdn4k3bW/Ke8WbNWuWl5WV5bVGhx12mLf77ru7v2+66abekUce6f7+7LPPuqnDfAceeKC3/fbb13rt2Wef7Q0dOjR2v0+fPt6YMWNqPef+++937/Pbb7/Fth177LFeTk6OV1JSEtu24447uu11+fzzz937+K9555133P0lS5bU+RrtT0ZGhpebmxu73XzzzbHHbrzxxlrPX2eddbxLLrkkdl/vf9FFF8Xul5aWumvg1VdfdffPP/98r2/fvl51dXWDY+ubMmWKe99vvvnG3b/gggu8wYMHe9FoNPac22+/3cvLy/MikYi7P2LECG+LLbao9T4bbbSRd+6557q/33DDDd6gQYPq3I9EOu5+/frVO17p6eluP3Vdf/TRR+7xX3/91W3z78vChQu97Oxs78knn3T311prLe/SSy9N+rljx471dthhh1rbZsyY4d7zl19+iR3rqaeeWus5jTnXMn/+fPe877//Punjn332mXv8mWeeqfd93njjDS8UCnnTp0+Pbfvxxx/da3UdyvDhw73jjjuu1us22WQTdw35evfu7f3f//1fredcccUV7rXxTj/9dG/kyJF17o+uyT+n8at1mztpklc+Y0ajbtE/ryUAAAAAAFamoqIi9zur/myOZs8BqMoxv+1Tf28OVa/Ft4T6FU2itlVVO6m9r7VTtdY222zjVkpOpAomtUTG01xqaqPVGPgVkGrbTaRqs/79+8fuq21SLabx46ht8dWV33zzjasyVKusKrH8qi61Zg4dOrTRx3T22WfXqhzs1KmTNYVaYH2qGlO7p7+f2je1/MZXyDWVxlVVb/FzS2pcS0tLXTWm2noT90NUcebvxz777OPOgxa1UMWhKvLUhpuWlvzHpqKiwlUt1jdeCxYscNVruh78ykXtq95zk002iT1frbdq7dZjotZjzRuotmG1lu+1116xfVeFpObhjD/vPlXYqR23KfQaVdSpdVdtxPHXSLJFVvzFTBqax1PHospD3Xy65lQhqMdUrak/j0uYR0/n0Z9nVOM3Y8YM1xocPwelqkPVHh9PC66oSrYu559/vqt09KkCUPuWHgi4GwAAAAAAbUWzA8A+ffrUmp9MYUZiMKJfyj/++ONaz42n9ko/QLjrrrtqtftqkQuFWdre2qmddccdd7QLLrhguXZbHXticJJsddhkrZWJAZneJ9k2P8BRa+cOO+zgbpoLUAGuQh3tm1qDm0KB34ABA5bbrhbIxP3321gb2nd/PxXcrKj6xjV+e337oTBI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FAAAAAAASNXfWVukAlCWLl1qTz/9tJv/T628HTp0sK+//tq6du3qFvmoz5QpU1pqNwAAAAAAAAC0dAD43Xff2XbbbeeSSK34e8wxx7gAUPP6TZs2zR566KGW+BgAAAAAAAAATdQis9efccYZdvjhh9vkyZMtKysrtn2nnXay999/v8HX77333nbNNdcst/3666+3ffbZpyV2EQAapaisotG3FJhBAQAAAACAv6cC8IsvvrC77757ue1q/Z07d26Dr3/vvffskksuWW77qFGj7D//+U9L7CIANMr4D7627JzcBp8XjXp24LYbW2FuNiMLAAAAAGj7AaCq/jQZYaJffvnFOnfu3ODrtWpwRkbGctvT09OTvi8ArCyhYNDdGhblJAAAAAAA/jkB4O67726XX365Pfnkk7HVeqdPn27nnXee7bXXXg2+ftiwYfbEE0/YxRdfXGv7448/bkOHDm2JXQSAFlFZWWlTf/vVlixeaOWzfrfMtIB169jeNtt0E+vSpYsFGxUeAgAAAADQygJAtemOHj3a/fJbUVFhI0aMcK2/w4cPtyuvvLLB148dO9YFhVpBeJtttnHb3n77bXvsscfsqaeeaoldBIAWCf++/uwjW7hovgW9oP0YjVjQ88zzovbTr3/Y/nvvbn1XX50QEAAAAADQ9gLAgoIC+/DDD23ChAn29ddfWzQatfXXX9+tDNwYu+22mz333HN21VVX2dNPP23Z2dm29tpr21tvveXCRABIBT9+941N+/0Py+5UYO899biVFi2xgvYdbLdDjrNvf/vdAs++YP867GDr1KnTqt5VAAAAAABaLgAMh8NuDsCJEye66j2/gq+pdt55Z3cDgFSkFX9//OIzy27X0fIyCy3gt/oGghbMyDTLyrePvvzattx0E9uSABAAAAAAkEJWeLKqtLQ069Onj0UikZbZIwBIQTU11VZaVGzp2emWlZ9vwUBA6Z/7My0j2zLTMm3p0hKb/MfUVb2rAAAAAADU0iKz1V900UV2/vnn2+LFi1vi7QAg5UQjUYuG9Q8d6RatDpv353b9mZWbZukFheYFgjZ3/txVvKcAAAAAAKyEOQBvueUW++2336xHjx6uGjA3N7fW45oXEABaM61uXllTY+HKCivsUGDBYMhcDWAgaKGMXPPKllpaKN2WLC1a1bsKAAAAAEDLB4BjxoxpibcBgJSe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wGktvfzlL7fz/sMf/oA73/nOeNCDHoTx8XF7juvRcR09VlB+//vft3N+5CMfaeHds571LHvfne50p9nqw5vd7Gb7bJ/b4HZvdKMb2bm+5z3vwYc+9CELUgcxTCyXy/jVr36F17/+9VbZ+J3vfMee43V7y1vegve973345z//adeLYdlifvrTn1qgec1r7m1ZZbDG42a4lqbpPu9h6zIDYPr73/9u58MWXmKY+4xnPAO//vWv8b3vfc+qChmaMtCj8847z34ydOT7/vu//3vB43r+859vASC/N3/5y19sfcKNGzfOeQ2D0p/85CeLnlu327Ugc/BGSRwd9C3wHZx1jXU448QxbN2yBdf8tzviure8B86++8Nwx7ve20JLERERERERkTWTiqzQwx72sPQe97iH/fkmN7lJ+shHPtL+/KUvfYkp0OzrHvjAB6Z3uMMd5rz32c9+dnrGGWfM3j/++OPTc889d85rPvKRj9h2LrjggtnHHve4x6WlUimt1+uzj51zzjn2+GLOO+882072nh/84Ad2f2JiYtH38HhyuVxaLpdnb29729tmn3vLW94y5/Vnnnlm+tKXvnT2Prf/ohe9aPZ+o9FIHcdJv/nNb9r95z//+emJJ56Y9nq9Za9t5qKLLrLtnn/++Xb/BS94QXraaaelSZLMvuZd73pXWqlU0jiO7f7ZZ5+d3uIWt5iznRvd6Ebpc5/7XPvzm970pvTUU09d9Djm43mfdNJJ+zzOY/F9Px0dHU3vdKc7pa9//evT7du3zz6/kmtOO3futNf98Y9/XPCcF7o+09PTaT6fTz/wgQ8sue2nP/3p6a1vfetFn+fnx33Nv+284sK0U9+1qrck6X8+IiIiIiIiIgdiamrK/s7KnwdCFYByQFh9xUozVl/NxzXhbn7zm895jPdZcTbYusu23flYbXbyySfP3mdVF1twK5XKnMcGW3y5Vt897nEPHH/88dZam7WNXnrppft1Ts9+9rOt3Ta7PfShD92v91/3uted/TMr8Hgs2XFye2z5DYIAB4rX9aY3vemcgSu8ro1GY0415uBxEFuFs+O4z33ug3a7jZNOOsnarlnFN9hCPB9fy6rF+dhuy8Eg733ve3HGGWfYz9NPP90qPpfCdl+2aHP/bIXOWn7357PidWD13u1ud7slX1csFpdck5BVhFNTU7O3yy67zB7P+S5yvreqNxEREREREZHD6fBOF5CrLLaznnPOOXjBC16wT7stC+LmTwVeqFWUIdl88wMybmehx7KWUbaU3vGOd7Qb1wLkun0Mk3hs+ztYhEMtuKbcfGxTnX/8YRiu6Niz42QYdbCWuq6Djy91HGzPZVsuW4LZZvuEJzzBWrG5tuBC4SSvyWKDNLiGHwNF3rgmJNfte+Mb32jB8GLudre72TF84AMfsPUHeVxsA9+fz2ql15Lt19k6jgthG+5Crbjpb96AdGgE8PfzM+NnEU6zhxjI1QB35tdrmsC53hOBwsj+bU9ERERERERklSgAlAP22te+1oZhnHrqqXMeZ0UY144bxMERfB3XEFxNf/vb32xQBY+FwRL95je/WdV9METienQZrhXHdQb3B6vyGIwxOFwoaMvlcnOqIxfC68q19QaDQF5XVhoec8wx+xWgcagHb0984hNnK/ducIMb7PNahnqs9GMIyIEei+Hxs3KTgWx2nwbPac+ePVa9x/UHWQ1J878nC71vPg5Y4TlwDcFHP/rRi77uT3/602w16H4JKkDcBhwXCPYNqReUJkA41f/JoM8NrErxbxddianpFnITX0XolFEb3Yozzry+1gAUERERERGRNaUWYDlgHB7BQRccCDLomc98poUzHMzxj3/8w4Kvd77znTbsYrVx+itDIx7DhRdeaJN3ud/VxAm3HD7CgRIMlR72sIftd5D5pCc9yYJDDkZhQMl2aG6T1XjENmcOD+F9BpoLVRiyWo9tqpyCzOCTU4Nf+tKX2lANVimuBAexcHAIz4PXi8fAMI3t0wthAMgA9Gc/+9nsY5zS/OAHP9h+8vPlMbPyj0Na2IpN3B5DSr5m165d1qbMAJFVgxzicsEFF9gwFB77oA0bNtjxcADMjh07rDV3PrYkP/e5z7VJxx//+MetrfiXv/ylnVeGrb8ctMLK0P3mlwC/DERNIOwHmkti6NebApIIyA/Phn8/++0/cNmVu9HrthHu+ie6O/6My/76ffz0e1+z50VERERERETWigJAOSgM2+a3x7KS7HOf+5xN8mV750te8hKbRHsoJvMynGKo9fnPf94q5FgJyDBqNXGtOLY83/Wud7UpvOeee+6cdQpXgsEXAy8GYWeffTbOOussa4PNqgG5Ht9pp51m6yLOD9wyrPJjyMZJuWeeeSYe//jH41GPehRe9KIXrfg4hoeHbb9cO5BViQxqv/a1r9nxLYRBJ6cVf+pTn5p9jNeZazUy6GUF6E1uchP7vD/4wQ/iIQ95yOyxciry8573PFuzkQEoQ0p+JxjM8Xvx9Kc/3dqPB/m+b1OgWSXIFuEsUJyP03+5f363OKH4fve735x1IRmOMhzOKg33Gyv/VhICLhD+0fl/uRi79uzGSMXDXZ/7RdzhUa/FhnIHI+4Edl5wHv7vlz8/sOMSEREREREROQAOJ4EcyBtF5OqBlXjXuta1LLhbrFLwSHPjG98YT3va02zgyEqxQnNoaAgT3385apWZwScM/xgCMgyc3w68SPhHb/3Yt3CtrWUUCjnc4dlftsd+8PaHIoKHbpzDnyZLeMaLVjeoFhERERERkaPX9MzfWdkpx6Ga+0sVgCKyJFbwsb12f6cqHy6sBLz3ve+NBzzgAQe/scUqAZcI/+wYdk0jRggHe4ez+EEMJ2wiau3Bjkv6rd8iIiIiIiIia0FDQERkWYu14h6JuI4g1wdcNVnlH0NA4nTgJcI/2j0xCT8dQy7YO8wkn8ZI/RS+G2HnFZet3vGJiIiIiIiILEMBoIjI/oSAFgQ6i4Z/NNlsIElSVIKS3WcdYD7vwE89TPYmMTW973ATERERERERkUNFLcAiIivByr/Z35y5RcM/6nUdTLc6mOq17D4XWk26id2fbrbQ7XV0zUVERERERGTNqAJQRGQ52Zp/rOVj+Jd0+2sCzh8MMsPzgDCKsWd3s5/+Abh4zyTibmSPe+7etQFFREREREREDjVVAIqILGX+wI/80MKDQQZ0whBwHIzWcv3+Xwc4bl2xf991EfJ5ERERERERkTWiCkARkcUsNu13/mCQeZWAcQyUijnkC97eTcFDPu+hVAgQhTNlgSIiIiIiIiJrQBWAIiL7E/5lGPotUgno+y7Y5Vtwy1kBIGrDebvPxz3PQ5oqBBQREREREZG1oQBQRGR/w79lQsCCH2C0UoBbiGcf6zV7cIsxRmsFBDkP3a4GgYiIiIiIiMjaUAuwiMiBhH+ZBdqBc4UUfiEPN9r7KzZ1fbhdB0GuhJzvI464DuDAZGERERERERGRQ0QVgCIig8LplYd/i1QCxkmK8T11hEmaDQFGmroI0wR7xht2X3OARUREREREZK2oAlBEZJCFf2MrD/8WqAQMUheX7mkgyOXsIYaAU+0epiZbuGyijnxpdDYYFBERERERETnUFACKiAzKD+1/+DcvBDzz9M2YnIywLd/Gp194W+QKBVy+q45GI8Fk28WZt7ojPP8A9yEiIiIiIiKyn9QCLCIyyDnIYC4o49H3vBmiJMZEK0IcB0hRQuxUMe0UEZaugYc84snI5wu67iIiIiIiIrImVAEoIjIojfptwAdhZN0mPOG+N8fnv/tnXLxrGiVsQisEiuuvhcc88NHYuGkzHEerAIqIiIiIiMjaUAAoIjLAufaj4NRqB31NRgE87vYzd/JDcBwVXIuIiIiIiMjhoQBQRGSAUxiBUzj4AFBERERERETkSKGSFBERERERERERkaOYAkAREREREREREZGjmAJAERERERERERGRo5gCQBERERERERERkaOYhoCIiAzojV+GXlRdk2sSDG+F4+rfYUREREREROTQUgAoIjLgr6+/OUbWbz6wa5Im6O65BEFlPdxCZenXxhFOfcb3kBs9TtdfREREREREDikFgCIiA1iR5/q5A7omaZrAcRw4nr/gNqIows7JLjphBCcNEf7fLzFyYg9bjz8Bvq9fxyIiIiIiInJo6G+cIiJrgOHfXy/eiX9sn0AYpij4Cf786XeisvU6uNEd7onr3+TWCgFFRERERETkkFAAKCKyBv512W78+u+7MVoC3n0esLsNrK/+Es+66w58/bJ/IHI8XPfaZyKFAz9XQL5QsGpCERERERERkYOl1edFRNbA9/+6E0EE5FP2Gfcfc5IQzvRlcHb+Ad/4+AcQdRtIOtNoTmzDxO6dSJJEn42IiIiIiIgcNAWAIiJr4OKdQNEH4sRmhQApwHwvbLYRTO/E3//wfRRzPgr5ANVSAX7cxOSeXUhTJoYiIiIiIiIiB04BoIjIGug0ASRAJQd4/M3rAK4DVBgKRsDEFTvmvL5QKAC9Jrqdjj4fEREREREROSgKAEVE1kA3BmoFYKQIeDMtwPw5UgJqPhD2sE+1nx/4iHoKAEVEREREROTgKAAUEVkDqQ+UfMD3rfu3/xhDQADFAIgcoDO/2i8FNAdEREREREREDpYCQBGRNeAmQBdAu8lKPyDiWoAp0GkBPSaBEdCY2LvmXxRF8HIFe42IiIiIiIjIwfAP6t0iIrIiUQxMtoEcl//LpgA7QJQC9Xa/GrDXadiaf34QIIaHgOWCfkFXWERERERERA6KKgBFRNYoAPQ8oFrq3/dnfvsWSv3HnRi4cvt2NJpNpF4BQb6IxPGR5zAQERERERERkYOgCkARkTXAyb+OC7hB/19eWATIn5wEzDDQ84EkTuEXKkj5Ir+AYqEAR4sAioiIiIiIyEFSACgisgaKOaDsAO0WEKf9ll/+bHeBAgeEBMDQyAhK1RFUhkb0mYiIiIiIiMiqUQuwiMgaYKVfVgE453EfCALAyQOp48PPqeVXREREREREVpcCQFnSD3/4Q2tBnJycvEpdqYsvvtiO+3e/+93hPhTc6la3wn/913+t+PUf/ehHMTw8jCMJr+WXv/xlHKle9rKX4XrXu97s/Wc961l4ylOegiOJHwATPaDX2/sYu3tdF5jqAn41j8q647Tmn4iIiIiIiKw6BYBr5OEPf7iFKK997WvnPM5Q5aq+xtcJJ5xg5zB427p165pe23PPPXfOY8ceeyy2bduGa1/72jicvv71r2P79u24//3vPxumLnVj+HdVtNBncDg95znPwUc+8hFcdNFFOFJccyuwuwXs6gEJ+39nWoB3N4ErOg6ucYM74fiTT73K/z4QERERERGRI48CwDVUKBTwute9DhMTE6u63d5gSdFh8v/+3/+zwC27nX/++Yf1eDzPw6ZNm+D7h3eZy7e//e14xCMeAdd1cbOb3WzONbrvfe+LO93pTnMeu9/97neV/Q4cSTZs2IA73vGOeO9734sjxS1O24ShCjDRAR55PeAlNwMee9Midnibse46t8cDHv+8w/59FRERERERkaOTAsA1dPvb395Cqde85jVLvu6LX/wirnWtayGfz1t13Zve9KY5z/OxV77ylVZ1NTQ0hMc85jGzbaOsODvttNNQKpVw73vfG81mEx/72MfsPSMjI3jyk5+MOI5nt/XJT34SN7zhDVGtVu3YHvjAB2Lnzp37fW7Z+7Pb+vXrZ4/1rW9965zXslWTLZsZVjx98IMfxD3veU877mtc4xr46le/Ouc9f/7zn3GXu9wFtVrN9nXLW94S//rXv2w7PL+vfOUrs1V0rLRbqAX4Rz/6EW584xvbdd28eTOe97znIYqi2edvfetbW9soq8dGR0ftPAaPk3j/uOOOs21s2bJlyTbT3bt347vf/S7ufve72/1cLjfnGhWLRdvO/Mcy3/72t3HNa14TlUplNiicX3HH7xKP49RTT7XHr7jiCgsR+VmPjY3hHve4h12L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5cwzz8x8f+SRR+TnP/+5+jx89LzzzpNEIpGZj9//85//lP3331+PzV/+8hdXKcCl2OKGG26QYcOGqY8cfPDBHVKfb7nlFll//fW1reutt55cf/31mXk4JuBnP/uZthn9CNrwr3/9Sx566CGd5jxfv/nmGxk1apT6HI439s953lmfQB+A9uP8JIQQ0k0MIYQQQgghy9hxxx1NdXW1ueCCC8xnn32m/3o8HjNixAhz44036rTjjjvONDY2mpaWFv3NvHnzTL9+/cyZZ55pPv74Y/POO++Y3Xff3ey8884Zu957773mvvvu099Pnz7d7LfffmbjjTc2yWRS51966aVm2LBh5sUXXzSzZs0yL730krnjjjt03ldffWVw24rfWRYtWqTTnnvuOf2Of/F9k002MU8++aT5/PPPzY8//mjOOusss95665knnnjCfPHFF+aWW24xlZWV5vnnn9ffzZ49W7+fcsop5pNPPjH//ve/zcCBA3Vd2EZnYP4DDzyQ1T5s59FHHzWffvqpOeigg8zw4cNNPB7vch1Dhw7V/Zw5c6Y5+eSTTVVVlVmwYIHOj8Vi5uyzzzZvvvmm+fLLL7Vt4XDY3HXXXZl1jB071tTU1Jhx48ap7R955BFdBsfKMnLkSLP++uurbd99912z5557mrXWWkvXD/bZZx89Xu+//77aCOt44YUXXB/bM844w9TX15tbb71V7Y5jN2nSJJ0HHxkyZIg58MADzQcffGCeeeYZs/rqq2u7i9kH+N9GG21kXn31VfPWW2+ZbbbZxoRCIXPllVfq/HvuuUfXMWXKFPP111+bN954I+v3pWB9yvoBtotz4fzzz9djDF9CG/AvgP0qKirM/Pnz9fupp56qtjv44IP1O3wBx/fxxx/X7/BJtBl2g93ht6uttpo599xzs3xkwIAB5qabbtJlcG7kA75Wqi3OOeccE4lEzC677KLnGI49/GPMmDGZZfD7wYMH6zkMX8S/DQ0N2nYAH0Vbn376afPtt9+qDzc1NZlDDjnE7LXXXjoNn/b2dvWJtdde2xx99NFqs48++ki3te666+p86xOw1eGHH24+/PBD9R1CCCHdgwIgIYQQQgjJEgC32267zPdEIqHiAB7ELXiQx8P+a6+9pt8nTpxo9thjjywrzpkzR5eBUJKPH374QefbB/uTTjpJBYhUKtVh2WIEwAcffDCz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" width="854"></p>
   <p>A full writeup is available at <a data-link-type="biblio" href="#biblio-closures-in-c-benchmark" title="The Cost of a Closure in C">[closures-in-c-benchmark]</a> and <a data-link-type="biblio" href="#biblio-closures-in-c-benchmark-followup" title="The Cost of a Closure in C">[closures-in-c-benchmark-followup]</a> which includes methodology and other information about the tests.</p>
   <h5 class="heading settled" data-level="3.4.1.3" id="design-benchmarks-manorboy-conclusions"><span class="secno">3.4.1.3. </span><span class="content">Conclusions, Comparisons to Other Proposals, and Inferences</span><a class="self-link" href="#design-benchmarks-manorboy-conclusions"></a></h5>
   <p class="note" role="note"><span class="marker">Note:</span> A wide function pointer type is necessary no matter the solution chosen.</p>
   <p class="note" role="note"><span class="marker">Note:</span> A fixed, statically-known object that can be optionally type-erased behind a Wide Function Pointer seems optimal for even complex usages of closures in C.</p>
   <p class="note" role="note"><span class="marker">Note:</span> Apple Blocks and GNU Nested Functions have intrinsic design flaws that drastically impact their performance, meaning that even transporting a context pointer through a global variable with a normal C function is better.</p>
   <p class="note" role="note"><span class="marker">Note:</span> Manual management of closure pointer-to-function pointer trampolines may produce much better code generation and quality than implementation can currently handle, while allowing the user to have as much or as little security as possible.</p>
   <p>In addition to the key takeaways above, some other details we have understood are as follows. C++-style lambdas have the capability to be both awful (Lambdas using the Rosetta Code technique) and powerful (Lambdas with Perfect Type Information). Both of these techniques are unusable as-is in C as the things that make them awful or great are tied not due to lambdas design but moreso how they are used (e.g., <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function</c-></code> abstractions or translation-time recursion prevention.) Normal C functions (storing the integer <code class="highlight"><c- n>k</c-></code> by value) can achieve near-parity with C++-style Lambdas at their best in terms of performance. However, it requires the modification of the function signature, which may not be viable in all cases (such as calling already-compiled interfaces or working with FFI). The use of <code class="highlight"><c- k>static</c-></code> and <code class="highlight"><c- k>thread_local</c-></code> to pass information across function boundaries comes with an unshakeable and implicit cost. <code class="highlight"><c- k>thread_local</c-></code> is -- for obvious reasons -- more expensive than just <code class="highlight"><c- k>static</c-></code>, but both incur overhead.</p>
   <p>After evaluating current industry extensions, we find them to be strangely poorly-performing despite being decades-old in some cases. Apple Blocks (<a data-link-type="biblio" href="#biblio-apple-blocks" title="Documentation Archive: Declaring and Creating Blocks">[apple-blocks]</a>) and similar heap-based solutions incur a fixed overhead due to the Blocks Runtime scheme, making it unsuitable for resource-constrained C environments. This means it is not worth pursuing this as a long-term solution in our technical opinion. GNU Nested Functions (<a data-link-type="biblio" href="#biblio-nested-functions" title="Nested Functions (Using the GNU Compiler Collection (GCC))">[nested-functions]</a>), as a quirk of its current most popular implementation, really inhibit inlining and other similar optimizations. A different implementation (e.g., the current <code class="highlight"><c- o>-</c-><c- n>ftrampoline</c-><c- o>-</c-><c- n>impl</c-><c- o>=</c-><c- n>heap</c-></code> work that is currently available on 5 platforms in GCC trunk at time-of-writing) could be better. But, the fact that a typical quality of implementation provides such awful performance characteristics compared to every other solution despite being the oldest solution means that they too should be looked at skeptically for direct ISO C standardization. The heap-based trampolines of GNU Nested Functions also look like they may incur a similar fixed overhead just like the Apple Blocks implementation.</p>
   <p>The Function Literals and Local Functions (<a data-link-type="biblio" href="#biblio-n3678" title="Local Functions">[n3678]</a>, <a data-link-type="biblio" href="#biblio-n3679" title="Function Literals">[n3679]</a>) proposals can have their performance approximated in their best-case as following the performance of the series of Normal Functions. This requires modifying the function signature. If the function signature isn’t modified, there isn’t really a point of comparison in these benchmarks other than falling back to other means of context transportation. All of these solutions vary wildly in performance, from Apple Blocks runtimes to various style of trampolines. This makes it impossible to understand Function Literals and Local Functions as solving the problem at hand, because they provide no plausible forward path on which to judge. Thus, we consider them incomplete.</p>
   <p>Accessing the Context of Nested Functions (<a data-link-type="biblio" href="#biblio-n3654" title="n3654: Accessing the Context of Nested Functions">[n3654]</a>), even in its later iterations, approximates either the Normal Functions (can modify the signature, best case) or GNU Nested Functions ((<a data-link-type="biblio" href="#biblio-nested-functions" title="Nested Functions (Using the GNU Compiler Collection (GCC))">[nested-functions]</a>, <a data-link-type="biblio" href="#biblio-n2661" title="n2661: Nested Functions">[n2661]</a>)) (creates an invisible trampoline to transport closure context, worst case) performance. We are unsure of how this would continue given the deeply negative impact given access to the current invocation’s stack frame / "function environment" is on the optimizer’s ability to push for performance. While we think there is potential for this, we believe explicitly or implicitly capturing just the data -- and not the environment or stack frame abstraction itself -- would result in better performance characteristics no matter the design.</p>
   <p>Finally, any solution is going to need a Wide Function Pointer type in the C ecosystem to make it usable and worthwhile. In particular, Lambdas with <code class="highlight"><c- n>std</c-><c- o>::</c-><c- n>function_ref</c-></code> is a directly applicable proxy to what "Capture Functions and Wide Function Pointers" and/or "Lambdas and Wide Function Pointers" could bring in terms of worst-case performance to the C ecosystem as a whole.</p>
   <h2 class="heading settled" data-level="4" id="wording"><span class="secno">4. </span><span class="content">Wording</span><a class="self-link" href="#wording"></a></h2>
   <p><strong class="advisement"> THIS SECTION IS NOT GOING TO BE OFFICIAL UNTIL THE DESIGN SHAKEDOWN IS COMPLETE.</strong></p>
   <p class="note" role="note"><span class="marker">NOTE:</span> THIS PROPOSAL WILL ONLY INCLUDE LANGUAGE (CLAUSE 6) WORDING. LIBRARY WORDING WILL BE DONE AFTER THE LANGUAGE IS HANDLED, LIKELY IN A SEPARATE PROPOSAL.</p>
   <h3 class="heading settled" data-level="4.1" id="wording-__self_func"><span class="secno">4.1. </span><span class="content"><code class="highlight"><c- n>__self_func</c-></code> Changes</span><a class="self-link" href="#wording-__self_func"></a></h3>
   <h4 class="heading settled" data-level="4.1.1" id="wording-__self_func-6.4.3.2"><span class="secno">4.1.1. </span><span class="content">Modify "Predefined identifiers" (6.4.3.2)</span><a class="self-link" href="#wording-__self_func-6.4.3.2"></a></h4>
   <ul>
    <li data-md>
     <p>change the mention of "execution encoding" in this section to instead be "literal encoding (6.2.9)";</p>
    <li data-md>
     <p>and, add <code class="highlight"><c- n>constexpr</c-></code> to the list of storage class specifiers for <code class="highlight"><c- k>static</c-> <c- k>const</c-> <c- b>char</c-> <c- n>__func__</c-><c- p>[]</c-> <c- o>=</c-> <c- s>"function-name"</c-></code>.</p>
   </ul>
   <h4 class="heading settled" data-level="4.1.2" id="wording-__self_func-6.4.2"><span class="secno">4.1.2. </span><span class="content">Add the new keyword <code class="highlight"><c- n>__self_func</c-></code> to §6.4.2</span><a class="self-link" href="#wording-__self_func-6.4.2"></a></h4>
   <blockquote>
    <p><strong>Syntax</strong></p>
    <p><sup>1</sup> <em>keyword:</em> one of</p>
    <dl>
     <dd data-md>
      <p>...</p>
     <dd data-md>
      <ins><code class="highlight"><c- n>__self_func</c-></code></ins>
    </dl>
   </blockquote>
   <h4 class="heading settled" data-level="4.1.3" id="wording-__self_func-6.5.2"><span class="secno">4.1.3. </span><span class="content">Add <code class="highlight"><c- n>__self_func</c-></code> to the <em>primary-expression</em> grammar of §6.5.2</span><a class="self-link" href="#wording-__self_func-6.5.2"></a></h4>
   <blockquote>
    <p><strong>Syntax</strong></p>
    <p><sup>1</sup> <em>primary-expression:</em></p>
    <dl>
     <dd data-md>
      <p>identifier</p>
     <dd data-md>
      <p>constant</p>
     <dd data-md>
      <p>string-literal</p>
     <dd data-md>
      <p>( expression )</p>
     <dd data-md>
      <p>generic-selection</p>
     <dd data-md>
      <ins><code class="highlight"><c- n>__self_func</c-></code></ins>
    </dl>
   </blockquote>
   <h4 class="heading settled" data-level="4.1.4" id="wording-__self_func-6.5.2.✨"><span class="secno">4.1.4. </span><span class="content">Add a new section §6.5.2.✨ "<code class="highlight"><c- n>__self_func</c-></code> after §6.5.2.1 "Generic selection"</span><a class="self-link" href="#wording-__self_func-6.5.2.✨"></a></h4>
   <blockquote>
    <ins>
     <div class="wording-clause-header"> <span class="wording-clause-number">6.5.2.✨</span> <span class="wording-clause-title"><code class="highlight"><c- n>__self_func</c-></code></span> </div>
     <div class="wording-section">
      <div class="wording-clause-section-title"> Constraints </div>
      <div class="wording-numbered">
       <p><code class="highlight"><c- n>__self_func</c-></code> shall only appear in the body of an invocable, and refers to the innermost invocable statement list it is inside.</p>
      </div>
      <div class="wording-clause-section-title"> Semantics </div>
      <div class="wording-numbered">
       <p><code class="highlight"><c- n>__self_func</c-></code> is either:</p>
       <ul>
        <li data-md>
         <p>the lvalue of the closure (6.2.✨1) that it is contained within;</p>
        <li data-md>
         <p>or, the function designator (6.3.3.1) designating and having the type of the function it is used in.</p>
       </ul>
      </div>
     </div>
    </ins>
   </blockquote>
   <h3 class="heading settled" data-level="4.2" id="wording-core"><span class="secno">4.2. </span><span class="content">Core, Shared Changes</span><a class="self-link" href="#wording-core"></a></h3>
   <h4 class="heading settled" data-level="4.2.1" id="wording-core-6.2.1"><span class="secno">4.2.1. </span><span class="content">Modify §6.2.1 "Scopes of identifiers, type names, and compound literals"</span><a class="self-link" href="#wording-core-6.2.1"></a></h4>
   <blockquote>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.2.1</span> <span class="wording-clause-title">Scopes of identifiers, type names, and compound literals</span> </div>
    <div class="wording-section">
     <div class="wording-numbered">
      <p>An identifier can denote:</p>
      <ul>
       <li data-md>
        <p>a standard attribute, an attribute prefix, or an attribute name;</p>
       <li data-md>
        <p>an object;</p>
       <li data-md>
        <p>a function;</p>
       <li data-md>
        <ins>a closure;</ins>
       <li data-md>
        <p>a tag or a member of a structure, union, or enumeration;</p>
       <li data-md>
        <p>a typedef name;</p>
       <li data-md>
        <p>a label name;</p>
       <li data-md>
        <p>a macro name;</p>
       <li data-md>
        <p>or, a macro parameter.</p>
      </ul>
     </div>
     <div class="wording-numbered">
      <p>
       For each different entity that an identifier designates, the identifier is <em>visible</em> (i.e. can be used) only within a region of program text called its scope. Different entities designated by the same identifier either have different scopes or are in different name spaces. There are four kinds of scopes: 
       <del>function</del>
       <ins>invocable</ins>
       , file, block, and function prototype. (A <em>function prototype</em> is a declaration of a function.)
      </p>
     </div>
     <div class="wording-numbered">
      <p>
       A label name is the only kind of identifier that has 
       <del><em>function scope</em></del>
       <ins><em>invocable scope</em></ins>
       . It can be used (in a <code class="highlight"><c- k>goto</c-></code> statement) anywhere in the 
       <del>function</del>
       <ins>body of the invocable (6.2.✨0)</ins>
        in which it appears
       <del>, and</del>
       <ins> excluding the body of any nested invocables, unless otherwise specified. It</ins>
        is declared implicitly by its syntactic appearance (followed by a <code class="highlight"><c- o>:</c-></code> and a statement).
       <ins> Each invocable body has an invocable scope that is separate from the invocable scope of any other invocable body. In particular, a label is visible in exactly one invocable scope (the innermost body in which it appears) and distinct invocable bodies may use the same identifier to designate different labels.</ins>
      </p>
     </div>
     <div> ... </div>
     <ins>
      <div class="wording-newnumbered wording-numbered-9">
       <p>NOTE   Properties of the feature to which an identifier refers are not necessarily uniformly available within its whole scope of visibility. Examples are identifiers or functions with an incomplete type that is only completed in a subscope of its visibility, labels that are only valid targets of <code class="highlight"><c- k>goto</c-></code> statements when the jump does not cross the scope of a VLA, identifiers of objects to which the access is restricted in specific contexts such as signal handlers or closures, or library features such as <code class="highlight"><c- n>setjmp</c-></code> where the use is restricted to a specific subset of the grammar.</p>
      </div>
     </ins>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.2.2" id="wording-core-6.2.5"><span class="secno">4.2.2. </span><span class="content">Modify §6.2.5 "Types"</span><a class="self-link" href="#wording-core-6.2.5"></a></h4>
   <blockquote>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.2.5</span> <span class="wording-clause-title">Types</span> </div>
    <div class="wording-section">
     <div class="wording-numbered">
      <p>...</p>
     </div>
     <div>
      <p>...</p>
     </div>
     <div class="wording-numbered wording-numbered-25">
      <p>Any number of derived types can be constructed from the object and function types, as follows:</p>
      <p>— ...</p>
      <ul>
       <li data-md>
        <p>A <em>function type</em> describes a function with specified return type. A function type is characterized by its return type and the number and types of its parameters. A function type is said to be derived from its return type, and if its return type is <em>T</em>, the function type is sometimes called "function returning <em>T</em>". The construction of a function type from a return type is called "function type derivation".</p>
       <li data-md>
        <ins>A <em>closure type</em> describes a structure or union type that is similar to a function with a specified or inferred return type (6.2.✨1). It is characterized by: its return type; the number, order, and type of its parameters; its lexical position in the program; and, the number, order, and type of its captures. The function type that has the same return type and list of parameter types as the closure type is the <em>closure’s function type</em>. A closure type is said to be derived from its function type’s return type and, if present, any of its captures. If its return type is <em>T</em>, the closure type is sometimes called "closure returning <em>T</em>" or "closure with captures returning <em>T</em>" (referring to closures with any number of captures, including zero captures).</ins>
       <li data-md>
        <p>...</p>
      </ul>
      <p>These methods of constructing derived types can be applied recursively.</p>
     </div>
     <div> ... </div>
     <div class="wording-numbered wording-numbered-29">
      <p>A complete type shall have a size that is less than or equal to <code class="highlight"><c- n>SIZE_MAX</c-></code>. A type has <em>known constant size</em> if it is complete and is not a variable length array type.</p>
     </div>
     <ins>
      <div class="wording-newnumbered">
       <p>An <em>invocable type</em> is either a closure type, a function type, or a pointer to function type (6.2.✨0).</p>
      </div>
      <div class="wording-newnumbered">
       <p>A <em>closure literal type</em> is a closure type characterized by having no captures. If its return type is <em>T</em>, the closure literal type is sometimes called "closure literal returning <em>T</em>" or "closure with no captures returning <em>T</em>". Closure literal types are a proper subset of the closure types.</p>
      </div>
     </ins>
     <div>
      <p>...</p>
     </div>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.2.3" id="wording-core-6.2.7"><span class="secno">4.2.3. </span><span class="content">Modify §6.2.7 "Compatible type and composite type"</span><a class="self-link" href="#wording-core-6.2.7"></a></h4>
   <blockquote>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.2.7</span> <span class="wording-clause-title">Compatible type and composite type</span> </div>
    <div> ... </div>
    <div class="wording-section">
     <div class="wording-numbered wording-numbered-3">
      <p>A <em>composite type</em> can be constructed from two types that are compatible. If both types are the same type, the composite type is this type. Otherwise, it is a type that is compatible with both and satisfies the following conditions:</p>
      <ul>
       <li data-md>
        <p>If both types are structure types or both types are union types, the composite type is determined recursively by forming the composite types of their members.</p>
       <li data-md>
        <p>If both types are array types, the following rules are applied:</p>
        <ul>
         <li data-md>
          <p>If one type is an array of known constant length, the composite type is an array of that length.</p>
         <li data-md>
          <p>Otherwise, if one type is a variable length array whose length is specified, the composite type is a variable length array of that length.</p>
         <li data-md>
          <p>Otherwise, if one type is a variable length array of unspecified length, the composite type is a variable length array of unspecified length.</p>
         <li data-md>
          <p>Otherwise, both types are arrays of unknown length, and the composite type is an array of unknown length.</p>
        </ul>
        <p>The element type of the composite type is the composite type of the two element types.</p>
       <li data-md>
        <p>If both types are function types, the type of each parameter in the composite parameter type list is the composite type of the corresponding parameters.</p>
       <li data-md>
        <ins>If both types are closure types, the composite function type of the closure types' function types and the composite of the implementation-defined structure or union type of the closure types is the composite type of the two closure types.</ins>
       <li data-md>
        <p>If one of the types has a standard attribute, the composite type also has that attribute.</p>
       <li data-md>
        <p>If both types are enumerated types, the composite type is an enumerated type.</p>
       <li data-md>
        <p>If one type is an enumerated type and the other is an integer type other than an enumerated type, it is implementation-defined whether or not the composite type is an enumerated type.</p>
      </ul>
      <p>These rules apply recursively to the types from which the two types are derived.</p>
     </div>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.2.4" id="wording-core-6.2.new0"><span class="secno">4.2.4. </span><span class="content">Add a new section §6.2.✨0 "Invocable", likely §6.2.10</span><a class="self-link" href="#wording-core-6.2.new0"></a></h4>
   <blockquote class="quote-ins">
    <div class="wording-clause-header"> <span class="wording-clause-number">6.2.✨0</span> <span class="wording-clause-title">Invocable</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Syntax </div>
     <div class="wording-numbered">
      <p><em>parameter-clause</em>:</p>
      <dl>
       <dd data-md>
        <p><code class="highlight"><c- p>(</c-></code> <em>parameter-type-list</em><sub><em>opt</em></sub> <code class="highlight"><c- p>)</c-></code></p>
      </dl>
     </div>
     <div class="wording-clause-section-title"> Description </div>
     <div class="wording-numbered">
      <p>An <em>invocable</em> is something with zero or more parameters (and possibly zero or more captures if it is a closure) that may be invoked/called to trigger an entry into and subsequent execution of an associated series of statements and/or expressions.</p>
     </div>
     <div class="wording-numbered">
      <p>Certain invocables can be declared (6.7.7) and potentially used before they are defined.</p>
     </div>
     <div class="wording-numbered">
      <p>Invocables are:</p>
      <ul>
       <li data-md>
        <p>functions and pointers to functions (6.3.3.1, 6.5.3.3, 6.7.7.4, 6.9.2);</p>
       <li data-md>
        <p>and, closures (6.2.✨1).</p>
      </ul>
     </div>
     <div class="wording-numbered">
      <p>The associated series of statements and/or expressions is called the <em>invocable body</em> or <em>body of the invocable</em>. The body of an invocable has its own scope, and that scope includes any captures it was created with and arguments it was invoked with. The scope that includes just the associated series of statements and/or expressions without the arguments or captures is called the <em>invocable statement list</em>. The scope in which an invocable is declared or defined is called the invocable’s <em>surrounding scope</em>, which is either the block scope of another invocable or file scope.</p>
     </div>
     <div class="wording-numbered">
      <p>As part of the declaration or definition of its parameter list, an invocable may include an ellipses in its list, either as the sole argument or at the end of its list. This is called a <em>variadic parameter</em>. Arguments supplied to an invocable whose positions match or come after the ellipses in the parameter list are its <em>varying arguments</em>. Any invocable which contains a variadic parameter is a <em>variadic invocable</em>. Additionally, functions with a variadic parameter are sometimes specifically called <em>variadic functions</em> and closures with a variadic parameter are sometimes specifically called <em>variadic closures</em>.</p>
     </div>
     <div class="wording-clause-section-title"> Constraints </div>
     <div class="wording-numbered">
      <p>Although variable length array types of unspecified size and incomplete types can be used as part of a parameter declaration for the declaration of an invocable, they shall not be used as part of a parameter declaration in the definition of an invocable.</p>
     </div>
     <div class="wording-numbered">
      <p>The only storage-class specifier that shall occur in a parameter declaration is <code class="highlight"><c- k>register</c-></code>.</p>
     </div>
     <div class="wording-numbered">
      <p>After adjustment, the parameters in a parameter type list in an invocable declarator (such as a function declarator) that is part of a definition of that invocable shall not have incomplete type.</p>
     </div>
     <div class="wording-numbered">
      <p>Except for <code class="highlight"><c- b>void</c-></code>, an invocable shall not specify a return type that is a function type, an array type, or an incomplete type.</p>
     </div>
     <div class="wording-numbered">
      <p>A parameter declaration shall not specify a <code class="highlight"><c- b>void</c-></code> type, except for the special case of a single unnamed parameter of type <code class="highlight"><c- b>void</c-></code> with no storage-class specifier, no type qualifier, and no following ellipsis terminator. If the parameter list consists of a single parameter of type <code class="highlight"><c- b>void</c-></code>, the parameter declarator shall not include an identifier.</p>
     </div>
     <div class="wording-clause-section-title"> Semantics </div>
     <div class="wording-numbered">
      <p>An invocable can have a sequence of arguments passed to it that comply with the constraints and requirements of the invocable’s list of parameters. An invocable’s parameters have automatic storage duration.</p>
     </div>
     <div class="wording-numbered">
      <p>The identifier of the parameter, if any, is an lvalue in the invocable body. Variable length array types of unspecified size shall not be used as part of a parameter declaration in an invocable definition. The layout of the storage for parameters is unspecified. The type of each parameter is adjusted as described later in this subclause.</p>
     </div>
     <div class="wording-numbered">
      <p>NOTE   A parameter that has no declared name is inaccessible within the invocable body. A parameter’s identifier cannot be redeclared in the invocable body except in an enclosed block. The visibility scope of a parameter in a function definition starts when its declaration is completed, extends to following parameter declarations, to possible attributes that follow the parameter type list, and then to the entire function body. The lifetime of each instance of a parameter starts when the declaration is evaluated starting a call and ends when that call terminates.</p>
     </div>
     <div class="wording-numbered">
      <p>The special case of an unnamed parameter of type <code class="highlight"><c- b>void</c-></code> as the only item in the parameter list specifies that the function has no parameters.</p>
     </div>
     <div class="wording-numbered">
      <p>A declaration of a parameter as "array of <em>type</em>" shall be adjusted to "qualified pointer to <em>type</em>", where the type qualifiers (if any) are those specified within the <code class="highlight"><c- p>[</c-></code> and <code class="highlight"><c- p>]</c-> </code>of the array type derivation. If the keyword <code class="highlight"><c- k>static</c-></code> also appears within the <code class="highlight"><c- p>[</c-></code> and <code class="highlight"><c- p>]</c-></code> of the array type derivation, then for each call to the function, the value of the corresponding actual argument must provide access to the first element of an array with at least as many elements as specified by the size expression.</p>
     </div>
     <div class="wording-numbered">
      <p>If, in a parameter declaration, an identifier can be treated either as a typedef name or as a parameter name, it shall be taken as a typedef name.</p>
     </div>
     <div class="wording-numbered">
      <p>A declaration of a parameter as "function returning <em>type</em>" shall be adjusted to "pointer to function returning <em>type</em>", as in 6.3.3.1.</p>
     </div>
     <div class="wording-numbered">
      <p>If the invocable declarator is not part of a definition of that invocable, parameters can have incomplete type and can use the <code class="highlight"><c- p>[</c-><c- o>*</c-><c- p>]</c-></code> notation in their sequences of declarator specifiers to specify variable length array types.</p>
     </div>
     <div class="wording-numbered">
      <p>The storage-class specifier in the declaration specifiers for a parameter declaration, if present, is ignored unless the declared parameter is one of the members of the parameter type list for the definition of the invocable. The optional attribute specifier sequence in a parameter declaration appertains to the parameter.</p>
     </div>
     <div class="wording-numbered">
      <p>On entry to the invocable, the size expressions of each variably modified parameter and typeof operators used in declarations of parameters are evaluated and the value of each argument expression is converted to the type of the corresponding parameter as if by assignment. (Array expressions and function designators as arguments were converted to pointers before the call.)</p>
     </div>
     <div class="wording-numbered">
      <p>After all parameters have been assigned, the invocable statement list is executed.</p>
     </div>
     <div class="wording-numbered">
      <p>Upon return to its invoker/caller from either finishing the execution of its body or returning, an invocable can either return nothing (indicated by the return type <code class="highlight"><c- b>void</c-></code>) or return a value of object type (6.8.7.5). Unless otherwise specified, if the end of the invocable body is reached (such as the terminating <code class="highlight"><c- p>{</c-></code>), and the value of the function call is used by the caller, the behavior is undefined.</p>
     </div>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.2.5" id="wording-core-6.2.new1"><span class="secno">4.2.5. </span><span class="content">Add a new section §6.2.✨1 "Closures", after §6.2.✨0 "Invocables", likely §6.2.11</span><a class="self-link" href="#wording-core-6.2.new1"></a></h4>
   <blockquote class="quote-ins">
    <div class="wording-clause-header"> <span class="wording-clause-number">6.2.✨1</span> <span class="wording-clause-title">Closures</span> </div>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.2.✨1.1</span> <span class="wording-clause-title">General</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Description </div>
     <div class="wording-numbered">
      <p>A <em>closure</em> is a structure or union object of invocable type which has zero or more captures and zero or more parameters.</p>
     </div>
     <div class="wording-numbered">
      <p>A closure’s object is composed of at least any information necessary to invoke it with its arguments and for its implicit or explicit captures (6.2.✨1.2).</p>
     </div>
     <div class="wording-clause-section-title"> Constraints </div>
     <div class="wording-numbered">
      <p>Within the invocable body of a closure, identifiers shall be used according to the usual scoping rules. Captures and parameters can be accessed by their name in the invocable body. However, no identifier that is a variably modified type or an object of variably modified type shall be used in the invocable statement list.</p>
     </div>
     <div class="wording-numbered">
      <p>An identifier that is an object of automatic storage duration which has a storage-class specifier of <code class="highlight"><c- n>constexpr</c-></code> may also be used, but its address shall not be taken in the invocable body of the closure.</p>
     </div>
     <div class="wording-numbered">
      <p>An object of closure literal type shall be convertible to a function pointer.</p>
     </div>
     <div class="wording-clause-section-title"> Semantics </div>
     <div class="wording-numbered">
      <p>A closure with zero captures has closure literal type. Otherwise, it has closure type.</p>
     </div>
     <div class="wording-numbered">
      <p>A closure literal is convertible to a function pointer. That function pointer is the same for every closure literal of that closure literal type. An invocation of that function pointer invokes the associated body of that closure with the provided arguments.</p>
     </div>
     <div class="wording-numbered">
      <p>A closure’s size, layout, and representation are all implementation-defined unless otherwise specified. Each closure’s type is unique, and is characterized by:</p>
      <ul>
       <li data-md>
        <p>any captures it can have;</p>
       <li data-md>
        <p>the function type it has, particularly any parameters it can have and its return type;</p>
       <li data-md>
        <p>and, the lexical position of the first declaration and/or definition.</p>
      </ul>
      <p>A closure’s type is not required to be compatible with any other type, unless otherwise specified.</p>
     </div>
     <div class="wording-numbered">
      <p>NOTE   Two closures with identical captures and parameter types are not necessarily compatible (e.g. assignable) to one another.</p>
     </div>
     <div class="wording-numbered">
      <p>Unless otherwise specified for the associated closure, each captured value can be accessed with the member access operator <code class="highlight"><c- p>.</c-></code> on that closure, or with the member access operator <code class="highlight"><c- o>-></c-></code> on a pointer to that closure, using the capture’s name. The layout of the storage for the captures of a closure is implementation-defined.</p>
     </div>
     <div class="wording-numbered">
      <p>NOTE   While accessing captures uses the member access operators, there is no requirements or constraints on what the actual members, layout, and other details of a closure is.</p>
     </div>
    </div>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.2.✨1.2</span> <span class="wording-clause-title">Captures</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Syntax </div>
     <div class="wording-numbered">
      <p><em>capture-list</em></p>
      <dl>
       <dd data-md>
        <p><em>capture-default</em></p>
       <dd data-md>
        <p><em>capture-name-list</em></p>
       <dd data-md>
        <p><em>capture-default</em> <code class="highlight"><c- p>,</c-></code> <em>capture-name-list</em></p>
      </dl>
      <p><em>capture-name-list</em>:</p>
      <dl>
       <dd data-md>
        <p><em>capture</em></p>
       <dd data-md>
        <p><em>capture-name-list</em> <code class="highlight"><c- p>,</c-></code> <em>capture</em></p>
      </dl>
      <p><em>capture-default</em>:</p>
      <dl>
       <dd data-md>
        <p><code class="highlight"><c- o>=</c-></code></p>
       <dd data-md>
        <p><code class="highlight"><c- o>&amp;</c-></code></p>
      </dl>
      <p><em>capture</em>:</p>
      <dl>
       <dd data-md>
        <p><code class="highlight"><c- o>&amp;</c-></code><sub>opt</sub> <em>identifier</em> <em>capture-rename</em><sub><em>opt</em></sub></p>
      </dl>
      <p><em>capture-rename</em>:</p>
      <dl>
       <dd data-md>
        <p><code class="highlight"><c- o>=</c-></code> <em>assignment-expression</em></p>
      </dl>
     </div>
     <div class="wording-clause-section-title"> Description </div>
     <div class="wording-numbered">
      <p>"Capturing" an object or a "captured" object describes the process of making visible objects from a surrounding scope visible in an inner, more nested invocable scope.</p>
     </div>
     <div class="wording-numbered">
      <p>A <em>capture list</em> allows access to objects visible in a certain scope named by the capture’s identifier or computed by the optional capture rename. A <em>capture</em> is an entry in the capture list.</p>
     </div>
     <div class="wording-numbered">
      <p>The <code class="highlight"><c- o>=</c-></code> capture default is a <em>default value capture</em>. The <code class="highlight"><c- o>&amp;</c-></code> capture default is a <em>default reference capture</em>. Either one is called a <em>default capture</em>. The identifier in a capture is the <em>capture name</em>. The optional capture rename is the <em>capture initialization expression</em>. A capture with no capture initialization expression is called a <em>identifier capture</em>. A capture with a capture initialization expression is called an <em>expression capture</em>.</p>
     </div>
     <div class="wording-numbered">
      <p>If present, the closure which the capture partly characterizes and modifies is called the <em>associated closure</em>. The capture list’s <em>associated scope</em> is the surrounding scope of the associated closure unless otherwise specified.</p>
     </div>
     <div class="wording-numbered">
      <p>A capture name with no preceding <code class="highlight"><c- o>&amp;</c-></code> is called a <em>value capture</em>. A capture name preceded by a <code class="highlight"><c- o>&amp;</c-></code> is called a <em>reference capture</em>.</p>
     </div>
     <div class="wording-clause-section-title"> Constraints </div>
     <div class="wording-numbered">
      <p>The capture name shall appear at most once across the capture list and, if present, the parameter names of an associated closure. If the capture list’s associated scope is file scope, then no captures or default captures are permitted in the list.</p>
     </div>
     <div class="wording-numbered">
      <p>For a capture that is a reference capture and an identifier capture, the identifier shall be an object which is addressable. For a capture that is a reference capture and an expression capture, the capture initialization expression shall be an addressable lvalue.</p>
     </div>
     <div class="wording-numbered">
      <p>For an identifier capture, the capture name shall be a visible identifier of automatic storage duration from the associated scope.</p>
     </div>
     <div class="wording-numbered">
      <p>If a default value capture is specified, then subsequent captures shall only be reference captures. If a default reference capture is specified, then subsequent captures shall only be value captures.</p>
     </div>
     <div class="wording-numbered">
      <p>The type of the capture shall not be a variably modified type.</p>
     </div>
     <div class="wording-numbered">
      <p>NOTE   Parameters of variably modified type are allowed to be captured because their type after adjustment is a pointer type.</p>
     </div>
     <div class="wording-clause-section-title"> Semantics </div>
     <div class="wording-numbered">
      <p>Capture lists are evaluated when their associated closure is defined and evaluated. The order of evaluation for captures are sequenced in order of declaration. The capture name is complete after its optional capture initialization expression. An earlier capture may occur within the capture initialization expression of a later capture.</p>
     </div>
     <div class="wording-numbered">
      <p>Value captures provide the value at time of evaluation of the capture when used. It is either the value of the identifier it refers to if it is an identifier capture, or the value of the capture initialization expression used to compute it if it is an expression capture. Unless otherwise specified, value captures have either:</p>
      <ul>
       <li data-md>
        <p>the storage duration of an associated closure (if present);</p>
       <li data-md>
        <p>or, automatic storage duration.</p>
      </ul>
     </div>
     <div class="wording-numbered">
      <p>NOTE   A possible implementation of value captures is having a stored member in the closure object that is accessed every time it is used within the associated closure.</p>
     </div>
     <div class="wording-numbered">
      <p>Reference captures are lvalues that either:</p>
      <ul>
       <li data-md>
        <p>refer to an identifier which exists in the surrounding scope identified by the capture name (if it is an identifier capture);</p>
       <li data-md>
        <p>or, to the addressable lvalue of the capture initialization expression at the time of evaluation (if it is an expression capture).</p>
      </ul>
      <p>If a reference capture is used after the lifetime of what it refers to or addresses finishes, the behavior is undefined.</p>
     </div>
     <div class="wording-numbered">
      <p>NOTE   A possible implementation of reference captures is storing a value capture of the address of the desired addressable lvalue in the closure object, and automatically dereferencing it upon its use in the associated closure.</p>
     </div>
     <div class="wording-numbered">
      <p>If a default capture is present, then it behaves as if all automatic storage duration objects visible in the surrounding scope are:</p>
      <ul>
       <li data-md>
        <p>value captured, for <code class="highlight"><c- o>=</c-></code>;</p>
       <li data-md>
        <p>or, reference captured, for <code class="highlight"><c- o>&amp;</c-></code>.</p>
      </ul>
     </div>
     <div class="wording-numbered">
      <p>For a capture, let <em>T</em><sub><em>capture-initial</em></sub> be:</p>
      <ul>
       <li data-md>
        <p><code class="highlight"><c- n>typeof</c-><c- p>(</c-><c- n>identifier</c-><c- p>)</c-></code>, where <code class="highlight"><c- n>identifier</c-></code> is the capture name if it is identifier capture;</p>
       <li data-md>
        <p>or, the type of the capture initialization expression if it is an expression capture.</p>
      </ul>
      <p>Let <em>T</em><sub><em>capture</em></sub> be the type of the capture after lvalue, array-to-pointer, or function designator to pointer conversion is applied to <em>T</em><sub><em>capture-initial</em></sub>. The type of a capture is <code class="highlight"><c- n>T</c-><sub><em><c- n>capture</c-></em></sub> <c- k>const</c-></code>, unless otherwise specified.</p>
     </div>
     <div class="wording-numbered">
      <p>NOTE   A capture therefore will not have array type itself, but a member of the captured type can possibly have array type.</p>
     </div>
     <div class="wording-clause-section-title"> Recommended practice </div>
     <div class="wording-numbered">
      <p>If all captures in a capture list are reference captures, implementations are encouraged to take advantage of potential layout and storage optimizations which respect to the lifetime of any associated closure.</p>
     </div>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.2.6" id="wording-core-6.3.3.1"><span class="secno">4.2.6. </span><span class="content">Modify §6.3.3.1 "Lvalues, arrays, and function designators"</span><a class="self-link" href="#wording-core-6.3.3.1"></a></h4>
   <blockquote>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.3.3.1</span> <span class="wording-clause-title">Lvalues, arrays, and function designators</span> </div>
    <div class="wording-section">
     <div class="wording-numbered">
      <p>...</p>
     </div>
     <div class="wording-numbered wording-numbered-4">
      <p>
       A <em>function designator</em> is an expression that has 
       <del>function</del>
       <ins>invocable</ins>
        type. Except when it is the operand of the <code class="highlight"><c- k>sizeof</c-></code> operator, a typeof operator, or the unary <code class="highlight"><c- o>&amp;</c-></code> operator, a function designator with type
       <del> "function returning <em>type</em>" is converted to an expression that has type "pointer to function returning <em>type</em>"</del>
       <ins>:</ins>
      </p>
      <ins>
       <ul>
        <li data-md>
         <p>"function returning <em>R</em>";</p>
        <li data-md>
         <p>or, "closure literal returning <em>R</em>",</p>
       </ul>
       <p>is converted to an expression that has type "pointer to function returning <em>R</em>", where "<em>R</em>" is the return type.</p>
      </ins>
     </div>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.2.7" id="wording-core-6.5.3.3"><span class="secno">4.2.7. </span><span class="content">Modify §6.5.3.3 "Function calls"</span><a class="self-link" href="#wording-core-6.5.3.3"></a></h4>
   <p>In order,</p>
   <ol>
    <li data-md>
     <p>Replace the title "Function calls" with "Invocation"</p>
    <li data-md>
     <p>Outside the EXAMPLE and NOTE text, replace every instance of "type pointer to function" with "invocable type".</p>
    <li data-md>
     <p>Outside the EXAMPLE and NOTE text, replace every instance of "function type" with "invocable type".</p>
    <li data-md>
     <p>Outside the EXAMPLE and NOTE text, replace every instance of "a function" with "an invocable".</p>
    <li data-md>
     <p>Outside the EXAMPLE and NOTE text, replace every instance of "function" with "invocable", EXCEPT:</p>
     <ul>
      <li data-md>
       <p>"... ellipses in a variadic function declarator (6.7.7.4) ..." becomes "... ellipsis notation in a variadic invocable (6.2.✨0) ..."</p>
     </ul>
    <li data-md>
     <p>Add a new description section before the Constraints:</p>
     <blockquote>
      <ins>
        <strong>Description</strong> 
       <p><sup>1</sup> Invocation, sometimes referred to as a "function call", "invocable call", "closure call", "function invocation", or "closure invocation", refers to calling an invocable (e.g. a function or (closure) object) and triggering the execution of the invocable’s statement list, as described in 6.2.✨0.</p>
      </ins>
     </blockquote>
   </ol>
   <h4 class="heading settled" data-level="4.2.8" id="wording-core-6.5.5"><span class="secno">4.2.8. </span><span class="content">Modify §6.5.5 "Cast operators"</span><a class="self-link" href="#wording-core-6.5.5"></a></h4>
   <blockquote>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.5.5</span> <span class="wording-clause-title">Cast operators</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Constraints </div>
     <div> ... </div>
     <div class="wording-numbered wording-numbered-4">
      <p>
       A pointer type shall be converted only to <code class="highlight"><c- b>void</c-></code>, an integer type, or a pointer type. Only a pointer, integer,
       <ins> closure literal</ins>
        or <code class="highlight"><c- n>nullptr_t</c-></code> type shall be converted to a pointer type. The type <code class="highlight"><c- n>nullptr_t</c-></code> shall not be converted to any type other than <code class="highlight"><c- b>void</c-></code>, <code class="highlight"><c- b>bool</c-></code> or a pointer type. If the target type is <code class="highlight"><c- n>nullptr_t</c-></code>, the cast expression shall be a null pointer constant or have type <code class="highlight"><c- n>nullptr_t</c-></code>.
       <ins> A closure literal type shall not be converted to any pointer type other than a pointer to the closure’s function type.</ins>
      </p>
     </div>
     <div class="wording-clause-section-title"> Semantics </div>
     <div> ... </div>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.2.9" id="wording-core-6.5.17.2"><span class="secno">4.2.9. </span><span class="content">Modify §6.5.17.2 "Simple assignment"</span><a class="self-link" href="#wording-core-6.5.17.2"></a></h4>
   <blockquote>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.5.17.2</span> <span class="wording-clause-title">Simple assignment</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Constraints </div>
     <div class="wording-numbered">
      <p>One of the following shall hold:</p>
      <ul>
       <li data-md>
        <p>the left operand has atomic, qualified, or unqualified arithmetic type, and the right operand has arithmetic type;</p>
       <li data-md>
        <p>the left operand has an atomic, qualified, or unqualified version of a structure or union type compatible with the type of the right operand;</p>
       <li data-md>
        <p>the left operand has atomic, qualified, or unqualified pointer type, and (considering the type the left operand would have after lvalue conversion) both operands are pointers to qualified or unqualified versions of compatible types, and the type pointed to by the left operand has all the qualifiers of the type pointed to by the right operand;</p>
       <li data-md>
        <p>the left operand has atomic, qualified, or unqualified pointer type, and (considering the type the left operand would have after lvalue conversion) one operand is a pointer to an object type, and the other is a pointer to a qualified or unqualified version of <code class="highlight"><c- b>void</c-></code>, and the type pointed to by the left operand has all the qualifiers of the type pointed to by the right operand;</p>
       <li data-md>
        <ins>the left operand has atomic, qualified, or unqualified pointer type, and (considering the type the left operand would have after lvalue conversion) one operand is a pointer to a function type, and the other is a closure literal type whose function type is compatible with the left’s pointed to function type;</ins>
       <li data-md>
        <p>the left operand has an atomic, qualified, or unqualified version of the <code class="highlight"><c- n>nullptr_t</c-></code> type and the right operand is a null pointer constant or its type is <code class="highlight"><c- n>nullptr_t</c-></code>;</p>
       <li data-md>
        <p>the left operand is an atomic, qualified, or unqualified pointer, and the right operand is a null pointer constant or its type is <code class="highlight"><c- n>nullptr_t</c-></code>; or</p>
       <li data-md>
        <p>the left operand has type atomic, qualified, or unqualified <code class="highlight"><c- b>bool</c-></code>, and the right operand is a pointer or its type is <code class="highlight"><c- n>nullptr_t</c-></code>.</p>
      </ul>
     </div>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.2.10" id="wording-core-6.7.7.4"><span class="secno">4.2.10. </span><span class="content">Remove §6.7.7.4 "Function declarators" to rewrite in a new version it in terms of invocables</span><a class="self-link" href="#wording-core-6.7.7.4"></a></h4>
   <blockquote class="quote-ins">
    <div class="wording-clause-header"> <span class="wording-clause-number">6.7.7.4</span> <span class="wording-clause-title">Function declarators</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Description </div>
     <div class="wording-numbered">
      <p>If, in the declaration "<code class="highlight"><c- n>T</c-> <c- n>D1</c-></code>", <code class="highlight"><c- n>D1</c-></code> has the form</p>
      <dl>
       <dd data-md>
        <p><code class="highlight"><c- n>D</c-></code> <em>parameter-clause</em> <em>attribute-specifier-sequence</em><sub><em>opt</em></sub></p>
      </dl>
      <p>and the type specified for ident in the declaration "<code class="highlight"><c- n>T</c-> <c- n>D</c-></code>" is "<em>derived-declarator-type-list</em> <code class="highlight"><c- n>T</c-></code>", then it is an invocable declarator (6.2.✨0) and the type specified for <em>ident</em> is "<em>derived-declarator-type-list</em> function returning the unqualified, non-atomic version of <code class="highlight"><c- n>T</c-></code>".</p>
     </div>
     <div class="wording-clause-section-title"> Semantics </div>
     <div class="wording-numbered">
      <p>The optional attribute specifier sequence appertains to the function type.</p>
     </div>
     <div class="wording-numbered">
      <p>Two function types are compatible if and only if all of the following hold:</p>
      <ul>
       <li data-md>
        <p>They specify compatible return types.</p>
       <li data-md>
        <p>The parameter type lists agree in the number of parameters and in whether the function is variadic or not.</p>
       <li data-md>
        <p>The corresponding parameters have compatible types.</p>
      </ul>
      <p>In the determination of type compatibility and of a composite type, each parameter declared with function or array type is taken as having the adjusted type and each parameter declared with qualified type is taken as having the unqualified version of its declared type.</p>
     </div>
     <div class="wording-numbered">
      <p>EXAMPLE   The declaration</p>
<pre class="language-cpp highlight"><c- b>int</c-> <c- nf>f</c-><c- p>(</c-><c- b>void</c-><c- p>),</c-> <c- o>*</c-><c- n>fip</c-><c- p>(),</c-> <c- p>(</c-><c- o>*</c-><c- n>pfi</c-><c- p>)();</c->
</pre>
      <p>declares a function <code class="highlight"><c- n>f</c-></code> with no parameters returning an <code class="highlight"><c- b>int</c-></code>, a function <code class="highlight"><c- n>fip</c-></code> with no parameters returning a pointer to an <code class="highlight"><c- b>int</c-></code>, and a pointer <code class="highlight"><c- n>pfi</c-></code> to a function with no parameters returning an <code class="highlight"><c- b>int</c-></code>. It is especially useful to compare the last two. The binding of <code class="highlight"><c- o>*</c-><c- n>fip</c-><c- p>()</c-></code> is <code class="highlight"><c- o>*</c-><c- p>(</c-><c- n>fip</c-><c- p>())</c-></code>, so that the declaration suggests, and the same construction in an expression requires, the calling of a function <code class="highlight"><c- n>fip</c-></code>, and then using indirection through the pointer result to yield an <code class="highlight"><c- b>int</c-></code>. In the declarator <code class="highlight"><c- p>(</c-><c- o>*</c-><c- n>pfi</c-><c- p>)()</c-></code>, the extra parentheses are necessary to indicate that indirection through a pointer to a function yields a function designator, which is then used to call the function; it returns an <code class="highlight"><c- b>int</c-></code>.</p>
      <p>If the declaration occurs outside of any function, the identifiers have file scope and external linkage. If the declaration occurs inside a function, the identifiers of the functions <code class="highlight"><c- n>f</c-></code> and <code class="highlight"><c- n>fip</c-></code> have block scope and either internal or external linkage (depending on what file scope declarations for these identifiers are visible), and the identifier of the pointer <code class="highlight"><c- n>pfi</c-></code> has block scope and no linkage.</p>
     </div>
     <div class="wording-numbered">
      <p>EXAMPLE   The declaration</p>
<pre class="language-cpp highlight"><c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>apfi</c-><c- p>[</c-><c- mi>3</c-><c- p>])(</c-><c- b>int</c-> <c- o>*</c-><c- n>x</c-><c- p>,</c-> <c- b>int</c-> <c- o>*</c-><c- n>y</c-><c- p>);</c->
</pre>
      <p>declares an array <code class="highlight"><c- n>apfi</c-></code> of three pointers to functions returning <code class="highlight"><c- b>int</c-></code>. Each of these functions has two parameters that are pointers to <code class="highlight"><c- b>int</c-></code>. The identifiers <code class="highlight"><c- n>x</c-></code> and <code class="highlight"><c- n>y</c-></code> are declared for descriptive purposes only and go out of scope at the end of the declaration of <code class="highlight"><c- n>apfi</c-></code>.</p>
     </div>
     <div class="wording-numbered">
      <p>EXAMPLE   The declaration</p>
<pre class="language-cpp highlight"><c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>fpfi</c-><c- p>(</c-><c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- p>)(</c-><c- b>long</c-><c- p>),</c-> <c- b>int</c-><c- p>))(</c-><c- b>int</c-><c- p>,</c-> <c- p>...);</c->
</pre>
      <p>declares a function <code class="highlight"><c- n>fpfi</c-></code> that returns a pointer to a function returning an <code class="highlight"><c- b>int</c-></code>. The function <code class="highlight"><c- n>fpfi</c-></code> has two parameters: a pointer to a function returning an <code class="highlight"><c- b>int</c-></code> (with one parameter of type <code class="highlight"><c- b>long</c-> <c- b>int</c-></code>), and an <code class="highlight"><c- b>int</c-></code>. The pointer returned by <code class="highlight"><c- n>fpfi</c-></code> points to a function that has one int parameter and accepts zero or more additional arguments of any type.</p>
     </div>
     <div class="wording-numbered">
      <p>EXAMPLE   The following prototype has a variably modified parameter.</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>addscalar</c-><c- p>(</c-><c- b>int</c-> <c- n>n</c-><c- p>,</c-> <c- b>int</c-> <c- n>m</c-><c- p>,</c-> <c- b>double</c-> <c- n>a</c-><c- p>[</c-><c- n>n</c-><c- p>][</c-><c- n>n</c-><c- o>*</c-><c- n>m</c-><c- o>+</c-><c- mi>300</c-><c- p>],</c-> <c- b>double</c-> <c- n>x</c-><c- p>);</c->

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>void</c-><c- p>)</c->
<c- p>{</c->
  <c- b>double</c-> <c- n>b</c-><c- p>[</c-><c- mi>4</c-><c- p>][</c-><c- mi>308</c-><c- p>];</c->
  <c- n>addscalar</c-><c- p>(</c-><c- mi>4</c-><c- p>,</c-> <c- mi>2</c-><c- p>,</c-> <c- n>b</c-><c- p>,</c-> <c- mf>2.17</c-><c- p>);</c->
  <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
<c- p>}</c->

<c- b>void</c-> <c- nf>addscalar</c-><c- p>(</c-><c- b>int</c-> <c- n>n</c-><c- p>,</c-> <c- b>int</c-> <c- n>m</c-><c- p>,</c-> <c- b>double</c-> <c- n>a</c-><c- p>[</c-><c- n>n</c-><c- p>][</c-><c- n>n</c-><c- o>*</c-><c- n>m</c-><c- o>+</c-><c- mi>300</c-><c- p>],</c-> <c- b>double</c-> <c- n>x</c-><c- p>)</c->
<c- p>{</c->
  <c- k>for</c-> <c- p>(</c-><c- b>int</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>0</c-><c- p>;</c-> <c- n>i</c-> <c- o>&lt;</c-> <c- n>n</c-><c- p>;</c-> <c- n>i</c-><c- o>++</c-><c- p>)</c->
    <c- k>for</c-> <c- p>(</c-><c- b>int</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>0</c-><c- p>,</c-> <c- n>k</c-> <c- o>=</c-> <c- n>n</c-><c- o>*</c-><c- n>m</c-><c- o>+</c-><c- mi>300</c-><c- p>;</c-> <c- n>j</c-> <c- o>&lt;</c-> <c- n>k</c-><c- p>;</c-> <c- n>j</c-><c- o>++</c-><c- p>)</c->
      <c- c1>// a is a pointer to a VLA with n*m+300 elements</c->
      <c- n>a</c-><c- p>[</c-><c- n>i</c-><c- p>][</c-><c- n>j</c-><c- p>]</c-> <c- o>+=</c-> <c- n>x</c-><c- p>;</c->
<c- p>}</c->
</pre>
     </div>
     <div class="wording-numbered">
      <p>EXAMPLE   The following are all compatible function prototype declarators.</p>
<pre class="language-cpp highlight"><c- b>double</c-> <c- nf>maximum</c-><c- p>(</c-><c- b>int</c-> <c- n>n</c-><c- p>,</c-> <c- b>int</c-> <c- n>m</c-><c- p>,</c-> <c- b>double</c-> <c- n>a</c-><c- p>[</c-><c- n>n</c-><c- p>][</c-><c- n>m</c-><c- p>]);</c->
<c- b>double</c-> <c- nf>maximum</c-><c- p>(</c-><c- b>int</c-> <c- n>n</c-><c- p>,</c-> <c- b>int</c-> <c- n>m</c-><c- p>,</c-> <c- b>double</c-> <c- n>a</c-><c- p>[</c-><c- o>*</c-><c- p>][</c-><c- o>*</c-><c- p>]);</c->
<c- b>double</c-> <c- nf>maximum</c-><c- p>(</c-><c- b>int</c-> <c- n>n</c-><c- p>,</c-> <c- b>int</c-> <c- n>m</c-><c- p>,</c-> <c- b>double</c-> <c- n>a</c-><c- p>[</c-> <c- p>][</c-><c- o>*</c-><c- p>]);</c->
<c- b>double</c-> <c- nf>maximum</c-><c- p>(</c-><c- b>int</c-> <c- n>n</c-><c- p>,</c-> <c- b>int</c-> <c- n>m</c-><c- p>,</c-> <c- b>double</c-> <c- n>a</c-><c- p>[</c-> <c- p>][</c-><c- n>m</c-><c- p>]);</c->
</pre>
      <p>as are:</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>f</c-><c- p>(</c-><c- b>double</c-> <c- p>(</c-><c- o>*</c-> <c- kr>restrict</c-> <c- n>a</c-><c- p>)[</c-><c- mi>5</c-><c- p>]);</c->
<c- b>void</c-> <c- nf>f</c-><c- p>(</c-><c- b>double</c-> <c- n>a</c-><c- p>[</c-><c- kr>restrict</c-><c- p>][</c-><c- mi>5</c-><c- p>]);</c->
<c- b>void</c-> <c- nf>f</c-><c- p>(</c-><c- b>double</c-> <c- n>a</c-><c- p>[</c-><c- kr>restrict</c-> <c- mi>3</c-><c- p>][</c-><c- mi>5</c-><c- p>]);</c->
<c- b>void</c-> <c- nf>f</c-><c- p>(</c-><c- b>double</c-> <c- n>a</c-><c- p>[</c-><c- kr>restrict</c-> <c- k>static</c-> <c- mi>3</c-><c- p>][</c-><c- mi>5</c-><c- p>]);</c->
</pre>
      <p>The last declaration also specifies that the argument corresponding to a in any call to <code class="highlight"><c- n>f</c-></code> can be expected to be a non-null pointer to the first of at least three arrays of 5 <code class="highlight"><c- b>double</c-></code>s, which the others do not.</p>
     </div>
    </div>
   </blockquote>
   <p><em>📝 IMPORTANT Editor’s Note: Undefined Behavior List J.2 references 6.7.7.4 -- change to 6.2.✨0.</em></p>
   <h4 class="heading settled" data-level="4.2.11" id="wording-core-6.8.1"><span class="secno">4.2.11. </span><span class="content">Modify §6.8 "Statements and blocks"'s §6.8.1 "General" for blanket jump/label banning</span><a class="self-link" href="#wording-core-6.8.1"></a></h4>
   <blockquote>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.8</span> <span class="wording-clause-title">Statements and blocks</span> </div>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.8.1</span> <span class="wording-clause-title">General</span> </div>
    <div class="wording-section">
     <ins>
      <div class="wording-clause-section-title"> Constraints </div>
      <div class="wording-newnumbered">
       <p>Unless otherwise specified, every jump and label is associated with the innermost invocable body it is contained within. Nested declarations or definitions of invocable bodies shall not refer to jump, iteration, or labeled statements in the invocable’s surrounding scope and shall only refer to a visible label or statement in the body of the associated invocable’s scope.</p>
      </div>
     </ins>
     <div class="wording-clause-section-title"> Semantics </div>
     <div class="wording-numbered">
      <p>A <em>statement</em> specifies an action to be performed. Except as indicated, statements are executed in sequence. The optional attribute specifier sequence appertains to the respective statement.</p>
     </div>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.2.12" id="wording-core-6.8.3"><span class="secno">4.2.12. </span><span class="content">Modify §6.8.3 "Compound Statement"</span><a class="self-link" href="#wording-core-6.8.3"></a></h4>
   <blockquote>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.8.3</span> <span class="wording-clause-title">Compound Statement</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Semantics </div>
     <div class="wording-numbered">
      <p>
       A <em>compound statement</em> that is a 
       <del>function body</del>
       <ins>invocable body</ins>
        together with the parameter type list and the optional attribute specifier sequence between them forms the block associated with the function definition
       <ins> or closure definition</ins>
        in which it appears. Otherwise, it is a block that is different from any other block. A label that is not followed by another label or an unlabeled statement shall be translated as if it were followed by a null statement.
      </p>
     </div>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.2.13" id="wording-core-6.9.2"><span class="secno">4.2.13. </span><span class="content">Rewrite §6.9.2 "Function definitions" in terms of Invocables</span><a class="self-link" href="#wording-core-6.9.2"></a></h4>
   <blockquote class="quote-ins">
    <div class="wording-clause-header"> <span class="wording-clause-number">6.9.2</span> <span class="wording-clause-title">Function definition</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Description </div>
     <div class="wording-numbered">
      <p>A function definition defines (or declares and defines) the invocable body of a function call. Its surrounding scope is always file scope, even if a function declarator at block scope is the first encountered declaration of such a function.</p>
     </div>
     <div class="wording-clause-section-title"> Constraints </div>
     <div class="wording-numbered">
      <p>The identifier declared in a function definition (which is the name of the function) shall have a function type, as specified by the declarator portion of the function definition.</p>
     </div>
     <div class="wording-numbered">
      <p>The storage-class specifier, if any, in the declaration specifiers shall be either <code class="highlight"><c- k>extern</c-></code> or <code class="highlight"><c- k>static</c-></code>.</p>
     </div>
     <div class="wording-clause-section-title"> Semantics </div>
     <div class="wording-numbered">
      <p>The optional attribute specifier sequence in a function definition appertains to the function.</p>
     </div>
     <div class="wording-numbered">
      <p>The declarator in a function definition specifies the name of the function being defined and the types (and optionally the names) of all the parameters; the declarator also serves as a function prototype for later calls to the same function in the same translation unit. The type of each parameter is adjusted as described in 6.2.✨0.</p>
     </div>
     <div class="wording-numbered">
      <p>NOTE   In a function definition, the return type of the function and its prototype cannot be inherited from a typedef:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- nf>F</c-><c- p>(</c-><c- b>void</c-><c- p>);</c->
<c- c1>// type F is "function with no parameters returning int"</c->

<c- n>F</c-> <c- n>f</c-><c- p>,</c-> <c- n>g</c-><c- p>;</c->                      <c- c1>// f and g both have type compatible with F</c->
<c- n>F</c-> <c- n>f</c-> <c- p>{</c-> <c- d>/* ... */</c-> <c- p>}</c->            <c- c1>// WRONG: syntax/constraint error</c->
<c- n>F</c-> <c- n>g</c-><c- p>()</c-> <c- p>{</c-> <c- d>/* ... */</c-> <c- p>}</c->          <c- c1>// WRONG: declares that g returns a function</c->
<c- b>int</c-> <c- n>f</c-><c- p>(</c-><c- b>void</c-><c- p>)</c-> <c- p>{</c-> <c- d>/* ... */</c-> <c- p>}</c->    <c- c1>// RIGHT: f has type compatible with F</c->
<c- b>int</c-> <c- n>g</c-><c- p>()</c-> <c- p>{</c-> <c- d>/* ... */</c-> <c- p>}</c->        <c- c1>// RIGHT: g has type compatible with F</c->
<c- n>F</c-> <c- o>*</c-><c- n>e</c-><c- p>(</c-><c- b>void</c-><c- p>)</c-> <c- p>{</c-> <c- d>/* ... */</c-> <c- p>}</c->     <c- c1>// e returns a pointer to a function</c->
<c- n>F</c-> <c- o>*</c-><c- p>((</c-><c- n>e</c-><c- p>))(</c-><c- b>void</c-><c- p>)</c-> <c- p>{</c-> <c- d>/* ... */</c-> <c- p>}</c-> <c- c1>// same: parentheses irrelevant</c->
<c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>fp</c-><c- p>)(</c-><c- b>void</c-><c- p>);</c->             <c- c1>// fp points to a function that has type F</c->
<c- n>F</c-> <c- o>*</c-><c- n>Fp</c-><c- p>;</c->                       <c- c1>// Fp points to a function that has type F</c->
</pre>
     </div>
     <div class="wording-numbered">
      <p>EXAMPLE  In the following:</p>
<pre class="language-cpp highlight"><c- k>extern</c-> <c- b>int</c-> <c- nf>max</c-><c- p>(</c-><c- b>int</c-> <c- n>a</c-><c- p>,</c-> <c- b>int</c-> <c- n>b</c-><c- p>)</c->
<c- p>{</c->
  <c- k>return</c-> <c- n>a</c-> <c- o>></c-> <c- n>b</c-> <c- o>?</c-> <c- n>a</c-><c- o>:</c-> <c- n>b</c-><c- p>;</c->
<c- p>}</c->
</pre>
      <p><code class="highlight"><c- k>extern</c-></code> is the storage-class specifier and <code class="highlight"><c- b>int</c-></code> is the type specifier; <code class="highlight"><c- n>max</c-><c- p>(</c-><c- b>int</c-> <c- n>a</c-><c- p>,</c-> <c- b>int</c-> <c- n>b</c-><c- p>)</c-></code> is the function declarator; and <code class="highlight"><c- p>{</c-> <c- k>return</c-> <c- n>a</c-> <c- o>></c-> <c- n>b</c-> <c- o>?</c-> <c- n>a</c-><c- o>:</c-> <c- n>b</c-><c- p>;</c-> <c- p>}</c-></code> is the function body.</p>
     </div>
     <div class="wording-numbered">
      <p>EXAMPLE  To pass one function to another, one can say</p>
<pre class="language-cpp highlight"><c- b>int</c-> <c- nf>f</c-><c- p>(</c-><c- b>void</c-><c- p>);</c->
<c- d>/* ... */</c->
<c- n>g</c-><c- p>(</c-><c- n>f</c-><c- p>);</c->
</pre>
      <p>Then the definition of <code class="highlight"><c- n>g</c-></code> can read</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>g</c-><c- p>(</c-><c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>funcp</c-><c- p>)(</c-><c- b>void</c-><c- p>))</c->
<c- p>{</c->
  <c- d>/* ... */</c->
  <c- p>(</c-><c- o>*</c-><c- n>funcp</c-><c- p>)();</c-> <c- d>/* or funcp(); */</c->
<c- p>}</c->
</pre>
      <p>or, equivalently,</p>
<pre class="language-cpp highlight"><c- b>void</c-> <c- nf>g</c-><c- p>(</c-><c- b>int</c-> <c- n>func</c-><c- p>(</c-><c- b>void</c-><c- p>))</c->
<c- p>{</c->
  <c- d>/* ... */</c->
  <c- n>func</c-><c- p>();</c-> <c- d>/* or (*func)(); */</c->
<c- p>}</c->
</pre>
     </div>
    </div>
   </blockquote>
   <h3 class="heading settled" data-level="4.3" id="wording-lambda"><span class="secno">4.3. </span><span class="content">Lambda Expression Changes</span><a class="self-link" href="#wording-lambda"></a></h3>
   <h4 class="heading settled" data-level="4.3.1" id="wording-lambda-6.5.3.1"><span class="secno">4.3.1. </span><span class="content">Add <em>lambda-expression</em> to the <em>postfix-expression</em> grammar of §6.5.3.1</span><a class="self-link" href="#wording-lambda-6.5.3.1"></a></h4>
   <blockquote>
    <p><strong>Syntax</strong></p>
    <p><sup>1</sup> <em>postfix-expression:</em></p>
    <dl>
     <dd data-md>
      <p><em>primary-expression</em></p>
     <dd data-md>
      <p><em>postfix-expression</em> <code class="highlight"><c- p>[</c-></code> <em>expression</em> <code class="highlight"><c- p>]</c-></code></p>
     <dd data-md>
      <p><em>postfix-expression</em> <code class="highlight"><c- p>(</c-></code> <em>argument-expression-list</em><sub><em>opt</em></sub> <code class="highlight"><c- p>)</c-></code></p>
     <dd data-md>
      <p><em>postfix-expression</em> <code class="highlight"><c- p>.</c-></code> <em>identifier</em></p>
     <dd data-md>
      <p><em>postfix-expression</em> <code class="highlight"><c- o>-></c-></code> <em>identifier</em></p>
     <dd data-md>
      <p><em>postfix-expression</em> <code class="highlight"><c- o>++</c-></code></p>
     <dd data-md>
      <p><em>postfix-expression</em> <code class="highlight"><c- o>--</c-></code></p>
     <dd data-md>
      <p><em>compound-literal</em></p>
     <dd data-md>
      <ins><em>lambda-expression</em></ins>
    </dl>
   </blockquote>
   <h4 class="heading settled" data-level="4.3.2" id="wording-lambda-6.5.3.new"><span class="secno">4.3.2. </span><span class="content">Add a new section §6.5.3.✨ "Lambda expressions" somewhere after §6.5.3.4 "Structure and union members", likely §6.5.3.5</span><a class="self-link" href="#wording-lambda-6.5.3.new"></a></h4>
   <blockquote class="quote-ins">
    <div class="wording-clause-header"> <span class="wording-clause-number">6.5.3.✨</span> <span class="wording-clause-title">Lambda expressions</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Syntax </div>
     <div class="wording-numbered">
      <p><em>lambda-expression</em>:</p>
      <dl>
       <dd data-md>
        <p><em>terse-capture-clause</em> <em>attribute-specifier-sequence</em><sub><em>opt</em></sub> <em>parameter-clause</em><sub><em>opt</em></sub> <em>attribute-specifier-sequence</em><sub><em>opt</em></sub> <em>trailing-return-clause</em><sub><em>opt</em></sub> <em>function-body</em></p>
      </dl>
      <p><em>terse-capture-clause</em>:</p>
      <dl>
       <dd data-md>
        <p><code class="highlight"><c- p>[</c-></code> <em>capture-list</em><sub><em>opt</em></sub> <code class="highlight"><c- p>]</c-></code></p>
      </dl>
      <p><em>trailing-return-clause</em>:</p>
      <dl>
       <dd data-md>
        <p><code class="highlight"><c- o>-></c-></code> <em>type-name</em></p>
      </dl>
     </div>
     <div class="wording-clause-section-title"> Description </div>
     <div class="wording-numbered">
      <p>A lambda expression (or just "lambda") creates a closure definition that is immediately usable as an invocable. It is introduced and partly characterized by the terse capture clause, has parameters listed in the optional parameter clause, and has a surrounding scope of either:</p>
      <ul>
       <li data-md>
        <p>the block scope at the lexical position within an invocable;</p>
       <li data-md>
        <p>or, file scope.</p>
      </ul>
     </div>
     <div class="wording-clause-section-title"> Constraints </div>
     <div class="wording-numbered">
      <p>If a lambda or pointer to lambda is the first operand of the <code class="highlight"><c- p>.</c-></code> operator or <code class="highlight"><c- o>-></c-></code> operator, respectively, the second operand shall only specify a capture name from that lambda’s capture clause as the identifier to designate a member.</p>
     </div>
     <div class="wording-numbered">
      <p>If the trailing return clause is specified, the return type of the lambda is the specified type name. Otherwise, the return type is inferred from the body of the lambda expression. If the return type is inferred, then:</p>
      <ul>
       <li data-md>
        <p>all <code class="highlight"><c- k>return</c-></code> statements shall have an expression which is the exact same type of any one <code class="highlight"><c- k>return</c-></code> statement’s an expression;</p>
       <li data-md>
        <p>or, <code class="highlight"><c- b>void</c-></code> if there is no expression for all the return statements or there are no return statements.</p>
      </ul>
     </div>
     <div class="wording-clause-section-title"> Semantics </div>
     <div class="wording-numbered">
      <p>The optional attribute specifier sequence in a lambda expression appertains to the resulting lambda type and to its function type. If the parameter clause is omitted, and parameter clause of the form <code class="highlight"><c- p>()</c-></code> is assumed.</p>
     </div>
     <div class="wording-numbered">
      <p>EXAMPLE   In following lambda object initialization:</p>
<pre class="language-cpp highlight"><c- b>int</c-> <c- nf>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- p>[[</c-><c- n>deprecated</c-><c- p>]]</c-> <c- k>auto</c-> <c- n>f</c-> <c- o>=</c-> <c- p>[]()</c-> <c- p>[[</c-><c- n>unsequenced</c-><c- p>]]</c-> <c- p>{</c->
    <c- k>return</c-> <c- mi>2</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>f</c-><c- p>();</c->
<c- p>}</c->
</pre>
      <p><code class="highlight"><c- p>[[</c-><c- n>unsequenced</c-><c- p>]]</c-></code> describes the properties of the invocable body through its its function type, while <code class="highlight"><c- p>[[</c-><c- n>deprecated</c-><c- p>]]</c-></code> applies to the closure object <code class="highlight"><c- n>f</c-></code> and a diagnostic is encouraged at the invocation of <code class="highlight"><c- n>f</c-></code> in <code class="highlight"><c- k>return</c-> <c- n>f</c-><c- p>()</c-></code>.</p>
     </div>
     <div class="wording-numbered">
      <p>Similar to a function definition, a lambda expression forms a single block that comprises all of its parts. Each capture and parameter has a scope of visibility that starts immediately after its definition is completed and extends to the end of the lambda body. Captures and parameters are visible throughout the body of a lambda unless they are redeclared in an inner block within that lambda’s body.</p>
     </div>
     <div class="wording-numbered">
      <p>Value captures have the same storage duration as the lambda. Value captures are initialized and formed during the evaluation of the lambda expression, and are tied to that specific lambda expression’s closure. Each invocation to the formed lambda creates a new instance of each parameter, similar to a function call. The layout of the storage for parameters is unspecified.</p>
     </div>
     <div class="wording-numbered">
      <p>The behavior is undefined if the lifetime of the lvalue referred ends and the reference capture is used.</p>
     </div>
     <div class="wording-numbered">
      <p>EXAMPLE   Non-capturing lambdas can be immediately converted to function pointers, which makes them usable in functions such as <code class="highlight"><c- n>qsort</c-></code>:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>

<c- b>int</c-> <c- nf>main</c-><c- p>(</c-><c- b>int</c-> <c- n>argc</c-><c- p>,</c-> <c- b>char</c-><c- o>*</c-> <c- n>argv</c-><c- p>[])</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>list</c-><c- p>[]</c-> <c- o>=</c-> <c- p>{</c-> <c- mi>2</c-><c- p>,</c-> <c- mi>11</c-><c- p>,</c-> <c- mi>32</c-><c- p>,</c-> <c- mi>49</c-><c- p>,</c-> <c- mi>57</c-><c- p>,</c-> <c- mi>20</c-><c- p>,</c-> <c- mi>110</c-><c- p>,</c-> <c- mi>203</c-> <c- p>};</c->
  <c- n>qsort</c-><c- p>(</c-><c- n>list</c-><c- p>,</c-> <c- n>_Countof</c-><c- p>(</c-><c- n>list</c-><c- p>),</c-> <c- k>sizeof</c-><c- p>(</c-><c- o>*</c-><c- n>list</c-><c- p>),</c->
    <c- p>[]()</c-> <c- p>(</c-><c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_left</c-><c- p>,</c-> <c- k>const</c-> <c- b>void</c-><c- o>*</c-> <c- n>untyped_right</c-><c- p>)</c-> <c- p>{</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>left</c-> <c- o>=</c-> <c- n>untyped_left</c-><c- p>;</c->
      <c- k>const</c-> <c- b>int</c-><c- o>*</c-> <c- n>right</c-> <c- o>=</c-> <c- n>untyped_right</c-><c- p>;</c->
      <c- k>return</c-> <c- o>*</c-><c- n>left</c-> <c- o>-</c-> <c- o>*</c-><c- n>right</c-><c- p>;</c->
    <c- p>}</c->
  <c- p>);</c->
	
  <c- k>return</c-> <c- n>list</c-><c- p>[</c-><c- mi>0</c-><c- p>];</c-> <c- c1>// return 2;</c->
<c- p>}</c->
</pre>
     </div>
    </div>
   </blockquote>
   <h3 class="heading settled" data-level="4.4" id="wording-capture.functions"><span class="secno">4.4. </span><span class="content">Capture Function Changes</span><a class="self-link" href="#wording-capture.functions"></a></h3>
   <h4 class="heading settled" data-level="4.4.1" id="wording-capture.functions-6.7.7.1"><span class="secno">4.4.1. </span><span class="content">Add <em>capture-function-declarator</em> to the <em>direct-declarator</em> grammars of §6.7.7.1 "General" of "Declarators"</span><a class="self-link" href="#wording-capture.functions-6.7.7.1"></a></h4>
   <blockquote>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.7.7.1</span> <span class="wording-clause-title">General</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Syntax </div>
     <div class="wording-numbered">
      <p>...</p>
      <p><em>direct-declarator</em>:</p>
      <dl>
       <dd data-md>
        <p><em>identifier</em> <em>attribute-specifier-sequence</em><sub><em>opt</em></sub></p>
       <dd data-md>
        <p><code class="highlight"><c- p>(</c-></code> <em>declarator</em> <code class="highlight"><c- p>)</c-></code></p>
       <dd data-md>
        <p><em>array-declarator</em> <em>attribute-specifier-sequence</em><sub><em>opt</em></sub></p>
       <dd data-md>
        <p><em>function-declarator</em> <em>attribute-specifier-sequence</em><sub><em>opt</em></sub></p>
       <dd data-md>
        <ins><em>capture-function-declarator</em> <em>attribute-specifier-sequence</em><sub><em>opt</em></sub></ins>
      </dl>
      <p>...</p>
     </div>
     <div> ... </div>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.4.2" id="wording-capture.functions-6.7.7.new"><span class="secno">4.4.2. </span><span class="content">Add a new section §6.7.7.✨ "Capture function declarators" somewhere after §6.7.7.4 "Function declarators", likely becoming §6.7.7.5</span><a class="self-link" href="#wording-capture.functions-6.7.7.new"></a></h4>
   <blockquote class="quote-ins">
    <div class="wording-clause-header"> <span class="wording-clause-number">6.7.7.✨</span> <span class="wording-clause-title">Capture function declarators</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Syntax </div>
     <div class="wording-numbered">
      <p><em>capture-function-declarator</em>:</p>
      <dl>
       <dd data-md>
        <p><em>direct-declarator</em> <em>parameter-clause</em> <em>function-capture-clause</em></p>
      </dl>
      <p><em>function-capture-clause</em>:</p>
      <dl>
       <dd data-md>
        <p><code class="highlight"><c- n>_Capture</c-></code> <code class="highlight"><c- p>(</c-></code> <em>capture-list</em><sub><em>opt</em></sub> <code class="highlight"><c- p>)</c-></code></p>
      </dl>
     </div>
     <div class="wording-clause-section-title"> Description </div>
     <div class="wording-numbered">
      <p>A capture function declarator declares a closure object. It is introduced similarly to a function declarator but is characterized by the function capture clause as well as its lexical position, and has a surrounding scope of either:</p>
      <ul>
       <li data-md>
        <p>the block scope at the lexical position within an invocable;</p>
       <li data-md>
        <p>or, file scope.</p>
      </ul>
     </div>
     <div class="wording-clause-section-title"> Constraints </div>
     <div class="wording-numbered">
      <p>The identifier declared in a capture function declarator (which is the name of the capture function) shall have closure type, as specified by the declarator portion of the capture function declarator.</p>
     </div>
     <div class="wording-numbered">
      <p>A capture function object that is declared but not yet defined (6.9.✨) shall not have the member access operators <code class="highlight"><c- p>.</c-></code> on the object or <code class="highlight"><c- o>-></c-></code> the a pointer to that object applied to it.</p>
     </div>
     <div class="wording-clause-section-title"> Semantics </div>
     <div class="wording-numbered">
      <p>If, in the declaration "<code class="highlight"><c- n>T</c-> <c- n>D1</c-></code>", <code class="highlight"><c- n>D1</c-></code> has the form</p>
      <dl>
       <dd data-md>
        <p><code class="highlight"><c- n>D</c-></code> <em>parameter-clause</em> <em>function-capture-clause</em> <em>attribute-specifier-sequence</em><sub><em>opt</em></sub></p>
      </dl>
      <p>and the type specified for the identifier <em>ident</em> in the declaration "<code class="highlight"><c- n>T</c-></code> <code class="highlight"><c- n>D</c-></code>" is "<em>derived-declarator-type-list</em> <code class="highlight"><c- n>T</c-></code>", then the type specified for <em>ident</em> is "<em>derived-declarator-type-list</em> closure returning the unqualified, non-atomic version of <code class="highlight"><c- n>T</c-></code>". The type is complete after the end of the function capture clause. The optional attribute specifier sequence appertains to the closure’s function type.</p>
     </div>
     <div class="wording-numbered">
      <p>The second optional attribute specifier sequence after the parameter type list appertains to the closure object.</p>
     </div>
     <div class="wording-numbered">
      <p>EXAMPLE   In following capture function declaration and definition:</p>
<pre class="language-cpp highlight"><c- b>int</c-> <c- nf>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- p>[[</c-><c- n>unsequenced</c-><c- p>]]</c-> <c- b>int</c-> <c- n>f</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>()</c-> <c- p>[[</c-><c- n>deprecated</c-><c- p>]]</c-> <c- p>{</c->
    <c- k>return</c-> <c- mi>2</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>f</c-><c- p>();</c->
<c- p>}</c->
</pre>
      <p><code class="highlight"><c- p>[[</c-><c- n>unsequenced</c-><c- p>]]</c-></code> appertains to and describes the properties of the invocable body through its its function type, while <code class="highlight"><c- p>[[</c-><c- n>deprecated</c-><c- p>]]</c-></code> appertains and applies to the closure object <code class="highlight"><c- n>f</c-></code> and a diagnostic is encouraged at the invocation of <code class="highlight"><c- n>f</c-></code> in <code class="highlight"><c- k>return</c-> <c- n>f</c-><c- p>()</c-></code>.</p>
     </div>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.4.3" id="wording-capture.functions-6.7.8"><span class="secno">4.4.3. </span><span class="content">Add <em>capture-function-abstract-declarator</em> to the <em>direct-abstract-declarator</em> grammars of §6.7.8 "Type names"</span><a class="self-link" href="#wording-capture.functions-6.7.8"></a></h4>
   <blockquote>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.7.8</span> <span class="wording-clause-title">Type names</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Syntax </div>
     <div class="wording-numbered">
      <p>...</p>
      <p><em>direct-abstract-declarator</em>:</p>
      <dl>
       <dd data-md>
        <p><code class="highlight"><c- p>(</c-></code> <em>abstract-declarator</em> <code class="highlight"><c- p>)</c-></code></p>
       <dd data-md>
        <p><em>array-abstract-declarator</em> <em>attribute-specifier-sequence</em><sub><em>opt</em></sub></p>
       <dd data-md>
        <p><em>function-abstract-declarator</em> <em>attribute-specifier-sequence</em><sub><em>opt</em></sub></p>
       <dd data-md>
        <ins><em>capture-function-abstract-declarator</em> <em>attribute-specifier-sequence</em><sub><em>opt</em></sub></ins>
      </dl>
      <p>...</p>
      <ins>
       <p><em>capture-function-abstract-declarator</em>:</p>
       <dl>
        <dd data-md>
         <p><em>direct-abstract-declarator</em><sub><em>opt</em></sub> <em>parameter-clause</em> <em>function-capture-clause</em></p>
       </dl>
      </ins>
     </div>
     <div class="wording-clause-section-title"> Semantics </div>
     <div class="wording-numbered">
      <p>In several contexts, it is necessary to specify a type. This is accomplished using a type name, which is syntactically a declaration for a function or an object of that type that omits the identifier. The optional attribute specifier sequence in a direct abstract declarator appertains to the preceding array or function type. The attribute specifier sequence affects the type only for the declaration it appears in, not other declarations involving the same type.</p>
     </div>
     <div class="wording-numbered">
       EXAMPLE   The constructions 
<pre class="language-cpp highlight"><c- p>(</c-><c- n>a</c-><c- p>)</c->  <c- b>int</c->
<c- p>(</c-><c- n>b</c-><c- p>)</c->  <c- b>int</c-> <c- o>*</c->
<c- p>(</c-><c- n>c</c-><c- p>)</c->  <c- b>int</c-> <c- o>*</c-><c- p>[</c-><c- mi>3</c-><c- p>]</c->
<c- p>(</c-><c- n>d</c-><c- p>)</c->  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- p>)[</c-><c- mi>3</c-><c- p>]</c->
<c- p>(</c-><c- n>e</c-><c- p>)</c->  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- p>)[</c-><c- o>*</c-><c- p>]</c->
<c- p>(</c-><c- n>f</c-><c- p>)</c->  <c- b>int</c-> <c- o>*</c-><c- p>()</c->
<c- p>(</c-><c- n>g</c-><c- p>)</c->  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- p>)(</c-><c- b>void</c-><c- p>)</c->
<c- p>(</c-><c- n>h</c-><c- p>)</c->  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- k>const</c-> <c- p>[])(</c-><c- b>unsigned</c-> <c- b>int</c-><c- p>,</c-> <c- p>...)</c->
<c- p>(</c-><c- n>i</c-><c- p>)</c->  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- p>)()</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>&amp;</c-><c- p>)</c->
<c- p>(</c-><c- n>j</c-><c- p>)</c->  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- k>const</c-> <c- p>[])(</c-><c- b>unsigned</c-> <c- b>int</c-><c- p>,</c-> <c- p>...)</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>=</c-><c- p>)</c->
</pre>
      <p>name respectively the types</p>
      <dl>
       <dd data-md>
        <p>(a) <code class="highlight"><c- b>int</c-></code>,</p>
       <dd data-md>
        <p>(b) pointer to <code class="highlight"><c- b>int</c-></code>,</p>
       <dd data-md>
        <p>(c) array of three pointers to <code class="highlight"><c- b>int</c-></code>,</p>
       <dd data-md>
        <p>(d) pointer to an array of three <code class="highlight"><c- b>int</c-></code>s,</p>
       <dd data-md>
        <p>(e) pointer to a variable length array of an unspecified number of <code class="highlight"><c- b>int</c-></code>s,</p>
       <dd data-md>
        <p>(f) function with no parameters returning a pointer to <code class="highlight"><c- b>int</c-></code>,</p>
       <dd data-md>
        <p>(g) pointer to function with no parameters returning an <code class="highlight"><c- b>int</c-></code>, and</p>
       <dd data-md>
        <p>(h) array of an unspecified number of constant pointers to functions, each with one parameter that has type <code class="highlight"><c- b>unsigned</c-> <c- b>int</c-></code> and an unspecified number of other parameters, returning an <code class="highlight"><c- b>int</c-></code>.</p>
       <dd data-md>
        <ins>(i) pointer to closure which takes no parameters and default captures the current scope by reference, returning an <code class="highlight"><c- b>int</c-></code>.</ins>
       <dd data-md>
        <ins>(j) array of an unspecified number of constant pointers to closures, which take an <code class="highlight"><c- b>unsigned</c-> <c- b>int</c-></code>, an unspecified number of other parameters, and default captures by value of the current scope, returning an <code class="highlight"><c- b>int</c-></code>.</ins>
      </dl>
      <ins>The constructions (i) and (j), while valid types, are nonsensical as the lexical position of the abstract declarator for such a types makes it unique, regardless of the similarity of captures and function types of the closure type. Such a type may not be meaningfully useful in the program’s text for interacting with closures and closure types.</ins>
     </div>
     <ins>
      <div class="wording-numbered">
       <p>NOTE   As indicated by the syntax, empty parentheses in a type name are interpreted as "function with no parameters", rather than redundant parentheses around the omitted identifier.</p>
      </div>
     </ins>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.4.4" id="wording-capture.functions-6.8.3"><span class="secno">4.4.4. </span><span class="content">Modify §6.8.3 "Compound statements" and add a new grammar production for "<em>block-item</em>"</span><a class="self-link" href="#wording-capture.functions-6.8.3"></a></h4>
   <blockquote>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.8.3</span> <span class="wording-clause-title">Compound statements</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Syntax </div>
     <div class="wording-numbered">
      <p>...</p>
      <p><em>block-item</em>:</p>
      <dl>
       <dd data-md>
        <p><em>declaration</em></p>
       <dd data-md>
        <ins><em>function-definition</em></ins>
       <dd data-md>
        <ins><em>capture-function-definition</em></ins>
       <dd data-md>
        <p><em>unlabeled-statement</em></p>
       <dd data-md>
        <p><em>label</em></p>
      </dl>
     </div>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.4.5" id="wording-capture.functions-6.9"><span class="secno">4.4.5. </span><span class="content">Modify the title of §6.9 to feature more than external definitions to "Definitions" and add a new grammar production for "<em>external-declaration</em>"</span><a class="self-link" href="#wording-capture.functions-6.9"></a></h4>
   <blockquote>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.9</span> <span class="wording-clause-title"><ins>Definitions</ins><del>External definitions</del></span> </div>
    <div class="wording-clause-header"> <span class="wording-clause-number">6.9.1</span> <span class="wording-clause-title">General</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Syntax </div>
     <div class="wording-numbered">
      <p><em>translation-unit</em>:</p>
      <dl>
       <dd data-md>
        <p><em>external-declaration</em></p>
       <dd data-md>
        <p><em>translation-unit</em> <em>external-declaration</em></p>
      </dl>
      <p><em>external-declaration</em>:</p>
      <dl>
       <dd data-md>
        <p><em>function-definition</em></p>
       <dd data-md>
        <ins><em>capture-function-definition</em></ins>
       <dd data-md>
        <p><em>declaration</em></p>
      </dl>
     </div>
    </div>
   </blockquote>
   <h4 class="heading settled" data-level="4.4.6" id="wording-capture.functions-6.9.new"><span class="secno">4.4.6. </span><span class="content">Add a new section §6.9.✨ "Capture function definitions" somewhere after §6.9.2 "Function definitions", likely 6.9.3</span><a class="self-link" href="#wording-capture.functions-6.9.new"></a></h4>
   <blockquote class="quote-ins">
    <div class="wording-clause-header"> <span class="wording-clause-number">6.9.✨</span> <span class="wording-clause-title">Capture function definitions</span> </div>
    <div class="wording-section">
     <div class="wording-clause-section-title"> Syntax </div>
     <div class="wording-numbered">
      <p><em>capture-function-definition</em>:</p>
      <dl>
       <dd data-md>
        <p><em>direct-declarator</em> <em>parameter-clause</em> <em>function-capture-clause</em> <em>attribute-specifier-sequence</em><sub><em>opt</em></sub> <em>function-body</em></p>
      </dl>
     </div>
     <div class="wording-clause-section-title"> Description </div>
     <div class="wording-numbered">
      <p>A capture function definition declares and defines an invocable of closure type. All of the description, constraints, and semantic requirements in 6.7.7.✨ apply to a capture function definition, with a few additional constraints and semantics as follows.</p>
     </div>
     <div class="wording-clause-section-title"> Constraints </div>
     <div class="wording-numbered">
      <p>The storage-class specifier, if any, in the declaration specifiers shall not be <code class="highlight"><c- k>typedef</c-></code>.</p>
     </div>
     <div class="wording-numbered">
      <p>If a capture function or pointer to capture functions is the first operand of the <code class="highlight"><c- p>.</c-></code> operator or <code class="highlight"><c- o>-></c-></code> operator, respectively, the second operand shall only specify a capture name from its function capture clause as the identifier to designate a member.</p>
     </div>
     <div class="wording-clause-section-title"> Semantics </div>
     <div class="wording-numbered">
      <p>At block scope, a function definition is interpreted as a capture function definition with the empty function capture clause <code class="highlight"><c- n>_Capture</c-><c- p>()</c-></code>.</p>
     </div>
     <div class="wording-numbered">
      <p>EXAMPLE   In following capture function declaration:</p>
<pre class="language-cpp highlight"><c- b>int</c-> <c- nf>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- p>[[</c-><c- n>unsequenced</c-><c- p>]]</c-> <c- b>int</c-> <c- n>f</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>()</c-> <c- p>[[</c-><c- n>deprecated</c-><c- p>]]</c-> <c- p>{</c->
    <c- k>return</c-> <c- mi>2</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>f</c-><c- p>();</c->
<c- p>}</c->
</pre>
      <p><code class="highlight"><c- p>[[</c-><c- n>unsequenced</c-><c- p>]]</c-></code> describes the properties of the invocable body through its its function type, while <code class="highlight"><c- p>[[</c-><c- n>deprecated</c-><c- p>]]</c-></code> applies to the closure object <code class="highlight"><c- n>f</c-></code> and a diagnostic is encouraged at the invocation of <code class="highlight"><c- n>f</c-></code> in <code class="highlight"><c- k>return</c-> <c- n>f</c-><c- p>()</c-></code>.</p>
     </div>
     <div class="wording-numbered">
      <p>Similar to a function definition, a capture function forms a single block that comprises all of its parts. Each capture and parameter has a scope of visibility that starts immediately after its definition is completed and extends to the end of the capture function’s body. Captures and parameters are visible throughout the body of a capture function unless they are redeclared in an inner block within that capture function’s body.</p>
     </div>
     <div class="wording-numbered">
      <p>Value captures have the same storage duration as the capture function. Value captures are initialized and formed during the evaluation of the capture function, and are tied to that specific capture function’s closure. Each invocation of the capture function creates a new instance of each parameter, similar to a function call. The layout of the storage for parameters is implementation-defined.</p>
     </div>
     <div class="wording-numbered">
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdlib.h>

<c- k>typedef</c-> <c- b>int</c-> <c- nf>seven_fn_trampoline_t</c-><c- p>(</c-><c- b>void</c-><c- o>*</c-><c- p>);</c->
<c- k>typedef</c-> <c- k>struct</c-> <c- nc>seven_fn_data</c-> <c- p>{</c->
  <c- n>seven_fn_trampoline_t</c-><c- o>*</c-> <c- n>f</c-><c- p>;</c->
  <c- b>void</c-><c- o>*</c-> <c- n>p</c-><c- p>;</c->
<c- p>}</c-> <c- n>seven_fn_data</c-><c- p>;</c->

<c- n>seven_fn_data</c-> <c- nf>make_seven</c-> <c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>)</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>y</c-> <c- o>=</c-> <c- mi>7</c-><c- p>;</c->
  <c- b>int</c-> <c- n>seven_fn</c-><c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- n>x</c-><c- p>,</c-> <c- n>y</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- n>y</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>typedef</c-> <c- n>typeof</c-><c- p>(</c-><c- n>seven_fn</c-><c- p>)</c-> <c- n>seven_fn_t</c-><c- p>;</c->
  <c- b>int</c-> <c- n>seven_fn_trampoline</c-><c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>p</c-><c- p>)</c-> <c- p>{</c->
    <c- n>seven_fn_t</c-><c- o>*</c-> <c- n>seven_fn</c-> <c- o>=</c-> <c- n>p</c-><c- p>;</c->
    <c- k>return</c-> <c- n>seven_fn</c-><c- p>();</c->
  <c- p>}</c->
  <c- n>seven_fn_data</c-> <c- n>d</c-> <c- o>=</c-> <c- p>{</c->
    <c- p>.</c-><c- n>f</c-> <c- o>=</c-> <c- n>seven_fn_trampoline</c-><c- p>,</c-> <c- c1>// OK: closure literal</c->
    <c- p>.</c-><c- n>p</c-> <c- o>=</c-> <c- n>malloc</c-><c- p>(</c-><c- k>sizeof</c-><c- p>(</c-><c- n>seven_fn</c-><c- p>))</c->
  <c- p>};</c->
  <c- c1>// simple assignment of closure into allocated storage</c->
  <c- o>*</c-><c- p>((</c-><c- n>seven_fn_t</c-><c- o>*</c-><c- p>)</c-><c- n>d</c-><c- p>.</c-><c- n>p</c-><c- p>)</c-> <c- o>=</c-> <c- n>seven_fn</c-><c- p>;</c->
  <c- k>return</c-> <c- n>d</c-><c- p>;</c-> 
<c- p>}</c->

<c- k>typedef</c-> <c- b>int</c-> <c- nf>eight_fn_t</c-><c- p>();</c->

<c- n>eight_fn_t</c-><c- o>*</c-> <c- nf>make_eight</c-> <c- p>()</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>eight_fn</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>()</c-> <c- p>{</c->
    <c- k>return</c-> <c- mi>8</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>eight_fn</c-><c- p>;</c-> <c- c1>// OK: empty capture means closure literal</c->
<c- p>}</c->

<c- k>typedef</c-> <c- b>int</c-> <c- nf>nine_fn_t</c-><c- p>();</c->

<c- n>nine_fn_t</c-><c- o>*</c-> <c- nf>make_nine</c-> <c- p>()</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>val</c-> <c- o>=</c-> <c- mi>30</c-><c- p>;</c->
  <c- b>int</c-> <c- n>nine_fn</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- n>val</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>val</c-><c- p>;</c->
  <c- p>}</c->
  <c- k>return</c-> <c- n>nine_fn</c-><c- p>;</c-> <c- c1>// constraint violation: cannot convert</c->
  <c- c1>// closure to function pointer</c->
<c- p>}</c->

<c- b>int</c-> <c- nf>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>10</c-><c- p>;</c->
  <c- b>int</c-> <c- n>zero</c-> <c- p>()</c-> <c- p>{</c->
    <c- c1>// OK, no external variables used</c->
    <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>also_zero</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>()</c-> <c- p>{</c->
    <c- c1>// same as above, just explicit</c->
    <c- k>return</c-> <c- mi>0</c-><c- p>;</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>double_it</c-> <c- p>()</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>2</c-><c- p>;</c-> <c- c1>// constraint violation</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>also_wrong</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>()</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>2</c-><c- p>;</c-> <c- c1>// constraint violation</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>triple_it</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- n>x</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>3</c-><c- p>;</c-> <c- c1>// OK, x = 3 when called</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>quadruple_it</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>&amp;</c-><c- n>x</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>4</c-><c- p>;</c-> <c- c1>// OK, x = 5 when called</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>quintuple_it</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>=</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>5</c-><c- p>;</c-> <c- c1>// OK, x = 3 when called</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>sextuple_it</c-> <c- p>()</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>&amp;</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>*</c-> <c- mi>6</c-><c- p>;</c-> <c- c1>// OK, x = 5 when caled</c->
  <c- p>}</c->
  <c- n>x</c-> <c- o>=</c-> <c- mi>1000</c-><c- p>;</c->
	
  <c- b>void</c-><c- o>*</c-> <c- n>trampoline_data</c-> <c- o>=</c-> <c- k>nullptr</c-><c- p>;</c->
  <c- k>auto</c-> <c- n>seven_tuple_it</c-> <c- o>=</c-> <c- n>make_seven</c-><c- p>(</c-><c- n>x</c-><c- p>);</c->
	
  <c- n>eight_fn_t</c-><c- o>*</c-> <c- n>eight</c-> <c- o>=</c-> <c- n>make_eight</c-><c- p>();</c->
  <c- b>int</c-> <c- n>result</c-> <c- o>=</c-> <c- n>zero</c-><c- p>()</c->
    <c- o>+</c-> <c- n>triple_it</c-><c- p>()</c-> <c- o>+</c-> <c- n>quadruple_it</c-><c- p>()</c->
    <c- o>+</c-> <c- n>quintuple_it</c-><c- p>()</c-> <c- o>+</c-> <c- n>sextuple_it</c-><c- p>()</c->
    <c- o>+</c-> <c- n>seven_tuple_it</c-><c- p>.</c-><c- n>f</c-><c- p>(</c-><c- n>seven_tuple_it</c-><c- p>.</c-><c- n>d</c-><c- p>)</c->
    <c- o>+</c-> <c- n>eight</c-><c- p>();</c->
  <c- c1>// same as</c->
  <c- c1>// int result = 17088;</c->
  <c- c1>// 0</c->
  <c- c1>// + (10 * 3) + (1000 * 4)</c->
  <c- c1>// + (10 * 5) + (1000 * 6)</c->
  <c- c1>//            + (1000 * 7)</c->
  <c- c1>// + 8</c->
  <c- n>free</c-><c- p>(</c-><c- n>seven_tuple_it</c-><c- p>.</c-><c- n>d</c-><c- p>);</c->
  <c- k>return</c-> <c- n>result</c-><c- p>;</c->
<c- p>}</c->
</pre>
     </div>
    </div>
   </blockquote>
   <h2 class="heading settled" data-level="5" id="appendix"><span class="secno">5. </span><span class="content">Appendix</span><a class="self-link" href="#appendix"></a></h2>
   <h3 class="heading settled" data-level="5.1" id="appendix-nested.functions.context"><span class="secno">5.1. </span><span class="content">Accessing Context in Nested Functions</span><a class="self-link" href="#appendix-nested.functions.context"></a></h3>
   <p>A newer paper by Dr. Martin Uecker discusses the various ways to access GNU Nested Functions and their potential future standardization (<a data-link-type="biblio" href="#biblio-n3654" title="n3654: Accessing the Context of Nested Functions">[n3654]</a>). It addresses the executable stack / general-trampoline problem of GNU Nested Functions (by providing a wide function pointer type to get around it) before discussing various ways forward and various improvements around GNU Nested Functions, but takes a dissimilar approach to the one outlined in our proposal. We will go through the some of the sections in the paper and talk about how it differs from the approach this paper is going to take, and the criticisms it levies at the various aspects of other solutions such as Apple Blocks, Lambdas, GNU Nested Functions, and more.</p>
   <h4 class="heading settled" data-level="5.1.1" id="appendix-nested.functions.context-section.1.section.2"><span class="secno">5.1.1. </span><span class="content">§1 &amp; §2</span><a class="self-link" href="#appendix-nested.functions.context-section.1.section.2"></a></h4>
   <p>These are sections we agree with the most: the introduction of a wide function pointer type is necessary (<a href="#appendix-wide.function.pointer">§ 5.2 Wide Function Pointer Type</a>), no matter which solution is picked. Wide Function Pointers are a unifying part to make C more of the appropriate "lingua franca" between languages. This proposal even agrees that naked, unadorned GNU Nested Functions can be introduced as part of C: however, the caveat would be that, insofar as the design in <a href="#design-capture.functions">§ 3.2 Capture Functions: Rehydrated Nested Function</a> is concerned, it would produce a constraint violation to not appropriately capture any objects from the outside local scope that are used inside. Secondly, the use of it in <a data-link-type="biblio" href="#biblio-n3654" title="n3654: Accessing the Context of Nested Functions">[n3654]</a>'s <code class="highlight"><c- n>api_old</c-></code> would not be "implementation-defined", but rather a constraint violation that GNU (and other compilers) could turn into well-defined behavior. From §2:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>cb_t</c-><c- p>)(</c-><c- b>int</c-><c- p>);</c->
<c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>cb_wide_t</c-><c- p>)(</c-><c- b>int</c-><c- p>)</c-> <c- n>_Wide</c-><c- p>;</c->

<c- b>void</c-> <c- nf>api_old_simple</c-><c- p>(</c-><c- n>cb_t</c-> <c- n>cb</c-><c- p>);</c->
<c- b>void</c-> <c- nf>api_old</c-><c- p>(</c-><c- n>cb_t</c-> <c- n>cb</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>);</c->
<c- b>void</c-> <c- nf>api_new</c-><c- p>(</c-><c- n>cb_wide_t</c-> <c- n>cb</c-><c- p>);</c->

<c- b>void</c-> <c- nf>example4</c-><c- p>()</c->
<c- p>{</c->
  <c- b>int</c-> <c- n>d</c-> <c- o>=</c-> <c- mi>4</c-><c- p>;</c->
  <c- b>int</c-> <c- n>bar</c-><c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>+</c-> <c- n>d</c-><c- p>;</c-> <c- c1>// constraint violation: `d` not captured</c->
  <c- p>}</c->
  <c- b>int</c-> <c- n>bar_fixed</c-><c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>)</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>&amp;</c-><c- p>)</c-> <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>+</c-> <c- n>d</c-><c- p>;</c-> <c- c1>// ok</c->
  <c- p>}</c->
  <c- n>api_old</c-><c- p>(</c-><c- n>bar</c-><c- p>,</c-> <c- k>nullptr</c-><c- p>);</c-> <c- c1>// GNU extension, constraint violation in ISO C</c->
  <c- n>api_new</c-><c- p>(</c-><c- n>bar</c-><c- p>);</c-> <c- c1>// ok</c->
<c- p>}</c->
</pre>
   <p class="note" role="note"><span class="marker">NOTE:</span> <a data-link-type="biblio" href="#biblio-n3654" title="n3654: Accessing the Context of Nested Functions">[n3654]</a> does not seem to use its own API correctly, so the code above is not identical to what is in <a data-link-type="biblio" href="#biblio-n3654" title="n3654: Accessing the Context of Nested Functions">[n3654]</a>: e.g. <code class="highlight"><c- n>api_old</c-></code> is called in <a data-link-type="biblio" href="#biblio-n3654" title="n3654: Accessing the Context of Nested Functions">[n3654]</a> with just <code class="highlight"><c- n>bar</c-></code> and nothing else, leaving off the second required parameter.</p>
   <p>Our hope is to fix that with <a href="#appendix-make.trampoline">§ 5.3 Make Trampoline and Singular Function Pointers</a>:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>cb_t</c-><c- p>)(</c-><c- b>int</c-><c- p>);</c->
<c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>cb_wide_t</c-><c- p>)(</c-><c- b>int</c-><c- p>)</c-> <c- n>_Wide</c-><c- p>;</c->
<c- c1>// or: typedef int (%cb_wide_t)(int);</c->

<c- b>void</c-> <c- nf>api_old_simple</c-><c- p>(</c-><c- n>cb_t</c-> <c- n>cb</c-><c- p>);</c->
<c- b>void</c-> <c- nf>api_old</c-><c- p>(</c-><c- n>cb_t</c-> <c- n>cb</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>);</c->
<c- b>void</c-> <c- nf>api_new</c-><c- p>(</c-><c- n>cb_wide_t</c-> <c- n>cb</c-><c- p>);</c->

<c- b>void</c-> <c- nf>example4</c-><c- p>()</c->
<c- p>{</c->
  <c- b>int</c-> <c- n>d</c-> <c- o>=</c-> <c- mi>4</c-><c- p>;</c->
  <c- b>int</c-> <c- n>bar</c-><c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>)</c-> <c- p>{</c-> <c- c1>// GNU Extension, Nested Functions</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>+</c-> <c- n>d</c-><c- p>;</c-> 
  <c- p>}</c->
  <c- b>int</c-> <c- n>bar_fixed</c-><c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>)</c-> <c- n>_Capture</c-><c- p>(</c-><c- o>&amp;</c-><c- p>)</c-> <c- p>{</c-> <c- c1>// (Proposed) ISO C, Capture Functions</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>+</c-> <c- n>d</c-><c- p>;</c->
  <c- p>}</c->
  <c- n>cb_t</c-> <c- n>bar_fn_ptr</c-> <c- o>=</c-> <c- n>stdc_make_trampoline</c-><c- p>(</c-><c- n>bar</c-><c- p>);</c-> <c- c1>// Extension, but works</c->
  <c- n>cb_t</c-> <c- n>bar_fixed_fn_ptr</c-> <c- o>=</c-> <c- n>stdc_make_trampoline</c-><c- p>(</c-><c- n>bar_fixed</c-><c- p>);</c->
  <c- c1>// all ok now</c->
  <c- n>api_old_simple</c-><c- p>(</c-><c- n>bar_fn_ptr</c-><c- p>);</c-> 
  <c- n>api_old</c-><c- p>(</c-><c- n>bar_fn_ptr</c-><c- p>,</c-> <c- k>nullptr</c-><c- p>);</c->
  <c- n>api_new</c-><c- p>(</c-><c- n>bar</c-><c- p>);</c->
  <c- n>api_old_simple</c-><c- p>(</c-><c- n>bar_fixed_fn_ptr</c-><c- p>);</c-> 
  <c- n>api_old</c-><c- p>(</c-><c- n>bar_fixed_fn_ptr</c-><c- p>,</c-> <c- k>nullptr</c-><c- p>);</c->
  <c- n>api_new</c-><c- p>(</c-><c- n>bar_fixed</c-><c- p>);</c->
  <c- c1>// trampolines must be freed</c->
  <c- n>stdc_destroy_trampoline</c-><c- p>(</c-><c- n>bar_fn_ptr</c-><c- p>);</c->
  <c- n>stdc_destroy_trampoline</c-><c- p>(</c-><c- n>bar_fixed_fn_ptr</c-><c- p>);</c->
<c- p>}</c->
</pre>
   <p>Individuals can rely on the GNU Nested Functions, but would have an explicit way to opt-in to get ISO Standard C behavior. We think this is a better path forward for harmonizing things, and would let the user be explicit about where and when trampolines (and their effects) are created/used.</p>
   <h4 class="heading settled" data-level="5.1.2" id="appendix-nested.functions.context-section.3"><span class="secno">5.1.2. </span><span class="content">§3</span><a class="self-link" href="#appendix-nested.functions.context-section.3"></a></h4>
   <p>We agree with the premise of section 3, including of the way that any capture can be used with the "old" style of API, so long as it passes a userdata parameter:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>cb_t</c-><c- p>)(</c-><c- b>int</c-><c- p>);</c->
<c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>cb_wide_t</c-><c- p>)(</c-><c- b>int</c-><c- p>)</c-> <c- n>_Wide</c-><c- p>;</c->

<c- b>void</c-> <c- nf>api_old</c-><c- p>(</c-><c- n>cb_t</c-> <c- n>cb</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>);</c->

<c- b>void</c-> <c- nf>example5</c-><c- p>()</c->
<c- p>{</c->
  <c- b>int</c-> <c- n>d</c-> <c- o>=</c-> <c- mi>4</c-><c- p>;</c->
  <c- b>int</c-> <c- n>bar</c-><c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>)</c-> <c- p>{</c-> <c- k>return</c-> <c- n>x</c-> <c- o>+</c-> <c- n>d</c-><c- p>;</c-> <c- p>}</c->
  <c- c1>// static (capture-less) nested function</c->
  <c- k>static</c-> <c- b>int</c-> <c- n>trampoline</c-><c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>ptr</c-><c- p>)</c->
  <c- p>{</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- p>(</c-><c- n>cb_wide_t</c-><c- p>)</c-><c- n>ptr</c-><c- p>)(</c-><c- n>x</c-><c- p>);</c->
  <c- p>}</c->
  <c- n>api_old</c-><c- p>(</c-><c- n>trampoline</c-><c- p>,</c-> <c- o>&amp;</c-><c- p>(</c-><c- n>cb_wide_t</c-><c- p>){</c-> <c- n>bar</c-> <c- p>});</c->
<c- p>}</c->
</pre>
   <p><a data-link-type="biblio" href="#biblio-n3654" title="n3654: Accessing the Context of Nested Functions">[n3654]</a> then introduces a potential new keyword to capture what is, effectively, the current function frame and reuse it in the same place:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>cb_t</c-><c- p>)(</c-><c- b>int</c-><c- p>);</c->

<c- b>void</c-> <c- nf>api_old</c-><c- p>(</c-><c- n>cb_t</c-> <c- n>cb</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>);</c->

<c- b>void</c-> <c- nf>example6</c-><c- p>()</c->
<c- p>{</c->
  <c- k>const</c-> <c- b>int</c-> <c- n>d</c-> <c- o>=</c-> <c- mi>4</c-><c- p>;</c->
  <c- c1>// static chain passed via specified argument</c->
  <c- b>int</c-> <c- n>bar</c-><c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>)</c-> <c- n>_Closure</c-><c- p>(</c-><c- n>data</c-><c- p>)</c->
  <c- p>{</c->
    <c- k>return</c-> <c- n>x</c-> <c- o>+</c-> <c- n>d</c-><c- p>;</c->
  <c- p>}</c->
  <c- n>api_old</c-><c- p>(</c-><c- n>bar</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>));</c->
<c- p>}</c->
</pre>
   <p><code class="highlight"><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>)</c-></code> can effectively be seen as a signal to the implementation for the invocation of <code class="highlight"><c- n>__builtin_frame_address</c-></code>, while <code class="highlight"><c- n>_Closure</c-><c- p>(</c-><c- n>data</c-><c- p>)</c-></code> attached to the function definition is a directive to the compiler to use <code class="highlight"><c- n>__builtin_call_with_static_chain</c-></code>. Semantically, the use of <code class="highlight"><c- n>_Closure</c-><c- p>(</c-><c- n>data</c-><c- p>)</c-></code> on the definition ties the contents of the nested function to the surrounding scope from the perspective of whatever function definition <code class="highlight"><c- n>_Closure</c-></code> is attached to. It’s a way to saying the surrounding scope is being provided by the <code class="highlight"><c- b>void</c-><c- o>*</c-></code> argument (<code class="highlight"><c- n>data</c-></code> in this case). This is mildly more type-safe than just a regular <code class="highlight"><c- b>void</c-><c- o>*</c-></code> cast to a structure type inside. It is impossible to cast to the wrong type since it’s some (unnamed) type related to the current scope, and therefore the location provides the safety. It also offers a way to have two different closures use the same <code class="highlight"><c- b>void</c-><c- o>*</c-></code> data, meaning that one could theoretically optimize a function taking 2 or three callbacks to have only one <code class="highlight"><c- b>void</c-><c- o>*</c-></code> userdata-style parameter.</p>
   <p>The problem with that is that assuming two or three callbacks all have the same environment or use the same userdata is, oftentimes, not a good idea. An example in the <code class="highlight"><c- n>thrd_create_attrs_err</c-></code> proposed function (<a data-link-type="biblio" href="#biblio-thread-attributes" title="Thread Attributes - Implementation Extensible and ABI-Resistant">Thread Attributes</a>); if the API were to assume that all three <code class="highlight"><c- b>void</c-><c- o>*</c-></code> provided to this function can or should be the same, there could be many possible issues (thread of invocation does not match expectations, race conditions, having access to the wrong data, and more). So it’s unclear whether or not that would be good in general purpose, widely-adopted, or prolofic library interfaces.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> Folding together multiple nested functions to have similar closure data would certainly be useful for internal APIs where the caller of a specific API can make assumptions of how things work; but it does not hold up for external or uncontrollably-available APIs.</p>
   <p>The final problem with this section is that it still assumes that the only kind of closure one would want is one that refers to variables in the current scope. This results in all the same problems documented in <a href="#intro-nested.functions-captures">§ 2.2.4 The Nature of Captures</a>; undefined behavior, lifetime failures, and more. This could especially be the case for <code class="highlight"><c- n>thrd_create_attrs_err</c-></code>, thread/worker pools, thread queues, and other asynchronous scheduling initiatives.</p>
   <h4 class="heading settled" data-level="5.1.3" id="appendix-nested.functions.context-section.4"><span class="secno">5.1.3. </span><span class="content">§4</span><a class="self-link" href="#appendix-nested.functions.context-section.4"></a></h4>
   <p>This section introduces the concept of modifying how Nested Functions capture variables, recommending that some variables are captured by value inside of the data stored for a closure. The recommendation is that values that are <code class="highlight"><c- k>const</c-></code> should be captured, while other mutable values are not. The examples do not seem to explain why capturing only <code class="highlight"><c- k>const</c-></code> variables is helpful, as the primary reason to capture by value (particularly as Apple Blocks has explained (<a href="#intro-blocks-runtime">§ 2.3.2 Runtime Required</a>)) is for safety in copying the closure to another location. The following example, using an old-style, <code class="highlight"><c- b>void</c-><c- o>*</c-></code> based API for the purposes of copying, is given:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>cb_t</c-><c- p>)(</c-><c- b>int</c-><c- p>);</c->
<c- b>void</c-> <c- nf>api_old_copy</c-><c- p>(</c-><c- n>cb_t</c-> <c- n>cb</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>data_size</c-><c- p>);</c->

<c- b>void</c-> <c- nf>example7</c-><c- p>()</c->
<c- p>{</c->
  <c- c1>// const-qualified variables can be copied</c->
  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- k>const</c-> <c- n>p</c-><c- p>)[</c-><c- mi>10</c-><c- p>]</c-> <c- o>=</c-> <c- n>malloc</c-><c- p>(</c-><c- k>sizeof</c-> <c- o>*</c-><c- n>p</c-><c- p>);</c->
  <c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>p</c-><c- p>)</c-> <c- k>return</c-><c- p>;</c->
  <c- b>int</c-> <c- n>bar</c-><c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>)</c-> <c- n>_Closure</c-><c- p>(</c-><c- n>data</c-><c- p>)</c->
  <c- p>{</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p</c-><c- p>)[</c-><c- n>x</c-><c- p>];</c->
  <c- p>}</c->
  <c- c1>// sizeof can be used to obtain the required size</c->
  <c- n>api_old_copy</c-><c- p>(</c-><c- n>bar</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>),</c-> <c- k>sizeof</c-><c- p>(</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>)));</c->
<c- p>}</c->
</pre>
   <p>We do not see how the <code class="highlight"><c- k>const</c-></code> qualification helps in this scenario, and also note that this isn’t helpful for the vast majority of declarations and types that are non-<code class="highlight"><c- k>const</c-></code> qualified. For example, if this pointer was not <code class="highlight"><c- k>const</c-></code> qualified, a copy would have to be created solely for the purpose of capture:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>cb_t</c-><c- p>)(</c-><c- b>int</c-><c- p>);</c->
<c- b>void</c-> <c- nf>api_old_copy</c-><c- p>(</c-><c- n>cb_t</c-> <c- n>cb</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>data_size</c-><c- p>);</c->

<c- b>void</c-> <c- nf>example7_modified</c-><c- p>()</c->
<c- p>{</c->
  <c- c1>// non const-qualified variable is by-name</c->
  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>p</c-><c- p>)[</c-><c- mi>10</c-><c- p>]</c-> <c- o>=</c-> <c- n>malloc</c-><c- p>(</c-><c- k>sizeof</c-> <c- o>*</c-><c- n>p</c-><c- p>);</c->
  <c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>p</c-><c- p>)</c-> <c- k>return</c-><c- p>;</c->
  <c- c1>// change to `const` to enable capture</c->
  <c- b>int</c-> <c- p>(</c-><c- k>const</c-> <c- o>*</c-><c- n>cap_p</c-><c- p>)[</c-><c- mi>10</c-><c- p>]</c-> <c- o>=</c-> <c- n>p</c-><c- p>;</c->
  <c- b>int</c-> <c- n>bar</c-><c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>)</c-> <c- n>_Closure</c-><c- p>(</c-><c- n>data</c-><c- p>)</c->
  <c- p>{</c->
<c- cp>#if 0</c->
<c- c>    // dangerous -- may not exist</c->
<c- c>    return (*p)[x];</c->
<c- cp>#else</c->
    <c- c1>// not dangerous -- captured by value</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>cap_p</c-><c- p>)[</c-><c- n>x</c-><c- p>];</c->
<c- cp>#endif</c->
  <c- p>}</c->
  <c- c1>// sizeof can be used to obtain the required size</c->
  <c- n>api_old_copy</c-><c- p>(</c-><c- n>bar</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>),</c-> <c- k>sizeof</c-><c- p>(</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>)));</c->
<c- p>}</c->
</pre>
   <p>One would need to form a copy of any mutable variable into a <code class="highlight"><c- k>const</c-></code> one in order to ensure that it gets its whole value placed inside of whatever the implementation decides to place inside of <code class="highlight"><c- n>_Closure</c-></code>. This is, in many ways, a by-proxy form of doing C++ Lambda captures or using <code class="highlight"><c- n>__block</c-></code> in Apple blocks. At the very least with C++ Lambdas and Apple Blocks, their design is once again explicit; it allows the user to decide if something should be transported by-value, and then can be moved into a by-name state by the user. For 1980 direction, this requires duplicated variables, and given how <code class="highlight"><c- n>_Closure</c-></code> works  rather than the user stating their intent directly ("put this variable inside of this thing so I can carry it around in the manner of my chosing"), they have to instead contort their declarations to be <code class="highlight"><c- k>const</c-></code> as a means of perhaps making safe access to these variables ("this variable is now <code class="highlight"><c- k>const</c-></code> so it should be copied in, but anything else is implementation-defiend or something"). This is a roundabout way of just being clear about what is coming and going and what the properties of that thing are; we believe this to be infinitely less clear than erroring on something that is not captured and making the user specify explicitly.</p>
   <p>Capture-by-<code class="highlight"><c- k>const</c-></code> is not a useful or reliable scheme and would require users to contort their declarations for the sole purpose of making it work better with this new solution: we do not believe it to be a viable path forward.</p>
   <h4 class="heading settled" data-level="5.1.4" id="appendix-nested.functions.context-section.5.section.6"><span class="secno">5.1.4. </span><span class="content">§5 and §6</span><a class="self-link" href="#appendix-nested.functions.context-section.5.section.6"></a></h4>
   <p>This is where the paper starts departing more strongly from what we believe to be the right direction. This section opens with a use of <code class="highlight"><c- n>api_old_copy_del</c-></code>:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>cb_t</c-><c- p>)(</c-><c- b>int</c-><c- p>);</c->
<c- b>void</c-> <c- nf>api_old_copy_del</c-><c- p>(</c-><c- n>cb_t</c-> <c- n>cb</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>size</c-><c- p>,</c-> <c- b>void</c-> <c- p>(</c-><c- o>*</c-><c- n>del</c-><c- p>)(</c-><c- b>void</c-><c- o>*</c-><c- p>));</c->

<c- b>void</c-> <c- nf>example8</c-><c- p>()</c->
<c- p>{</c->
  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- k>const</c-> <c- n>p</c-><c- p>)[</c-><c- mi>10</c-><c- p>]</c-> <c- o>=</c-> <c- n>malloc</c-><c- p>(</c-><c- k>sizeof</c-> <c- o>*</c-><c- n>p</c-><c- p>);</c->
  <c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>p</c-><c- p>)</c-> <c- k>return</c-><c- p>;</c->
  <c- b>int</c-> <c- n>bar</c-><c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>)</c-> <c- n>_Closure</c-><c- p>(</c-><c- n>data</c-><c- p>)</c->
  <c- p>{</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p</c-><c- p>)[</c-><c- n>x</c-><c- p>];</c->
  <c- p>}</c->
  <c- c1>// static nested functions acting as destructor</c->
  <c- k>static</c-> <c- b>void</c-> <c- n>del</c-><c- p>(</c-><c- b>void</c-> <c- o>*</c-><c- n>_data</c-><c- p>)</c->
  <c- p>{</c->
    <c- c1>// the structure type is visible at this point</c->
    <c- n>typeof</c-><c- p>(</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>))</c-> <c- o>*</c-><c- n>data</c-> <c- o>=</c-> <c- n>_data</c-><c- p>;</c->
    <c- n>free</c-><c- p>(</c-><c- n>data</c-><c- o>-></c-><c- n>p</c-><c- p>);</c->
  <c- p>}</c->
  <c- n>api_old_copy_del</c-><c- p>(</c-><c- n>bar</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>),</c-> <c- k>sizeof</c-><c- p>(</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>)),</c-> <c- n>del</c-><c- p>);</c->
<c- p>}</c->
</pre>
   <p>The problem is that there seems to be a limitation in how <code class="highlight"><c- n>_Closure</c-></code> can be used; the assertion is that <code class="highlight"><c- n>_Closure</c-></code> is meant to strongly mimic "call with static chain" and map entirely towards that. This is fine for that architecture, but it begs the question in this example: why is <code class="highlight"><c- n>Closure</c-><c- p>(</c-><c- n>_data</c-><c- p>)</c-></code> in <code class="highlight"><c- n>del</c-></code> not allowed like so?</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>cb_t</c-><c- p>)(</c-><c- b>int</c-><c- p>);</c->
<c- b>void</c-> <c- nf>api_old_copy_del</c-><c- p>(</c-><c- n>cb_t</c-> <c- n>cb</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>size</c-><c- p>,</c-> <c- b>void</c-> <c- p>(</c-><c- o>*</c-><c- n>del</c-><c- p>)(</c-><c- b>void</c-><c- o>*</c-><c- p>));</c->

<c- b>void</c-> <c- nf>example8_modified</c-><c- p>()</c->
<c- p>{</c->
  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- k>const</c-> <c- n>p</c-><c- p>)[</c-><c- mi>10</c-><c- p>]</c-> <c- o>=</c-> <c- n>malloc</c-><c- p>(</c-><c- k>sizeof</c-> <c- o>*</c-><c- n>p</c-><c- p>);</c->
  <c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>p</c-><c- p>)</c-> <c- k>return</c-><c- p>;</c->
  <c- b>int</c-> <c- n>bar</c-><c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>)</c-> <c- n>_Closure</c-><c- p>(</c-><c- n>data</c-><c- p>)</c->
  <c- p>{</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p</c-><c- p>)[</c-><c- n>x</c-><c- p>];</c->
  <c- p>}</c->
  <c- c1>// static nested functions acting as destructor</c->
  <c- k>static</c-> <c- b>void</c-> <c- n>del</c-><c- p>(</c-><c- b>void</c-> <c- o>*</c-><c- n>_data</c-><c- p>)</c-> <c- n>_Closure</c-><c- p>(</c-><c- n>data</c-><c- p>)</c->
  <c- p>{</c->
    <c- n>free</c-><c- p>(</c-><c- n>p</c-><c- p>);</c->
  <c- p>}</c->
  <c- n>api_old_copy_del</c-><c- p>(</c-><c- n>bar</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>),</c-> <c- k>sizeof</c-><c- p>(</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>)),</c-> <c- n>del</c-><c- p>);</c->
<c- p>}</c->
</pre>
   <p>One should be able to simply say that local variables can be looked up through whatever is given to <code class="highlight"><c- n>_Closure</c-></code>. For example, if someone were to make a global <code class="highlight"><c- b>void</c-><c- o>*</c-></code> variable and set it to the value, it would also be a viable way to saying "this is the function’s current frame / environment" without necessarily requiring that the function be explicitly used with a static chain:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>cb_t</c-><c- p>)(</c-><c- b>int</c-><c- p>);</c->
<c- c1>// `del` takes no void* now</c->
<c- b>void</c-> <c- nf>api_old_copy_del</c-><c- p>(</c-><c- n>cb_t</c-> <c- n>cb</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>size</c-><c- p>,</c-> <c- b>void</c-> <c- p>(</c-><c- o>*</c-><c- n>del</c-><c- p>)());</c->

<c- k>static</c-> <c- b>void</c-><c- o>*</c-> <c- n>my_env</c-><c- p>;</c->
	
<c- b>void</c-> <c- nf>example8_modified</c-><c- p>()</c->
<c- p>{</c->
  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- k>const</c-> <c- n>p</c-><c- p>)[</c-><c- mi>10</c-><c- p>]</c-> <c- o>=</c-> <c- n>malloc</c-><c- p>(</c-><c- k>sizeof</c-> <c- o>*</c-><c- n>p</c-><c- p>);</c->
  <c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>p</c-><c- p>)</c-> <c- k>return</c-><c- p>;</c->
  <c- b>int</c-> <c- n>bar</c-><c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>)</c-> <c- n>_Closure</c-><c- p>(</c-><c- n>data</c-><c- p>)</c->
  <c- p>{</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p</c-><c- p>)[</c-><c- n>x</c-><c- p>];</c->
  <c- p>}</c->
	
  <c- k>static</c-> <c- b>void</c-> <c- n>del</c-><c- p>()</c-> <c- n>_Closure</c-><c- p>(</c-><c- n>my_env</c-><c- p>)</c->
  <c- p>{</c->
    <c- n>free</c-><c- p>(</c-><c- n>p</c-><c- p>);</c-> <c- c1>// `p` is found because we have statically asserted</c->
    <c- c1>// that the stack frame of `example8_modified`</c->
    <c- c1>// comes from the variable `my_env`</c->
  <c- p>}</c->

  <c- n>my_env</c-> <c- o>=</c-> <c- o>&amp;</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>);</c-> <c- c1>// get closure data pointer</c->
  <c- n>api_old_copy_del</c-><c- p>(</c-><c- n>bar</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>),</c-> <c- k>sizeof</c-><c- p>(</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>)),</c-> <c- n>del</c-><c- p>);</c->
<c- p>}</c->
</pre>
   <p>This is hinted at in §6 of the paper, but the chosen syntax and explanation uses a plain naked nested function that implicitly (?) knows the static chain without a <code class="highlight"><c- b>void</c-> <c- o>*</c-><c- n>data</c-></code> or <code class="highlight"><c- b>void</c-> <c- o>*</c-><c- n>_data</c-></code> argument:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>cb_t</c-><c- p>)(</c-><c- b>int</c-><c- p>);</c->
<c- b>void</c-> <c- nf>api_old_copy_del</c-><c- p>(</c-><c- n>cb_t</c-> <c- n>cb</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>size</c-><c- p>,</c-> <c- b>void</c-> <c- p>(</c-><c- o>*</c-><c- n>del</c-><c- p>)());</c->

<c- b>void</c-> <c- nf>example9</c-><c- p>()</c->
<c- p>{</c->
  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>p</c-><c- p>)[</c-><c- mi>10</c-><c- p>]</c-> <c- o>=</c-> <c- n>malloc</c-><c- p>(</c-><c- k>sizeof</c-> <c- o>*</c-><c- n>p</c-><c- p>);</c->
  <c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>p</c-><c- p>)</c-> <c- k>return</c-><c- p>;</c->
  <c- b>int</c-> <c- n>bar</c-><c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>)</c-> <c- n>_Closure</c-><c- p>(</c-><c- n>data</c-><c- p>)</c->
  <c- p>{</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p</c-><c- p>)[</c-><c- n>x</c-><c- p>];</c->
  <c- p>}</c->
  <c- c1>// nested function acting as destructor</c->
  <c- b>void</c-> <c- n>del</c-><c- p>()</c-> <c- p>{</c-> <c- n>free</c-><c- p>(</c-><c- n>p</c-><c- p>);</c-> <c- n>p</c-> <c- o>=</c-> NULL<c- p>;</c-> <c- p>}</c-> <c- c1>// missing... `void*` and `_Closure`?</c->
  <c- c1>// wrong function name, as well</c->
  <c- n>api_data_copy_del</c-><c- p>(</c-><c- n>bar</c-><c- p>,</c-> <c- o>&amp;</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>),</c-> <c- k>sizeof</c-><c- p>(</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>)),</c-> <c- n>del</c-><c- p>);</c->
<c- p>}</c->
</pre>
   <p>It’s completely unclear how <code class="highlight"><c- n>del</c-></code> receives the environment for <code class="highlight"><c- n>bar</c-></code> here: is it simply assumed that nested functions contained in the same scope all implicitly receive the environment? If so, how? And, importantly, how does an API compiled separately (e.g., as a DLL in a library) know to make the association between <code class="highlight"><c- n>bar</c-></code> and <code class="highlight"><c- n>del</c-></code> here? Is there something that needs to be done internally in <code class="highlight"><c- n>api_data_copy_del</c-></code> (meant to be <code class="highlight"><c- n>api_old_copy_del</c-></code>?) for this to happen?</p>
   <p>Adjusting this to allow for a callback that takes a <code class="highlight"><c- b>void</c-><c- o>*</c-></code>, AND making it <code class="highlight"><c- k>static</c-></code> so that the environment can be shared while <code class="highlight"><c- n>del</c-></code> is can be used as a normal function pointer with a shared environment would likely look more like this:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>cb_t</c-><c- p>)(</c-><c- b>int</c-><c- p>);</c->
<c- c1>// signature adjusted to allow for `void*` into `del` callback</c->
<c- b>void</c-> <c- nf>api_old_copy_del</c-><c- p>(</c-><c- n>cb_t</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>size</c-><c- p>,</c-> <c- b>void</c-> <c- p>(</c-><c- o>*</c-><c- n>del</c-><c- p>)(</c-><c- b>void</c-><c- o>*</c-><c- p>));</c->

<c- b>void</c-> <c- nf>example9_modified</c-><c- p>()</c->
<c- p>{</c->
  <c- b>int</c-> <c- p>(</c-><c- o>*</c-><c- n>p</c-><c- p>)[</c-><c- mi>10</c-><c- p>]</c-> <c- o>=</c-> <c- n>malloc</c-><c- p>(</c-><c- k>sizeof</c-> <c- o>*</c-><c- n>p</c-><c- p>);</c->
  <c- k>if</c-> <c- p>(</c-><c- o>!</c-><c- n>p</c-><c- p>)</c-> <c- k>return</c-><c- p>;</c->
  <c- b>int</c-> <c- n>bar</c-><c- p>(</c-><c- b>int</c-> <c- n>x</c-><c- p>,</c-> <c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>)</c-> <c- n>_Closure</c-><c- p>(</c-><c- n>data</c-><c- p>)</c->
  <c- p>{</c->
    <c- k>return</c-> <c- p>(</c-><c- o>*</c-><c- n>p</c-><c- p>)[</c-><c- n>x</c-><c- p>];</c->
  <c- p>}</c->
	
  <c- k>static</c-> <c- b>void</c-> <c- n>del</c-><c- p>(</c-><c- b>void</c-> <c- o>*</c-><c- n>data</c-><c- p>)</c-> <c- n>_Closure</c-><c- p>(</c-><c- n>data</c-><c- p>)</c->
  <c- p>{</c->
    <c- n>free</c-><c- p>(</c-><c- n>p</c-><c- p>);</c->
    <c- n>p</c-> <c- o>=</c-> NULL<c- p>;</c->
  <c- p>}</c->
  <c- n>api_old_copy_del</c-><c- p>(</c-><c- n>bar</c-><c- p>,</c->
    <c- o>&amp;</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>),</c-> <c- c1>// "environment" of `bar`</c->
    <c- k>sizeof</c-><c- p>(</c-><c- n>_Closure</c-><c- p>(</c-><c- n>bar</c-><c- p>)),</c-> <c- c1>// size for closure data to be copied in and survive</c->
    <c- n>del</c-> <c- c1>// `del` now appropriate is just a regular function pointer</c->
  <c- p>);</c->
<c- p>}</c->
</pre>
   <p>Whether the <code class="highlight"><c- b>void</c-><c- o>*</c-></code> data is passed to the <code class="highlight"><c- n>del</c-></code> callback or it comes from some other (<code class="highlight"><c- k>_Thread_local</c-></code> or <code class="highlight"><c- k>static</c-></code>) object, there’s some amount of potential for "can take a pointer and using the surrounding scope assert that it is some implementation-defined environment containing values for use". There’s nothing wrong with using the location of the nested function as a way of saying:</p>
   <ul>
    <li data-md>
     <p>"any <code class="highlight"><c- n>_Closure</c-><c- p>(</c-><c- n>some</c-><c- o>-</c-><c- b>void</c-><c- o>-</c-><c- n>ptr</c-><c- p>)</c-></code> represents the surrounding scope and should be used to look up identifiers if possible" (in the <code class="highlight"><c- k>static</c-></code> nested function case);</p>
    <li data-md>
     <p>OR, "any <code class="highlight"><c- n>_Closure</c-><c- p>(</c-><c- n>some</c-><c- o>-</c-><c- b>void</c-><c- o>-</c-><c- n>ptr</c-><c- p>)</c-></code> represents a <code class="highlight"><c- n>__builtin_call_with_static_chain</c-></code> (or Function Descriptor, or etc. etc. Implementation Decision Here) to appropriately call the function and set the necessary captures and data" (in the non-<code class="highlight"><c- k>static</c-></code> nested function case).</p>
   </ul>
   <p>But <a data-link-type="biblio" href="#biblio-n3654" title="n3654: Accessing the Context of Nested Functions">[n3654]</a> has a hard time communicating that effectively, if that is indeed what it is trying to communicate at all.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> We are assuming this is what it means. This is why many of the code samples taken from the paper have been changed with the addition of <code class="highlight"><c- n>_modified</c-></code> in the example function’s name.</p>
   <p>We do not critique much of the rest of the paper because it is simply building on top of this API, but using partially related orchestrations for Polymorphic Types. We are not interested in what polymorphic types will or will not do for this, and it is outside the scope of what we care about for this.</p>
   <h4 class="heading settled" id="appendix-nested.functions.context-appendix.b"><span class="content">Appendix B: C++ Lambda Quiz</span><a class="self-link" href="#appendix-nested.functions.context-appendix.b"></a></h4>
   <p>The final problem of this proposal is in the appendices. We will start with Appendix B, which has a quiz formulated using C++ Lambdas and asking "what will it print?":</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdio.h>

<c- b>int</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>3</c-><c- p>;</c->

<c- b>int</c-> <c- nf>main</c-><c- p>()</c->
<c- p>{</c->
  <c- b>int</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>3</c-><c- p>;</c->
  <c- k>auto</c-> <c- n>foo</c-> <c- o>=</c-> <c- p>[</c-><c- o>=</c-><c- p>](){</c-> <c- n>printf</c-><c- p>(</c-><c- s>"%d</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c-> <c- n>i</c-><c- p>);</c-> <c- p>};</c->
  <c- k>auto</c-> <c- n>bar</c-> <c- o>=</c-> <c- p>[</c-><c- o>=</c-><c- p>](){</c-> <c- n>printf</c-><c- p>(</c-><c- s>"%d</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c-> <c- n>j</c-><c- p>);</c-> <c- p>};</c->
  <c- n>i</c-> <c- o>=</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>4</c-><c- p>;</c->
  <c- n>foo</c-><c- p>();</c->
  <c- n>bar</c-><c- p>();</c->
<c- p>}</c->
</pre>
   <p>The answer is "3" and then "4" (<a href="https://godbolt.org/z/KW4j1zG93">https://godbolt.org/z/KW4j1zG93</a>). Before we talk about the answer, we are going to <em>compare</em> this answer to what the answer would be with GNU Nested Functions and Apple Blocks. To start, let’s try this quiz with GNU Nested Functions:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdio.h>

<c- b>int</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>3</c-><c- p>;</c->

<c- b>int</c-> <c- nf>main</c-><c- p>()</c->
<c- p>{</c->
  <c- b>int</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>3</c-><c- p>;</c->
  <c- b>void</c-> <c- n>foo</c-><c- p>(){</c-> <c- n>printf</c-><c- p>(</c-><c- s>"%d</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c-> <c- n>i</c-><c- p>);</c-> <c- p>};</c->
  <c- b>void</c-> <c- n>bar</c-> <c- p>(){</c-> <c- n>printf</c-><c- p>(</c-><c- s>"%d</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c-> <c- n>j</c-><c- p>);</c-> <c- p>};</c->
  <c- n>i</c-> <c- o>=</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>4</c-><c- p>;</c->
  <c- n>foo</c-><c- p>();</c->
  <c- n>bar</c-><c- p>();</c->
<c- p>}</c->
</pre>
   <p>The answer here is "4" and then "4" (<a href="https://godbolt.org/z/voWG3Gjo3">https://godbolt.org/z/voWG3Gjo3</a>). The file-scope variable still gives the same answer (because of course it does): the change here is in the local variable. As explained in the above introduction to GNU Nested Functions (<a href="#intro-nested.functions-captures">§ 2.2.4 The Nature of Captures</a>), it captures by-name, so the value is updated. This makes sense to what the expectation is. Apple Blocks behave differently:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdio.h>

<c- b>int</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>3</c-><c- p>;</c->

<c- b>int</c-> <c- nf>main</c-><c- p>()</c->
<c- p>{</c->
  <c- b>int</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>3</c-><c- p>;</c->
  <c- k>auto</c-> <c- n>foo</c-> <c- o>=</c-> <c- o>^</c-><c- p>(){</c-> <c- n>printf</c-><c- p>(</c-><c- s>"%d</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c-> <c- n>i</c-><c- p>);</c-> <c- p>};</c->
  <c- k>auto</c-> <c- n>bar</c-> <c- o>=</c-> <c- o>^</c-><c- p>(){</c-> <c- n>printf</c-><c- p>(</c-><c- s>"%d</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c-> <c- n>j</c-><c- p>);</c-> <c- p>};</c->
  <c- n>i</c-> <c- o>=</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>4</c-><c- p>;</c->
  <c- n>foo</c-><c- p>();</c->
  <c- n>bar</c-><c- p>();</c->
<c- p>}</c->
</pre>
   <p>The answer is now back to "3" and then "4" (<a href="https://godbolt.org/z/a9c79cjYb">https://godbolt.org/z/a9c79cjYb</a>). That is because, as explained above, the default for Apple Blocks is capturing by-value (<a href="#intro-blocks-captures">§ 2.3.3 Captures</a>).</p>
   <p>The implication of this quiz is that Apple Blocks -- the thing that has worked for the entirety of the Apple ecosystem -- is wrong and unexpected, and the GNU Nested Function behavior is correct and expected. It wouldn’t be a "Quiz", after all, if the answer was anticipated to be entirely normal. In the rush to make a point about captures doing certain things, <a data-link-type="biblio" href="#biblio-n3654" title="n3654: Accessing the Context of Nested Functions">[n3654]</a> effectively called the entirety of the Apple Blocks ecosystem fraudulent in its expectations. That’s certainly a choice that can be made, but a more important point that overshadows this is that C++ Lambdas can have the <em>same behavior as GNU Nested Functions</em>:</p>
<pre class="language-cpp highlight"><c- cp>#include</c-> &lt;stdio.h>

<c- b>int</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>3</c-><c- p>;</c->

<c- b>int</c-> <c- nf>main</c-><c- p>()</c->
<c- p>{</c->
  <c- b>int</c-> <c- n>i</c-> <c- o>=</c-> <c- mi>3</c-><c- p>;</c->
  <c- k>auto</c-> <c- n>foo</c-> <c- o>=</c-> <c- p>[</c-><c- o>&amp;</c-><c- p>](){</c-> <c- n>printf</c-><c- p>(</c-><c- s>"%d</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c-> <c- n>i</c-><c- p>);</c-> <c- p>};</c->
  <c- k>auto</c-> <c- n>bar</c-> <c- o>=</c-> <c- p>[</c-><c- o>&amp;</c-><c- p>](){</c-> <c- n>printf</c-><c- p>(</c-><c- s>"%d</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c-> <c- n>j</c-><c- p>);</c-> <c- p>};</c->
  <c- n>i</c-> <c- o>=</c-> <c- n>j</c-> <c- o>=</c-> <c- mi>4</c-><c- p>;</c->
  <c- n>foo</c-><c- p>();</c->
  <c- n>bar</c-><c- p>();</c->
<c- p>}</c->
</pre>
   <p>This changes the answer to "4" and then "4" (<a href="https://godbolt.org/z/EW8PETdxz">https://godbolt.org/z/EW8PETdxz</a>). What this means is that this Quiz -- when properly displayed next to its counterparts -- shows that C++ Lambdas can be naturally configured to work like Apple Blocks OR like GNU Nested Functions, at the cost of one (1) character change in its capture clause. We can imagine that a person writing from the perspective of Apple Blocks could present the preceding C++ Lambda that doesn’t have the same behavior they expect to be a "Quiz" that contains a big "Gotcha". The reality is that C++'s design can handle both defaults without compromising the ergonomics in any serious manner. The syntax for lambdas is, of course, "sinfully ugly" -- even C++ enthusiasts acknowledge this readily -- but the acknowlegement that there are engineering tradeoffs to be had -- and not things to poke fun at or make "gotcha"s out of -- is why the design is mature and useful.</p>
   <p>In contrast, <a data-link-type="biblio" href="#biblio-n3654" title="n3654: Accessing the Context of Nested Functions">[n3654]</a> proposes capturing and copying based on things such as whether or not a variable is <code class="highlight"><c- k>const</c-></code>, which does not approximate how it works in <strong>any</strong> existing practice.</p>
   <h4 class="heading settled" id="appendix-nested.functions.context-appendix.a"><span class="content">Appendix A: List of Issues with C++ Lambdas</span><a class="self-link" href="#appendix-nested.functions.context-appendix.a"></a></h4>
   <p>Appendix A is a laundry list of issues with C++ Lambdas, in no particular order. Some of them are already addressed in the introduction of Lambdas (<a href="#intro-lambdas">§ 2.4 C++-Style Lambdas</a>), but in-general the list of issues has many flaws in its reasoning.</p>
   <blockquote>
    <ul>
     <li data-md>
      <p>"Passing of a lambda as a regular parameter needs either trampolines or a new type."</p>
    </ul>
   </blockquote>
   <p>Every single solution requires trampolines or a new type to be useful, GNU Nested Functions and Apple Blocks included. C++ did not have this problem because they have a much stronger base language that can do this as a library type: C needs a fundamental "wide function pointer" type no matter what (<a href="#appendix-wide.function.pointer">§ 5.2 Wide Function Pointer Type</a>) and it needs trampoline-making functionality (<a href="#appendix-make.trampoline">§ 5.3 Make Trampoline and Singular Function Pointers</a>).</p>
   <blockquote>
    <ul>
     <li data-md>
      <p>Lambdas with lvalue capture suffer from the same lifetime limitations as nested functions. <code class="highlight"><c- k>auto</c-> <c- n>foo</c-><c- p>(</c-><c- b>int</c-> <c- n>i</c-><c- p>)</c-> <c- p>{</c-> <c- k>return</c-> <c- p>[</c-><c- o>&amp;</c-><c- p>](){</c-> <c- n>printf</c-><c- p>(</c-><c- s>"%d</c-><c- se>\n</c-><c- s>"</c-><c- p>,</c-> <c- n>i</c-><c- p>);</c-> <c- p>};</c-> <c- p>}</c-></code></p>
    </ul>
   </blockquote>
   <p>This is discussed earlier in the introduction, but GNU Nested Functions have an identical problem. At the very least, Lambdas have a mechanism to stop this from being a problem: there is no built-in solution with GNU Nested Functions. Apple Blocks use an entire heap runtime and thus avoid this problem completely.</p>
   <blockquote>
    <ul>
     <li data-md>
      <p>Not having destructors and smart pointers in C requires workarounds not needed in C++.</p>
     <li data-md>
      <p>Not having explicit access to the structure holding the captured values requires unsafe byte copies, causes issues with alignment and makes deep copying impossible.</p>
    </ul>
   </blockquote>
   <p>Everything in C is a byte copy, unless an explicit function is inserted to do something just before that byte copy happens. An example of this comes from Apple Blocks, with a required <code class="highlight"><c- n>Block_release</c-></code> and <code class="highlight"><c- n>Block_copy</c-></code> required to make usage of stored blocks safer (<a href="#intro-blocks-runtime-stack.based">§ 2.3.2.1 More Complications: Generally Unsafe to Return</a>). To uphold this as a problem is to lambast the entirety of C and its object model as unsafe; which, honestly, is not an unfair assessment. The fix to that is to restore access to the objects captured inside of an object, as shown in <a href="#design-capture.functions-data.captures.fields">§ 3.2.5 NEW: Data Captures are Accessible</a>, which makes any capturing entity -- whether it’s a <code class="highlight"><c- n>_Closure</c-></code> like in <a data-link-type="biblio" href="#biblio-n3654" title="n3654: Accessing the Context of Nested Functions">[n3654]</a>, Capture Functions as in this paper, or Lambdas -- accessible once more.</p>
   <blockquote>
    <ul>
     <li data-md>
      <p>Making the lambda itself have a unique anonymous object type in C means it can only be invoked immediately which seems useful only in macros. In C++ it can be returned from and passed to template functions.</p>
    </ul>
   </blockquote>
   <p>This criticism is partly untrue: complete objects in C can have their type retrieved with <code class="highlight"><c- n>typeof</c-></code>. That means it can be cast/assigned into heap storage, copied around, and called just fine in certain contexts (c.f. the "static trampoline" technique mentioned both in the paper and used extensively in the example code above). We also already have the <code class="highlight"><c- k>auto</c-></code> type-specifier: as regular complete objects, such types can be created and then stored in what already exists as a feature in C23. Macros are a foundationally important use case: it means that expressions being passed into function-like macros can be evaluated once, and only once, by being passed to an immediately-invoked lambda expression.</p>
   <p>Storage outside of those contexts has to be powered by a wide function pointer type, and this proposal acknowledges that it will be necessary to solve that problem (but not in this proposal). GNU Nested Functions also need such a type, as do Apple Blocks (though they do come with their own Block type as well using the <code class="highlight"><c- o>^</c-></code> syntax). This is also partly discussed in <a href="#design-lambdas-returns">§ 3.3.3 Trailing Return Types / Deduced Return Type</a>. Actual returns were handled by <a data-link-type="biblio" href="#biblio-n2923" title="Type inference for variable definitions and function returns">[n2923]</a> but only the <code class="highlight"><c- k>auto</c-></code> for variable definitions was handled: functions was left for later, and there was initially consensus for something of this nature for the purposes of lambdas.</p>
   <blockquote>
    <ul>
     <li data-md>
      <p>To address the various use cases, there are many different ways to capture variables <code class="highlight"><c- p>[</c-><c- o>&amp;</c-><c- p>]</c-></code>, <code class="highlight"><c- p>[</c-><c- o>=</c-><c- p>]</c-></code>, <code class="highlight"><c- p>[]</c-></code>, <code class="highlight"><c- p>[</c-><c- n>a</c-><c- p>]</c-></code>, <code class="highlight"><c- p>[</c-><c- o>&amp;</c-><c- n>b</c-><c- p>]</c-></code>, <code class="highlight"><c- p>[</c-><c- n>a</c-> <c- o>=</c-> <c- n>b</c-><c- p>]</c-></code>, <code class="highlight"><c- n>mutable</c-></code>, etc. adding a lot of complexity that does not seem necessary.</p>
    </ul>
   </blockquote>
   <p>The complexity is necessary, as demonstrated by the Quiz example in <a href="#appendix-nested.functions.context-appendix.b">Appendix B: C++ Lambda Quiz</a>: the fact that captures can be changed and are not dependent on unrelated properties like <code class="highlight"><c- k>const</c-></code>-ness (as in <a data-link-type="biblio" href="#biblio-n3654" title="n3654: Accessing the Context of Nested Functions">[n3654]</a>) is how it successfully blends into e.g. the GNU ecosystem or the Apple ecosystem without breaking either of them. The complexity is inherent to the problem domain: glossing over it like GNU Nested Functions does limits whether or not this can successfully be deployed to replace Apple Blocks as an ISO C Standard solution.</p>
   <blockquote>
    <ul>
     <li data-md>
      <p>Value captures can be confusing as they shadow the original variable under same name.</p>
    </ul>
   </blockquote>
   <p>It is unclear how captures in which the user makes an explicit choice can be more confusing than one where the user has no choice but the behavior changes. We have already established this in the Apple Ecosystem perspective with Blocks versus the GNU Nested Functions perspective in <a href="#appendix-nested.functions.context-appendix.b">Appendix B: C++ Lambda Quiz</a>; switching from one to another can result in bugs when people do not expect the default capturing style to change. Being explicit means nobody is surprised, and having renames prevents shadowing confusion: but it all has to be the user’s choice.</p>
   <blockquote>
    <ul>
     <li data-md>
      <p>Other features from C++ may need to be pulled in from C++ to make them fully useful, such as trailing return types, return type deduction, and generic arguments.</p>
    </ul>
   </blockquote>
   <p>Trailing return types enhance what is capable, but are not strictly required (<a href="#design-lambdas-returns">§ 3.3.3 Trailing Return Types / Deduced Return Type</a>). Generic arguments are the one part that was opposed for inclusion in C23 and did not have consensus; it was, in fact, generic arguments that served as one of the primary reason Gustedt’s Lambdas were completely and utterly tanked. This proposal does not use it and the design below does not require it to be useful, especially as anything relating to an immediately-invoked lambda in a macro can be covered by the necessary <code class="highlight"><c- n>typeof</c-><c- p>(...)</c-></code> from C23.</p>
   <blockquote>
    <ul>
     <li data-md>
      <p>Adopting lambdas from C++ would limit out design freedom relative to C++. We can not easily change specific aspects when it might be better for C, because it would then be a divergence from C++ that should be avoided and will be opposed by implementers.</p>
    </ul>
   </blockquote>
   <p>As a sole solution, certainly. But this proposal provides Capture Functions (<a href="#design-capture.functions">§ 3.2 Capture Functions: Rehydrated Nested Function</a>) as the flagship proposal for C, and maintains 1:1 identical capabilities with the proposed secondary Lambda part (<a href="#design-lambdas">§ 3.3 Lambdas</a>). There are also other reasons as to why having lambdas is good (particularly, for macros and for use as an expression). But, the general improvement here is that one can have Capture Functions that are rooted in C history and C syntax and C needs, while maintaining just enough of Lambdas that serve as a compatibility layer.</p>
   <p>The fact that this paper is already proposing a depature from C++ for C lambdas and Capture Functions by having accessible data captures already shows we have the power to improve on things in C’s favor, if we’re willing to hold onto that (<a href="#design-capture.functions-data.captures.fields">§ 3.2.5 NEW: Data Captures are Accessible</a>).</p>
   <h4 class="heading settled" data-level="5.1.5" id="appendix-nested.functions.context-conclusions"><span class="secno">5.1.5. </span><span class="content">Insufficient</span><a class="self-link" href="#appendix-nested.functions.context-conclusions"></a></h4>
   <p>Given the state of <a data-link-type="biblio" href="#biblio-n3654" title="n3654: Accessing the Context of Nested Functions">[n3654]</a>, it seems like it has not sufficiently explored the consequences or implications of its proposed design, nor grounded it in sufficient existing practice for us to consider yielding to its principles. That does not mean all of the ideas are bad. In the above sections, after we repair some of the broken examples, there is clearly some potential in <code class="highlight"><c- n>_Closure</c-></code> and the idea of an "environment" pointer. There is also perhaps merit in having a pointer that ties a specific function frame to a specific function call so that variable lookup that does not find a local variable can look in the "environment"/"<code class="highlight"><c- n>_Closure</c-></code>" first before checking further surrounding variables (e.g., file-scope or <code class="highlight"><c- k>static</c-></code> objects). But that is a separable problem -- and a lower-level problem -- that the tying of "function and its associated data".</p>
   <p>A wide function pointer type (<a href="#appendix-wide.function.pointer">§ 5.2 Wide Function Pointer Type</a>) would be a far better pursuit, separately, even if none of the solutions here or in other proposals are achieved.</p>
   <p>The paper also seems to be driven, largely, by three things:</p>
   <ul>
    <li data-md>
     <p>animus and disdain for C++ Lambdas and their design;</p>
    <li data-md>
     <p>a desire to formalize the (potentially advanced) uses of <code class="highlight"><c- n>__builtin_call_with_static_chain</c-></code>;</p>
    <li data-md>
     <p>and, a strong preference for all of the design decisions of GNU Nested Functions.</p>
   </ul>
   <p>It offers a "we can do these small things first" and then presents a wider narrative around how to handle the "data" part of "Functions with Data". Having a standardized solution that is less powerful than all of C++ Lambdas, GNU Nested Functions, Apple Blocks, and Jens Gustedt’s proposed C Lambdas does not seem like a good or useful starting point. As much as WG14 as a Committee has many members that continue to extol the virtues of being slow, we believe that there has been significant existing practice and useful explanations of designs to move forward with something much more comprehensive and robust. Giving in to the temptation of "simplified GNU Nested Functions" with a somewhat incomplete and incoherent design plan based around the idea of <code class="highlight"><c- n>_Closure</c-></code> after 30+ years of design work in this space from directly-related and applicable languages is not something we consider a good use of time.</p>
   <p>We do not comment on the Polymorphic Types API because that is beyond what we consider the useful scope of what can or should be addressed in our current proposal.</p>
   <h3 class="heading settled" data-level="5.2" id="appendix-wide.function.pointer"><span class="secno">5.2. </span><span class="content">Wide Function Pointer Type</span><a class="self-link" href="#appendix-wide.function.pointer"></a></h3>
   <p><a data-link-type="biblio" href="#biblio-n2862" title="n2862: Wide Function Pointer Types for Pairing Code and Data">[n2862]</a>, by Dr. Martin Uecker, is already looking into standardizing a wide function pointer type. A wide function pointer type is necessary in the general-purpose ecosystem, but isn’t directly required to be tied to this proposal. Because it is a smaller entity, it can be put directly into the standard separately. We hope it’s explored that rather than using <code class="highlight"><c- n>_Closure</c-><c- p>(</c-><c- n>function</c-><c- o>-</c-><c- n>type</c-><c- p>)</c-></code> or <code class="highlight"><c- n>function</c-><c- o>-</c-><c- n>type</c-> <c- n>_Wide</c-></code> syntax, that <code class="highlight"><c- n>function</c-><c- o>-</c-><c- n>type</c-><c- o>%</c-></code> is deployed as a usable syntax instead. This would simplify its use and its introduction:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>int</c-> <c- nf>foo_fn_t</c-><c- p>(</c-><c- b>int</c-><c- p>);</c->

<c- n>foo_fn_t</c-><c- o>%</c-> <c- n>call_me</c-> <c- p>(</c-><c- b>int</c-><c- o>*</c-> <c- n>x</c-><c- p>)</c-> <c- p>{</c->
  <c- k>return</c-> <c- p>[</c-><c- n>x</c-><c- p>](</c-><c- b>int</c-> <c- n>y</c-><c- p>)</c-> <c- p>{</c-> <c- k>return</c-> <c- o>*</c-><c- n>x</c-> <c- o>+</c-> <c- n>y</c-><c- p>;</c-> <c- p>};</c->
<c- p>}</c->

<c- b>int</c-> <c- n>use_me</c-><c- p>(</c-><c- n>foo_fn_t</c-><c- o>%</c-> <c- n>fn</c-><c- p>)</c-> <c- p>{</c->
  <c- k>return</c-> <c- n>fn</c-><c- p>(</c-><c- mi>2</c-><c- p>);</c->
<c- p>}</c->

<c- b>int</c-> <c- n>main</c-> <c- p>()</c-> <c- p>{</c->
  <c- b>int</c-> <c- n>x</c-> <c- o>=</c-> <c- mi>30</c-><c- p>;</c->
  <c- k>return</c-> <c- n>use_me</c-><c- p>(</c-><c- n>call_me</c-><c- p>(</c-><c- o>&amp;</c-><c- n>x</c-><c- p>));</c->
<c- p>}</c->
</pre>
   <p>In the above example, <code class="highlight"><c- n>foo_fn_t</c-><c- o>%</c-></code> can be replaced with <code class="highlight"><c- n>_Closure</c-><c- p>(</c-><c- n>foo_fn_t</c-><c- p>)</c-></code> or <code class="highlight"><c- n>foo_fn_t</c-> <c- n>_Wide</c-></code>; we prefer the former than the two latter for obvious grammatical and ease-of-use reasons. Most importantly, there is a canonical and viably implementable conversion path for not only whatever is standardized in ISO C, but all of the existing extensions such as Blocks, Nested Functions, C++ Lambdas, and language-external closure types.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> The caret (<code class="highlight"><c- o>^</c-></code>) cannot be used for this purpose thanks to Apple and Objective-C/Objective-C++ taking that design space.</p>
   <p class="note" role="note"><span class="marker">NOTE:</span> The percent sign (<code class="highlight"><c- o>%</c-></code>) does not conflict with Managed C++/CLI <code class="highlight"><c- n>ref</c-></code> declarations that use <code class="highlight"><c- o>%</c-></code> because naked <code class="highlight"><c- o>%</c-></code> can only be applied to "value types" -- that is <code class="highlight"><c- k>struct</c-></code> types. There is no callback type that fits this description in the garbage-collected .NET imperative language universe (C# or Managed C++/CLI); all callback types are declared as either raw function pointer types or <code class="highlight"><c- n>class</c-></code>-based, "reference type" delegates in Managed C++/CLI.</p>
   <h3 class="heading settled" data-level="5.3" id="appendix-make.trampoline"><span class="secno">5.3. </span><span class="content">Make Trampoline and Singular Function Pointers</span><a class="self-link" href="#appendix-make.trampoline"></a></h3>
   <p>In the later examples in <a href="#intro-nested.functions-alternative.implementations">§ 2.2.3 Alternative Nested Function Implementations</a>, a magic compiler builtin named <code class="highlight"><c- n>__gnu_make_trampoline</c-></code>, with a secondary follow-on builtin named <code class="highlight"><c- n>__gnu_destroy_trampoline</c-></code>, is used. This section talks about what that would look like, if it was to be implemented. In particular, an ideal solution that makes a trampoline needs to be an explicit request from the user because:</p>
   <ul>
    <li data-md>
     <p>you want to opt-in to any dynamic allocations;</p>
    <li data-md>
     <p>you want to provide a way to override the default allocation if possible;</p>
    <li data-md>
     <p>and, you explicit control on when those resources (the allocation, the protected memory, and similar) are released.</p>
   </ul>
   <p>While this section was spawned from GNU Nested Functions, this same technique can be used to make possible single function pointer trampolines for Blocks with or without captures (<a href="#intro-blocks">§ 2.3 Apple Blocks</a>) as well as C++-style Lambdas (<a href="#intro-lambdas">§ 2.4 C++-Style Lambdas</a>).</p>
   <p>Therefore, the best design to do this would be -- using the <a data-link-type="biblio" href="#biblio-_any_func" title="_Any_func - A Universal Function Pointer Storage Type">[_Any_func]</a>* paper and its new type -- the following:</p>
<pre class="language-cpp highlight"><c- k>typedef</c-> <c- b>void</c-><c- o>*</c-> <c- nf>allocate_function_t</c-><c- p>(</c-><c- b>size_t</c-> <c- n>alignment</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>size</c-><c- p>);</c->
<c- k>typedef</c-> <c- b>void</c-> <c- nf>deallocate_function_t</c-><c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>p</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>alignment</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>size</c-><c- p>);</c->

<c- n>_Any_func</c-><c- o>*</c-> <c- nf>stdc_make_trampoline</c-><c- p>(</c-><c- n>FUNCTION</c-><c- o>-</c-><c- n>WITH</c-><c- o>-</c-><c- n>DATA</c-><c- o>-</c-><c- n>IDENTIFIER</c-> <c- n>func</c-><c- p>);</c->
<c- n>_Any_func</c-><c- o>*</c-> <c- nf>stdc_make_trampoline_with</c-><c- p>(</c->
  <c- n>FUNCTION</c-><c- o>-</c-><c- n>WITH</c-><c- o>-</c-><c- n>DATA</c-><c- o>-</c-><c- n>IDENTIFIER</c-> <c- n>func</c-><c- p>,</c->
  <c- n>allocation_function_t</c-><c- o>*</c-> <c- n>alloc</c->
<c- p>);</c->

<c- b>void</c-> <c- nf>stdc_destroy_trampoline</c-><c- p>(</c-><c- n>_Any_func</c-><c- o>*</c-> <c- n>func</c-><c- p>);</c->
<c- b>void</c-> <c- nf>stdc_destroy_trampoline_with</c-><c- p>(</c-><c- n>_Any_func</c-><c- o>*</c-> <c- n>func</c-><c- p>,</c-> <c- n>deallocate_function_t</c-><c- o>*</c-> <c- n>dealloc</c-><c- p>);</c->
</pre>
   <p><code class="highlight"><c- n>stdc_make_trampoline</c-><c- p>(</c-><c- n>f</c-><c- p>)</c-></code> would use some implementation-defined memory (including something pre-allocated, such as in Apple blocks (<a href="#intro-blocks-trampoline">§ 2.3.5 (Explicit) Trampolines: Page-based Non-Executable Implementation</a>)). The recommended default would be that it just calls <code class="highlight"><c- n>stdc_make_trampoline_with</c-><c- p>(</c-><c- n>f</c-><c- p>,</c-> <c- n>aligned_alloc</c-><c- p>)</c-></code>. <code class="highlight"><c- n>stdc_destroy_trampoline</c-><c- p>(</c-><c- n>f</c-><c- p>)</c-></code> would undo, exactly, what <code class="highlight"><c- n>stdc_make_trampoline</c-></code> would give. The recommended default would be that it is identical to <code class="highlight"><c- n>stdc_destroy_trampoline_with</c-><c- p>(</c-><c- n>f</c-><c- p>,</c-> <c- n>free_aligned_size</c-><c- p>)</c-></code>. Providing an allocation and a deallocation function means that while the implementation controls what is done to the memory and how it gets set up, the user controls where that memory is surfaced from. This would prevent the problem of the Heap Alternative Nested Function implementation: rather than creating a special stack or having to rely on memory allocation functions, the compiler can instead source the memory from a user. This also makes such an allocation explicit, and means that its lifetime could be  Though, given our memory primitives, a slightly better implementation that would allow the implementation to take care of (potentially) extra space handed down by alignment and what not would be:</p>
<pre class="language-cpp highlight"><c- k>struct</c-> <c- nc>allocation</c-> <c- p>{</c-> <c- b>void</c-><c- o>*</c-> <c- n>data</c-><c- p>;</c-> <c- b>size_t</c-> <c- n>size</c-><c- p>;</c-> <c- p>};</c->
<c- k>typedef</c-> <c- n>allocation</c-> <c- nf>allocate_function_t</c-> <c- p>(</c-><c- b>size_t</c-> <c- n>alignment</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>size</c-><c- p>);</c->
<c- k>typedef</c-> <c- b>void</c-> <c- nf>deallocate_function_t</c-> <c- p>(</c-><c- b>void</c-><c- o>*</c-> <c- n>p</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>alignment</c-><c- p>,</c-> <c- b>size_t</c-> <c- n>size</c-><c- p>);</c->

<c- n>_Any_func</c-><c- o>*</c-> <c- nf>stdc_make_trampoline</c-><c- p>(</c-><c- n>FUNCTION_TYPE</c-> <c- n>func</c-><c- p>);</c->
<c- n>_Any_func</c-><c- o>*</c-> <c- nf>stdc_make_trampoline_with</c-><c- p>(</c-><c- n>FUNCTION_TYPE</c-> <c- n>func</c-><c- p>,</c-> <c- n>allocation_function_t</c-><c- o>*</c-> <c- n>alloc</c-><c- p>);</c->

<c- b>void</c-> <c- nf>stdc_destroy_trampoline</c-><c- p>(</c-><c- n>_Any_func</c-><c- o>*</c-> <c- n>func</c-><c- p>);</c->
<c- b>void</c-> <c- nf>stdc_destroy_trampoline_with</c-><c- p>(</c-><c- n>_Any_func</c-><c- o>*</c-><c- p>,</c-> <c- n>deallocate_function_t</c-><c- o>*</c-> <c- n>dealloc</c-><c- p>);</c->
</pre>
   <p>Regardless the form that the <code class="highlight"><c- n>make</c-></code>/<code class="highlight"><c- n>destroy</c-></code> functions take, this sort of intrinsic would be capable of lifting not just a typical GNU nested functions but all types of functions to be a single, independent function pointer with some kind of backing storage. Some desire may still exist to make the allocation and deallocation process automatic, but that should be left to compiler vendors to decide for ease-of-use tradeoffs versus e.g. security, like in <a href="#intro-nested.functions-design">§ 2.2.2 Early Design Flaw: Nested Functions turn the stack Executable!</a>.</p>
   <p>It should be noted that Apple itself already has a version of this with this Objective-C Blocks Implementation (<a data-link-type="biblio" href="#biblio-objective-c-block-trampoline" title="Objective-C Runtime / imp_implementationWithBlock">[objective-c-block-trampoline]</a>), albeit with limitations discussed in <a href="#intro-blocks-trampoline">§ 2.3.5 (Explicit) Trampolines: Page-based Non-Executable Implementation</a>. GCC does not expose an intrinsic for this per-se, but does provide <code class="highlight"><c- n>__builtin_call_with_static_chain</c-></code> (<a data-link-type="biblio" href="#biblio-builtin_call_with_static_chain_gcc" title="GCC Online Documentation: Constructing Calls">GCC Documentation: Builtin Call with Static Chain</a>). One can build a trampoline mechanism overtop of that, provided they had the properly-created function plus the right stack frame / "environment" chain pointer to go with the function callable. Since C++ Lambdas -- and the proposed Capture Functions and C-Style Lambdas here -- are by themselves <a href="#design-capture.functions-complete.objects">Complete Objects</a>, one can always create a "thunk" or "trampoline" for them manually, using a wide variety of allowable techniques from heap allocation to pre-stored arrays to <code class="highlight"><c- k>_Thread_local</c-></code>/<code class="highlight"><c- k>static</c-></code> data or otherwise. C++ could implement <code class="highlight"><c- n>stdc_make_trampoline</c-></code> entirely as a library function, but C cannot; so, this is something vendors will have to figure out on their own.</p>
   <p>The only part that needs to be user-configurable is the source of memory. Of course, if an implementation does not want to honor a user’s request, they can simply return a <code class="highlight"><c- p>(</c-><c- n>Any_func</c-><c- o>*</c-><c- p>)</c-><c- n>nullptr</c-><c- p>;</c-></code> all the time. This would be hostile, of course, so a vendor would have to choose wisely about whether or not they should do this. The paper proposing this functionality would also need to discuss setting <code class="highlight"><c- n>errno</c-></code> to an appropriate indicator after use of the intrinsic, if only to appropriately indicate what went wrong. For example, <code class="highlight"><c- n>errno</c-></code> could be set to:</p>
   <ul>
    <li data-md>
     <p><code class="highlight"><c- n>ENOMEM</c-></code>: the allocation function call failed (that is, <code class="highlight"><c- n>alloc</c-></code> returned <code class="highlight"><c- n>nullptr</c-></code>).</p>
    <li data-md>
     <p><code class="highlight"><c- n>EADDRNOAVAIL</c-></code>: the address cannot be used for function calls (e.g., somehow being given invalid memory such as an address in <code class="highlight"><c- p>.</c-><c- n>bss</c-></code>).</p>
    <li data-md>
     <p><code class="highlight"><c- n>EINVAL</c-></code>: <code class="highlight"><c- n>func</c-></code> is a null function pointer or a null object.</p>
    <li data-md>
     <p><code class="highlight"><c- n>EACCESS</c-></code>: the address could be used for function calls but cannot be given adequate permissions (e.g., it cannot be succesfully <code class="highlight"><c- n>mprotect</c-></code>d or <code class="highlight"><c- n>VirtualProtect</c-></code>d).</p>
   </ul>
   <p>to indicate a problem. Albeit, there are always complaints about <code class="highlight"><c- n>errno</c-></code>, so it may also be possible to take an <code class="highlight"><c- b>int</c-><c- o>*</c-> <c- n>p_errcode</c-></code> parameter in the <code class="highlight"><c- n>make_trampoline</c-></code> functions, and use that as a means of solving the problem (or swap the return type and the error code parameter to return the error code and output into an <code class="highlight"><c- n>_Any_func</c-><c- o>*</c-></code>). The API design possibilities are, really, endless.</p>
   <h3 class="heading settled" data-level="5.4" id="appendix-executable.stack.cves"><span class="secno">5.4. </span><span class="content">Executable Stack CVEs</span><a class="self-link" href="#appendix-executable.stack.cves"></a></h3>
   <p><strong class="advisement"> THIS SECTION IS INCOMPLETE.</strong></p>
   <p>The following CVEs are related to executable stack issues.</p>
   <ul>
    <li data-md>
     <p><a href="https://www.cve.org/CVERecord?id=CVE-2017-1000376">CVE 2017-100376: https://www.cve.org/CVERecord?id=CVE-2017-1000376</a></p>
    <li data-md>
     <p><a href="https://www.cve.org/CVERecord?id=CVE-2023-38408">CVE 2023-38408: https://www.cve.org/CVERecord?id=CVE-2023-38408</a></p>
   </ul>
  </main>
<script>
(function() {
  "use strict";
  var collapseSidebarText = '<span aria-hidden="true">←</span> '
                          + '<span>Collapse Sidebar</span>';
  var expandSidebarText   = '<span aria-hidden="true">→</span> '
                          + '<span>Pop Out Sidebar</span>';
  var tocJumpText         = '<span aria-hidden="true">↑</span> '
                          + '<span>Jump to Table of Contents</span>';

  var sidebarMedia = window.matchMedia('screen and (min-width: 78em)');
  var autoToggle   = function(e){ toggleSidebar(e.matches) };
  if(sidebarMedia.addListener) {
    sidebarMedia.addListener(autoToggle);
  }

  function toggleSidebar(on) {
    if (on == undefined) {
      on = !document.body.classList.contains('toc-sidebar');
    }

    /* Don't scroll to compensate for the ToC if we're above it already. */
    var headY = 0;
    var head = document.querySelector('.head');
    if (head) {
      // terrible approx of "top of ToC"
      headY += head.offsetTop + head.offsetHeight;
    }
    var skipScroll = window.scrollY < headY;

    var toggle = document.getElementById('toc-toggle');
    var tocNav = document.getElementById('toc');
    if (on) {
      var tocHeight = tocNav.offsetHeight;
      document.body.classList.add('toc-sidebar');
      document.body.classList.remove('toc-inline');
      toggle.innerHTML = collapseSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, 0 - tocHeight);
      }
      tocNav.focus();
      sidebarMedia.addListener(autoToggle); // auto-collapse when out of room
    }
    else {
      document.body.classList.add('toc-inline');
      document.body.classList.remove('toc-sidebar');
      toggle.innerHTML = expandSidebarText;
      if (!skipScroll) {
        window.scrollBy(0, tocNav.offsetHeight);
      }
      if (toggle.matches(':hover')) {
        /* Unfocus button when not using keyboard navigation,
           because I don't know where else to send the focus. */
        toggle.blur();
      }
    }
  }

  function createSidebarToggle() {
    /* Create the sidebar toggle in JS; it shouldn't exist when JS is off. */
    var toggle = document.createElement('a');
      /* This should probably be a button, but appearance isn't standards-track.*/
    toggle.id = 'toc-toggle';
    toggle.class = 'toc-toggle';
    toggle.href = '#toc';
    toggle.innerHTML = collapseSidebarText;

    sidebarMedia.addListener(autoToggle);
    var toggler = function(e) {
      e.preventDefault();
      sidebarMedia.removeListener(autoToggle); // persist explicit off states
      toggleSidebar();
      return false;
    }
    toggle.addEventListener('click', toggler, false);


    /* Get <nav id=toc-nav>, or make it if we don't have one. */
    var tocNav = document.getElementById('toc-nav');
    if (!tocNav) {
      tocNav = document.createElement('p');
      tocNav.id = 'toc-nav';
      /* Prepend for better keyboard navigation */
      document.body.insertBefore(tocNav, document.body.firstChild);
    }
    /* While we're at it, make sure we have a Jump to Toc link. */
    var tocJump = document.getElementById('toc-jump');
    if (!tocJump) {
      tocJump = document.createElement('a');
      tocJump.id = 'toc-jump';
      tocJump.href = '#toc';
      tocJump.innerHTML = tocJumpText;
      tocNav.appendChild(tocJump);
    }

    tocNav.appendChild(toggle);
  }

  var toc = document.getElementById('toc');
  if (toc) {
    createSidebarToggle();
    toggleSidebar(sidebarMedia.matches);

    /* If the sidebar has been manually opened and is currently overlaying the text
       (window too small for the MQ to add the margin to body),
       then auto-close the sidebar once you click on something in there. */
    toc.addEventListener('click', function(e) {
      if(e.target.tagName.toLowerCase() == "a" && document.body.classList.contains('toc-sidebar') && !sidebarMedia.matches) {
        toggleSidebar(false);
      }
    }, false);
  }
  else {
    console.warn("Can't find Table of Contents. Please use <nav id='toc'> around the ToC.");
  }

  /* Wrap tables in case they overflow */
  var tables = document.querySelectorAll(':not(.overlarge) > table.data, :not(.overlarge) > table.index');
  var numTables = tables.length;
  for (var i = 0; i < numTables; i++) {
    var table = tables[i];
    var wrapper = document.createElement('div');
    wrapper.className = 'overlarge';
    table.parentNode.insertBefore(wrapper, table);
    wrapper.appendChild(table);
  }

})();
</script>
  <h2 class="no-num no-ref heading settled" id="references"><span class="content">References</span><a class="self-link" href="#references"></a></h2>
  <h3 class="no-num no-ref heading settled" id="informative"><span class="content">Informative References</span><a class="self-link" href="#informative"></a></h3>
  <dl>
   <dt id="biblio-__self_func">[__SELF_FUNC]
   <dd>JeanHeyd Meneide; Shepherd (Shepherd's Oasis, LLC). <a href="https://thephd.dev/_vendor/future_cxx/papers/C%20-%20__self_func.html"><cite>__self_func</cite></a>. February 11th, 2025. URL: <a href="https://thephd.dev/_vendor/future_cxx/papers/C%20-%20__self_func.html">https://thephd.dev/_vendor/future_cxx/papers/C%20-%20__self_func.html</a>
   <dt id="biblio-_any_func">[_Any_func]
   <dd>JeanHeyd Meneide; Shepherd (Shepherd's Oasis). <a href="https://thephd.dev/_vendor/future_cxx/papers/C%20-%20_Any_func.html"><cite>_Any_func - A Universal Function Pointer Storage Type</cite></a>. July 6th, 2025. URL: <a href="https://thephd.dev/_vendor/future_cxx/papers/C%20-%20_Any_func.html">https://thephd.dev/_vendor/future_cxx/papers/C%20-%20_Any_func.html</a>
   <dt id="biblio-apple-blocks">[APPLE-BLOCKS]
   <dd>Apple &amp; Contributors. <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/bxDeclaringCreating.html#//apple_ref/doc/uid/TP40007502-CH4-SW1"><cite>Documentation Archive: Declaring and Creating Blocks</cite></a>. May 3rd, 2025. URL: <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/bxDeclaringCreating.html#//apple_ref/doc/uid/TP40007502-CH4-SW1">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/bxDeclaringCreating.html#//apple_ref/doc/uid/TP40007502-CH4-SW1</a>
   <dt id="biblio-builtin_call_with_static_chain_gcc">[BUILTIN_CALL_WITH_STATIC_CHAIN_GCC]
   <dd>GNU Compiler Collection Contributors; Free Software Foundation. <a href="https://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html#index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain"><cite>GCC Online Documentation: Constructing Calls</cite></a>. May 3rd, 2025. URL: <a href="https://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html#index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain">https://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html#index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain</a>
   <dt id="biblio-clang-blocks-spec">[CLANG-BLOCKS-SPEC]
   <dd>The Clang Team; LLVM and Contributors; Apple. <a href="https://clang.llvm.org/docs/Block-ABI-Apple.html"><cite>Clang + LLVM (Latest): Block Implementation Specification</cite></a>. July 8th, 2025. URL: <a href="https://clang.llvm.org/docs/Block-ABI-Apple.html">https://clang.llvm.org/docs/Block-ABI-Apple.html</a>
   <dt id="biblio-closures-in-c-benchmark">[CLOSURES-IN-C-BENCHMARK]
   <dd>JeanHeyd Meneide. <a href="https://thephd.dev/the-cost-of-a-closure-in-c-c2y"><cite>The Cost of a Closure in C</cite></a>. December 10th, 2025. URL: <a href="https://thephd.dev/the-cost-of-a-closure-in-c-c2y">https://thephd.dev/the-cost-of-a-closure-in-c-c2y</a>
   <dt id="biblio-closures-in-c-benchmark-followup">[CLOSURES-IN-C-BENCHMARK-FOLLOWUP]
   <dd>JeanHeyd Meneide. <a href="https://thephd.dev/the-cost-of-a-closure-in-c-c2y-followup"><cite>The Cost of a Closure in C</cite></a>. December 28th, 2025. URL: <a href="https://thephd.dev/the-cost-of-a-closure-in-c-c2y-followup">https://thephd.dev/the-cost-of-a-closure-in-c-c2y-followup</a>
   <dt id="biblio-gamingonlinux-dawe">[GAMINGONLINUX-DAWE]
   <dd>Liam Dawe. <a href="https://www.gamingonlinux.com/2025/02/the-glibc-2-41-update-has-been-causing-problems-for-linux-gaming/"><cite>The glibc 2.41 update has been causing problems for Linux gaming</cite></a>. February 13th, 2025. URL: <a href="https://www.gamingonlinux.com/2025/02/the-glibc-2-41-update-has-been-causing-problems-for-linux-gaming/">https://www.gamingonlinux.com/2025/02/the-glibc-2-41-update-has-been-causing-problems-for-linux-gaming/</a>
   <dt id="biblio-lambdas-nested-functions-block-expressions-oh-my">[LAMBDAS-NESTED-FUNCTIONS-BLOCK-EXPRESSIONS-OH-MY]
   <dd>JeanHeyd Meneide. <a href="https://thephd.dev/lambdas-nested-functions-block-expressions-oh-my"><cite>Lambdas, Nested Functions, and Blocks, oh my!</cite></a>. July 16th, 2021. URL: <a href="https://thephd.dev/lambdas-nested-functions-block-expressions-oh-my">https://thephd.dev/lambdas-nested-functions-block-expressions-oh-my</a>
   <dt id="biblio-n1229">[N1229]
   <dd>Nick Stoughton. <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1229.pdf"><cite>Potential Extensions For Inclusion In a Revision of ISO/IEC 9899</cite></a>. March 26th, 2007. URL: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1229.pdf">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1229.pdf</a>
   <dt id="biblio-n1370">[N1370]
   <dd>Blaine Garst; Apple, Inc.. <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1370.pdf"><cite>n1370: Apple Extensions to C</cite></a>. March 10th, 2009. URL: <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1370.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1370.pdf</a>
   <dt id="biblio-n1451">[N1451]
   <dd>Blaine Garst; Apple. <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1451.pdf"><cite>n1451: Blocks Proposal</cite></a>. April 13th, 2010. URL: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1451.pdf">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1451.pdf</a>
   <dt id="biblio-n1457">[N1457]
   <dd>Blaine Garst; Apple. <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1457.pdf"><cite>n1457: Blocks</cite></a>. April 20th, 2010. URL: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1457.pdf">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1457.pdf</a>
   <dt id="biblio-n2030">[N2030]
   <dd>Blaine Garst. <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2030.pdf"><cite>n2030: A Closure for C</cite></a>. March 11th, 2016. URL: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2030.pdf">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2030.pdf</a>
   <dt id="biblio-n2661">[N2661]
   <dd>Martin Uecker. <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2661.pdf"><cite>n2661: Nested Functions</cite></a>. February 13th, 2021. URL: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2661.pdf">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2661.pdf</a>
   <dt id="biblio-n2862">[N2862]
   <dd>Martin Uecker; Jens Gustedt. <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2862.pdf"><cite>n2862: Wide Function Pointer Types for Pairing Code and Data</cite></a>. November 30th, 2021. URL: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2862.pdf">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2862.pdf</a>
   <dt id="biblio-n2892">[N2892]
   <dd>Jens Gustedt. <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2892.pdf"><cite>Basic lambdas for C</cite></a>. December 25th, 2021. URL: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2892.pdf">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2892.pdf</a>
   <dt id="biblio-n2893">[N2893]
   <dd>Jens Gustedt. <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2893.htm"><cite>Options for Lambdas</cite></a>. December 25th, 2021. URL: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2893.htm">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2893.htm</a>
   <dt id="biblio-n2923">[N2923]
   <dd>Jens Gustedt. <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2923.pdf"><cite>Type inference for variable definitions and function returns</cite></a>. January 30th, 2022. URL: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2923.pdf">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2923.pdf</a>
   <dt id="biblio-n2924">[N2924]
   <dd>Jens Gustedt. <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2924.pdf"><cite>Type-generic Lambdas</cite></a>. January 30th, 2022. URL: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2924.pdf">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2924.pdf</a>
   <dt id="biblio-n3564">[N3564]
   <dd>N. Gustafsson, D. Brewis, H. Sutter, S. Mithani. <a href="https://wg21.link/n3564"><cite>Resumable Functions</cite></a>. 15 March 2013. URL: <a href="https://wg21.link/n3564">https://wg21.link/n3564</a>
   <dt id="biblio-n3643">[N3643]
   <dd>Jakub Łukasiewicz. <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3643.htm"><cite>n3643: Statement Expressions (draft)</cite></a>. July 10th, 2025. URL: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3643.htm">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3643.htm</a>
   <dt id="biblio-n3654">[N3654]
   <dd>Martin Uecker. <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3654.pdf"><cite>n3654: Accessing the Context of Nested Functions</cite></a>. July 20th, 2025. URL: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3654.pdf">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3654.pdf</a>
   <dt id="biblio-n3678">[N3678]
   <dd>Thiago R. Adams. <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3678.pdf"><cite>Local Functions</cite></a>. September 30th, 2025. URL: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3678.pdf">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3678.pdf</a>
   <dt id="biblio-n3679">[N3679]
   <dd>Thiago R. Adams. <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3679.pdf"><cite>Function Literals</cite></a>. September 30th, 2025. URL: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3679.pdf">https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3679.pdf</a>
   <dt id="biblio-nested-functions">[NESTED-FUNCTIONS]
   <dd>GNU Compiler Collection Contributors. <a href="https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html"><cite>Nested Functions (Using the GNU Compiler Collection (GCC))</cite></a>. May 3rd, 2025. URL: <a href="https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html">https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html</a>
   <dt id="biblio-objective-c-block-trampoline">[OBJECTIVE-C-BLOCK-TRAMPOLINE]
   <dd>Objective-C Development Team and Contributors; Apple. <a href="https://developer.apple.com/documentation/objectivec/imp_implementationwithblock(_:)?language=objc"><cite>Objective-C Runtime / imp_implementationWithBlock</cite></a>. July 17th, 2025. URL: <a href="https://developer.apple.com/documentation/objectivec/imp_implementationwithblock(_:)?language=objc">https://developer.apple.com/documentation/objectivec/imp_implementationwithblock(_:)?language=objc</a>
   <dt id="biblio-solar-non-executable-stack-exploits">[SOLAR-NON-EXECUTABLE-STACK-EXPLOITS]
   <dd>solar FALSE COM (Solar Designer). <a href="https://seclists.org/bugtraq/1997/Aug/63"><cite>Getting around non-executable stack (and fix)</cite></a>. August 10th, 1997. URL: <a href="https://seclists.org/bugtraq/1997/Aug/63">https://seclists.org/bugtraq/1997/Aug/63</a>
   <dt id="biblio-swift-escapes">[SWIFT-ESCAPES]
   <dd>Swift Development Team and Contributors; Apple. <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures/#Escaping-Closures"><cite>The Swift Programming Language: Closures</cite></a>. July 6th, 2025. URL: <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures/#Escaping-Closures">https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures/#Escaping-Closures</a>
   <dt id="biblio-thread-attributes">[THREAD-ATTRIBUTES]
   <dd>JeanHeyd Meneide; Shepherd (Shepherd's Oasis, LLC). <a href="https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Thread%20Attributes%20-%20Implementation%20Extensible%20and%20ABI-Resistant.html"><cite>Thread Attributes - Implementation Extensible and ABI-Resistant</cite></a>. July 6th, 2025. URL: <a href="https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Thread%20Attributes%20-%20Implementation%20Extensible%20and%20ABI-Resistant.html">https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Thread%20Attributes%20-%20Implementation%20Extensible%20and%20ABI-Resistant.html</a>
   <dt id="biblio-transparent-aliases">[TRANSPARENT-ALIASES]
   <dd>JeanHeyd Meneide; Shepherd (Shepherd's Oasis, LLC). <a href="https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Transparent%20Aliases.html"><cite>Transparent Aliases</cite></a>. February 20th, 2025. URL: <a href="https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Transparent%20Aliases.html">https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Transparent%20Aliases.html</a>
   <dt id="biblio-wsl-no-executable-stack">[WSL-no-executable-stack]
   <dd>Microsoft; WSL Authors and Contributors; Martin Uecker. <a href="https://github.com/Microsoft/WSL/issues/286"><cite>fis-gtm does not run due to missing support for executable stack</cite></a>. August 7th, 2018. URL: <a href="https://github.com/Microsoft/WSL/issues/286">https://github.com/Microsoft/WSL/issues/286</a>
   <dt id="biblio-ztd-idk-closures-benchmark">[ZTD-IDK-CLOSURES-BENCHMARK]
   <dd>JeanHeyd Meneide. <a href="https://github.com/soasis/idk/tree/main/benchmarks/closures"><cite>ztd.idk Closures Benchmark</cite></a>. December 28th, 2025. URL: <a href="https://github.com/soasis/idk/tree/main/benchmarks/closures">https://github.com/soasis/idk/tree/main/benchmarks/closures</a>
  </dl>