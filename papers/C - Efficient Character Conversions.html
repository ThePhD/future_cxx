<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="JeanHeyd Meneide &lt;phdofthehouse@gmail.com&gt;" />
  <meta name="author" content="Shepherd (Shepherd’s Oasis) &lt;shepherd@soasis.org&gt;" />
  <title>Restartable and Non-Restartable Functions for Efficient Character Conversions | r2</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f8f8f8; }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ef2929; } /* Alert */
code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #c4a000; } /* Attribute */
code span.bn { color: #0000cf; } /* BaseN */
code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4e9a06; } /* Char */
code span.cn { color: #000000; } /* Constant */
code span.co { color: #8f5902; font-style: italic; } /* Comment */
code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code span.dt { color: #204a87; } /* DataType */
code span.dv { color: #0000cf; } /* DecVal */
code span.er { color: #a40000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #0000cf; } /* Float */
code span.fu { color: #000000; } /* Function */
code span.im { } /* Import */
code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code span.ot { color: #8f5902; } /* Other */
code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code span.sc { color: #000000; } /* SpecialChar */
code span.ss { color: #4e9a06; } /* SpecialString */
code span.st { color: #4e9a06; } /* String */
code span.va { color: #000000; } /* Variable */
code span.vs { color: #4e9a06; } /* VerbatimString */
code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Restartable and Non-Restartable Functions for Efficient Character Conversions | r2</h1>
<p class="author">JeanHeyd Meneide &lt;<a href="mailto:phdofthehouse@gmail.com" class="email">phdofthehouse@gmail.com</a>&gt;</p>
<p class="author">Shepherd (Shepherd’s Oasis) &lt;<a href="mailto:shepherd@soasis.org" class="email">shepherd@soasis.org</a>&gt;</p>
<p class="date">March 2nd, 2020</p>
</header>
<style>
pre {
  margin-top: 0px;
  margin-bottom: 0px;
}
.ins, ins, ins *, span.ins, span.ins * {
  background-color: rgb(200, 250, 200);
  color: rgb(0, 136, 0);
  text-decoration: underline;
}
.del, del, del *, span.del, span.del * {
  background-color: rgb(250, 200, 200);
  color: rgb(255, 0, 0);
  text-decoration: line-through;
  text-decoration-color: rgb(255, 0, 0);
}
math, span.math {
  font-family: serif;
  font-style: italic;
}
ul {
  list-style-type: "— ";
}
blockquote {
  counter-reset: paragraph;
}
div.numbered, div.newnumbered {
  margin-left: 2em;
  margin-top: 1em;
  margin-bottom: 1em;
}
div.numbered:before, div.newnumbered:before {
  position: absolute;
  margin-left: -2em;
  display-style: block;
}
div.numbered:before {
  content: counter(paragraph);
  counter-increment: paragraph;
}
div.newnumbered:before {
  content: "�";
}
div.numbered ul, div.newnumbered ul {
  counter-reset: list_item;
}
div.numbered li, div.newnumbered li {
  margin-left: 3em;
}
div.numbered li:before, div.newnumbered li:before {
  position: absolute;
  margin-left: -4.8em;
  display-style: block;
}
div.numbered li:before {
  content: "(" counter(paragraph) "." counter(list_item) ")";
  counter-increment: list_item;
}
div.newnumbered li:before {
  content: "(�." counter(list_item) ")";
  counter-increment: list_item;
}

@media print
{
  .pagebreak { break-after: always }
}
</style>
<p><em><strong>Document</strong></em>: n2500<br />
<em><strong>Previous Revisions</strong></em>: n2440, n2431<br />
<em><strong>Audience</strong></em>: WG14<br />
<em><strong>Proposal Category</strong></em>: New Library Features<br />
<em><strong>Target Audience</strong></em>: General Developers, Text Processing Developers<br />
<em><strong>Latest Revision</strong></em>: <a href="https://thephd.github.io/vendor/future_cxx/papers/source/n2440.html">https://thephd.github.io/vendor/future_cxx/papers/source/n2440.html</a></p>
<p style="text-align: center">
<span style="font-style: italic; font-weight: bold">Abstract:</span>
<p>
Implementations firmly control what both the Wide Character and Multibyte Character literals are interpreted as for the encoding, as well as how they are treated at runtime by the Standard Library. While this control is fine, users of the Standard Library have no portability guarantees about how these library functions may behave, especially in the face of encodings that do not support each other’s full codepage. And, despite additions to C11 for maybe-UTF16 and maybe-UTF32 encoded types, these functions only offer conversions of a single unit of information at a time, leaving orders of magnitude of performance on the table.
</p>
<p>
This paper proposes and explores additional library functionality to allow users to retrieve multibyte and wide character into a statically known encoding to enhance the ability to work with text.
</p>
</p>
<h1 id="introduction-and-motivation"><span class="header-section-number">1</span> Introduction and Motivation</h1>
<p>C adopted conversion routines for the current active locale-derived/<code>LC_TYPE</code>-controlled/implementation-defined encoding for Multibyte (<code>mb</code>) Strings and Wide (<code>wc</code>) Strings. While the rationale for having such conversion routines to and from Multibyte and Wide strings in the C library are not explicitly stated in the documents, it is easy to derive the many benefits of a full ecosystem of both restarting (<code>r</code>) and non-restarting conversion routines for both single units and string-based bulk conversions for <code>mb</code> and <code>wc</code> strings. From ease of use with string literals to performance optimizations from bulk processing with vectorization and SIMD operations, the <code>mbs(r)towcs</code> — and vice-versa — granted a rich and fertile ground upon which C library developers took advantage of platform amenities, encoding specifics, and hardware support to provide useful and fast abstractions upon which encoding-aware applications could build.</p>
<p>Unfortunately, none of these API designs were granted to <code>char16_t</code> (<code>c16</code>) or <code>char32_t</code> (<code>c32</code>) conversion functions. Nor were they given a way to work with a well-defined 8-bit multibyte encoding such as UTF8 without having to first pin it down with platform-specific <code>setlocale(...)</code> calls. This has resulted in a series of extremely vexing problems when trying to write a portable, reliable C library code that is not locked to a specific vendor.</p>
<p>This paper looks at the problems, and then proposes a solution (without C Standard wording) with the goal of hoping to arrive at a solution that is worth implementing for the C Standard Library.</p>
<h2 id="problem-1-lack-of-portability"><span class="header-section-number">1.1</span> Problem 1: Lack of Portability</h2>
<p>Already, Windows, z/OS, and POSIX platforms greatly differ in what they offer for <code>char</code>-typed, Multibyte string encodings. EBCDIC is still in play after many decades. Windows’s Active Code Page functionality on its machine prevents portability even within its own ecosystem. Platforms where LANG environment variables control functionality make communication between even processes on the same hardware a silent and often unforeseen gamble for library developers. Using functions which convert to/from <code>mbs</code> make it impossible to have stability guarantees not only between platforms, but for individual machines. Sometimes even cross-process communication becomes exceedingly problematic without opting into a serious amount of platform-specific or vendor-specific code and functionality to lock encodings in, harming the portability of C code greatly.</p>
<p><code>wchar_t</code> does not fare better. By definition, a wide character type must be capable of holding the entire character set in a single unit of <code>wchar_t</code>. Reality, however, is different: this has been a fundamental impossibility for decades for implementers that switched to 16-bit UCS-2 early. IBM machines persist with this issue for all 32-bit builds, though some IBM platforms took advantage of the 64-bit change to do an ABI break and use UTF32 like other Linux distributions settled on. Even if one were to know this knowledge about IBM and program exclusively on their machines, certain IBM platforms can still end up in a situation where <code>wchar_t</code> is neither 32-bit UTF32 or 16-bit UCS-2/UTF16: the encoding can change to something else in certain Chinese locales, becoming completely different.</p>
<p>Windows is permanently stuck on having to explicitly detail that its implementation is “16-bit, UCS-2 as per the standard”, before explicitly informing developers to use vendor-specific <code>WideCharToMultibyte</code>/<code>MultibyteToWideChar</code> to handle UTF16-encoded characters in <code>wchar_t</code>.</p>
<p>These solutions provide ways to achieve a local maxima for a specific vendor or platform. Unfortunately, this comes at the extreme cost of portability: the code has no guarantee it will work anywhere but your machine, and in a world that is increasingly interconnected by devices that interface with networks it makes sharing both data and code troublesome and hard to work with.</p>
<h2 id="problem-2-what-is-the-encoding"><span class="header-section-number">1.2</span> Problem 2: What is the Encoding?</h2>
<p>With <code>setlocale</code> and <code>getlocale</code> only responding to and returning implementation-defined <code>(const )char*</code>, there is no way to portably determine what the locale (and any associated encoding) should or should not be. The typical solution for this has been to code and program only for what is guaranteed by the Standard as what is in the Basic Character Set. While this works fine for source code itself, this produces an extremely hostile environment:</p>
<ul>
<li>conversion functions in the standard mangle and truncate data in (sometimes troubling, sometimes hilarious) fashion;</li>
<li>programs which are not careful to meticulously track encoding of incoming text often lose the ability to understand that text;</li>
<li>programmers can never trust the platform will support even the Latin characters in any representation of data beyond the 7th bit of a byte;</li>
<li>and, interchange between cultures with different default encodings makes it impossible to communicate with others without entirely forsaking the standard library.</li>
</ul>
<p>Abandoning the C <strong>Standard</strong> Library – to get <strong>standard</strong> behavior across platforms – is an exceedingly bitter pill to have to swallow as an enthusiastic C developer.</p>
<h2 id="problem-3-performance"><span class="header-section-number">1.3</span> Problem 3: Performance</h2>
<p>The current version of the C Standard includes functions which attempt to alleviate Problems 1 and 2 by providing conversions from the per-process (and sometimes per-thread), locale-sensitive black box encoding of multibyte <code>char*</code> strings. They do this by providing conversions to <code>char16_t</code> units or <code>char32_t</code> units with <code>mbrtoc(16|32)</code> and <code>c(16|32)rtomb</code> functions. We will for a brief moment ignore the presence of the <code>__STD_C_UTF16__</code> and <code>__STD_C_UTF32__</code> macros and assume the two types mean that string literals and library functions convert to and from UTF16 and UTF32 respectively. We will also ignore that <code>wchar_t</code>’s encoding – which is just as locale-sensitive and unknown at compile and runtime as <code>char</code>’s encoding is – has no such conversion functions. These givens make it possible to say that we, as C programmers, have 2 known encodings which we can use to shepherd data into a stable state for manipulation and processing as library developers.</p>
<p>Even with that knowledge, these one-unit-at-a-time conversions functions are slower than they should be.</p>
<p>On many platforms, these one-at-a-time function calls come from the operating system, dynamically loaded libraries, or other places which otherwise inhibit compiler observation and optimizer inspection. Attempts to vectorize code or unroll loops built around these functions is thoroughly thwarted by this. Building static libraries or from source is very often a non-starter for many platforms. Since the encoding used for multibyte strings and wide strings are controlled by the implementation, it becomes increasingly difficult to provide the functionality to convert long segments of data with decent performance characteristics without needing to opt into vendor or platform specific tricks.</p>
<h2 id="problem-4-wchar_t-cannot-roundtrip"><span class="header-section-number">1.4</span> Problem 4: wchar_t cannot roundtrip</h2>
<p>With no <code>wctoc32</code> or <code>wctoc16</code> functions, the only way to convert a wide character or wide character string to a program-controlled, statically known encoding is to first invoke the wide character to multibyte function, and then invoke the multibyte function to either <code>char16_t</code> or <code>char32_t</code>.</p>
<p>This means that even if we have a well-behaved <code>wchar_t</code> that is not sensitive to the locale (e.g., on Windows machines), we lose data if the locale-controlled <code>char</code> encoding is not set to something that can handle all incoming code unit sequences. The locale-based encoding in a program can thus tank what is simply meant to be a pass-through encoding from <code>wchar_t</code> to <code>char16_t</code>/<code>char32_t</code>, all because the only Standards-compliant conversion channels data through the locale-based multibyte encoding <code>mb(s)(r)toX</code> functions.</p>
<p>For example, it was fundamentally impossible to engage in a successful conversion from <code>wchar_t</code> strings to <code>char</code> multibyte strings on Windows using the C Standard Library. Until a very recent Windows 10 update, UTF8 could <strong>not</strong> be set as the active system codepage either programmatically or through an experimental, deeply-buried setting. This has changed with Windows Version 1903 (May 2019 Update), but the problems do not stop there.</p>
<p>Because other library functions can be used to change or alter the locale in some manner, it once again becomes impossible to have a portable, compliant program with deterministic behavior if even one library changes the locale of the program, let alone if the encoding or locale is unexpected by the developer because they do not know of that culture or its locale setting. This hidden state is nearly impossible to account for, and ends up with software systems that cannot properly handle text in a meaningful way without abandoning C’s encoding facilities, relying on vendor-specific extensions/encodings/tools, or confining one’s program to only the 7-bit plane of existence.</p>
<h2 id="motivation"><span class="header-section-number">1.5</span> Motivation</h2>
<p>In short, the problems C developers face today with respect to encoding and dealing with vendor and platform-specific black boxes is a staggering trifecta: non-portability between processes running on the same physical hardware, performance degradation from using standard facilities, and potentially having a locale changed out from under your program to prevent roundtripping.</p>
<p>This serves as the core motivation for this proposal.</p>
<h1 id="prior-art"><span class="header-section-number">2</span> Prior Art</h1>
<p>The Small Device C Compiler (SDCC) has already begun some of this work. One of its principle contributors, Philip K. Krause, wrote papers addressing exactly this problem<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2282.htm">[1]</a>. Krause’s work focuses entirely on non-restartable conversions from Multibyte Strings to <code>char16_t</code>. and <code>char32_t</code>. There is no need for a conversion to a UTF8 <code>char</code> style string for SDCC, since the Multibyte String in SDCC is always UTF8. This means that <code>mbstoc16s</code> and <code>mbstoc32s</code> and the “reverse direction” functions encompass an entire ecosystem of UTF8, UTF16, and UTF32.</p>
<p>While this is good for SDCC, this is not quite enough for other developers who attempt to write code in a cross-platform manner. While the non-restartable functions can save quite a bit of code size (see <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2282.htm">[1]</a>), unfortunately there are many encodings which are not as nice and require state to be processed correctly (e.g., Shift JIS and other ISO-2022 encodings). Not being able to retain that state between potential calls in a <code>mbstate_t</code> is detrimental to the ability to move forward with any encoding endeavor that wishes to bridge the gap between these disparate platform encodings and the current locale.</p>
<p>SDCC’s work is still important, however: it demonstrates that these functions are implementable, even for small devices. With additional work being done to implement them for other platforms, there is strong evidence that this can be implemented in a cross-platform manner and thusly is suitable for the Standard Library.</p>
<div class="pagebreak">

</div>
<h1 id="proposed-changes"><span class="header-section-number">3</span> Proposed Changes</h1>
<p>To understand what this paper proposes, an explanation of the current landscape is in order. The below table is meant to be read as being <code>{row}(r)to{column}</code>. The symbols provide the following information:</p>
<ul>
<li>✔️: Function exists in both its restartable (function name has the indicative <code>r</code> in it) and non-restartable form.</li>
<li>🇷: Function exists only in its restartable form.</li>
<li>❌: Function does not exist at all.</li>
<li>🅿️: Modifying marker indicates intention to standardize either the restartable function (🇷) or both restartable and non-restartable functions (✔️).</li>
</ul>
<p>Here is what exists in the C Standard Library so far:</p>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-weight:normal;padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
</style>
<table class="tg">
<tr>
<th class="tg-c3ow">
</th>
<th class="tg-c3ow">
mb
</th>
<th class="tg-c3ow">
wc
</th>
<th class="tg-c3ow">
mbs
</th>
<th class="tg-c3ow">
wcs
</th>
<th class="tg-c3ow">
c8
</th>
<th class="tg-c3ow">
c16
</th>
<th class="tg-c3ow">
c32
</th>
<th class="tg-c3ow">
c8s
</th>
<th class="tg-c3ow">
c16s
</th>
<th class="tg-c3ow">
c32s
</th>
</tr>
<tr>
<td class="tg-c3ow">
mb
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
✔️
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
🇷
</td>
<td class="tg-c3ow">
🇷
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
</tr>
<tr>
<td class="tg-c3ow">
wc
</td>
<td class="tg-c3ow">
✔️
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
</tr>
<tr>
<td class="tg-c3ow">
mbs
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
✔️
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
</tr>
<tr>
<td class="tg-c3ow">
wcs
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
✔️
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
</tr>
<tr>
<td class="tg-c3ow">
c8
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
</tr>
<tr>
<td class="tg-c3ow">
c16
</td>
<td class="tg-c3ow">
🇷
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
</tr>
<tr>
<td class="tg-c3ow">
c32
</td>
<td class="tg-c3ow">
🇷
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
</tr>
<tr>
<td class="tg-c3ow">
c8s
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌ <br>
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
</tr>
<tr>
<td class="tg-c3ow">
c16s
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
❌
</td>
</tr>
<tr>
<td class="tg-c3ow">
c32s
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
➖
</td>
</tr>
</table>
<div class="pagebreak">

</div>
<p>To support getting data losslessly out of <code>wchar_t</code> and <code>char</code> strings controlled firmly by the implementation – and back into those types if the code units in the characters are supported –, the following functionality is proposed:</p>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{padding:10px 10px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-3ib7{border-color:inherit;text-align:center;vertical-align:top}
</style>
<table class="tg">
<tr>
<th class="tg-3ib7">
</th>
<th class="tg-c3ow">
mb
</th>
<th class="tg-c3ow">
wc
</th>
<th class="tg-c3ow">
mbs
</th>
<th class="tg-c3ow">
wcs
</th>
<th class="tg-c3ow">
c8
</th>
<th class="tg-c3ow">
c16
</th>
<th class="tg-c3ow">
c32
</th>
<th class="tg-c3ow">
c8s
</th>
<th class="tg-c3ow">
c16s
</th>
<th class="tg-c3ow">
c32s
</th>
</tr>
<tr>
<td class="tg-c3ow">
mb
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
✔️
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
🅿️🇷
</td>
<td class="tg-c3ow">
🇷
</td>
<td class="tg-c3ow">
🇷
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
</tr>
<tr>
<td class="tg-c3ow">
wc
</td>
<td class="tg-c3ow">
✔️
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
🅿️🇷
</td>
<td class="tg-c3ow">
🅿️🇷
</td>
<td class="tg-c3ow">
🅿️🇷
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
</tr>
<tr>
<td class="tg-c3ow">
mbs
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
✔️
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
🅿️✔
</td>
<td class="tg-c3ow">
🅿️✔
</td>
<td class="tg-c3ow">
🅿️✔
</td>
</tr>
<tr>
<td class="tg-c3ow">
wcs
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
✔️
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
🅿️✔
</td>
<td class="tg-c3ow">
🅿️✔
</td>
<td class="tg-c3ow">
🅿️✔
</td>
</tr>
<tr>
<td class="tg-c3ow">
c8
</td>
<td class="tg-c3ow">
🅿️🇷
</td>
<td class="tg-c3ow">
🅿️🇷
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
</tr>
<tr>
<td class="tg-c3ow">
c16
</td>
<td class="tg-c3ow">
🇷
</td>
<td class="tg-c3ow">
🅿️🇷
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
</tr>
<tr>
<td class="tg-c3ow">
c32
</td>
<td class="tg-c3ow">
🇷
</td>
<td class="tg-c3ow">
🅿️🇷
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
</tr>
<tr>
<td class="tg-c3ow">
c8s
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
🅿️✔
</td>
<td class="tg-c3ow">
🅿️✔
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
</tr>
<tr>
<td class="tg-c3ow">
c16s
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
🅿️✔
</td>
<td class="tg-c3ow">
🅿️✔
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
➖
</td>
<td class="tg-c3ow">
❌
</td>
</tr>
<tr>
<td class="tg-c3ow">
c32s
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
🅿️✔
</td>
<td class="tg-c3ow">
🅿️✔
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
❌
</td>
<td class="tg-c3ow">
➖
</td>
</tr>
</table>
<p>In particular, it is imperative to recognize that the implementation is the “sole proprietor” of the wide character (<code>wc</code>) and Multibyte (<code>mb</code>) encodings for its string literals (compiler) and library functions (standard library).</p>
<h2 id="single-unit-functions"><span class="header-section-number">3.1</span> Single-Unit Functions</h2>
<p>Focus should be applied on adding the one-at-a-time functions for <code>char</code> and <code>wchar_t</code>, which begets the start of this proposal:</p>
<ul>
<li>Multibyte Character:
<ul>
<li><code>mbrtoc8</code> and <code>c8rtomb</code></li>
</ul></li>
<li>Wide Character:
<ul>
<li><code>wcrtoc8</code> and <code>c8rtowc</code></li>
<li><code>wcrtoc16</code> and <code>c16rtowc</code></li>
<li><code>wcrtoc32</code> and <code>c32rtowc</code></li>
</ul></li>
</ul>
<p>Only the “<code>r</code>” (restarting) versions of these functions are proposed here because otherwise single code unit conversions would not be able to respect multiple code units of either <code>char16_t</code> or <code>char32_t</code>. For more information about multi-unit encodings and the trouble that comes with not using a restartable version and not returning sufficient information, see the discussion related to <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2244.htm#dr_488">N1991 and DR488</a><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2244.htm#dr_488">[2]</a>.</p>
<p>The forms of such functions would be as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">/* Multibyte Character, Single Unit (UTF8): */</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="dt">size_t</span> mbrtoc8(<span class="dt">char</span>* restrict pc8, <span class="at">const</span> <span class="dt">char</span>* restrict src, <span class="dt">size_t</span> src_len, <span class="dt">mbstate_t</span>* restrict state);</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="dt">size_t</span> c8rtomb(<span class="dt">char</span>* restrict pc, <span class="at">const</span> <span class="dt">char</span>* restrict src, <span class="dt">size_t</span> src_len, <span class="dt">mbstate_t</span>* restrict state);</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">/* Wide Character, Single Unit: */</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="dt">size_t</span> wcrtocX(<span class="dt">charX_t</span>* restrict pcX, <span class="at">const</span> <span class="dt">wchar_t</span>* restrict src, <span class="dt">size_t</span> src_len, <span class="dt">mbstate_t</span>* restrict state);</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="dt">size_t</span> cXrtowc(<span class="dt">wchar_t</span>* restrict pwc, <span class="at">const</span> <span class="dt">charX_t</span>* restrict src, <span class="dt">size_t</span> src_len, <span class="dt">mbstate_t</span>* restrict state);</span></code></pre></div>
<p>where <code>X</code> and <code>charX_t</code> is one of { <code>8</code>, <code>char</code> }, { <code>16</code>, <code>char16_t</code> }, or { <code>32</code>, <code>char32_t</code> } for the function’s specification.</p>
<h2 id="multi-unit-functions"><span class="header-section-number">3.2</span> Multi-Unit Functions</h2>
<p>Additionally, the following is also proposed:</p>
<ul>
<li>Multibyte Character Strings:
<ul>
<li><code>mbstoc8s</code> and <code>c8stombs</code></li>
<li><code>mbsrtoc8s</code> and <code>c8srtombs</code></li>
<li><code>mbstoc16s</code> and <code>c16stombs</code></li>
<li><code>mbsrtoc16s</code> and <code>c16srtombs</code></li>
<li><code>mbstoc32s</code> and <code>c32stombs</code></li>
<li><code>mbsrtoc32s</code> and <code>c32srtombs</code></li>
</ul></li>
<li>Wide Character Strings:
<ul>
<li><code>wcstoc8s</code> and <code>c8stowcs</code></li>
<li><code>wcsrtoc8s</code> and <code>c8srtowcs</code></li>
<li><code>wcstoc16s</code> and <code>c16stowcs</code></li>
<li><code>wcsrtoc16s</code> and <code>c16srtowcs</code></li>
<li><code>wcstoc32s</code> and <code>c32stowcs</code></li>
<li><code>wcsrtoc32s</code> and <code>c32srtowcs</code></li>
</ul></li>
</ul>
<p>The functions follow the same conventions as their counterparts, <code>mbstowcs</code> and <code>wcstombs</code> (or <code>mbsrtowcs</code> and <code>wcsrtombs</code>, for the restartable versions). These allow for the implementation to bulk-convert to and from a statically-known encoding. Bulk conversions has significant performance benefits in both C and C++ code: see <a href="https://hsivonen.fi/encoding_rs/#results">[4]</a> and <a href="https://www.youtube.com/watch?v=5FQ87-Ecb-A">[5]</a> (both authors have shown that their code can be ported to use a C interface or just be written directly in C itself).</p>
<p>The forms of such functions would be as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">/* Multibyte Character Strings: */</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="dt">size_t</span> mbstocXs(<span class="dt">charX_t</span>* restrict dest, <span class="at">const</span> <span class="dt">char</span>* restrict src, <span class="dt">size_t</span> dest_len);</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="dt">size_t</span> cXstombs(<span class="dt">char</span>* restrict dest, <span class="at">const</span> <span class="dt">charX_t</span>* restrict src, <span class="dt">size_t</span> dest_len);</span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="dt">size_t</span> mbsrtocXs(<span class="dt">charX_t</span>* restrict dest, <span class="at">const</span> <span class="dt">char</span>** restrict src, <span class="dt">size_t</span> dest_len, <span class="dt">mbstate_t</span>* restrict state);</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="dt">size_t</span> cXsrtombs(<span class="dt">char</span>* dest, <span class="at">const</span> <span class="dt">charX_t</span>** restrict src, <span class="dt">size_t</span> dest_len, <span class="dt">mbstate_t</span>* restrict state);</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co">/* Wide Character Strings: */</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="dt">size_t</span> wcstocXs(<span class="dt">charX_t</span>* restrict dest, <span class="at">const</span> <span class="dt">wchar_t</span>* restrict src, <span class="dt">size_t</span> dest_len);</span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="dt">size_t</span> cXstowcs(<span class="dt">wchar_t</span>* restrict dest, <span class="at">const</span> <span class="dt">charX_t</span>* restrict src, <span class="dt">size_t</span> dest_len);</span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="dt">size_t</span> wcsrtocXs(<span class="dt">charX_t</span>* restrict dest, <span class="at">const</span> <span class="dt">wchar_t</span>** restrict src, <span class="dt">size_t</span> dest_len, <span class="dt">mbstate_t</span>* state);</span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="dt">size_t</span> cXsrtowcs(<span class="dt">wchar_t</span>* restrict dest, <span class="at">const</span> <span class="dt">charX_t</span>** restrict src, <span class="dt">size_t</span> dest_len, <span class="dt">mbstate_t</span>* restrict state);</span></code></pre></div>
<p>where <code>X</code> and <code>charX_t</code> is one of { <code>8</code>, <code>char</code> }, { <code>16</code>, <code>char16_t</code> }, or { <code>32</code>, <code>char32_t</code> } for the function’s specification.</p>
<h2 id="sized-conversion-functions"><span class="header-section-number">3.3</span> Sized Conversion Functions</h2>
<p>Following the conventions of the string-based conversion functions already present, the above functions will use null termination as a marker for stopping. Many streams of text data today have embedded nulls in them, and have thusly required many creative solutions for avoiding embedded nulls (including encodings like Modified UTF-8 (MUTF8)). Thusly, as an extension for this proposal targeting the Standard Library, sized versions of the above functions which take a <code>size_t</code> are also proposed. This parameter would specify the number of code units in the source string.</p>
<p>Previously, sized functions for certain string operations were attempted by trying to duplicate current library functionality but with an <code>RSIZE_MAX</code>-respecting parameter introduced the C 11 Standard, Annex K (for functions like <code>strncpy_s</code>). While the intention and rationale (N1570, §K.3.2 in <a href="http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf">[3]</a>) made it explicitly clear the goal was to prevent potential size errors when going from a signed number to <code>size_t</code> and promote safety, the effect of such changes was different. <code>RSIZE_MAX</code> values on certain platforms were restrictively tiny, taking payloads of reasonable sizes but still rejecting them. C programmers used to developing on certain platforms would use these functions in one area, port that code to another platform, and then would experience what amounted to a Denial of Service as their payloads exceeded the restrictively small <code>RSIZE_MAX</code> values.</p>
<p>Given Annex K’s history and issues, this paper does not propose to implement anything like the <code>rsize</code> functions. Instead, this paper would like to promote <code>size_t</code>-sized function for all of the above currently existing (✔️) and desired (🅿️) functions in the above table. Particularly:</p>
<ul>
<li>Multibyte Character Strings:
<ul>
<li><code>mbsntoc8s</code> and <code>c8sntombs</code></li>
<li><code>mbsnrtoc8s</code> and <code>c8snrtombs</code></li>
<li><code>mbsntoc16s</code> and <code>c16sntombs</code></li>
<li><code>mbsnrtoc16s</code> and <code>c16snrtombs</code></li>
<li><code>mbsntoc32s</code> and <code>c32sntombs</code></li>
<li><code>mbsnrtoc32s</code> and <code>c32snrtombs</code></li>
</ul></li>
<li>Wide Character Strings:
<ul>
<li><code>wcsntoc8s</code> and <code>c8sntowcs</code></li>
<li><code>wcsnrtoc8s</code> and <code>c8snrtowcs</code></li>
<li><code>wcsntoc16s</code> and <code>c16sntowcs</code></li>
<li><code>wcsnrtoc16s</code> and <code>c16snrtowcs</code></li>
<li><code>wcsntoc32s</code> and <code>c32sntowcs</code></li>
<li><code>wcsnrtoc32s</code> and <code>c32snrtowcs</code></li>
</ul></li>
</ul>
<p>The forms of such functions would be as follows:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">/* Multibyte Character Strings: */</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="dt">size_t</span> mbsntocXs(<span class="dt">size_t</span> dest_len, <span class="dt">charX_t</span>* restrict dest, <span class="dt">size_t</span> src_len, <span class="at">const</span> <span class="dt">char</span>* restrict src);</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="dt">size_t</span> cXsntombs(<span class="dt">size_t</span> dest_len, <span class="dt">char</span>* restrict dest, <span class="dt">size_t</span> src_len, <span class="at">const</span> <span class="dt">charX_t</span>* restrict src);</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="dt">size_t</span> mbsnrtocXs(<span class="dt">size_t</span> dest_len, <span class="dt">charX_t</span>* restrict dest, <span class="dt">size_t</span> src_len, <span class="at">const</span> <span class="dt">char</span>** restrict src, <span class="dt">mbstate_t</span>* restrict state);</span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="dt">size_t</span> cXsnrtombs(<span class="dt">size_t</span> dest_len, <span class="dt">char</span>* restrict dest, <span class="dt">size_t</span> src_len, <span class="at">const</span> <span class="dt">charX_t</span>** restrict src, <span class="dt">mbstate_t</span>* restrict state);</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="co">/* Wide Character Strings: */</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="dt">size_t</span> wcsntocXs(<span class="dt">size_t</span> dest_len, <span class="dt">charX_t</span>* restrict dest, <span class="at">const</span> <span class="dt">wchar_t</span>* restrict src);</span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="dt">size_t</span> cXsntowcs(<span class="dt">size_t</span> dest_len, <span class="dt">wchar_t</span>* restrict dest, <span class="at">const</span> <span class="dt">charX_t</span>* restrict src);</span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="dt">size_t</span> wcsnrtocXs(<span class="dt">size_t</span> dest_len, <span class="dt">charX_t</span>* restrict dest, <span class="dt">size_t</span> src_len, <span class="at">const</span> <span class="dt">wchar_t</span>** restrict src, <span class="dt">mbstate_t</span>* restrict state);</span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="dt">size_t</span> cXsnrtowcs(<span class="dt">size_t</span> dest_len, <span class="dt">wchar_t</span>* restrict dest, <span class="dt">size_t</span> src_len, <span class="at">const</span> <span class="dt">charX_t</span>** restrict src, <span class="dt">mbstate_t</span>* restrict state);</span></code></pre></div>
<p>where <code>X</code> and <code>charX_t</code> is one of { <code>8</code>, <code>char</code> }, { <code>16</code>, <code>char16_t</code> }, or { <code>32</code>, <code>char32_t</code> } for the function’s specification. Similar additions can be made for the currently existing <code>mbs(r)towcs</code> and <code>wcs(r)tombs</code> functions as well.</p>
<h2 id="what-about-utfx-utfy-functions"><span class="header-section-number">3.4</span> What about UTF{X} 🔄 UTF{Y} functions?</h2>
<p>Function interconverting between different Unicode Transformation Formats are not proposed here because – while useful – both sides of the encoding are statically known by the developer. The C Standard only wants to consider functionality strictly in the case where the implementation has more information / private information that the developer cannot access in a well-defined and standard manner. A developer can write their own Unicode Transformation Format conversion routines and get them completely right, whereas a developer cannot write the Wide Character and Multibyte Character functions without incredible heroics and/or error-prone assumptions.</p>
<p>This brings up an interesting point, however: if <code>__STD_C_UTF16__</code> and <code>__STD_C_UTF32__</code> both exist, does that not mean the implementation controls what <code>c16</code> and <code>c32</code> mean? This is true, <strong>however</strong>: within a (admittedly limited) survey of implementations, there has been no suggestion or report of an implementation which does not use UTF16 and UTF32 for their <code>char16_t</code> and <code>char32_t</code> literals, respectively. This motivation was, in fact, why a paper percolating through the WG21 Committee – <a href="https://wg21.link/p1041">p1041 “Make <code>char16_t</code>/<code>char32_t</code> literals be UTF16/UTF32”[6]</a> – was accepted. If this changes, then the conversion functions <code>c{X}toc{Y}</code> marked with an ❌ will become important.</p>
<p>Thankfully, that does not seem to be the case at this time. If such changes or such an implementation is demonstrated, these functions can be added to what should be added.</p>
<h1 id="wording"><span class="header-section-number">4</span> Wording</h1>
<p>Conspicuously, you will notice that the below wording is missing the <code>c8</code> functions from the above listing. This is because Tom Honermann has made it clear he would like to get <code>char8_t</code> into the C Language to maintain parity with C++ and its changes. Seeing as there is already a <code>u8</code> character literal type, it is prudent to hold off on giving direct wording to specify any interfaces which may be better served with <code>char8_t</code>, especially as such conversions intend to work explicitly with UTF-8.</p>
<h2 id="intent"><span class="header-section-number">4.1</span> Intent</h2>
<p>The intent of these changes is to add the following 4 character functions.</p>
<ul>
<li>Add <code>wcrtoc16</code>, <code>c16rtowc</code> functions (restartable, c16, wide, null-terminated)</li>
<li>Add <code>wcrtoc32</code>, <code>c32rtowc</code> functions (restartable, c32, wide, null-terminated)</li>
</ul>
<p>The character functions already existing and presented above will serve as the basis for the following 32 string functions:</p>
<ul>
<li>Add <code>mbstoc16s</code>, <code>c16stombs</code> functions (non-restartable, char16_t, multi byte, null-terminated)</li>
<li>Add <code>mbsrtoc16s</code>, <code>c16srtombs</code> functions (restartable, char16_t, multi byte, null-terminated)</li>
<li>Add <code>mbsntoc16s</code>, <code>c16sntombs</code> functions (non-restartable, char16_t, multi byte, sized)</li>
<li>Add <code>mbsnrtoc16s</code>, <code>c16snrtombs</code> functions (restartable, char16_t, multi byte, sized)</li>
<li>Add <code>mbstoc32s</code>, <code>c32stombs</code> functions (non-restartable, char32_t, multi byte, null-terminated)</li>
<li>Add <code>mbsrtoc32s</code>, <code>c32srtombs</code> functions (restartable, char32_t, multi byte, null-terminated)</li>
<li>Add <code>mbsntoc32s</code>, <code>c32sntombs</code> functions (non-restartable, char32_t, multi byte, sized)</li>
<li>Add <code>mbsnrtoc32s</code>, <code>c32snrtombs</code> functions (restartable, char32_t, multi byte, sized)</li>
<li>Add <code>wcstoc16s</code>, <code>c16stowcs</code> functions (non-restartable, char16_t, wide, null-terminated)</li>
<li>Add <code>wcsrtoc16s</code>, <code>c16srtowcs</code> functions (restartable, char16_t, wide, null-terminated)</li>
<li>Add <code>wcsntoc16s</code>, <code>c16sntowcs</code> functions (non-restartable, char16_t, wide, sized)</li>
<li>Add <code>wcsnrtoc16s</code>, <code>c16snrtowcs</code> functions (restartable, char16_t, wide, sized)</li>
</ul>
<p>There is no wording for <code>c8</code>-style functions due to waiting for a proper decision regarding <code>char8_t</code> from Tom Honermann’s paper.</p>
<h2 id="library-wording"><span class="header-section-number">4.2</span> Library Wording</h2>
<p>The following wording goes in §7 Library of the C Standard, relative to Working Draft N247</p>
<h3 id="add-to-7.28.1-restartable-multibytewide-character-conversion-functions-new-subsections-for-the-wcrtoc16-c16rtowc-wcrtoc32-and-c32rtowc-functions"><span class="header-section-number">4.2.1</span> Add to §7.28.1 “Restartable multibyte/wide character conversion functions” new subsections for the <code>wcrtoc16</code>, <code>c16rtowc</code>, <code>wcrtoc32</code>, and <code>c32rtowc</code> functions:</h3>
<blockquote>
<p>
<ins>
<b>7.28.1.� The <code>wcrtoc16</code> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p><sup>1</sup></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="dt">size_t</span> wcrtoc16(<span class="dt">char16_t</span> * restrict pc16, <span class="dt">wchar_t</span> * restrict s, <span class="dt">size_t</span> n, <span class="dt">mbstate_t</span> * ps);</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> If <code>s</code> is a null pointer, the <b><code>wcrtoc16</code></b> function is equivalent to the call:
</ins>
</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a>wcrtoc16(NULL, <span class="st">L&quot;&quot;</span>, <span class="dv">1</span>, ps)</span></code></pre></div>
<p>
<ins>
In this case, the values of the parameters <code>pc16</code> and <code>n</code> are ignored.
</ins>
</p>
<p>
<ins>
<sup>3</sup> If <code>s</code> is not a null pointer, the <b><code>wcrtoc16</code></b> function inspects at most <code>n</code> elements pointed to by <code>s</code> to determine the number of elements needed to complete the next wide character (including any shift sequences). If the function determines the next wide character is complete and valid, it determines the values of the corresponding <code>char16_t</code> characters and then, if <code>pc16</code> is not a null pointer, stores the value of the first (or only) such character in the object pointer to by <code>pc16</code>. Subsequent calls will store successive <code>char16_t</code> characters without consuming additional input until all the <code>char16_t</code> characters have been stored. If the corresponding <code>char16_t</code> character is the null character, the resulting state described is the initial conversion state.
</ins>
</p>
<p>
<ins>
<b>Returns</b>
</ins>
</p>
<p>
<ins>
<sup>4</sup> The <b><code>wcrtoc16</code></b> function returns the first of the following that applies (given the current conversion state):
</ins>
</p>
<dl>
<ins>
<dt>
<code>0</code>
</dt>
<dd>
if the next <code>n</code> or fewer elements complete the wide character that corresponds to the null <code>char16_t</code> character (which is the value stored).
</dd>
</ins>
<ins>
<dt>
<i>between</i> <code>1</code> <i>and</i> <code>n</code> <i>inclusive</i>
</dt>
<dd>
if the next <code>n</code> or fewer elements complete a valid wide character (which is the value stored); the value returned is the number of elements that complete the wide character.
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-3)</code>
</dt>
<dd>
if the next <code>char16_t</code> character resulting from a previous call has been stored (no wide characters from the input have been consumed by this call).
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-2)</code>
</dt>
<dd>
if the next <code>n</code> or fewer elements contribute to an incomplete (but potentially valid) <code>char16_t</code> character, and all <code>n</code> elements have been processed (no value is stored).
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-1)</code>
</dt>
<dd>
if an encoding error occurs, in which case the next <code>n</code> or fewer elements do not contribute to complete or valid <code>char16_t</code> characters: the function stores the value of the macro <b><code>EILSEQ</code></b> in <b><code>errno</code></b>.
</dd>
</ins>
</dl>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.1.� The <code>c16rtowc</code> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<ins>
<sup>1</sup>
</ins>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="dt">size_t</span> c16rtowc(<span class="dt">wchar_t</span> * restrict pwc, <span class="dt">char16_t</span> * restrict s, <span class="dt">size_t</span> n, <span class="dt">mbstate_t</span> * restrict ps);</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> If <code>s</code> is a null pointer, the <b><code>c16rtowc</code></b> function is equivalent to the call:
</ins>
</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a>c16rtowc(NULL, <span class="st">u&quot;&quot;</span>, <span class="dv">1</span>, ps)</span></code></pre></div>
<p>
<ins>
In this case, the values of the parameters <code>pwc</code> and <code>n</code> are ignored.
</ins>
</p>
<p>
<ins>
<sup>3</sup> If <code>s</code> is not a null pointer, the <b><code>c16rtowc</code></b> function inspects at most <code>n</code> elements pointed to by <code>s</code> to determine the number of elements needed to complete the next <code>char16_t</code> character (including any shift sequences). If the function determines the next <code>char16_t</code> character is complete and valid, it determines the values of the corresponding wide characters and then, if <code>pwc</code> is not a null pointer, stores the value of the first (or only) such character in the object pointer to by <code>pwc</code>. Subsequent calls will store successive wide characters without consuming additional input until all the wide characters have been stored. If the corresponding wide character is the null character, the resulting state described is the initial conversion state.
</ins>
</p>
<p>
<ins>
<b>Returns</b>
</ins>
</p>
<p>
<ins>
<sup>4</sup> The <b><code>c16rtowc</code></b> function returns the first of the following (including conversion state):
<dl>
<ins>
<dt>
<code>0</code>
</dt>
<dd>
if the next <code>n</code> or fewer elements complete the <code>char16_t</code> character that corresponds to the null wide character (which is the value stored).
</dd>
</ins>
<ins>
<dt>
<i>between</i> <code>1</code> <i>and</i> <code>n</code> <i>inclusive</i>
</dt>
<dd>
if the next <code>n</code> or fewer elements complete a valid <code>char16_t</code> character (which is the value stored); the value returned is the number of elements that complete the <code>char16_t</code> character.
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-3)</code>
</dt>
<dd>
if the next wide character resulting from a previous call has been stored (no <code>char16_t</code> characters from the input have been consumed by this call).
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-2)</code>
</dt>
<dd>
if the next <code>n</code> or fewer elements contribute to an incomplete (but potentially valid) wide character, and all <code>n</code> elements have been processed (no value is stored).
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-1)</code>
</dt>
<dd>
if an encoding error occurs, in which case the next <code>n</code> or fewer elements do not contribute to complete or valid wide characters: the function stores the value of the macro <b><code>EILSEQ</code></b> in <b><code>errno</code></b>.
</dd>
</ins>
</dl>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.1.� The <code>wcrtoc32</code> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<ins>
<sup>1</sup>
</ins>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="dt">size_t</span> wcrtoc32(<span class="dt">char32_t</span> * restrict pc32, <span class="dt">wchar_t</span> * restrict s, <span class="dt">size_t</span> n, <span class="dt">mbstate_t</span> * ps);</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> If <code>s</code> is a null pointer, the <b><code>wcrtoc32</code></b> function is equivalent to the call:
</ins>
</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a>wcrtoc32(NULL, <span class="st">L&quot;&quot;</span>, <span class="dv">1</span>, ps)</span></code></pre></div>
<p>
<ins>
In this case, the values of the parameters <code>pc32</code> and <code>n</code> are ignored.
</ins>
</p>
<p>
<ins>
<sup>3</sup> If <code>s</code> is not a null pointer, the <b><code>wcrtoc32</code></b> function inspects at most <code>n</code> elements pointed to by <code>s</code> to determine the number of elements needed to complete the next wide character (including any shift sequences). If the function determines the next wide character is complete and valid, it determines the values of the corresponding <code>char32_t</code> characters and then, if <code>pc32</code> is not a null pointer, stores the value of the first (or only) such character in the object pointer to by <code>pc32</code>. Subsequent calls will store successive <code>char32_t</code> characters without consuming additional input until all the <code>char32_t</code> characters have been stored. If the corresponding <code>char32_t</code> character is the null character, the resulting state described is the initial conversion state.
</ins>
</p>
<p>
<ins>
<b>Returns</b>
</ins>
</p>
<p>
<ins>
<sup>4</sup> The <b><code>wcrtoc32</code></b> function returns the first of the following that applies (given the current conversion state):
</ins>
</p>
<dl>
<ins>
<dt>
<code>0</code>
</dt>
<dd>
if the next <code>n</code> or fewer elements complete the wide character that corresponds to the null <code>char32_t</code> character (which is the value stored).
</dd>
</ins>
<ins>
<dt>
<i>between</i> <code>1</code> <i>and</i> <code>n</code> <i>inclusive</i>
</dt>
<dd>
if the next <code>n</code> or fewer elements complete a valid wide character (which is the value stored); the value returned is the number of elements that complete the wide character.
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-3)</code>
</dt>
<dd>
if the next <code>char32_t</code> character resulting from a previous call has been stored (no wide characters from the input have been consumed by this call).
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-2)</code>
</dt>
<dd>
if the next <code>n</code> or fewer elements contribute to an incomplete (but potentially valid) <code>char32_t</code> character, and all <code>n</code> elements have been processed (no value is stored).
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-1)</code>
</dt>
<dd>
if an encoding error occurs, in which case the next <code>n</code> or fewer elements do not contribute to complete or valid <code>char32_t</code> characters: the function stores the value of the macro <b><code>EILSEQ</code></b> in <b><code>errno</code></b>.
</dd>
</ins>
</dl>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.1.� The <code>c32rtowc</code> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<ins>
<sup>1</sup>
</ins>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="dt">size_t</span> c32rtowc(<span class="dt">wchar_t</span> * restrict pwc, <span class="dt">char32_t</span> * restrict s, <span class="dt">size_t</span> n, <span class="dt">mbstate_t</span> * restrict ps);</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> If <code>s</code> is a null pointer, the <b><code>c32rtowc</code></b> function is equivalent to the call:
</ins>
</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a>c32rtowc(NULL, <span class="st">u&quot;&quot;</span>, <span class="dv">1</span>, ps)</span></code></pre></div>
<p>
<ins>
In this case, the values of the parameters <code>pwc</code> and <code>n</code> are ignored.
</ins>
</p>
<p>
<ins>
<sup>3</sup> If <code>s</code> is not a null pointer, the <b><code>c32rtowc</code></b> function inspects at most <code>n</code> elements pointed to by <code>s</code> to determine the number of elements needed to complete the next <code>char32_t</code> character (including any shift sequences). If the function determines the next <code>char32_t</code> character is complete and valid, it determines the values of the corresponding wide characters and then, if <code>pwc</code> is not a null pointer, stores the value of the first (or only) such character in the object pointer to by <code>pwc</code>. Subsequent calls will store successive wide characters without consuming additional input until all the wide characters have been stored. If the corresponding wide character is the null character, the resulting state described is the initial conversion state.
</ins>
</p>
<p>
<ins>
<b>Returns</b>
</ins>
</p>
<p>
<ins>
<sup>4</sup> The <b><code>c32rtowc</code></b> function returns the first of the following (including conversion state):
<dl>
<ins>
<dt>
<code>0</code>
</dt>
<dd>
if the next <code>n</code> or fewer elements complete the <code>char32_t</code> character that corresponds to the null wide character (which is the value stored).
</dd>
</ins>
<ins>
<dt>
<i>between</i> <code>1</code> <i>and</i> <code>n</code> <i>inclusive</i>
</dt>
<dd>
if the next <code>n</code> or fewer elements complete a valid <code>char32_t</code> character (which is the value stored); the value returned is the number of elements that complete the <code>char32_t</code> character.
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-3)</code>
</dt>
<dd>
if the next wide character resulting from a previous call has been stored (no <code>char32_t</code> characters from the input have been consumed by this call).
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-2)</code>
</dt>
<dd>
if the next <code>n</code> or fewer elements contribute to an incomplete (but potentially valid) wide character, and all <code>n</code> elements have been processed (no value is stored).
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-1)</code>
</dt>
<dd>
if an encoding error occurs, in which case the next <code>n</code> or fewer elements do not contribute to complete or valid wide characters: the function stores the value of the macro <b><code>EILSEQ</code></b> in <b><code>errno</code></b>.
</dd>
</ins>
</dl>
</blockquote>
<h3 id="add-a-new-section-7.28.2-non-restartable-multibytewide-string-conversion-functions"><span class="header-section-number">4.2.2</span> Add a new section §7.28.2 “Non-restartable multibyte/wide string conversion functions”:</h3>
<blockquote>
<p>
<ins>
<h6>
7.28.2 Non-restartable multibyte/wide string conversion functions
</h6>
</ins>
</p>
<p>
<ins>
<b>7.28.2.1 The <b><code>mbstoc16s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="dt">size_t</span> mbstoc16s(<span class="dt">char16_t</span> *restrict c16s, <span class="at">const</span> <span class="dt">char</span> *restrict s, <span class="dt">size_t</span> n)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>mbstoc16s</code></b> function converts a sequence of multibyte characters that begins in the initial shift state from the array pointed to by s into a sequence of corresponding <code>char16_t</code> characters and stores not more than <code>n</code> <code>char16_t</code> characters into the array pointed to by <code>c16s</code>.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each multibyte character is converted as if by a call to the <b><code>mbrtoc16</code></b> function with a non-null <code>ps</code> and <b><code>MB_MAX_LEN</code></b> for <code>n</code>. However, no multibyte characters that follow a null character (which is converted into a null <code>char16_t</code> character) will be examined or converted.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a multibyte character is encountered that does not correspond to a valid sequence of <code>char16_t</code> characters, the <b><b><code>mbstoc16s</code></b></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><b><code>mbstoc16s</code></b></b> function returns the number of array elements modified, not including a terminating null <code>char16_t</code> character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.2.2 The <b><code>c16stombs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="dt">size_t</span> c16stombs(<span class="dt">char</span> *restrict s, <span class="at">const</span> <span class="dt">char16_t</span> *restrict c16s, <span class="dt">size_t</span> n)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c16stombs</code></b> function converts a sequence of <code>char16_t</code> characters from the array pointed to by c16s into a sequence of corresponding multibyte characters that begins in the initial shift state, and stores these multibyte characters into the array pointed to by <code>s</code>, stopping if a multibyte character would exceed the limit of <code>n</code> total bytes or if a null character is stored.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each sequence of <code>char16_t</code> characters is converted as if by calls to the c16rtomb function with a non-null <code>ps</code>.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a sequence of <code>char16_t</code> characters is encountered that does not correspond to a valid multibyte character, the c16stombs function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c16stombs</code></b> function returns the number of bytes modified, not including a terminating null character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.2.3 The <b><code>mbstoc32s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="dt">size_t</span> mbstoc32s(<span class="dt">char32_t</span> *restrict c32s, <span class="at">const</span> <span class="dt">char</span> *restrict s, <span class="dt">size_t</span> n)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The mbstoc32s function converts a sequence of multibyte characters that begins in the initial shift state from the array pointed to by <code>s</code> into a sequence of corresponding <code>char32_t</code> characters and stores not more than <code>n</code> <code>char32_t</code> characters into the array pointed to by <code>c32s</code>.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each multibyte character is converted as if by a call to the <code>mbrtoc32</code> function with a non-null <code>ps</code> and <code>MB_MAX_LEN</code> for <code>n</code>. However, no multibyte characters that follow a null character (which is converted into a null <code>char32_t</code> character) will be examined or converted.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If an invalid multibyte character is encountered, the <b><code>mbstoc32s</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>mbstoc32s</code></b> function returns the number of array elements modified, not including a terminating null <code>char32_t</code> character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.2.4 The <b><code>c32stombs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="dt">size_t</span> c32stombs(<span class="dt">char</span> *restrict s, <span class="at">const</span> <span class="dt">char32_t</span> *restrict s, <span class="dt">size_t</span> n)&gt;</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c32stombs</code></b> function converts a sequence of <code>char32_t</code> characters from the array pointed to by c32s into a sequence of corresponding multibyte characters that begins in the initial shift state, and stores these multibyte characters into the array pointed to by <code>s</code>, stopping if a multibyte character would exceed the limit of <code>n</code> total bytes or if a null character is stored.
</ins>
</p>
<p>
<ins>
<sup>3</sup>Each <code>char32_t</code> character is converted as if by calls to the <code>c32rtomb</code> function with a non-null <code>ps</code>.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a <code>char32_t</code> character is encountered that does not correspond to a valid multibyte character, the <b><code>c32stombs</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c32stombs</code></b> function returns the number of bytes modified, not including a terminating null character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.2.5 The <b><code>mbsntoc16s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="dt">size_t</span> mbsntoc16s(<span class="dt">size_t</span> c16n, <span class="dt">char16_t</span> *restrict c16s, <span class="dt">size_t</span> n, <span class="at">const</span> <span class="dt">char</span> *restrict s)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>mbsntoc16s</code></b> function converts a sequence of multibyte characters that begins in the initial shift state from the array pointed to by <code>s</code> into a sequence of corresponding <code>char16_t</code> characters and stores not more than <code>c16n</code> <code>char16_t</code> characters into the array pointed to by <code>c16s</code>. It does not convert more than <code>n</code> multibyte characters.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each multibyte character is converted as if by a call to the <b><code>mbrtoc16</code></b> function with a non-null <code>ps</code> and <b><code>MB_MAX_LEN</code></b> for <code>n</code>.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a multibyte character is encountered that does not correspond to a valid sequence of <code>char16_t</code> characters, the <b><b><code>mbsntoc16s</code></b></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><b><code>mbsntoc16s</code></b></b> function returns the number of array elements modified.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.2.6 The <b><code>c16sntombs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="dt">size_t</span> c16sntombs(<span class="dt">size_t</span> n, <span class="dt">char</span> *restrict s, <span class="dt">size_t</span> c16n, <span class="at">const</span> <span class="dt">char16_t</span> *restrict c16s)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c16sntombs</code></b> function converts a sequence of <code>char16_t</code> characters from the array pointed to by <code>c16s</code> into a sequence of corresponding multibyte characters that begins in the initial shift state, and stores these multibyte characters into the array pointed to by <code>s</code>, stopping if a multibyte character would exceed the limit of <code>n</code> total bytes or if the limit of <code>c16n</code> elements is converted.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each sequence of <code>char16_t</code> characters is converted as if by calls to the <code>c16rtomb</code> function with a non-null <code>ps</code>.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a sequence of <code>char16_t</code> characters is encountered that does not correspond to a valid multibyte character, the <b><code>c16sntombs</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c16sntombs</code></b> function returns the number of bytes modified.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.2.7 The <b><code>mbsntoc32s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="dt">size_t</span> mbsntoc32s(<span class="dt">size_t</span> c32n, <span class="dt">char32_t</span> *restrict c32s, <span class="dt">size_t</span> n, <span class="at">const</span> <span class="dt">char</span> *restrict s)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>mbsntoc32s</code></b> function converts a sequence of multibyte characters that begins in the initial shift state from the array pointed to by <code>s</code> into a sequence of corresponding <code>char32_t</code> characters and stores not more than <code>c32n</code> <code>char32_t</code> characters into the array pointed to by <code>c32s</code>. It does not convert more than <code>n</code> multibyte characters.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each multibyte character is converted as if by a call to the <code>mbrtoc32</code> function with a non-null <code>ps</code> and <code>MB_MAX_LEN</code> for <code>n</code>.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<p><sup>4</sup> If an invalid multibyte character is encountered, the <b><code>mbsntoc32s</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>mbsntoc32s</code></b> function returns the number of array elements modified.</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.2.8 The <b><code>c32sntombs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="dt">size_t</span> c32sntombs(<span class="dt">size_t</span> n, <span class="dt">char</span> *restrict s, <span class="dt">size_t</span> c32n, <span class="at">const</span> <span class="dt">char32_t</span> *restrict c32s)&gt;</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c32sntombs</code></b> function converts a sequence of <code>char32_t</code> characters from the array pointed to by c32s into a sequence of corresponding multibyte characters that begins in the initial shift state, and stores these multibyte characters into the array pointed to by <code>s</code>, stopping if a multibyte character would exceed the limit of <code>n</code> total bytes or if the limit of <code>c32n</code> elements is converted.
</ins>
</p>
<p>
<ins>
<sup>3</sup>Each <code>char32_t</code> character is converted as if by calls to the <code>c32rtomb</code> function with a non-null <code>ps</code>.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a <code>char32_t</code> character is encountered that does not correspond to a valid multibyte character, the <b><code>c32sntombs</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c32sntombs</code></b> function returns the number of bytes modified.
</ins>
</p>
</blockquote>
<h3 id="add-a-new-section-7.28.3-restartable-multibytewide-string-conversion-functions"><span class="header-section-number">4.2.3</span> Add a new section §7.28.3 “Restartable multibyte/wide string conversion functions”:</h3>
<blockquote>
<p>
<ins>
<h6>
7.28.3 Restartable multibyte/wide string conversion functions
</h6>
</ins>
</p>
<p>
<ins>
<b>7.28.3.1 The <b><code>mbsrtoc16s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="dt">size_t</span> mbsrtoc16s(<span class="dt">char16_t</span> *restrict c16s, <span class="at">const</span> <span class="dt">char</span> **restrict s, <span class="dt">size_t</span> n, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>mbsrtoc16s</code></b> function converts a sequence of multibyte characters that begins in the shift state specified by <code>ps</code> from the array indirectly pointed to by <code>s</code> into a sequence of corresponding <code>char16_t</code> characters and (if <code>c16s</code> is not a null pointer) stores not more than<code>n</code> <code>char16_t</code> characters into the array pointed to by <code>c16s</code>.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each multibyte character is converted as if by a call to the <b><code>mbrtoc16</code></b> function with <b><code>MB_MAX_LEN</code></b> for <code>n</code>. However, no multibyte characters that follow a null character (which is converted into a null <code>char16_t</code> character) will be examined or converted. If <code>c16s</code> not a null pointer, the pointer object pointed to by <code>s</code> is assigned either a null pointer (if conversion stopped due to reaching a terminating null character) or the address just past the last <code>char16_t</code> character converted (if any). If conversion stopped due to reaching a terminating null character and if <code>c16s</code> is not a null pointer, the resulting state described by <code>ps</code> is the initial conversion state.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a multibyte character is encountered that does not correspond to a valid sequence of <code>char16_t</code> characters, the <b><b><code>mbsrtoc16s</code></b></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><b><code>mbsrtoc16s</code></b></b> function returns the number of array elements modified, not including a terminating null <code>char16_t</code> character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.2 The <b><code>c16srtombs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="dt">size_t</span> c16srtombs(<span class="dt">char</span> *restrict s, <span class="at">const</span> <span class="dt">char16_t</span> **restrict c16s, <span class="dt">size_t</span> n, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c16srtombs</code></b> function converts a sequence of <code>char16_t</code> characters from the array indirectly pointed to by <code>c16s</code> into a sequence of corresponding multibyte characters that begins in the shift state specified by <code>ps</code>, and (if <code>s</code> is not a null pointer) stores these multibyte characters into the array pointed to by <code>s</code>, stopping if a multibyte character would exceed the limit of <code>n</code> total bytes or if a null character is stored.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each sequence of <code>char16_t</code> characters is converted as if by calls to the <b><code>c16rtomb</code></b> function. If <code>s</code> not a null pointer, the pointer object pointed to by <code>c16s</code> is assigned either a null pointer (if conversion stopped due to reaching a terminating null character) or the address just past the last <code>char16_t</code> character converted (if any). If conversion stopped due to reaching a terminating null character and if <code>s</code> is not a null pointer, the resulting state described by <code>ps</code> is the initial conversion state.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a sequence of <code>char16_t</code> characters is encountered that does not correspond to a valid multibyte character, the c16srtombs function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c16srtombs</code></b> function returns the number of bytes modified, not including a terminating null character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.3 The <b><code>mbsrtoc32s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="dt">size_t</span> mbsrtoc32s(<span class="dt">char32_t</span> *restrict c32s, <span class="at">const</span> <span class="dt">char</span> **restrict s, <span class="dt">size_t</span> n, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>mbsrtoc32s</code></b> function converts a sequence of multibyte characters that begins in the shift state specified by <code>ps</code> from the array indirectly pointed to by <code>s</code> into a sequence of corresponding <code>char32_t</code> characters and (if <code>c32s</code> is not a null pointer) stores not more than<code>n</code> <code>char32_t</code> characters into the array pointed to by <code>c32s</code>.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each multibyte character is converted as if by a call to the <b><code>mbrtoc32</code></b> function with <code>MB_MAX_LEN</code> for <code>n</code>. If <code>c32s</code> not a null pointer, the pointer object pointed to by <code>s</code> is assigned either a null pointer (if conversion stopped due to reaching a terminating null character) or the address just past the last <code>char32_t</code> character converted (if any). If conversion stopped due to reaching a terminating null character and if <code>c32s</code> is not a null pointer, the resulting state described by <code>ps</code> is the initial conversion state.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If an invalid multibyte character is encountered, the <b><code>mbsrtoc32s</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>mbsrtoc32s</code></b> function returns the number of array elements modified, not including a terminating null <code>char32_t</code> character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.4 The <b><code>c32srtombs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="dt">size_t</span> c32srtombs(<span class="dt">char</span> *restrict s, <span class="at">const</span> <span class="dt">char32_t</span> **restrict c32s, <span class="dt">size_t</span> n, mbstate *restrict ps)&gt;</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c32srtombs</code></b> function converts a sequence of <code>char32_t</code> characters from the array indirectly pointed to by <code>c32s</code> into a sequence of corresponding multibyte characters that begins in the shift state specified by <code>ps</code>, and (if <code>s</code> is not a null pointer) stores these multibyte characters into the array pointed to by <code>s</code>, stopping if a multibyte character would exceed the limit of <code>n</code> total bytes or if a null character is stored.
</ins>
</p>
<p>
<ins>
<sup>3</sup>Each <code>char32_t</code> character is converted as if by calls to the <b><code>c32rtomb</code></b> function. If <code>s</code> not a null pointer, the pointer object pointed to by <code>c32s</code> is assigned either a null pointer (if conversion stopped due to reaching a terminating null character) or the address just past the last <code>char32_t</code> character converted (if any). If conversion stopped due to reaching a terminating null character and if <code>s</code> is not a null pointer, the resulting state described by <code>ps</code> is the initial conversion state.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a <code>char32_t</code> character is encountered that does not correspond to a valid multibyte character, the <b><code>c32srtombs</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c32srtombs</code></b> function returns the number of bytes modified, not including a terminating null character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.5 The <b><code>mbsnrtoc16s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="dt">size_t</span> mbsnrtoc16s(<span class="dt">size_t</span> c16n, <span class="dt">char16_t</span> *restrict c16s, <span class="dt">size_t</span> n, <span class="at">const</span> <span class="dt">char</span> **restrict s, mbstate* ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>mbsnrtoc16s</code></b> function converts a sequence of multibyte characters that begins in the shift state specified by <code>ps</code> from the array indirectly pointed to by <code>s</code> into a sequence of corresponding <code>char16_t</code> characters and (if <code>c16s</code> is not a null pointer) stores not more than<code>c16n</code> <code>char16_t</code> characters into the array pointed to by <code>c16s</code>. It does not convert more than <code>n</code> multibyte characters.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each multibyte character is converted as if by a call to the <b><code>mbrtoc16</code></b> function with <b><code>MB_MAX_LEN</code></b> for <code>n</code>. If <code>c16s</code> not a null pointer, the pointer object pointed to by <code>s</code> is assigned to the address just past the last multibyte character converted (if any).
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a multibyte character is encountered that does not correspond to a valid sequence of <code>char16_t</code> characters, the <b><code>mbsnrtoc16s</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>mbsnrtoc16s</code></b> function returns the number of array elements modified.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.6 The <b><code>c16snrtombs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="dt">size_t</span> c16snrtombs(<span class="dt">size_t</span> n, <span class="dt">char</span> *restrict s, <span class="dt">size_t</span> c16n, <span class="at">const</span> <span class="dt">char16_t</span> **restrict c16s, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c16snrtombs</code></b> function converts a sequence of <code>char16_t</code> characters from the array indirectly pointed to by <code>c16s</code> into a sequence of corresponding multibyte characters that begins in the shift state specified by <code>ps</code>, and (if <code>s</code> is not a null pointer) stores these multibyte characters into the array pointed to by <code>s</code>, stopping if a multibyte character would exceed the limit of <code>n</code> total bytes or if the limit of <code>c16n</code> elements is converted.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each sequence of <code>char16_t</code> characters is converted as if by calls to the <b><code>c16rtomb</code></b> function. If <code>s</code> not a null pointer, the pointer object pointed to by <code>c16s</code> is assigned to the address just past the last <code>char32_t</code> character converted (if any).
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a sequence of <code>char16_t</code> characters is encountered that does not correspond to a valid multibyte character, the <b><code>c16snrtombs</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c16snrtombs</code></b> function returns the number of bytes modified.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.7 The <b><code>mbsnrtoc32s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="dt">size_t</span> mbsnrtoc32s(<span class="dt">size_t</span> c32n, <span class="dt">char32_t</span> *restrict c32s, <span class="dt">size_t</span> n, <span class="at">const</span> <span class="dt">char</span> **restrict s, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>mbsnrtoc32s</code></b> function converts a sequence of multibyte characters that begins in the shift state specified by <code>ps</code> from the array indirectly pointed to by <code>s</code> into a sequence of corresponding <code>char32_t</code> characters and (if <code>c32s</code> is not a null pointer) stores not more than<code>c32n</code> <code>char32_t</code> characters into the array pointed to by <code>c32s</code>. It does not convert more than <code>n</code> multibyte characters.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each multibyte character is converted as if by a call to the <b><code>mbrtoc32</code></b> function with <code>MB_MAX_LEN</code> for <code>n</code>. If <code>c32s</code> not a null pointer, the pointer object pointed to by <code>s</code> is assigned to the address just past the last multibyte character converted (if any).
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If an invalid multibyte character is encountered, the <b><code>mbsnrtoc32s</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>mbsnrtoc32s</code></b> function returns the number of array elements modified.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.8 The <b><code>c32snrtombs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="dt">size_t</span> c32snrtombs(<span class="dt">size_t</span> n, <span class="dt">char</span> *restrict s, <span class="dt">size_t</span> c32n, <span class="at">const</span> <span class="dt">char32_t</span> **restrict c32s, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c32snrtombs</code></b> function converts a sequence of <code>char32_t</code> characters from the array indirectly pointed to by <code>c32s</code> into a sequence of corresponding multibyte characters that begins in the shift state specified by <code>ps</code>, and (if <code>s</code> is not a null pointer) stores these multibyte characters into the array pointed to by <code>s</code>, stopping if a multibyte character would exceed the limit of <code>n</code> total bytes or if the limit of <code>c32n</code> elements is converted.
</ins>
</p>
<p>
<ins>
<sup>3</sup>Each <code>char32_t</code> character is converted as if by calls to the <b><code>c32rtomb</code></b> function with a non-null <code>ps</code>. If <code>s</code> not a null pointer, the pointer object pointed to by <code>c32s</code> is assigned to the address just past the last <code>char32_t</code> character converted (if any).
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a <code>char32_t</code> character is encountered that does not correspond to a valid multibyte character, the <b><code>c32snrtombs</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c32snrtombs</code></b> function returns the number of bytes modified.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.9 The <b><code>wcsrtoc16s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="dt">size_t</span> wcsrtoc16s(<span class="dt">char16_t</span> *restrict c16s, <span class="at">const</span> <span class="dt">wchar_t</span> **restrict s, <span class="dt">size_t</span> n, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>wcsrtoc16s</code></b> function converts a sequence of wide characters that begins in the shift state specified by <code>ps</code> from the array indirectly pointed to by <code>s</code> into a sequence of corresponding <code>char16_t</code> characters and (if <code>c16s</code> is not a null pointer) stores not more than<code>n</code> <code>char16_t</code> characters into the array pointed to by <code>c16s</code>.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each wide character is converted as if by a call to the <b><code>wcrtoc16</code></b> function. However, no wide characters that follow a null character (which is converted into a null <code>char16_t</code> character) will be examined or converted. If <code>c16s</code> not a null pointer, the pointer object pointed to by <code>s</code> is assigned either a null pointer (if conversion stopped due to reaching a terminating null character) or the address just past the last wide character converted (if any). If conversion stopped due to reaching a terminating null character and if <code>c16s</code> is not a null pointer, the resulting state described by <code>ps</code> is the initial conversion state.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a wide character is encountered that does not correspond to a valid sequence of <code>char16_t</code> characters, the <b><b><code>wcsrtoc16s</code></b></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><b><code>wcsrtoc16s</code></b></b> function returns the number of array elements modified, not including a terminating null <code>char16_t</code> character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.10 The <b><code>c16srtowcs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="dt">size_t</span> c16srtowcs(<span class="dt">wchar_t</span> *restrict s, <span class="at">const</span> <span class="dt">char16_t</span> **restrict c16s, <span class="dt">size_t</span> n, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c16srtowcs</code></b> function converts a sequence of <code>char16_t</code> characters from the array indirectly pointed to by <code>c16s</code> into a sequence of corresponding wide characters that begins in the shift state specified by <code>ps</code>, and (if <code>s</code> is not a null pointer) stores these wide characters into the array pointed to by <code>s</code>, stopping if a wide character would exceed the limit of <code>n</code> total wide characters or if a null character is stored.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each sequence of <code>char16_t</code> characters is converted as if by calls to the <b><code>c16rtomb</code></b> function. However, no <code>char16_t</code> characters that follow a null wide character (which is converted into a null <code>char16_t</code> character) will be examined or converted. If <code>s</code> not a null pointer, the pointer object pointed to by <code>c16s</code> is assigned either a null pointer (if conversion stopped due to reaching a terminating null character) or the address just past the last <code>char16_t</code> character converted (if any). If conversion stopped due to reaching a terminating null character and if <code>s</code> is not a null pointer, the resulting state described by <code>ps</code> is the initial conversion state.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a sequence of <code>char16_t</code> characters is encountered that does not correspond to a valid wide character, the c16srtowcs function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c16srtowcs</code></b> function returns the number of bytes modified, not including a terminating null character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.11 The <b><code>wcsrtoc32s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="dt">size_t</span> wcsrtoc32s(<span class="dt">char32_t</span> *restrict c32s, <span class="at">const</span> <span class="dt">wchar_t</span> **restrict s, <span class="dt">size_t</span> n, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The wcsrtoc32s function converts a sequence of wide characters that begins in the shift state specified by <code>ps</code> from the array indirectly pointed to by <code>s</code> into a sequence of corresponding <code>char32_t</code> characters and (if <code>c32s</code> is not a null pointer) stores not more than<code>n</code> <code>char32_t</code> characters into the array pointed to by <code>c32s</code>.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each wide character is converted as if by a call to the <code>wcrtoc32</code> function. However, no wide characters that follow a null wide character (which is converted into a null <code>char32_t</code> character) will be examined or converted. If <code>c32s</code> not a null pointer, the pointer object pointed to by <code>s</code> is assigned either a null pointer (if conversion stopped due to reaching a terminating null character) or the address just past the last wide character converted (if any). If conversion stopped due to reaching a terminating null character and if <code>c32s</code> is not a null pointer, the resulting state described by <code>ps</code> is the initial conversion state.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If an invalid wide character is encountered, the <b><code>wcsrtoc32s</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>wcsrtoc32s</code></b> function returns the number of array elements modified, not including a terminating null <code>char32_t</code> character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.12 The <b><code>c32srtowcs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="dt">size_t</span> c32srtowcs(<span class="dt">wchar_t</span> *restrict s, <span class="at">const</span> <span class="dt">char32_t</span> **restrict c32s, <span class="dt">size_t</span> n, mbstate *restrict ps)&gt;</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c32srtowcs</code></b> function converts a sequence of <code>char32_t</code> characters from the array indirectly pointed to by <code>c32s</code> into a sequence of corresponding wide characters that begins in the shift state specified by <code>ps</code>, and (if <code>s</code> is not a null pointer) stores these wide characters into the array pointed to by <code>s</code>, stopping if a wide character would exceed the limit of <code>n</code> total wide characters or if a null character is stored.
</ins>
</p>
<p>
<ins>
<sup>3</sup>Each <code>char32_t</code> character is converted as if by calls to the <b><code>c32rtomb</code></b> function. However, no <code>char32_t</code> characters that follow a null wide character (which is converted into a null <code>char32_t</code> character) will be examined or converted. If <code>s</code> not a null pointer, the pointer object pointed to by <code>c32s</code> is assigned either a null pointer (if conversion stopped due to reaching a terminating null character) or the address just past the last <code>char32_t</code> character converted (if any). If conversion stopped due to reaching a terminating null character and if <code>s</code> is not a null pointer, the resulting state described by <code>ps</code> is the initial conversion state.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a <code>char32_t</code> character is encountered that does not correspond to a valid wide character, the <b><code>c32srtowcs</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c32srtowcs</code></b> function returns the number of bytes modified, not including a terminating null character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.13 The <b><code>wcsnrtoc16s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="dt">size_t</span> wcsnrtoc16s(<span class="dt">size_t</span> c16n, <span class="dt">char16_t</span> *restrict c16s, <span class="dt">size_t</span> n, <span class="at">const</span> <span class="dt">wchar_t</span> **restrict s, mbstate* ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>wcsnrtoc16s</code></b> function converts a sequence of wide characters that begins in the shift state specified by <code>ps</code> from the array indirectly pointed to by <code>s</code> into a sequence of corresponding <code>char16_t</code> characters and (if <code>c16s</code> is not a null pointer) stores not more than<code>c16n</code> <code>char16_t</code> characters into the array pointed to by <code>c16s</code>. It does not convert more than <code>n</code> wide characters.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each wide character is converted as if by a call to the <b><code>wcrtoc16</code></b> function. If <code>c16s</code> not a null pointer, the pointer object pointed to by <code>s</code> is assigned to the address just past the last wide character converted (if any).
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a wide character is encountered that does not correspond to a valid sequence of <code>char16_t</code> characters, the <b><b><code>wcsnrtoc16s</code></b></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><b><code>wcsnrtoc16s</code></b></b> function returns the number of array elements modified.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.14 The <b><code>c16snrtowcs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="dt">size_t</span> c16snrtowcs(<span class="dt">size_t</span> n, <span class="dt">wchar_t</span> *restrict s, <span class="dt">size_t</span> c16n, <span class="at">const</span> <span class="dt">char16_t</span> **restrict c16s, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c16snrtowcs</code></b> function converts a sequence of <code>char16_t</code> characters from the array indirectly pointed to by <code>c16s</code> into a sequence of corresponding wide characters that begins in the shift state specified by <code>ps</code>, and (if <code>s</code> is not a null pointer) stores these wide characters into the array pointed to by <code>s</code>, stopping if a wide character would exceed the limit of <code>n</code> total elements or if the limit of <code>c16n</code> elements is converted.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each sequence of <code>char16_t</code> characters is converted as if by calls to the <b><code>c16rtomb</code></b> function. If <code>s</code> not a null pointer, the pointer object pointed to by <code>c16s</code> is assigned to the address just past the last <code>char16_t</code> character converted (if any).
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a sequence of <code>char16_t</code> characters is encountered that does not correspond to a valid wide character, the <b><code>c16snrtowcs</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c16snrtowcs</code></b> function returns the number of bytes modified.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.15 The <b><code>wcsnrtoc32s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="dt">size_t</span> wcsnrtoc32s(<span class="dt">size_t</span> c32n, <span class="dt">char32_t</span> *restrict c32s, <span class="dt">size_t</span> n, <span class="at">const</span> <span class="dt">wchar_t</span> **restrict s, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>wcsnrtoc32s</code></b> function converts a sequence of wide characters that begins in the shift state specified by <code>ps</code> from the array indirectly pointed to by <code>s</code> into a sequence of corresponding <code>char32_t</code> characters and (if <code>c32s</code> is not a null pointer) stores not more than<code>c32n</code> <code>char32_t</code> characters into the array pointed to by <code>c32s</code>. It does not convert more than <code>n</code> wide character.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each wide character is converted as if by a call to the <code>wcrtoc32</code> function. If <code>c32s</code> not a null pointer, the pointer object pointed to by <code>s</code> is assigned to the address just past the last wide character converted (if any).
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If an invalid wide character is encountered, the <b><code>wcsnrtoc32s</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>wcsnrtoc32s</code></b> function returns the number of array elements modified.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.16 The <b><code>c32snrtowcs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="dt">size_t</span> c32snrtowcs(<span class="dt">size_t</span> n, <span class="dt">wchar_t</span> *restrict s, <span class="dt">size_t</span> c32n, <span class="at">const</span> <span class="dt">char32_t</span> **restrict c32s, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c32snrtowcs</code></b> function converts a sequence of <code>char32_t</code> characters from the array indirectly pointed to by <code>c32s</code> into a sequence of corresponding wide characters that begins in the shift state specified by <code>ps</code>, and (if <code>s</code> is not a null pointer) stores these wide characters into the array pointed to by <code>s</code>, stopping if a wide character would exceed the limit of <code>n</code> total wide characters or if the limit of <code>c32n</code> elements is converted.
</ins>
</p>
<p>
<ins>
<sup>3</sup>Each <code>char32_t</code> character is converted as if by calls to the <b><code>c32rtomb</code></b> function with a non-null <code>ps</code>
</ins>
. If <code>s</code> not a null pointer, the pointer object pointed to by <code>c32s</code> is assigned to the address just past the last <code>char32_t</code> character converted (if any).
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a <code>char32_t</code> character is encountered that does not correspond to a valid wide character, the <b><code>c32snrtowcs</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c32snrtowcs</code></b> function returns the number of bytes modified.
</ins>
</p>
</blockquote>
<h2 id="library-wording---utf8-wording-not-to-be-applied"><span class="header-section-number">4.3</span> Library Wording - UTF8 Wording (Not To Be Applied)</h2>
<p>There are additional parts of this wording that are contingent upon the completion of a <code>char8_t</code> addition to the C Standard. Adding these UTF-8 functions to the standard without some mild assurance that the signatures will not step of the toes of the <code>char8_t</code> paper author’s feet. Therefore, this wording is NOT to be applied.</p>
<h3 id="add-to-7.28.1-restartable-multibytewide-character-conversion-functions-new-subsections-for-the-wcrtoc8-and-c8rtowc-functions"><span class="header-section-number">4.3.1</span> Add to §7.28.1 “Restartable multibyte/wide character conversion functions” new subsections for the <code>wcrtoc8</code>, and <code>c8rtowc</code> functions:</h3>
<blockquote>
<p>
<ins>
<b>7.28.1.� The <code>wcrtoc8</code> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p><sup>1</sup></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="dt">size_t</span> wcrtoc8(<span class="dt">char8_t</span> * restrict pc8, <span class="dt">wchar_t</span> * restrict s, <span class="dt">size_t</span> n, <span class="dt">mbstate_t</span> * ps);</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> If <code>s</code> is a null pointer, the <b><code>wcrtoc8</code></b> function is equivalent to the call:
</ins>
</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1"></a>wcrtoc8(NULL, <span class="st">L&quot;&quot;</span>, <span class="dv">1</span>, ps)</span></code></pre></div>
<p>
<ins>
In this case, the values of the parameters <code>pc8</code> and <code>n</code> are ignored.
</ins>
</p>
<p>
<ins>
<sup>3</sup> If <code>s</code> is not a null pointer, the <b><code>wcrtoc8</code></b> function inspects at most <code>n</code> elements pointed to by <code>s</code> to determine the number of elements needed to complete the next wide character (including any shift sequences). If the function determines the next wide character is complete and valid, it determines the values of the corresponding <code>char8_t</code> characters and then, if <code>pc8</code> is not a null pointer, stores the value of the first (or only) such character in the object pointer to by <code>pc8</code>. Subsequent calls will store successive <code>char8_t</code> characters without consuming additional input until all the <code>char8_t</code> characters have been stored. If the corresponding <code>char8_t</code> character is the null character, the resulting state described is the initial conversion state.
</ins>
</p>
<p>
<ins>
<b>Returns</b>
</ins>
</p>
<p>
<ins>
<sup>4</sup> The <b><code>wcrtoc8</code></b> function returns the first of the following that applies (given the current conversion state):
</ins>
</p>
<dl>
<ins>
<dt>
<code>0</code>
</dt>
<dd>
if the next <code>n</code> or fewer elements complete the wide character that corresponds to the null <code>char8_t</code> character (which is the value stored).
</dd>
</ins>
<ins>
<dt>
<i>between</i> <code>1</code> <i>and</i> <code>n</code> <i>inclusive</i>
</dt>
<dd>
if the next <code>n</code> or fewer elements complete a valid wide character (which is the value stored); the value returned is the number of elements that complete the wide character.
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-3)</code>
</dt>
<dd>
if the next <code>char8_t</code> character resulting from a previous call has been stored (no wide characters from the input have been consumed by this call).
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-2)</code>
</dt>
<dd>
if the next <code>n</code> or fewer elements contribute to an incomplete (but potentially valid) <code>char8_t</code> character, and all <code>n</code> elements have been processed (no value is stored).
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-1)</code>
</dt>
<dd>
if an encoding error occurs, in which case the next <code>n</code> or fewer elements do not contribute to complete or valid <code>char8_t</code> characters: the function stores the value of the macro <b><code>EILSEQ</code></b> in <b><code>errno</code></b>.
</dd>
</ins>
</dl>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.1.� The <code>c8rtowc</code> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<ins>
<sup>1</sup>
</ins>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="dt">size_t</span> c8rtowc(<span class="dt">wchar_t</span> * restrict pwc, <span class="dt">char8_t</span> * restrict s, <span class="dt">size_t</span> n, <span class="dt">mbstate_t</span> * restrict ps);</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> If <code>s</code> is a null pointer, the <b><code>c8rtowc</code></b> function is equivalent to the call:
</ins>
</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1"></a>c8rtowc(NULL, <span class="st">u8&quot;&quot;</span>, <span class="dv">1</span>, ps)</span></code></pre></div>
<p>
<ins>
In this case, the values of the parameters <code>pwc</code> and <code>n</code> are ignored.
</ins>
</p>
<p>
<ins>
<sup>3</sup> If <code>s</code> is not a null pointer, the <b><code>c8rtowc</code></b> function inspects at most <code>n</code> elements pointed to by <code>s</code> to determine the number of elements needed to complete the next <code>char8_t</code> character (including any shift sequences). If the function determines the next <code>char8_t</code> character is complete and valid, it determines the values of the corresponding wide characters and then, if <code>pwc</code> is not a null pointer, stores the value of the first (or only) such character in the object pointer to by <code>pwc</code>. Subsequent calls will store successive wide characters without consuming additional input until all the wide characters have been stored. If the corresponding wide character is the null character, the resulting state described is the initial conversion state.
</ins>
</p>
<p>
<ins>
<b>Returns</b>
</ins>
</p>
<p>
<ins>
<sup>4</sup> The <b><code>c8rtowc</code></b> function returns the first of the following (including conversion state):
<dl>
<ins>
<dt>
<code>0</code>
</dt>
<dd>
if the next <code>n</code> or fewer elements complete the <code>char8_t</code> character that corresponds to the null wide character (which is the value stored).
</dd>
</ins>
<ins>
<dt>
<i>between</i> <code>1</code> <i>and</i> <code>n</code> <i>inclusive</i>
</dt>
<dd>
if the next <code>n</code> or fewer elements complete a valid <code>char8_t</code> character (which is the value stored); the value returned is the number of elements that complete the <code>char8_t</code> character.
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-3)</code>
</dt>
<dd>
if the next wide character resulting from a previous call has been stored (no <code>char8_t</code> characters from the input have been consumed by this call).
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-2)</code>
</dt>
<dd>
if the next <code>n</code> or fewer elements contribute to an incomplete (but potentially valid) wide character, and all <code>n</code> elements have been processed (no value is stored).
</dd>
</ins>
<ins>
<dt>
<code>(size_t)(-1)</code>
</dt>
<dd>
if an encoding error occurs, in which case the next <code>n</code> or fewer elements do not contribute to complete or valid wide characters: the function stores the value of the macro <b><code>EILSEQ</code></b> in <b><code>errno</code></b>.
</dd>
</ins>
</dl>
</blockquote>
<h3 id="add-into-section-7.28.2-non-restartable-multibytewide-string-conversion-functions"><span class="header-section-number">4.3.2</span> Add into section §7.28.2 “Non-restartable multibyte/wide string conversion functions”:</h3>
<blockquote>
<p>
<ins>
<b>7.28.2.�1 The <b><code>mbstoc8s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb40-2"><a href="#cb40-2"></a><span class="dt">size_t</span> mbstoc8s(<span class="dt">char8_t</span> *restrict c8s, <span class="at">const</span> <span class="dt">char</span> *restrict s, <span class="dt">size_t</span> n)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>mbstoc8s</code></b> function converts a sequence of multibyte characters that begins in the initial shift state from the array pointed to by s into a sequence of corresponding <code>char8_t</code> characters and stores not more than <code>n</code> <code>char8_t</code> characters into the array pointed to by <code>c8s</code>.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each multibyte character is converted as if by a call to the <b><code>mbrtoc8</code></b> function with a non-null <code>ps</code> and <b><code>MB_MAX_LEN</code></b> for <code>n</code>. However, no multibyte characters that follow a null character (which is converted into a null <code>char8_t</code> character) will be examined or converted.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a multibyte character is encountered that does not correspond to a valid sequence of <code>char8_t</code> characters, the <b><b><code>mbstoc8s</code></b></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><b><code>mbstoc8s</code></b></b> function returns the number of array elements modified, not including a terminating null <code>char8_t</code> character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.2.�2 The <b><code>c8stombs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="dt">size_t</span> c8stombs(<span class="dt">char</span> *restrict s, <span class="at">const</span> <span class="dt">char8_t</span> *restrict c8s, <span class="dt">size_t</span> n)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c8stombs</code></b> function converts a sequence of <code>char8_t</code> characters from the array pointed to by c8s into a sequence of corresponding multibyte characters that begins in the initial shift state, and stores these multibyte characters into the array pointed to by <code>s</code>, stopping if a multibyte character would exceed the limit of <code>n</code> total bytes or if a null character is stored.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each sequence of <code>char8_t</code> characters is converted as if by calls to the c8rtomb function with a non-null <code>ps</code>.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a sequence of <code>char8_t</code> characters is encountered that does not correspond to a valid multibyte character, the c8stombs function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c8stombs</code></b> function returns the number of bytes modified, not including a terminating null character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.2.�3 The <b><code>mbsntoc8s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="dt">size_t</span> mbsntoc8s(<span class="dt">size_t</span> c8n, <span class="dt">char8_t</span> *restrict c8s, <span class="dt">size_t</span> n, <span class="at">const</span> <span class="dt">char</span> *restrict s)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>mbsntoc8s</code></b> function converts a sequence of multibyte characters that begins in the initial shift state from the array pointed to by <code>s</code> into a sequence of corresponding <code>char8_t</code> characters and stores not more than <code>c8n</code> <code>char8_t</code> characters into the array pointed to by <code>c8s</code>. It does not convert more than <code>n</code> multibyte characters.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each multibyte character is converted as if by a call to the <b><code>mbrtoc8</code></b> function with a non-null <code>ps</code> and <b><code>MB_MAX_LEN</code></b> for <code>n</code>.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a multibyte character is encountered that does not correspond to a valid sequence of <code>char8_t</code> characters, the <b><b><code>mbsntoc8s</code></b></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><b><code>mbsntoc8s</code></b></b> function returns the number of array elements modified.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.2.�4 The <b><code>c8sntombs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="dt">size_t</span> c8sntombs(<span class="dt">size_t</span> n, <span class="dt">char</span> *restrict s, <span class="dt">size_t</span> c8n, <span class="at">const</span> <span class="dt">char8_t</span> *restrict c8s)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c8sntombs</code></b> function converts a sequence of <code>char8_t</code> characters from the array pointed to by <code>c8s</code> into a sequence of corresponding multibyte characters that begins in the initial shift state, and stores these multibyte characters into the array pointed to by <code>s</code>, stopping if a multibyte character would exceed the limit of <code>n</code> total bytes or if the limit of <code>c8n</code> elements is converted.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each sequence of <code>char8_t</code> characters is converted as if by calls to the <code>c8rtomb</code> function with a non-null <code>ps</code>.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a sequence of <code>char8_t</code> characters is encountered that does not correspond to a valid multibyte character, the <b><code>c8sntombs</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c8sntombs</code></b> function returns the number of bytes modified.
</ins>
</p>
</blockquote>
<h3 id="add-into-section-7.28.3-restartable-multibytewide-string-conversion-functions"><span class="header-section-number">4.3.3</span> Add into section §7.28.3 “Restartable multibyte/wide string conversion functions”:</h3>
<blockquote>
<p>
<ins>
<b>7.28.3.1 The <b><code>mbsrtoc8s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="dt">size_t</span> mbsrtoc8s(<span class="dt">char8_t</span> *restrict c8s, <span class="at">const</span> <span class="dt">char</span> **restrict s, <span class="dt">size_t</span> n, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>mbsrtoc8s</code></b> function converts a sequence of multibyte characters that begins in the shift state specified by <code>ps</code> from the array indirectly pointed to by <code>s</code> into a sequence of corresponding <code>char8_t</code> characters and (if <code>c8s</code> is not a null pointer) stores not more than<code>n</code> <code>char8_t</code> characters into the array pointed to by <code>c8s</code>.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each multibyte character is converted as if by a call to the <b><code>mbrtoc8</code></b> function with <b><code>MB_MAX_LEN</code></b> for <code>n</code>. However, no multibyte characters that follow a null character (which is converted into a null <code>char8_t</code> character) will be examined or converted. If <code>c8s</code> not a null pointer, the pointer object pointed to by <code>s</code> is assigned either a null pointer (if conversion stopped due to reaching a terminating null character) or the address just past the last <code>char8_t</code> character converted (if any). If conversion stopped due to reaching a terminating null character and if <code>c8s</code> is not a null pointer, the resulting state described by <code>ps</code> is the initial conversion state.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a multibyte character is encountered that does not correspond to a valid sequence of <code>char8_t</code> characters, the <b><b><code>mbsrtoc8s</code></b></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><b><code>mbsrtoc8s</code></b></b> function returns the number of array elements modified, not including a terminating null <code>char8_t</code> character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.2 The <b><code>c8srtombs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="dt">size_t</span> c8srtombs(<span class="dt">char</span> *restrict s, <span class="at">const</span> <span class="dt">char8_t</span> **restrict c8s, <span class="dt">size_t</span> n, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c8srtombs</code></b> function converts a sequence of <code>char8_t</code> characters from the array indirectly pointed to by <code>c8s</code> into a sequence of corresponding multibyte characters that begins in the shift state specified by <code>ps</code>, and (if <code>s</code> is not a null pointer) stores these multibyte characters into the array pointed to by <code>s</code>, stopping if a multibyte character would exceed the limit of <code>n</code> total bytes or if a null character is stored.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each sequence of <code>char8_t</code> characters is converted as if by calls to the <b><code>c8rtomb</code></b> function. If <code>s</code> not a null pointer, the pointer object pointed to by <code>c8s</code> is assigned either a null pointer (if conversion stopped due to reaching a terminating null character) or the address just past the last <code>char8_t</code> character converted (if any). If conversion stopped due to reaching a terminating null character and if <code>s</code> is not a null pointer, the resulting state described by <code>ps</code> is the initial conversion state.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a sequence of <code>char8_t</code> characters is encountered that does not correspond to a valid multibyte character, the c8srtombs function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c8srtombs</code></b> function returns the number of bytes modified, not including a terminating null character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.5 The <b><code>mbsnrtoc8s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="dt">size_t</span> mbsnrtoc8s(<span class="dt">size_t</span> c8n, <span class="dt">char8_t</span> *restrict c8s, <span class="dt">size_t</span> n, <span class="at">const</span> <span class="dt">char</span> **restrict s, mbstate* ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>mbsnrtoc8s</code></b> function converts a sequence of multibyte characters that begins in the shift state specified by <code>ps</code> from the array indirectly pointed to by <code>s</code> into a sequence of corresponding <code>char8_t</code> characters and (if <code>c8s</code> is not a null pointer) stores not more than<code>c8n</code> <code>char8_t</code> characters into the array pointed to by <code>c8s</code>. It does not convert more than <code>n</code> multibyte characters.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each multibyte character is converted as if by a call to the <b><code>mbrtoc8</code></b> function with <b><code>MB_MAX_LEN</code></b> for <code>n</code>. If <code>c8s</code> not a null pointer, the pointer object pointed to by <code>s</code> is assigned to the address just past the last multibyte character converted (if any).
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a multibyte character is encountered that does not correspond to a valid sequence of <code>char8_t</code> characters, the <b><code>mbsnrtoc8s</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>mbsnrtoc8s</code></b> function returns the number of array elements modified.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.6 The <b><code>c8snrtombs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="dt">size_t</span> c8snrtombs(<span class="dt">size_t</span> n, <span class="dt">char</span> *restrict s, <span class="dt">size_t</span> c8n, <span class="at">const</span> <span class="dt">char8_t</span> **restrict c8s, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c8snrtombs</code></b> function converts a sequence of <code>char8_t</code> characters from the array indirectly pointed to by <code>c8s</code> into a sequence of corresponding multibyte characters that begins in the shift state specified by <code>ps</code>, and (if <code>s</code> is not a null pointer) stores these multibyte characters into the array pointed to by <code>s</code>, stopping if a multibyte character would exceed the limit of <code>n</code> total bytes or if the limit of <code>c8n</code> elements is converted.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each sequence of <code>char8_t</code> characters is converted as if by calls to the <b><code>c8rtomb</code></b> function. If <code>s</code> not a null pointer, the pointer object pointed to by <code>c8s</code> is assigned to the address just past the last <code>char32_t</code> character converted (if any).
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a sequence of <code>char8_t</code> characters is encountered that does not correspond to a valid multibyte character, the <b><code>c8snrtombs</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c8snrtombs</code></b> function returns the number of bytes modified.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.9 The <b><code>wcsrtoc8s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="dt">size_t</span> wcsrtoc8s(<span class="dt">char8_t</span> *restrict c8s, <span class="at">const</span> <span class="dt">wchar_t</span> **restrict s, <span class="dt">size_t</span> n, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>wcsrtoc8s</code></b> function converts a sequence of wide characters that begins in the shift state specified by <code>ps</code> from the array indirectly pointed to by <code>s</code> into a sequence of corresponding <code>char8_t</code> characters and (if <code>c8s</code> is not a null pointer) stores not more than<code>n</code> <code>char8_t</code> characters into the array pointed to by <code>c8s</code>.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each wide character is converted as if by a call to the <b><code>wcrtoc8</code></b> function. However, no wide characters that follow a null character (which is converted into a null <code>char8_t</code> character) will be examined or converted. If <code>c8s</code> not a null pointer, the pointer object pointed to by <code>s</code> is assigned either a null pointer (if conversion stopped due to reaching a terminating null character) or the address just past the last wide character converted (if any). If conversion stopped due to reaching a terminating null character and if <code>c8s</code> is not a null pointer, the resulting state described by <code>ps</code> is the initial conversion state.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a wide character is encountered that does not correspond to a valid sequence of <code>char8_t</code> characters, the <b><b><code>wcsrtoc8s</code></b></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><b><code>wcsrtoc8s</code></b></b> function returns the number of array elements modified, not including a terminating null <code>char8_t</code> character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.10 The <b><code>c8srtowcs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="dt">size_t</span> c8srtowcs(<span class="dt">wchar_t</span> *restrict s, <span class="at">const</span> <span class="dt">char8_t</span> **restrict c8s, <span class="dt">size_t</span> n, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c8srtowcs</code></b> function converts a sequence of <code>char8_t</code> characters from the array indirectly pointed to by <code>c8s</code> into a sequence of corresponding wide characters that begins in the shift state specified by <code>ps</code>, and (if <code>s</code> is not a null pointer) stores these wide characters into the array pointed to by <code>s</code>, stopping if a wide character would exceed the limit of <code>n</code> total wide characters or if a null character is stored.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each sequence of <code>char8_t</code> characters is converted as if by calls to the <b><code>c8rtomb</code></b> function. However, no <code>char8_t</code> characters that follow a null wide character (which is converted into a null <code>char8_t</code> character) will be examined or converted. If <code>s</code> not a null pointer, the pointer object pointed to by <code>c8s</code> is assigned either a null pointer (if conversion stopped due to reaching a terminating null character) or the address just past the last <code>char8_t</code> character converted (if any). If conversion stopped due to reaching a terminating null character and if <code>s</code> is not a null pointer, the resulting state described by <code>ps</code> is the initial conversion state.
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a sequence of <code>char8_t</code> characters is encountered that does not correspond to a valid wide character, the c8srtowcs function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c8srtowcs</code></b> function returns the number of bytes modified, not including a terminating null character, if any.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.13 The <b><code>wcsnrtoc8s</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb50-2"><a href="#cb50-2"></a><span class="dt">size_t</span> wcsnrtoc8s(<span class="dt">size_t</span> c8n, <span class="dt">char8_t</span> *restrict c8s, <span class="dt">size_t</span> n, <span class="at">const</span> <span class="dt">wchar_t</span> **restrict s, mbstate* ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>wcsnrtoc8s</code></b> function converts a sequence of wide characters that begins in the shift state specified by <code>ps</code> from the array indirectly pointed to by <code>s</code> into a sequence of corresponding <code>char8_t</code> characters and (if <code>c8s</code> is not a null pointer) stores not more than<code>c8n</code> <code>char8_t</code> characters into the array pointed to by <code>c8s</code>. It does not convert more than <code>n</code> wide characters.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each wide character is converted as if by a call to the <b><code>wcrtoc8</code></b> function. If <code>c8s</code> not a null pointer, the pointer object pointed to by <code>s</code> is assigned to the address just past the last wide character converted (if any).
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a wide character is encountered that does not correspond to a valid sequence of <code>char8_t</code> characters, the <b><b><code>wcsnrtoc8s</code></b></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><b><code>wcsnrtoc8s</code></b></b> function returns the number of array elements modified.
</ins>
</p>
</blockquote>
<blockquote>
<p>
<ins>
<b>7.28.3.14 The <b><code>c8snrtowcs</code></b> function</b>
</ins>
</p>
<p>
 <ins><b>Synopsis</b></ins>
</p>
<p>
<ins>
<sup>1</sup>
</ins>
</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1"></a><span class="pp">#include </span><span class="im">&lt;uchar.h&gt;</span></span>
<span id="cb51-2"><a href="#cb51-2"></a><span class="dt">size_t</span> c8snrtowcs(<span class="dt">size_t</span> n, <span class="dt">wchar_t</span> *restrict s, <span class="dt">size_t</span> c8n, <span class="at">const</span> <span class="dt">char8_t</span> **restrict c8s, mbstate *restrict ps)</span></code></pre></div>
<p>
 <ins><b>Description</b></ins>
</p>
<p>
<ins>
<sup>2</sup> The <b><code>c8snrtowcs</code></b> function converts a sequence of <code>char8_t</code> characters from the array indirectly pointed to by <code>c8s</code> into a sequence of corresponding wide characters that begins in the shift state specified by <code>ps</code>, and (if <code>s</code> is not a null pointer) stores these wide characters into the array pointed to by <code>s</code>, stopping if a wide character would exceed the limit of <code>n</code> total elements or if the limit of <code>c8n</code> elements is converted.
</ins>
</p>
<p>
<ins>
<sup>3</sup> Each sequence of <code>char8_t</code> characters is converted as if by calls to the <b><code>c8rtomb</code></b> function. If <code>s</code> not a null pointer, the pointer object pointed to by <code>c8s</code> is assigned to the address just past the last <code>char8_t</code> character converted (if any).
</ins>
</p>
<p>
 <ins><b>Returns</b></ins>
</p>
<p>
<ins>
<sup>4</sup> If a sequence of <code>char8_t</code> characters is encountered that does not correspond to a valid wide character, the <b><code>c8snrtowcs</code></b> function returns <code>(size_t)(-1)</code>. Otherwise, the <b><code>c8snrtowcs</code></b> function returns the number of bytes modified.
</ins>
</p>
</blockquote>
<h1 id="conclusion"><span class="header-section-number">5</span> Conclusion</h1>
<p>The ecosystem deserves ways to get to a statically-known encoding and not rely on implementation and locale-parameterized encodings. This allows developers a way to perform cross-platform text processing without needing to go through fantastic gymnastics to support different languages and platforms. An independent library implementation, <em>cuneicode</em><sup>[7]</sup> is available upon request to the author. A patch to musl-libc will be available by the 2020 Freiburg, Germany meeting.</p>
<h1 id="acknowledgements"><span class="header-section-number">6</span> Acknowledgements</h1>
<p>Thank you to Philipp K. Krause for responding to the e-mails of a newcomer to matters of C and providing me with helpful guidance. Thank you to Rajan Bhakta, Daniel Plakosh, and David Keaton for guidance on how to submit these papers and get started in WG14. Thank you to Tom Honermann for lighting the passionate fire for proper text handling in me for not just C++, but for our sibling language C.</p>
<div class="pagebreak">

</div>
<h1 id="references"><span class="header-section-number">7</span> References</h1>
<p>[1]: Philip K. Krause. N2282: Additional multibyte/wide string conversion functions. June 2018. Published: <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2282.htm">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2282.htm</a>.<br />
[2]: WG14. Clarification Request Summary for C11, Version 1.13. October 2017. Published: <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2244.htm">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2244.htm</a>.<br />
[3]: ISO/IEC, WG14. Programming Languages - C (Committee Draft). April 12, 2011. Published: <a href="http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf">http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf</a>.<br />
[4]: Henri Sivonen. <code>encoding_rs</code>: a Web-Compatible Character Encoding Library in Rust. December 2018. Published: <a href="https://hsivonen.fi/encoding_rs/#results">https://hsivonen.fi/encoding_rs/#results</a>.<br />
[5]: Bob Steagall. Fast Conversion From UTF-8 with C++, DFAs, an SSE Intrinsics. September 2018. Published: <a href="https://www.youtube.com/watch?v=5FQ87-Ecb-A">https://www.youtube.com/watch?v=5FQ87-Ecb-A</a><br />
[6]: Robot Martinho Fernandes. p1041. February 2019. Published: <a href="https://wg21.link/p1041">https://wg21.link/p1041</a>.<br />
[7]: JeanHeyd Meneide. Cuneicode. November 2019. Published Meeting C++: <a href="https://www.youtube.com/watch?v=FQHofyOgQtM">https://www.youtube.com/watch?v=FQHofyOgQtM</a>.</p>
<p><sub><sub><sub>May the Tower of Babel’s curse be defeated.</sub></sub></sub></p>
</body>
</html>
