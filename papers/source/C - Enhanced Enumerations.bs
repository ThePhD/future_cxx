<pre class='metadata'>
Title: Enhancements to Enumerations
Shortname: 29XX
Revision: 3
!Previous Revisions: <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2575.pdf">N2575 (r2)</a>, <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2533.pdf">n2533 (r1)</a>, <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2008.pdf">n2008 (r0)</a>
Status: P
Date: 2021-12-15
Group: WG14
!Proposal Category: Feature Request
!Target: General Developers, ABI Lovers, Embedded Systems Developers
Editor: JeanHeyd Meneide (thephd.dev), phdofthehouse@gmail.com
Editor: Shepherd (Shepherd's Oasis LLC), shepherd@soasis.org
Editor: Clive Pygott (LDRA Ltd.)
URL: https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Enhanced%20Enumerations.html
!Paper Source: <a href="https://thephd.dev/_vendor/future_cxx/papers/source/C%20-%20Enhanced%20Enumerations.bs">GitHub</a>
Issue Tracking: GitHub https://github.com/ThePhD/future_cxx/issues
Metadata Order: Previous Revisions, Editor, This Version, Paper Source, Implementation, Issue Tracking, Project, Audience, Proposal Category, Target
Markup Shorthands: markdown yes
Toggle Diffs: no
Abstract: Implementations firmly control what both the Wide Character and Multi-Byte Character strings are treated at runtime by the Standard Library. While this control is fine, users of the Standard Library have no portability guarantees about how these library functions may behave, especially in the face of encodings that do not support each other's full codepage. And, despite additions to C11 for maybe-UTF16 and maybe-UTF32 encoded types, these functions only offer conversions of a single unit of information at a time, leaving orders of magnitude of performance on the table. This paper proposes and explores additional library functionality to allow users to retrieve multibyte and wide character into a statically known encoding to enhance the ability to work with text.
</pre>

<pre class="include-raw">
path: resources/css/bikeshed-wording.html
</pre>

<div class="pagebreak"></div>




# Changelog # {#changelog}



## Revision 2 - December 15th, 2021 ## {#changelog-r3}

- Change of paper primary author to JeanHeyd and Shepherd: thank you, Clive Pygott, for your studious shepherding of this issue for over 4 years!
- Address feedback and comments from March/April 2021 Virtual Meeting.
- Address direct feedback from Joseph Myers and Robert Seacord (thank you for the effort!).



## Revision 2 - October 4th, 2020 ## {#changelog-r2}

- Prepare for changes to C23, address some minor feedback comments from the August 2020 Virtual Meeting.
- Support for forward declarations of unspecified enumerations.
- Clarify that `_Bool` should not be supported as an underlying type.



## Revision 1 - June 28th, 2020 ## {#changelog-r1}

- 



## Revision 0 - February 17th, 2016 ## {#changelog-r0}

- Initial release ðŸŽ‰!




# Introduction and Motivation # {#intro}

These two posts capture pretty much the entire motivation for this whole proposal:

> > i realized today that C is so bad at its job that it needs the help of C++ to make some features of its ABI usable (since you can specify the width of an enum in C++ but not C)
> > 
> > â€” Whitequark [on May 25th, 2020](https://twitter.com/whitequark/status/1265081363717337093)
> 
> â€¦
> 
> > in this case the solution to "C is bad at its job" is definitely to "fix C" because, even if you hate C so much you want to eradicate it completely from the face of the earth, we'll still be stuck with the C ABI long after it's gone
> >
> > Whitequark [on May 25th, 2020](https://twitter.com/whitequark/status/1265122114811682816)

I don't hate C, but that doesn't make everything she's said wrong. In fact, it's genuinely correct: C normally tries to picks `int` for its enumerators, but it's entirely unspecified what the type for the type or its constants is supposed to be. This means it's impossible to portably define an enumeration, which drastically decreases its usefulness and makes it harder to rely on enumeration values (and consequently, their type) in standard C code. This has led to a number of communities and tools attempting to do enumerations differently in several languages, or in the case of C++ simply enhancing enumerations with specific features to make them both portable and dependable.

This proposal provides an underlying enumeration type, specified after a colon of the _identifier_ for the enumeration name, to give the enumeration a dependable type. It makes the types for each of the enumeration constants the same as the specified underlying type, while leaving the current enumerations as unspecified as they were in their old iterations. It does not attempt to solve problems outside the scope of making sure that constants with specified underlying type are dependable, and attempts to make forward declaration of enumerations work across implementations.




# Prior Art # {#prior}

C++ has this as a feature for their enumerations. Certain C compilers have this as an extension in 
their C compilation modes specifically, [including Clang](https://godbolt.org/z/xMz6n7TKK).




# Design # {#design}

The design of this feature follows C++'s syntax for both compatibility reasons and because the design is genuinely simple and useful:

```cpp
enum a : unsigned long long {
	a0 = 0xFFFFFFFFFFFFFFFFULL
	// ^ not a constraint violation with a 64-bit unsigned long long
};
```

Furthermore, the type of `a0` is therefore specified to be `unsigned long long`, such this program:

```cpp
enum a : unsigned long long {
	a0 = 0xFFFFFFFFFFFFFFFFULL
};

int main () {
	return _Generic(a0, unsigned long long: 0, default: 1);
}
```

exits with a return value of `0`. Note that because this change is entirely opt-in, no previous code is impacted and code that was originally a syntax violation will become well-formed with the same semantics as they had from their C++ counterparts.




# Proposed Wording # {#wording}

The following wording is [relative to N2731](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2731.pdf).



## Intent ## {#wording-intent}

The intent of the wording is to provide the ability to express enumerations with the underlying type present. In particular:

- enumerations can optionally have a type declared as the underlying type or otherwise defaults to the previous behavior (opt-in);
- enumerations with an underlying type must use a signed or unsigned extended integer type that is not a bit-precise integer type, `_Bool`, or another enumeration type directly;
- enumerations with underlying types ignore const, volatile, `_Atomic`, and all other qualifiers on a given type;
- enumerations with underlying types can be forward-declared;
- enumerations with underlying types cannot be forward-declared with different underlying types than the first forward declaration;
- enumerations with an underlying type can be redeclared without an underlying type (e.g., `enum a : int;` matches `enum a;`);
- enumerations without an underlying type can be redeclared with an underlying type (e.g., `enum a;` matches `enum a : short;` but cannot be re-redeclared as `enum a : long` in the same translation unit);
- enumerations with an underlying type can have enumerators initialized with integer constant expressions whose type is not strictly `int` or `unsigned int` used to specify their values;
- enumerations without an underlying type can have enumerators initialized with integer constant expressions whose type is `int` or some implementation-defined type of greater or equal bit width;
- enumerations of an underlying type used directly in a generic expression are treated as an integer of that underlying type; and,
- operations performed on an enumeration with an underlying type treat the type of the enumeration as an integer of that specified underlying type.



## Proposed Specification ## {#wording-specification}


### Modify Section Â§6.2.7 Compatible type and composite type, paragraph 1 ### {#wording-specification-6.2.7p1}

<blockquote>
<div class="wording-section">
<div class="wording-numbered">
â€¦ Moreover, two structure, union, or enumerated types declared in separate translation units are compatible if their tags and members satisfy the following requirements: if one is declared with a tag, the other shall be declared with the same tag. If both are completed anywhere within their respective translation units, then the following additional requirements apply: â€¦ For two enumerations, corresponding members shall have the same values <ins>and their underlying types shall be compatible types.</ins>
</div>
</div>
</blockquote>


### Modify Section Â§6.4.4.3 Enumeration constants ### {#wording-specification-6.4.4.3}

<blockquote>
<div class="wording-section">
<p><b>6.4.4.3 &emsp; Enumeration constants</b></p>
<p><b>Syntax</b></p>
<div class="wording-numbered">
<dl>
	<dd><i>enumeration-constant:</i>
	<dl>
		<dd><i>identifier</i></dd>
	</dl>
	</dd>
</dl>
</div>

<p><b>Semantics</b></p>
<div class="wording-numbered">
<del>An identifier declared as an enumeration constant for an enumeration without fixed underlying type has type <b>int</b>.</del><ins>An identifier declared as an enumeration constant for an enumeration with fixed underlying type has that underlying type during the specification of the enumeration type (i.e. at the start of the opening brace in the <i>enum-specifier</i>). An identifier declared as an enumeration constant for an enumeration without fixed underlying type has type <b>int</b> or an implementation-defined signed or unsigned integer type of width greater than or equal to <b>int</b> that is not <b>_Bool</b> or a bit-precise integer type during the specification of the enumeration type (i.e. until the closing brace in the <i>enum-specifier</i>).</ins>
</div>

<ins>
<div class="wording-numbered">
When an enumeration is used in any other integer context, it is treated as if it had the underlying type of the enumeration.
</div>
</ins>
</div>

Forward references: enumeration specifiers (6.7.2.2).
</blockquote>


### Modify Section Â§6.7.2.2 Enumeration constants ### {#wording-specification-6.7.2.2}

<blockquote>
<div class="wording-section">
<b>6.7.2.2 Enumeration specifiers</b>

<p><b>Syntax</b></p>
<dl>
	<dd><i>enum-specifier:</i>
	<dl>
		<dd><b>enum</b> <i>attribute-specifier-sequence<sub>opt</sub></i> <i>identifier<sub>opt</sub></i> <ins><i>enum-type-specifier<sub>opt</sub></i></ins> <b>{</b> <i>enumerator-list</i> <b>}</b>
		<dd><b>enum</b> <i>attribute-specifier-sequence<sub>opt</sub></i> <i>identifier<sub>opt</sub></i> <ins><i>enum-type-specifier<sub>opt</sub></i></ins> <b>{</b> <i>enumerator-list</i> <b>,</b> <b>}</b>
		<dd><b>enum</b> <i>identifier</i>
	</dl>
	</dd>
	<dd><i>enumerator-list:</i>
	</dl>
		<dd><i>enumerator</i></dd>
		<dd><i>enumerator-list</i> <b>,</b> <i>enumerator</i></dd>
	</dl>
	</dd>
	<dd><i>enumerator:</i>
	<dl>
		<dd><i>enumeration-constant</i> <i>attribute-specifier-sequence<sub>opt</sub></i></dd>
		<dd><i>enumeration-constant</i> <i>attribute-specifier-sequence<sub>opt</sub></i> <b>=</b> <i>constant-expression</i></dd>
	</dl>
	</dd>
	<ins>
	<dd><ins><i>enum-type-specifier:</i>
	<dl>
		<dd><b>:</b> <i>specifier-qualifier-list</i></dd>
	</dl>
	</ins></dd>
	</ins>
</dl>

<div class="wording-numbered">
<ins>All enumerations have an <i>underlying type</i>. The underlying type can be explicitly specified using an <i>enum-type-specifier</i> and such an underlying type is its <i>fixed underlying type</i>.</ins>
</div>

<b>Constraints</b>

<div class="wording-numbered">
<ins>The type specifiers in the enum type specifier's <i>specifier-qualifier-list</i> shall specify an integer type that is not an enumerated type, a bit-precise integer type, or <b>_Bool</b>. No alignment specifiers shall appear in the specifier qualifier list. The underlying type of the enumeration is the unqualified, non-atomic version of the type specified by the type specifiers in the specifier qualifier list.</ins>
</div>

<div class="wording-numbered">
<ins>The expression that defines the value of an enumeration constant of an enumeration with a fixed underlying type shall have a value representable as that fixed underlying type.</ins>
</div>

<div class="wording-numbered">
<del>The</del><ins>For an enumeration without a fixed underlying type, the</ins> expression that defines the value of an enumeration constant shall be an integer constant expression that has a value representable as an <b>int</b><ins> or an implementation-defined signed or unsigned integer type of width greater than or equal to <b>int</b> that is not <b>_Bool</b> or a bit-precise integer type.</ins>
</div>

<div class="wording-numbered">
<ins>An enum specifier that contains an enum type specifier to provide a fixed underlying type shall not precede a <i>declarator</i> unless the opening brace <b>{</b>, enumerator list, and closing brace <b>}</b> precedes the <i>declarator</i>.</ins>
</div>

<b>Semantics</b>

<div class="wording-numbered">
<ins>The optional attribute specifier sequence in the enum specifier appertains to the enumeration; the attributes in that attribute specifier sequence are thereafter considered attributes of the enumeration whenever it is named. The optional attribute specifier sequence in the enumerator appertains to that enumerator.</ins>
</div>

<div class="wording-numbered">
<ins>If an enum type specifier is present, then the longest possible sequence of tokens that can be interpreted as a type specifier is chosen.</ins>
</div>

<div class="wording-numbered">
The identifiers in an enumerator list are declared as constants <ins>that have the underlying type of the enumeration</ins> and may appear wherever such are permitted.<sup>133)</sup> An enumerator with <b>=</b> defines its enumeration constant as the value of the constant expression. If the first enumerator has no <b>=</b>, the value of its enumeration constant is 0. Each subsequent enumerator with no <b>=</b> defines its enumeration constant as the value of the constant expression obtained by adding 1 to the value of the previous enumeration constant. (The use of enumerators with <b>=</b> may produce enumeration constants with values that duplicate other values in the same enumeration.) The enumerators of an enumeration are also known as its members.
</div>

<div class="wording-numbered">
<del>Each</del><ins>For all enumerations without fixed underlying type, each</ins> enumerated type shall be compatible with <b>char</b>, a signed integer type, or an unsigned integer type <ins>(excluding the bit-precise integer types and <b>_Bool</b>)</ins>. The choice of type is implementation-defined<sup>134)</sup>, but shall be capable of representing the values of all the members of the enumeration.
</div>

<div class="wording-numbered">
<ins>For all enumerations with a fixed underlying type, the enumerated type has the underlying type of the enumeration.</ins>
</div>

<div class="wording-numbered">
<del>The</del><ins>An</ins> enumerated type <ins>declaration without a fixed underlying type</ins> is <ins>an</ins> incomplete <ins>type</ins> until immediately after the <b>}</b> that terminates the list of enumerator declarations, and complete thereafter. <ins>An enumerated type declaration of an enumeration with fixed underlying type declares a complete type immediately after its enum type specifier, including after the opening <b>{</b> of its enumerator list.</ins>
</div>

<div class="wording-numbered">
<b>EXAMPLE</b> &emsp; The following fragment: â€¦
</div>

<div class="wording-numbered">
<ins>EXAMPLE The following fragment:

```cpp
#include <limits.h>

enum E1: short;
enum E2: short;
enum E3;
enum E4 : unsigned long long;

enum E1 : short { m11, m12 };
enum E2 : long  { m21, m22 }; /* Constraint violation */

enum E3 : int;
enum E3 : int {
	m31,
	m32,
	m33 = sizeof(enum E3)
};

enum E4 : unsigned long long {
	m41 = ULLONG_MAX,
	m42 /* Constraint violation: unrepresentable value */
};

enum E1 x = m11;
enum E1 : long int x; /* Constraint violation: underlying type present with declarator */
```

demonstrates many of the properties of multiple declarations of enumerations with underlying types. `E3` in particular is an enumeration declaration that chooses `int` as its underlying type, which matches the second declaration and the third declaration with definition. Despite `E3` being declared without an underlying type first, it is declared with an underlying type second that is the same as its first, so `sizeof(enum E3)` is not a constraint violation.
</ins>
</div>

<div class="wording-numbered">
<ins>EXAMPLE The following fragment:

```cpp
enum e { A };
enum e : int;
enum e;
```

is a valid triplet of declarations if the implementation-defined underlying type chosen for the first declaration matches the underlying type specified in the second declaration. Otherwise, it is a constraint violation.</ins>
</div>

<div class="wording-numbered">
<ins>EXAMPLE The following fragment:

```cpp
enum e;
int before = sizeof(enum e); /* Constraint violation */
enum e : unsigned long long;
int after0 = sizeof(enum e); /* Okay */
enum e;
int after1 = sizeof(enum e); /* Okay */
```

begins with a valid forward declaration of an incomplete enumeration type, as it has no underlying type. The type is incomplete until the second declaration, which completes `e` and gives it an underlying type of `int`. The third declaration does not change the underlying type and it is still considered a complete type.
</ins>
</div>

Forward references: tags (6.7.2.3), <ins>declarators (6.7.6)</ins>.
</blockquote>â€ƒ`
</div>


### Modify Section Â§6.7.2.3 Tags ### {#wording-specification-6.7.2.3}

<blockquote>â€ƒ
<div class="wording-section">
<b>6.7.2.3 Tags</b>

<p><b>Constraints</b></p>

<div class="wording-numbered wording-numbered-3">
A type specifier of the form
<dl>
<dd><b>enum</b> <i>identifier</i></dd>
</dl>
without an enumerator list shall only appear after <del>the type it specifies is complete</del><ins>its underlying type is determined. For an enum without fixed underlying type, this is after the closing <b>}</b> of the enumerator list.</ins>
</div>

â€¦

<div class="wording-numbered wording-numbered-7">
A type specifier of the form

<dl>
	<dd><i>struct-or-union</i> <i>attribute-specifier-sequence<sub>opt</sub></i></i> <i>identifier<sub>opt</sub></i> <b>{</b> <i>member-declaration-list</i> }</dd>
</dl>

or

<dl>
	<dd><b>enum</b> <i>attribute-specifier-sequence<sub>opt</sub></i> <i>identifier<sub>opt</sub></i> <ins><i>enum-type-specifier<sub>opt</sub></i></ins> <b>{</b> <i>enumerator-list</i> <b>}</b></dd>
</dl>

or

<dl>
	<dd><b>enum</b> <i>attribute-specifier-sequence<sub>opt</sub></i> <i>identifier<sub>opt</sub></i> <ins><i>enum-type-specifier<sub>opt</sub></i></ins> <b>{</b> <i>enumerator-list</i> <b>,</b> <b>}</b></dd>
</dl>

declares a structure, union, or enumerated type. â€¦
</div>

â€¦

<div class="wording-numbered wording-numbered-8">
A declaration of the form

<dl>
	<dd><i>struct-or-union</i> <i>attribute-specifier-sequence<sub>opt</sub></i></i> <i>identifier</i> <b>;</b></dd>
</dl>

<ins>or</ins>

<dl>
	<dd><ins><b>enum</b> <i>attribute-specifier-sequence<sub>opt</sub></i> <i>identifier</i> <ins><i>enum-type-specifier<sub>opt</sub></i></ins> <b>;</b></ins></dd>
</dl>

specifies a <del>structure or union type</del><ins>structure, union, or enumerated type</ins> and declares the identifier as a tag of that type.<sup>142)</sup> <ins>If the enumerated type does not contain the enum type specifier, the enumerated type is incomplete. Otherwise, the enumerated type is complete.</ins> The optional attribute specifier sequence appertains to the structure or union type being declared; the attributes in that attribute specifier sequence are thereafter considered attributes of the structure or union type whenever it is named.
</div>

<div class="wording-numbered wording-numbered-9">
If a type specifier of the form

<dl>
	<dd><i>struct-or-union</i> <i>attribute-specifier-sequence<sub>opt</sub></i></i> <i>identifier</i></dd>
</dl>

<ins>or</ins>

<dl>
	<dd><ins><b>enum</b> <i>attribute-specifier-sequence<sub>opt</sub></i> <i>identifier</i></ins></dd>
</dl>

occurs other than as part of one of the above forms, and no other declaration of the identifier as a tag is visible, then it declares an incomplete <del>structure or union type</del><ins>structure, union, or enumerated type</ins>, and declares the identifier as the tag of that type.<sup>142)</sup>
</div>

<div class="wording-numbered wording-numbered-10">
If a type specifier of the form

<dl>
	<dd><i>struct-or-union</i> <i>attribute-specifier-sequence<sub>opt</sub></i></i> <i>identifier</i></dd>
</dl>

or

<dl>
	<dd><b>enum</b> <ins><i>attribute-specifier-sequence<sub>opt</sub></i></ins> <i>identifier</i></dd>
</dl>

occurs other than as part of one of the above forms, and a declaration of the identifier as a tag is visible, then it specifies the same type as that other declaration, and does not redeclare the tag.
</div>
</div>
</blockquote>


### Add implementation-defined enumeration behavior to Annex J ### {#wording-specification-annex-j}




# Acknowledgements # {#acknowledgements}

Thanks to:

- Aaron Ballman for help with the initial drafting;
- Aaron Ballman, Aaron Bachmann, Jens Gustedt & Joseph Myers for questions, suggestions and offline discussion;
- Robert Seacord for editing suggestions; and,
- Clive Pygott for the initial draft of this paper.

We hope this paper serves you all well.
