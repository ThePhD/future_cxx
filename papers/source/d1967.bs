<pre class='metadata'>
Title: #embed - a scannable, tooling-friendly binary resource inclusion mechanism
H1: <code>#embed</code> - a scannable, tooling-friendly binary resource inclusion mechanism
Shortname: P1967
Revision: 5
Status: P
Date: 2022-04-12
Group: WG21
Audience: EWG
Editor: JeanHeyd Meneide, phdofthehouse@gmail.com
Editor: Shepherd (Shepherd's Oasis LLC), shepherd@soasis.org
URL: https://thephd.dev/_vendor/future_cxx/papers/d1967.html
!Latest: <a href="https://thephd.dev/_vendor/future_cxx/papers/d1967.html">https://thephd.dev/_vendor/future_cxx/papers/d1967.html</a>
!Implementation: <a href="https://github.com/ThePhD/embed">GitHub ThePhD/embed</a>
!Paper Source: <a href="https://github.com/ThePhD/future_cxx/blob/main/papers/source/d1967.bs">GitHub ThePhD/future_cxx</a>
Metadata Order: Editor, Latest, Paper Source, Implementation, Project, Audience
Markup Shorthands: markdown yes
Toggle Diffs: no
Abstract: Pulling binary data into a program often involves external tools and build system coordination. Many programs need binary data such as images, encoded text, icons and other data in a specific format. Current state of the art for working with such static data in C includes creating files which contain solely string literals, directly invoking the linker to create data blobs to access through carefully named extern variables, or generating large brace-delimited lists of integers to place into arrays. As binary data has grown larger, these approaches have begun to have drawbacks and issues scaling. From parsing 5 megabytes worth of integer literal expressions into AST nodes to arbitrary string literal length limits in compilers, portably putting binary data in a C program has become an arduous task that taxes build infrastructure and compilation memory and time. This proposal provides a flexible preprocessor directive for making this data available to the user in a straightforward manner.
</pre>

<pre class="include-raw">
path: resources/css/bikeshed-wording.html
</pre>

<pre class="include-raw">
path: resources/css/bikeshed-color-fix.html
</pre>

<div class="pagebreak"></div>




# Changelog # {#changelog}



## Revision 5  - April 12<sup>th</sup>, 2022 ## {#changelog-r5}

- Additional syntax changes based on feedback from Joseph Myers, Hubert Tong, Jens Maurer, other implementers, and users.
- Minor wording tweaks and typo clean up.
- An implementation [available in Godbolt (since last revision as well and noted below)](https://godbolt.org/z/Kb3ejE7q5).
- The paper's source code has been refactored:
	- Separated WG21 paper from WG14 paper.
	- Core paper together (rationale, reasoning), included in both C and C++ papers since rationale is identical.
- Changed `__has_embed` to match feedback from last standards meeting, nominally that an empty resource returns `2` instead of `1` (but both decay to a truthy value during preprocessor conditional inclusion expressions). Modified by the wording and the prose in [[#design-__has_embed]].
- The wording for the limit parameter ([[#wording-specification-cpp.res.param]]) adjusted to perform macro expansion, at least once. Exact wording may need help.



## Revision 4  - June 15<sup>th</sup>, 2021 ## {#changelog-r4}

- Vastly improve C++ wording after June 3rd, 2021 discussion.
- Change syntax after comments from implementers of scanners / dependency trackers, and comments from implementers that were supported by users.
- Add support for "named parameter" implementation extensions.



## Revision 3 - April 15<sup>th</sup>, 2021 ## {#changelog-r3}

- Added post C meeting fixes to prepare for hopeful success next meeting.
- Added 2 more examples to C and C++ wording.
- Vastly improved wording and reduced ambiguities in syntax and semantics.
- Fixed various wording issues.



## Revision 2 - October 25<sup>th</sup>, 2020 ## {#changelog-r2}

- Added post C++ meeting notes and discussion.
- Removed type or bit specifications from the `#embed` directive.
- Moved "Type Flexibility" section and related notes to the Appendix as they are now unpursued.



## Revision 1 - April 10<sup>th</sup>, 2020 ## {#changelog-r1}

- Added post C meeting notes and discussion.
- Added discussion of potential endianness.
- Improved wording section at the end to be more detailed in handling preprocessor (which does not understand types).



## Revision 0 - January 5<sup>th</sup>, 2020 ## {#changelog-r0}

- Initial release.




# Polls & Votes # {#polls}

The votes for the C++ Committee are as follows:

- SF: Strongly in Favor
- F: In Favor
- N: Neutral
- A: Against
- SA: Strongly Against



## July 2021 Virtual C++ meeting ## {#polls-july.2021.c++}

No votes were taken at this meeting, since it was mostly directional and about the changing of the syntax to better fit tools and scanners. In particular, it was more or less unanimously encouraged to:

- re-do the syntax to be `#embed header-name additional-tokens...` instead of `#embed limit-parameter header-name`;
- the `additional-tokens` should be reshaped into a parameter specification, giving both standard parameters (such as making a named `limit(integer-constant)` argument) and implementation-defined ones (such as `clang::elementy_type(short)`);
- and, the wording should include some recommendation or specification for "as-if by fread" to make wording easier.

All of these recommendations were incorporated below.



## September 2020 Virtual C++ EWG Meeting ## {#polls-september.2020.c++}

"We want `#embed [optional limit] header-name` (no type name, no other specification) as a feature."

<table>
<thead>
	<tr>
		<th>SF</th>
		<th>F</th>
		<th>N</th>
		<th>A</th>
		<th>SA</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>2</td>
		<td>16</td>
		<td>3</td>
		<td>0</td>
		<td>1</td>
	</tr>
</tbody>
</table>

This vote gained the most consensus in the Committee. While there were some individuals who wanted to be able to specify a type, there was stronger interest in not specifying a type at all and always producing a list of integer literals suitable to be used anywhere an `comma-separated list` was valid.

"We want to explore allowing an optional sequence of tokens to specify a type to `#embed`."

<table>
<thead>
	<tr>
		<th>SF</th>
		<th>F</th>
		<th>N</th>
		<th>A</th>
		<th>SA</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>1</td>
		<td>9</td>
		<td>4</td>
		<td>4</td>
		<td>3</td>
	</tr>
</tbody>
</table>

Further need was also expressed for `constexpr` of different types of variables, so we would rather focus that ability into a sister feature, <a href="/_vendor/future_cxx/d1140.html">`std::embed`</a>. There was also an expression to augment `std::bitcast<...>(...)` to handle arrays of data, which would be a follow-on proposal. There was a great amount of interest in the `std::bitcast` direction, which means a paper should be written to follow up on it.



## April 2020 Virtual C Meeting ## {#polls-april.2020.c}

"We want to have a proper preprocessor `#embed ...` over a `#pragma _STDC embed ...`-based directive."

This had UNANIMOUS CONSENT to pursue a proper preprocessor directive and NOT use the `#pragma` syntax. It is noted that the author deems this to be the best decision!


**The following poll was later superceded in the C and C++ Committees.**

"We want to specify embed as using `#embed [bits-per-element] header-name` rather than `#embed [pp-tokens-for-type] header-name`." (2-way poll.)

<table>
<thead>
	<tr>
		<th>Y</th>
		<th>N</th>
		<th>A</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>10</td>
		<td>2</td>
		<td>3</td>
	</tr>
</tbody>
</table>

- Y: 10 bits-per-element (Ye)
- N: 2 type-based (Nay)
- A: 4 Abstain (Abstain)

This poll will be a bit harder to accommodate properly. Using a <i>`constant-expression`</i> that produces a numeric constant means that the max-length specifier is now ambiguous. The syntax of the directive may need to change to accommodate further exploration.




<pre class="include">
path: Preprocessor Embed Core.bs
</pre>




# Wording # {#wording}

This wording is relative to C++'s latest working draft.



## Intent ## {#wording-intent}

The intent of the wording is to provide a preprocessing directive that:

- takes a quote or chevron delimited header-name -- potentially from the expansion of a macro -- and uses it to find a unique resource in an implementation-defined manner;
- behaves as if it produces a list of values suitable for the initialization of an array as well as initializes each `unsigned char` element according to the specific environment limits found in an implementation-defined manner;
- errors if the size of the resource does not have enough bits to fully and properly initialize all the values generated by the directive;
- allows a limit parameter limiting the number of elements to be specified (but allowing less than the limit);
- produces a core constant expression that can be used to initialize `constexpr` arrays;
- and, present such contents as if it is a list of values, such that it can be used to initialize arrays of known and unknown bound even if additional elements of the whole initialization list come before or after the directive.



## Proposed Feature Test Macro## {#wording-feature_test}

The proposed feature test macro is `__cpp_pp_embed` for the preprocessor functionality.



## Proposed Language Wording ## {#wording-specification}


### Append to ¬ß14.8.1 Predefined macro names [**cpp.predefined**] an additional entry ### {#wording-specification-cpp.predefined}

<blockquote>
<ins>

```cpp
#define __cpp_pp_embed     ????? /* üìù NOTE: EDITOR VALUE HERE */
```
</ins>
</blockquote>


### Add to the *control-line* production in ¬ß15.1 Preamble [**cpp.pre**] a new grammar production, as well as a supporting *embed-attribute-list* production ### {#wording-specification-cpp.pre}

<blockquote>
<div class="wording-section">
<div>
<ins>

*embed-parameter-list*:

:: *attribute*<sub>opt</sub>
:: *embed-parameter-list* *attribute*<sub>opt</sub>

</ins>
</div>

<div>

*control-line*:

:: ...<br/>
:: <ins><code># embed</code> *pp-tokens* *new-line*</ins>

</div>

</div>
</blockquote>


### Modify ¬ß15.2 Conditional inclusion [**cpp.cond**] to include a new "has-embed-expression" by modifying paragraph 1 and adding a new paragraph 5 after the current paragraph 4 ### {#wording-specification-cpp.cond}

<blockquote>
<ins>

*has-embed-expression*:

:: ...
:: `__has_embed` `(` *header-name-tokens* *embed-parameter-list*<sub>opt</sub> `)` *new-line*

</ins>
</blockquote>

<blockquote>
<div class="wording-section">
<div class="wording-numbered">

‚Ä¶ and it may contain zero or more <del>*defined-macro-expressions* and/or *has-include-expressions* and/or *has-attribute-expressions* as unary operator expressions</del><ins>*defined-macro-expressions*, *has-include-expressions*, *has-attribute-expressions*, and/or *has-embed-expressions* as unary operator expressions</ins>.
</div>

<ins>
<div class="wording-numbered wording-numbered-5">

The *resource* identified by the parenthesized preprocessing token sequence in each contained *has-embed-expression* is searched for as if that preprocessing token sequence were the *pp-tokens* in a `# embed` directive ([<a href="#cpp.res">cpp.res</a>]). If such a directive would not satisfy the syntactic requirements of a `# embed` directive, the program is ill-formed. The *has-embed-expression* evaluates to:

<div class="wording-numbered-list">

- `0` if the search fails or any given *embed parameters* in the *embed-parameter-list* are not supported.
- Otherwise, `1` if the search for the *resource* succeeds, all the given *embed parameters* in the *embed-parameter-list* are supported, and the *resource* is not empty.
- Otherwise, `2` if the search for the *resource* succeeds, all the given *embed parameters* in the *embed-parameter-list* are supported, and the *resource* is empty.

</div>

</div>
</ins>
</div>
</blockquote>


### Add a new sub-clause ¬ß15.4 Resource inclusion [**cpp.res**] ### {#wording-specification-cpp.res}

<blockquote>
<ins>
<div class="wording-section">
<div id="cpp.res" class="wording-section-header">
<span class="wording-clause-number">15.4</span>
<span class="wording-clause-title">Resource inclusion</span>
<span class="wording-clause-stable-tag">[<b>cpp.res</b>]</span>
</div>

<div class="wording-numbered">

An `#embed` directive shall identify a *resource* that can be processed into a comma-delimited list of integer literals. A *resource* is a source of data accessible from the translation environment. An `# embed` directive can take an arbitrary number of *attribute* token sequences after the *q-char-sequence* or *h-char-sequence*, separated by white space. This is the *embed-parameter-list*, described in ([<a href="#cpp.res.param">cpp.res.param</a>]). An *embed-parameter* is a single attribute in the *embed-parameter-list*. It has an *implementation-resource-width*, which is the implementation-defined size in bits of the located resource. It also has a *resource-width*, which is:

<div class="wording-numbered-list">

- the number of bits as computed from the optionally-provided `limit` *embed-parameter* ([<a href="#cpp.res.param.limit">cpp.res.param.limit</a>]), if present.
- Otherwise, the *implementation-resource-width*.

</div>

</div>

<div class="wording-numbered">

Let *embed-element-width* be:

<div class="wording-numbered-list">

- an integer constant expression greater than zero determined from an implementation-defined embed parameter, if present.
- Otherwise, `CHAR_BIT`.

</div>

The result of `(resource-width) % (embed-element-width)` shall be zero, otherwise the program is ill-formed.

[ *Example*:

```cpp
int main (int, char*[]) {
	const unsigned char coeffs[] = {
// ill-formed if the resource-width is 6 bits and
// the embed-element-width is CHAR_BIT (which is, at minimum, 8 bits)
#embed "6_bits.bin"
	};

	const unsigned char fac[] = {
// may be ill-formed:
// (resource-width) % (embed-element-width)
// may not be 0 on an implementation where the resource-width is 12
#embed "12_bits.bin"
	};

	return 0;
}
```

‚Äì *end example*]
</div>

<div class="wording-numbered">
A preprocessing directive of the form

:: `# embed <` *h-char-sequence* `>` *embed-parameter-list*<sub>opt</sub> *new-line*

searches a sequence of implementation-defined places for a *resource* identified uniquely by the specified sequence between the `<` and `>` delimiters, and causes the replacement of that directive by a comma-delimited list of integer constant expressions as specified below. How the places are specified or the *resource* identified is implementation-defined. [ *Note*: A mechanism similar to, but distinct from, the implementation-defined search paths used for ([<a href="http://eel.is/c++draft/cpp.include">cpp.include</a>]) is encouraged. ‚Äî *end Note* ]</p>
</div>

<div class="wording-numbered">

A preprocessing directive of the form

:: `# embed` `"` *q-char-sequence* `"` *embed-parameter-list*<sub>opt</sub> *new-line*

searches a sequence of implementation-defined places for a *resource* identified uniquely by the specified sequence between the `"` and `"` delimiters. How the places are identified for the *resource* identified is implementation-defined. [ Note: A mechanism similar to, but distinct from, the implementation-defined search paths used for ([<a href="http://eel.is/c++draft/cpp.include">cpp.include</a>]) is encouraged. ‚Äî end Note ] If this search is not supported, or if the search fails, the directive is reprocessed as if it read

:: `# embed` `<` *h-char-sequence* `>` *embed-parameter-list*<sub>opt</sub> *new-line*

with the identical contained sequence (including &gt; characters, if any) from the original directive.
</div>

<div class="wording-numbered">

Either form of the `# embed` directive expands to a comma-separated list of integer literals, where each integer literal is `static_cast` ([<a href="http://eel.is/c++draft/expr.static.cast">expr.static.cast</a>]) to `unsigned char`. Each integer literal shall have an implementation-defined value between `0` and <code>2^<sup>embed-element-width</sup>-1</code>, inclusive. If that list is used to initialize a contiguous sequence of `unsigned char`, the elements of the sequence from the comma-separated list shall contain values as-if `std::fread` ([<a href="http://eel.is/c++draft/library.c">library.c</a>]) from the *resource* as a file during program execution. [ *Note*: Each integer literal produced should closely represent the bit stream of the resource unmodified. This may require an implementation to consider potential differences between translation and execution environments, endianness, and any other applicable sources of mismatch. ‚Äî *end note*]

[ *Example*:

```cpp
#include <cstring>
#include <cstddef>
#include <fstream>
#include <vector>

int main() {
	const unsigned char d[] = {
#embed <data.dat>
	};
	const std::vector<unsigned char> vec_d = {
#embed <data.dat>
	};

	constexpr std::size_t expected_size = sizeof(d);

	// same file in execution environment
	// as was embedded
	std::ifstream f_source("data.dat", std::ios::binary | std::ios::in); 
	unsigned char runtime_d[expected_size];
	char* ifstream_ptr = reinterpret_cast<char*>(runtime_d);
	if (!f_source.read(ifstream_ptr, expected_size))
		return 1;

	std::size_t ifstream_size = f_source.gcount();
	if (ifstream_size != expected_size)
		return 2;

	int is_same = std::memcmp(&d[0], ifstream_ptr, ifstream_size);
	if (is_same != 0)
		return 3;

	int is_same_vec = std::memcmp(vec_d.data(), ifstream_ptr, ifstream_size);
	if (is_same_vec != 0)
		return 4;

	// if the file is the same as the one in the translation environment,
	// the program reaches this statement and returns 0
	return 0;
}
```

‚Äî *end example*]

</div>

<div class="wording-numbered">

[ *Example*:

```cpp 
#include <cstddef>

void have_you_any_wool(const unsigned char*, std::size_t);

int main (int, char*[]) {
	constexpr const unsigned char baa_baa[] = {
#embed "black_sheep.ico"
	};

	have_you_any_wool(baa_baa, sizeof(baa_baa));

	return 0;
}
```
‚Äì *end example*]
</div>

<div class="wording-numbered">

A preprocessing directive of the form

:: `#` `embed` *pp-tokens* *new-line*

(that does not match one of the two previous forms) is permitted. The preprocessing tokens after `embed` in the directive are processed just as in normal text. (Each identifier currently defined as a macro name is replaced by its replacement list of preprocessing tokens.) The directive resulting after all replacements shall match one of the two previous forms [ Note: Adjacent string literals are not concatenated into a single string literal; thus, an expansion that results in two string literals is an invalid directive. ‚Äî end Note ]. The method by which a sequence of preprocessing tokens between a `<` and a `>` preprocessing token pair or a pair of `"` characters is combined into a single *resource* name preprocessing token is implementation-defined.

[ *Example*:

```cpp
#define INT_DATA_H "i.dat"

int main () {
	int i = {
#embed INT_DATA_H
	}; // well-formed if i.dat produces 1 value
	struct s {
		double a, b, c;
		struct { double e, f, g; };
		double h, i, j;
	};
	s x = {
	// well-formed, initializes each element in
	// order according to initialization rules for a
	// brace-delimited, comma-separated list
#embed "s.dat"
	};
	return 0;
}
```
‚Äì *end example*]

</div>
</div>
</ins>
</blockquote>

### Add a new sub-clause ¬ß15.4.1 under Resource Inclusion for Embed parameters [**cpp.res.param**] ### {#wording-specification-cpp.res.param}

<blockquote>
<ins>
<div id="cpp.res.param" class="wording-section">
<div class="wording-section">
<div class="wording-clause-header">
<span class="wording-clause-number">15.4.1</span>
<span class="wording-clause-title">Embed parameters</span>
<span class="wording-clause-stable-tag">[<b>cpp.res.param</b>]</span>
</div>

<div class="wording-numbered">

The *embed-parameter-list* contain *attributes* which may modify the result of the replacement for the `# embed` preprocessing directive. The *attribute-tokens* defined below are `limit`, `prefix`, and `suffix`.
</div>

<div class="wording-numbered">

For an *attribute-token* (including an *attribute-scoped-token*) not specified in this clause, the behavior is implementation-defined. Tokens reserved as *embed-parameter-list* for future revisions of this document and implementations are the same as described for attribute as in ([<a href="http://eel.is/c++draft/dcl.attr.grammar">dcl.attr.grammar</a>]).
</div>

</div>

<div id="cpp.res.param.limit" class="wording-section">
<div class="wording-section-header">
<span class="wording-clause-number">15.4.1.1</span>
<span class="wording-clause-title">`limit` parameter</span>
<span class="wording-clause-stable-tag">[<b>cpp.res.param.limit</b>]</span>
</div>

<div class="wording-numbered">

The *attribute-token* `limit` denotes a maximum number of elements that may be produced in the comma delimited list. It may appear zero, one, or multiple times in the *embed-parameter-list*. The most recent `limit` *embed-parameter* in lexical order applies and the others are ignored. It's *attribute-argument-clause* shall be present and have the form:

:: `(` *pp-tokens* `)`

</div>

<div class="wording-numbered">

It's *attribute-argument-clause* shall be an integral constant expression greater than zero after evaluation, and be processed as described in conditional inclusion ([<a href="http://eel.is/c++draft/cpp.con">cpp.cond</a>]). If the token `defined` appears in the *attribute-argument-clause* the program is ill-formed. There shall be at least one processing of the *attribute-argument-clause* tokens just as in normal text.
</div>

<div class="wording-numbered">

The resource width is:

<div class="wording-numbered-list">

- `0`, if the integer constant expression evaluates to `0`.
- Otherwise, the *implementation-resource-width*, if it is less than the *embed-element-width* multiplied by the integer constant expression.
- Otherwise, the *embed-element-width* multiplied by the integer constant expression, if it is less than or equal to the *implementation-resource-width*.

</div>

[ *Example*:

```cpp
#include <cassert>

int main (int, char*[]) {
	constexpr const char sound_signature[] = {
#embed <sdk/jump.wav> limit(2+2)
	};

	// verify PCM WAV resource
	assert(sound_signature[0] == 'R');
	assert(sound_signature[1] == 'I');
	assert(sound_signature[2] == 'F');
	assert(sound_signature[3] == 'F');
	assert(sizeof(sound_signature) == 4);

	return 0;
}
```
‚Äì *end example*]

[ *Example*:

```cpp
int main (int, char*[]) {
	const unsigned char scal[] = {
// may be ill-formed: if resource-width is greater than 24,
// and ((resource-width * 1) % 24) is not equivalent to 0
#embed "24_bits.bin" limit(1)
	};

	return 0;
}
```
‚Äì *end example*]
</div>
</div>

<div id="cpp.res.param.prefix" class="wording-section">
<div class="wording-section-header">
<span class="wording-clause-number">15.4.1.2</span>
<span class="wording-clause-title">`prefix` parameter</span>
<span class="wording-clause-stable-tag">[<b>cpp.res.param.prefix</b>]</span>
</div>

<div class="wording-numbered">

The *attribute-token* `prefix` denotes a maximum number of elements that may be produced in the comma delimited list. It may appear zero, one, or multiple times in the *embed-parameter-list*. The most recent `prefix` *embed-parameter* in lexical order applies and the others are ignored. It's *attribute-argument-clause* shall be present and have the form:

:: `(` *pp-tokens*<sub>opt</sub> `)`

</div>

<div class="wording-numbered">

If the *resource* is empty, this *embed-parameter* is ignored. Otherwise, any *pp-tokens* specified shall be placed immediately before the expansion of the `# embed` directive.
</div>
</div>

<div id="cpp.res.param.suffix" class="wording-section">
<div class="wording-section-header">
<span class="wording-clause-number">15.4.1.3</span>
<span class="clause-title">`suffix` parameter</span>
<span class="stable-tag">[<b>cpp.res.param.suffix</b>]</span>
</div>

<div class="wording-numbered">

The *attribute-token* `suffix` denotes a maximum number of elements that may be produced in the comma delimited list. It may appear zero, one, or multiple times in the *embed-parameter-list*. The most recent `suffix` *embed-parameter* in lexical order applies and the others are ignored. It's *attribute-argument-clause* shall be present and have the form:

:: `(` *pp-token*<sub>opt</sub> `)`

</div>

<div class="wording-numbered">

If the *resource* is empty, this *embed-parameter* is ignored. Otherwise, any *pp-tokens* specified shall be placed directly after the expansion of the `# embed` directive.

[ *Example*:

```cpp
#include <cstring>
#include <cassert>

#ifndef SHADER_TARGET
#define SHADER_TARGET "ches.glsl"
#endif

extern char* merp;

void init_data () {
	constexpr const char whl[] = {
#embed SHADER_TARGET \
		prefix(0xEF, 0xBB, 0xBF, ) /* UTF-8 BOM */ \
		suffix(,)
		0
	};
	// always null terminated,
	// contains BOM if not-empty
	bool is_good = (sizeof(whl) == 1 && whl[0] == '\0')
	|| (whl[0] == '0xEF' && whl[1] == '0xBB'
	    && whl[2] == '0xBF' && whl[sizeof(whl) - 1] == '\0');
	assert(is_good);
	std::strcpy(merp, whl);
}
```
‚Äì *end example*]
</div>
</div>

<div id="cpp.res.param.empty" class="wording-section">
<div class="wording-section-header">
<span class="wording-clause-number">15.4.1.3</span>
<span class="wording-clause-title">`is_empty` parameter</span>
<span class="wording-clause-stable-tag">[<b>cpp.res.param.empty</b>]</span>
</div>

<div class="wording-numbered">

The *attribute-token* `is_empty` denotes a sequence of tokens to use if the *resource* is empty. It may appear zero, one, or multiple times in the *embed-parameter-list*. The most recent `is_empty` *embed-parameter* in lexical order applies and the others are ignored. It's *attribute-argument-clause* shall be present and have the form:

:: `(` *pp-tokens*<sub>opt</sub> `)`

</div>

<div class="wording-numbered">

If the *resource* is not empty, this *embed-parameter* is ignored. Otherwise, any *pp-tokens* specified shall be placed where the embed directive is.

[ *Example*: If the file is empty, then this

```cpp
constexpr const char x[] = {
#embed "empty_file.dat" \
	empty((char)-1)
};
```

expands to

```cpp
constexpr const char x[] = {
	(char)-1
};
```

Otherwise, it expands to the contents of the file. ‚Äì *end example*]

[ *Example*: This resource is considered empty due to the `limit(0)` *embed-parameter*, always, including in `__has_embed` clauses.

```cpp
int main () {
#if __has_embed(</owo/uwurandom> limit(0) prefix(some tokens)) == 2
	// if </owo/uwurandom> exits, this
	// token sequence is always taken.
	return 0;
#else
	// the resource does not exist
	#error "The resource does not exist"
#endif
}
```

 ‚Äì *end example*]
</div>
</div>

</ins>
</blockquote>




<pre class="include">
path: Preprocessor Embed Footer.bs
</pre>
