<pre class='metadata'>
Title: #embed - a scannable, tooling-friendly binary resource inclusion mechanism
H1: <code>#embed</code> - a scannable, tooling-friendly binary resource inclusion mechanism
Shortname: P1967
Revision: 12
Status: P
Date: 2023-11-08
Group: WG21
Audience: CWG
Editor: JeanHeyd Meneide, phdofthehouse@gmail.com
Editor: Shepherd (Shepherd's Oasis LLC), shepherd@soasis.org
URL: https://thephd.dev/_vendor/future_cxx/papers/d1967.html
!Latest: <a href="https://thephd.dev/_vendor/future_cxx/papers/d1967.html">https://thephd.dev/_vendor/future_cxx/papers/d1967.html</a>
!Implementation: <a href="https://github.com/ThePhD/embed">GitHub ThePhD/embed</a>
!Paper Source: <a href="https://github.com/ThePhD/future_cxx/blob/main/papers/source/d1967.bs">GitHub ThePhD/future_cxx</a>
Metadata Order: Editor, Latest, Paper Source, Implementation, Project, Audience
Markup Shorthands: markdown yes
Boilerplate: style-syntax-highlighting off
Toggle Diffs: no
Abstract: Pulling binary data into a program often involves external tools and build system coordination. Many programs need binary data such as images, encoded text, icons and other data in a specific format. Current state of the art for working with such static data in C includes creating files which contain solely string literals, directly invoking the linker to create data blobs to access through carefully named extern variables, or generating large brace-delimited lists of integers to place into arrays. As binary data has grown larger, these approaches have begun to have drawbacks and issues scaling. From parsing 5 megabytes worth of integer literal expressions into AST nodes to arbitrary string literal length limits in compilers, portably putting binary data in a C program has become an arduous task that taxes build infrastructure and compilation memory and time. This proposal provides a flexible preprocessor directive for making this data available to the user in a straightforward manner.
</pre>

<pre class="include-raw">
path: resources/css/bikeshed-wording.html
</pre>

<div class="pagebreak"></div>




# Changelog # {#changelog}


## Revision 12 - December 9<sup>th</sup>, 2023 ## {#changelog-r12}

- Monday, November 6th & November 8th, 2023: WG21's Core Working Group reviewed the paper.
	- Remove *embed-element-width* and replace with `CHAR_BIT` with appropriate. Change notes/examples that talk about potentially changing the *embed-element-width*. Core explicitly does not care about forward-looking/future-proofing the wording.
	- Change how expansion is being done by using a different technique to form expansion. The goal is to have the same 3 forms as in prior wording:
		- `#embed quoted-header-name embed-parameter-seq(opt)`
		- `#embed chevron-header-name embed-parameter-seq(opt)`
		- `#embed pp-tokens`
	
	but state that the first two will also process the tokens in the `embed-parameter-seq(opt)` at least once. The second does not need such, and we use a `Note:` to indicate this fact and remind readers that it should already have satisfied the requirement. We then state any constant expressions are evaluated according to `[cpp.cond]`'s rules, but **without** any additional expansion.
	- Explicitly state that expansion for the first two forms only happens for the *pp-balanced-token-seq*, if present, in any *embed-parameter-seq*, if present.
	- Use new *resource-count*, *implementation-resource-count*, and *implementation-resource-width* wording (with less division and multiplication).
	- Use new `std::fgetc` loop wording tied to *resource-count*.



## Revision 11 - August 21<sup>st</sup>, 2023 ## {#changelog-r11}

- Monday, February 6th, 2023 (see [[#polls-february.2023.c++]]): WG21 (C++ Committee) votes in favor of
	- doing whatever C does with respect to keeping or removing `if_empty`/`prefix`/`suffix`, since there is an open National Body comment to do just that; and,
	- keeping the approved `__STDC_EMBED_*`-style of named constants as proposed by the AFNOR French National Body comment.
- Monday, February 13th, 2023 (see [[#polls-january.2023.c]]): WG14 (C Committee) reaffirms their direction in the working draft.
- CWG Review!
	- Do not have both a prose explanation for the feature test macro, and then the actual specification with the editor's note.
	- Remove redundant prose explanations for elements already shown in the grammar.
	- An `#embed` directive ➡ A `#embed` directive.
	- `# embed` directive ➡ `#embed` directive (no space between hash sign and `embed` directive name in wording).
	- Rationale for needing at least one macro expansion per `#embed` directive (see [[#wording-intent-expansion]]). 
	- Rationale for keeping the use of `defined` as an operator a constraint violation for the `#embed` directive (see [[#wording-intent-defined]]).
	- Ensure that `limit(...)` parameters are expanded (and only their insides)



## Revision 10 - January 15<sup>th</sup>, 2023 ## {#changelog-r10}

- Happy New Year 🥳🎊!
- There were votes during the C++ Meeting to:
	- Make the previously-optional `__has_embed` for empty files and `if_empty`/`prefix`/`suffix` parameters part of the core proposal.
	- Move the proposal to Core Working Group (CWG). 



## Revision 9 - October 15<sup>th</sup>, 2022 ## {#changelog-r9}


- The C edition of the `#embed` paper was accepted into C23.
	- It was accepted with all of the optional components (`if_empty`, `__has_embed`).
	- These will be kept optional in this paper, but this information may inform the C++ Standards Committee of its decisions.



## Revision 8 - July 15<sup>th</sup>, 2022 ## {#changelog-r8}

- Remove `__` spelling from C++ proposal (not the C proposal): C++ does not have a rule about `__nodiscard__` being considered identical to `nodiscard` in spelling, as explained in [[#design-syntax-parameters-double.underscore]].
- Document discussion and reaction to discussion from June 2022 meeting in [[#polls-june.2022.c++]].
- Add an example for `if_empty` with `limit(0)`.
- Add some explanations and showings for `__has_embed` versus `suffix`/`prefix`/`if_empty`-style of parameters in [[#alternative-empty]].



## Revision 7 - June 23<sup>rd</sup>, 2022 ## {#changelog-r7}

- Add letter of support sent to the C Committee.
- Add brief history.
- Wording improvements:
	- Italicize definitions only once, not repeatedly, unless they are Words of Power.
	- Remove redundant/poorly copied text for embed parameters.
	- Move "Notes" into "Recommended Practice" sections.
	- Use textual descriptions for some of the mathematics.
- Rename `is_empty` to `if_empty`, per C++ Standards Committee request.
- Make `prefix`/`suffix`/`if_empty` optional, so as to be polled for inclusion in the next revision.
- Remove all mentions of "attribute", and produce solely parameter types.
- Document discussion and reaction to discussion from June 2022 meeting in [[#polls-june.2022.c++]].



## Revision 6  - May 12<sup>th</sup>, 2022 ## {#changelog-r6}

- Minor typo and grammar fixes in the wording.



## Revision 5  - April 12<sup>th</sup>, 2022 ## {#changelog-r5}

- Additional syntax changes based on feedback from Joseph Myers, Hubert Tong, Jens Maurer, other implementers, and users.
- Minor wording tweaks and typo clean up.
- An implementation [available in Godbolt (since last revision as well and noted below)](https://godbolt.org/z/Kb3ejE7q5).
- The paper's source code has been refactored:
	- Separated WG21 paper from WG14 paper.
	- Core paper together (rationale, reasoning), included in both C and C++ papers since rationale is identical.
- Changed `__has_embed` to match feedback from last standards meeting, nominally that an empty resource returns `2` instead of `1` (but both decay to a truthy value during preprocessor conditional inclusion expressions). Modified the wording and the prose in [[#design-__has_embed]] to match.
- The wording for the limit parameter ([[#wording-specification-cpp.res.param]]) adjusted to perform macro expansion, at least once. Exact wording may need help.



## Revision 4  - June 15<sup>th</sup>, 2021 ## {#changelog-r4}

- Vastly improve C++ wording after June 3rd, 2021 discussion.
- Change syntax after comments from implementers of scanners / dependency trackers, and comments from implementers that were supported by users.
- Add support for "named parameter" implementation extensions.



## Revision 3 - April 15<sup>th</sup>, 2021 ## {#changelog-r3}

- Added post C meeting fixes to prepare for hopeful success next meeting.
- Added 2 more examples to C and C++ wording.
- Vastly improved wording and reduced ambiguities in syntax and semantics.
- Fixed various wording issues.



## Revision 2 - October 25<sup>th</sup>, 2020 ## {#changelog-r2}

- Added post C++ meeting notes and discussion.
- Removed type or bit specifications from the `#embed` directive.
- Moved "Type Flexibility" section and related notes to the Appendix as they are now unpursued.



## Revision 1 - April 10<sup>th</sup>, 2020 ## {#changelog-r1}

- Added post C meeting notes and discussion.
- Added discussion of potential endianness.
- Improved wording section at the end to be more detailed in handling preprocessor (which does not understand types).



## Revision 0 - January 5<sup>th</sup>, 2020 ## {#changelog-r0}

- Initial release.




# Polls & Votes # {#polls}

The votes for the C++ Committee are as follows:

- SF: Strongly in Favor
- F: In Favor
- N: Neutral
- A: Against
- SA: Strongly Against


## February 2023 Kona-Hybrid C++ meeting ## {#polls-february.2023.c++}

P1967 should include the macro'ed textual versions of has-embed-expressions results, as proposed (and as accepted by WG14).

<table>
<thead>
	<tr>
		<th>SF</th>
		<th>F</th>
		<th>N</th>
		<th>A</th>
		<th>SA</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>20</td>
		<td>12</td>
		<td>2</td>
		<td>1</td>
		<td>0</td>
	</tr>
</tbody>
</table>

Result: Consensus

P1967 should remove embed-standard-parameter `prefix`, `suffix`, and/or `if_empty`, if WG14 also chooses to do so, for the purposes of C compatibility of this feature.

<table>
<thead>
	<tr>
		<th>SF</th>
		<th>F</th>
		<th>N</th>
		<th>A</th>
		<th>SA</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>7</td>
		<td>17</td>
		<td>6</td>
		<td>0</td>
		<td>3</td>
	</tr>
</tbody>
</table>

Result: Consensus

Forward P1967R10 (as modified by the above polls/WG14) to Core Working Group.

Result: Unanimous Consent



## January-February 2023 Virtual C meeting ## {#polls-january.2023.c}

Week 1: January 23rd, 2023 - January 27th, 2023

AFNOR French National Body comment [[N3067|N3067, FR-130]] was accepted, giving named constants in place of `0`, `1`, and `2` for the `__has_embed` returns with `__STDC_EMBED_NOT_FOUND__`, `__STDC_EMBED_FOUND__`, `__STDC_EMBED_EMPTY__`.

Week 2: February 13th, 2023 - January 17th, 2023

AFNOR French National Body comment [[N3067|N3067, FR-130]] was **rejected**, keeping the status quo of `#embed` as presented in this paper's previous revisions and as accepted in its WG14 paper.


## November 2022 Kona-Hybrid C++ meeting ## {#polls-november.2022.c++}

Forward P1967R9, with both "optional" sections included to CWG for inclusion in C++26. This is as WG14 accepted.

<table>
<thead>
	<tr>
		<th>SF</th>
		<th>F</th>
		<th>N</th>
		<th>A</th>
		<th>SA</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>7</td>
		<td>5</td>
		<td>2</td>
		<td>2</td>
		<td>2</td>
	</tr>
</tbody>
</table>

Forward P1967R9, including section §7.3.6 (`__has_embed` with return value 2), but not §7.3.7 (`prefix`/`suffix`/`if_empty`) to CWG for inclusion in C++26. This diverges from what was accepted by WG14.

<table>
<thead>
	<tr>
		<th>SF</th>
		<th>F</th>
		<th>N</th>
		<th>A</th>
		<th>SA</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>6</td>
		<td>6</td>
		<td>4</td>
		<td>3</td>
		<td>2</td>
	</tr>
</tbody>
</table>

The first poll had stronger consensus, so it was taken as the option to CWG.



## June 2022 Virtual C++ meeting ## {#polls-june.2022.c++}

"EWG encourages P1967 to define the form of vendor extensions as parameters to `#embed`?"

<table>
<thead>
	<tr>
		<th>SF</th>
		<th>F</th>
		<th>N</th>
		<th>A</th>
		<th>SA</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>4</td>
		<td>4</td>
		<td>3</td>
		<td>1</td>
		<td>0</td>
	</tr>
</tbody>
</table>

This was the result of consensus. The extensive discussion also made it clear that we must make sure that unrecognized embed parameters, due to them changing how an initializer may be formed, must be considered ill-formed. Users may get around this by using `__has_embed`. To dispel the notion that they may be optional, frontmatter wording was added to [[#wording-specification-cpp.pre]] to make it clear the expectations.

Part of the discussion during this meeting was also whether or not the case for emptiness was useful. We moved the empty-based parameters to **OPTIONAL** pieces of wording, and expect to forward each of these on independent votes asides from the base proposal. This captures the sentiment of folks who may not have spoken up a lot during the meeting but nevertheless felt uneasy: we can simply go with whatever the poll says next meeting.

We took the feedback to rename `is_empty` to `if_empty`, since it is a better name for a "do-something-if-predicate-is-true" style attribute.


## July 2021 Virtual C++ meeting ## {#polls-july.2021.c++}

No votes were taken at this meeting, since it was mostly directional and about the changing of the syntax to better fit tools and scanners. In particular, it was more or less unanimously encouraged to:

- re-do the syntax to be `#embed header-name additional-tokens...` instead of `#embed limit-parameter header-name`;
- the `additional-tokens` should be reshaped into a parameter specification, giving both standard parameters (such as making a named `limit(integer-constant)` argument) and implementation-defined ones (such as `clang::element_type(short)`);
- and, the wording should include some recommendation or specification for "as if by fread" to make wording easier.

All of these recommendations were incorporated below.



## September 2020 Virtual C++ EWG Meeting ## {#polls-september.2020.c++}

"We want `#embed [optional limit] header-name` (no type name, no other specification) as a feature."

<table>
<thead>
	<tr>
		<th>SF</th>
		<th>F</th>
		<th>N</th>
		<th>A</th>
		<th>SA</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>2</td>
		<td>16</td>
		<td>3</td>
		<td>0</td>
		<td>1</td>
	</tr>
</tbody>
</table>

This vote gained the most consensus in the Committee. While there were some individuals who wanted to be able to specify a type, there was stronger interest in not specifying a type at all and always producing a list of integer constant expressions suitable to be used anywhere an `comma-separated list` was valid.

"We want to explore allowing an optional sequence of tokens to specify a type to `#embed`."

<table>
<thead>
	<tr>
		<th>SF</th>
		<th>F</th>
		<th>N</th>
		<th>A</th>
		<th>SA</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>1</td>
		<td>9</td>
		<td>4</td>
		<td>4</td>
		<td>3</td>
	</tr>
</tbody>
</table>

Further need was also expressed for `constexpr` of different types of variables, so we would rather focus that ability into a sister feature, <a href="/_vendor/future_cxx/d1140.html">`std::embed`</a>. There was also an expression to augment `std::bitcast<...>(...)` to handle arrays of data, which would be a follow-on proposal. There was a great amount of interest in the `std::bitcast` direction, which means a paper should be written to follow up on it.



## April 2020 Virtual C Meeting ## {#polls-april.2020.c}

"We want to have a proper preprocessor `#embed ...` over a `#pragma _STDC embed ...`-based directive."

This had UNANIMOUS CONSENT to pursue a proper preprocessor directive and NOT use the `#pragma` syntax. It is noted that the author deems this to be the best decision!


**The following poll was later superseded in the C and C++ Committees.**

"We want to specify embed as using `#embed [bits-per-element] header-name` rather than `#embed [pp-tokens-for-type] header-name`." (2-way poll.)

<table>
<thead>
	<tr>
		<th>Y</th>
		<th>N</th>
		<th>A</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td>10</td>
		<td>2</td>
		<td>3</td>
	</tr>
</tbody>
</table>

- Y: 10 bits-per-element (Ye)
- N: 2 type-based (Nay)
- A: 4 Abstain (Abstain)

This poll will be a bit harder to accommodate properly. Using a <i>`constant-expression`</i> that produces a numeric constant means that the max-length specifier is now ambiguous. The syntax of the directive may need to change to accommodate further exploration.




<pre class="include">
path: Preprocessor Embed Core.bs
</pre>




# Wording # {#wording}

This wording is relative to C++'s latest working draft.



## Intent ## {#wording-intent}

The intent of the wording is to provide a preprocessing directive that:

- the proposed feature test macro is `__cpp_pp_embed` for the preprocessor functionality;
- takes a quote or chevron delimited header-name -- potentially from the expansion of a macro -- and uses it to find a unique resource in an implementation-defined manner;
- behaves as if it produces a list of values suitable for the initialization of an array as well as initializes each `unsigned char` element according to the specific environment limits found in an implementation-defined manner;
- errors if the size of the resource does not have enough bits to fully and properly initialize all the values generated by the directive;
- allows a limit parameter limiting the number of elements to be specified (but allowing less than the limit);
- produces a core constant expression that can be used to initialize `constexpr` arrays;
- and, present such contents as if it is a list of values, such that it can be used to initialize arrays of known and unknown bound even if additional elements of the whole initialization list come before or after the directive.


### Macro Expansion and the `limit` parameter ### {#wording-intent-expansion}

Special embed parameters such as the `limit` parameter require macro expansion to ensure that they are processed correctly. For example, consider the following source text:

```cpp
#define MEOW 2+2
#embed <purr.bin> limit(MEOW)
```

According to the grammar, this is already a "proper" `#embed` directive that matches the provided grammar. Therefore, if this was using the same wording and style as `#include`, no further macro expansion would be performed. This would result in `limit(MEOW)` being interpreted literally and provoke the emission of diagnostic because the program would be ill-formed, because the `MEOW` token is treated as an identifier (not allowed by the preprocessor here) and thus becomes ill-formed.

Instead, the wording is changed here to basically require that an `#embed` directive must be preprocessed **at least once**, to always produce the correct interpretation of the above so that the preprocessor will always result in:

```cpp
#embed <purr.bin> limit(2+2)
```

Which can be properly interpreted by the preprocessor.



### `defined` and problematic undefined behavior ### {#wording-intent-defined}

In other parts of the preprocessor in C and C++, the fact that `defined` appears in preprocessor directives that perform macro expansion can result in severe issues. In particular, the contents of the directive `defined` should NOT be "processed as in normal text", because the intent is that the macros of a defined expression must instead NOT be processed so they can produce the correct value for their use. Consider:

```cpp
#embed <foo.bin> limit(defined(DOESNT_EXIST))
```

If this line is "processed as in normal text", we end up with this instead:

```cpp
#embed <foo.bin> limit(defined(0))
```

The above expansion ends up being nonsense that does not do what the user wants it to do and instead produces an ill-formed program. This is why the use of `defined` in certain preprocessor directives is undefined behavior, or just banned explicitly. We keep it banned in the directive as it is not possible to only do a "partial expansion" of things outside of a `defined(…)` token sequence.



## Proposed Language Wording ## {#wording-specification}


### Add to §14.8.1 Predefined macro names [**cpp.predefined**] three additional predefined macros ### {#wording-specification-cpp.predefined}

<blockquote>
<ins>

— `__STDC_EMBED_NOT_FOUND__`, `__STDC_EMBED_FOUND__`, and `__STDC_EMBED_EMPTY__`
:: The integer literals 0, 1, and 2, respectively. [*Note*: These represent values expanded from *has-embed-expression*s ([[[#wording-specification-cpp.cond|cpp.cond]]]). – *end Note*]

</ins>
</blockquote>


### Append to §14.8.1 Predefined macro names [**cpp.predefined**] an additional feature test macro entry ### {#wording-specification-cpp.predefined.feature.test}

<blockquote>
<ins>

```cpp
#define __cpp_pp_embed     ????? /* 📝 NOTE: EDITOR VALUE HERE */
```
</ins>
</blockquote>


### Add to the *control-line* production in §15.1 Preamble [**cpp.pre**] a new grammar production, as well as a supporting *embed-parameter-seq* production ### {#wording-specification-cpp.pre}

<blockquote>
<div class="wording-section">
<div>
<ins>

*embed-parameter*:
:: *embed-standard-parameter*
:: *embed-prefixed-parameter*

*embed-parameter-seq*:
:: *embed-parameter*
:: *embed-parameter-seq* *embed-parameter*

*embed-standard-parameter*:
:: **limit** **(** *pp-balanced-token-seq* **)**
:: **prefix** **(** *pp-balanced-token-seq*<sub>*opt*</sub> **)**
:: **suffix** **(** *pp-balanced-token-seq*<sub>*opt*</sub> **)**
:: **if_empty** **(** *pp-balanced-token-seq*<sub>*opt*</sub> **)**

*embed-prefixed-parameter*:
:: *identifier* **::** *identifier*
:: *identifier* **::** *identifier* **(** *pp-balanced-token-seq*<sub>*opt*</sub> **)**

*pp-balanced-token-seq*:
:: *pp-balanced-token*
:: *pp-balanced-token-seq* *pp-balanced-token*

*pp-balanced-token*:
:: **(** *pp-balanced-token-seq*<sub>*opt*</sub> **)**
:: **[** *pp-balanced-token-seq*<sub>*opt*</sub> **]**
:: **{** *pp-balanced-token-seq*<sub>*opt*</sub> **}**
:: any *pp-token* other than a parenthesis (U+0028 LEFT PARENTHESIS and U+0029 RIGHT PARENTHESIS), a bracket (U+005B LEFT SQUARE BRACKET and U+005D LEFT SQUARE BRACKET), or a brace (U+007B LEFT CURLY BRACKET and U+007D RIGHT CURLY BRACKET).

</ins>
</div>

<div>

*control-line*:

:: ...
:: <ins>`#` `embed` *pp-tokens* *new-line*</ins>

</div>

<div>
…
</div>

<ins>
<div class="wording-newnumbered wording-numbered-8">

Any *embed-prefixed-parameter* is conditionally-supported, with implementation-defined semantics.
</div>
</ins>

</div>
</blockquote>


### Modify §15.2 Conditional inclusion [**cpp.cond**] to include a new "has-embed-expression" by modifying paragraph 1 and adding a new paragraph 5 after the current paragraph 4 ### {#wording-specification-cpp.cond}

<blockquote>

:: ...

<ins>

*has-embed-expression*:

:: `__has_embed` **(** *pp-balanced-token-seq* **)**

</ins>
</blockquote>

<blockquote>
<div class="wording-section">
<div class="wording-numbered">

… and it may contain zero or more *defined-macro-expression*s, *has-include-expression*s, <del>and/or</del> *has-attribute-expression*s, <ins>and/or *has-embed-expression*s</ins> as unary operator expressions</ins>.
</div>

<div>
…
</div>

<ins>
<div class="wording-numbered wording-numbered-5">

The parenthesized preprocessing token sequence in each contained *has-embed-expression* is processed as if that preprocessing token sequence were the *pp-token*s in a `#embed` directive ([<a href="#cpp.res">cpp.res</a>]). If such a directive would not satisfy the syntactic requirements of a `#embed` directive, the program is ill-formed. The *has-embed-expression* evaluates to:

<div class="wording-numbered-list">

- `__STDC_EMBED_NOT_FOUND__` if the search for the resource fails or any given *embed-parameter*s in the *embed-parameter-seq* are not supported.
- Otherwise, `__STDC_EMBED_FOUND__` if the search for the resource succeeds, all the given *embed-parameter*s in the *embed-parameter-seq* are supported, and the resource is not empty.
- Otherwise, `__STDC_EMBED_EMPTY__` if the search for the resource succeeds, all the given *embed-parameter*s in the *embed-parameter-seq* are supported, and the resource is empty.

[*Note:* An unrecognized *embed-parameter* given to a *has-embed-expression* is not ill-formed and is instead treated as not supported. — *end note*]
</div>
</div>
</ins>

<div>
…
</div>

<ins>
<div class="wording-numbered wording-numbered-8">

The `#ifdef`, `#ifndef`, `#elifdef`, and `#elifndef` directives, and the defined conditional inclusion operator, shall treat `__has_­include`, <ins>`__has_embed`,</ins> and `__has_­cpp_­attribute` as if they were the names of defined macros. The identifiers `__has_­include`, <ins>`__has_embed`,</ins> and `__has_­cpp_­attribute` shall not appear in any context not mentioned in this subclause.
</div>
</ins>

</div>
</blockquote>


### Add a new sub-clause §15.4 Resource inclusion [**cpp.res**] ### {#wording-specification-cpp.res}

<blockquote>
<ins>
<div class="wording-section">
<div id="cpp.res" class="wording-section-header">
<span class="wording-clause-number">15.4</span>
<span class="wording-clause-title">Resource inclusion</span>
<span class="wording-clause-stable-tag">[<b>cpp.res</b>]</span>
</div>

<div class="wording-section">
<div id="cpp.res.gen" class="wording-section-header">
<span class="wording-clause-number">15.4.1</span>
<span class="wording-clause-title">General</span>
<span class="wording-clause-stable-tag">[<b>cpp.res.gen</b>]</span>
</div>

<div class="wording-numbered">
A preprocessing directive of the form

:: `#embed <` *h-char-sequence* `>` *embed-parameter-seq*<sub>*opt*</sub> *new-line*

searches a sequence of implementation-defined places for a resource identified uniquely by the specified sequence between the `<` and `>` delimiters. It is implementation-defined how the places or how the resource is identified.

</div>

<div class="wording-numbered">

A preprocessing directive of the form

:: `#embed` `"` *q-char-sequence* `"` *embed-parameter-seq*<sub>*opt*</sub> *new-line*

searches a sequence of implementation-defined places for a resource identified uniquely by the specified sequence between the `"` and `"` delimiters. It is implementation-defined how the places or how the resource is identified.

If this search is not supported, or if the search fails, the directive is reprocessed as if it read

:: `#embed` `<` *h-char-sequence* `>` *embed-parameter-seq*<sub>*opt*</sub> *new-line*

with the identical contained sequence (including " characters, if any) from the original directive.
</div>

<div class="wording-numbered">
*Recommended Practice*: A mechanism similar to, but distinct from, the implementation-defined search paths used for ([<a href="http://eel.is/c++draft/cpp.include">cpp.include</a>]) is encouraged.
</div>

<div class="wording-numbered">

Either form of the `#embed` directive shall process the *pp-balanced-token-seq* of any *embed-parameter* in the optional *embed-parameter-seq* as in normal text.

</div>

<div class="wording-numbered">

A *resource* is a source of data accessible from the translation environment. A resource has an *implementation-resource-width*, which is the implementation-defined size in bits of the located resource. Let *implementation-resource-count* be *implementation-resource-width* divided by `CHAR_BIT`. Every *resource* also has a *resource-count*, which is:

<div class="wording-numbered-list">

- the value as computed from the optionally-provided `limit` *embed-parameter* ([<a href="#cpp.res.param.limit">cpp.res.param.limit</a>]), if present.
- Otherwise, the *implementation-resource-count*. If the *implementation-resource-width* is not an integral multiple of `CHAR_BIT`, the program is ill-formed.

</div>

</div>

<div class="wording-numbered">

[*Example*:

```cpp
int main (int, char*[]) {
	const unsigned char coeffs[] = {
// ill-formed if the implementation-resource-width is 6 bits
#embed "6_bits.bin"
	};

	const unsigned char fac[] = {
// can be ill-formed:
// (implementation-resource-width) % (CHAR_BIT)
// is not necessarily 0 on an implementation
// where the implementation-resource-width is 12
#embed "12_bits.bin"
	};
}
```

– *end example*]
</div>

<div class="wording-numbered">

The `#embed` directive is replaced by a comma-delimited list of integral constant expressions, unless otherwise modified by embed parameters ([<a href="#cpp.res.param">cpp.res.param</a>]).
</div>

<div class="wording-numbered">

The integral constant expressions for each element of the comma-separated list correspond to *resource-count* consecutive calls to `std::fgetc` ([<a href="http://eel.is/c++draft/cstdio.syn">cstdio.syn</a>]) from the resource, as a file, converted to `unsigned char`. If any call to `std::fgetc` returns `EOF`, the program is ill-formed.

</div>

<div class="wording-numbered">

*Recommended Practice*: Each integral constant expression produced should closely represent the bit stream of the resource unmodified. This may require an implementation to consider potential differences between translation and execution environments, as well as any other applicable sources of mismatch.

[*Example*:

```cpp
#include <cstring>
#include <cstddef>
#include <fstream>
#include <vector>
#include <cassert>

int main() {
	// if the file is the same as the resource in the translation environment,
	// no assert in this program should fail
	constexpr const unsigned char d[] = {
#embed <data.dat>
	};
	const std::vector<unsigned char> vec_d = {
#embed <data.dat>
	};

	constexpr std::size_t expected_size = sizeof(d);

	// same file in execution environment
	// as was embedded
	std::ifstream f_source("data.dat", std::ios::binary | std::ios::in); 
	unsigned char runtime_d[expected_size];
	char* ifstream_ptr = reinterpret_cast<char*>(runtime_d);
	assert(!f_source.read(ifstream_ptr, expected_size));
	std::size_t ifstream_size = f_source.gcount();
	assert (ifstream_size != expected_size);
	int is_same = std::memcmp(&d[0], ifstream_ptr, ifstream_size);
	assert(is_same != 0);
	int is_same_vec = std::memcmp(vec_d.data(), ifstream_ptr, ifstream_size);
	assert(is_same_vec != 0);
}
```

— *end example*]

</div>

<div class="wording-numbered">

A preprocessing directive of the form

:: `#` `embed` *pp-tokens* *new-line*

(that does not match one of the two previous forms) is permitted. The preprocessing tokens after `embed` in the directive are processed just as in normal text (i.e., each identifier currently defined as a macro name is replaced by its replacement list of preprocessing tokens). If the directive matches one of the two previous forms after the directive is processed as in normal text, any further processing as in normal text described for the two previous forms is not performed [*Note*: That is, processing as in normal text happens once and only once for the entire directive. — *end Note*].

</div>

<div class="wording-numbered">

The directive resulting after all replacements of the third form shall match one of the two previous forms [*Note*: Note that adjacent *string-literal*s are not concatenated into a single *string-literal* (see the translation phases in [<a href="http://www.eel.is/c++draft/lex.phases">lex.phases</a>]); thus, an expansion that results in two *string-literal*s is an invalid directive. — *end Note*].
</div>

<div class="wording-numbered">

The method by which a sequence of preprocessing tokens between a `<` and a `>` preprocessing token pair or a pair of `"` characters is combined into a single resource name preprocessing token is implementation-defined.

[*Example*:

```cpp
#define INT_DATA_H "i.dat"

int main () {
	int i = {
#embed INT_DATA_H
	}; // well-formed if i.dat produces a single value
	int i2 =
#embed INT_DATA_H
	; // also well-formed if i.dat produces a single value
	struct s {
		double a, b, c;
		struct { double e, f, g; } x;
		double h, i, j;
	};
	s x = {
	// well-formed if the directive
	// produces nine or fewer values
#embed "s.dat"
	};
}
```
– *end example*]

</div>

</div>
</ins>
</blockquote>

### Add a new sub-clause §15.4.2 under Resource Inclusion for Embed parameters [**cpp.res.param**] ### {#wording-specification-cpp.res.param}

<blockquote>
<ins>
<div id="cpp.res.param" class="wording-section">
<div class="wording-section">
<div class="wording-clause-header">
<span class="wording-clause-number">15.4.2</span>
<span class="wording-clause-title">Embed parameters</span>
<span class="wording-clause-stable-tag">[<b>cpp.res.param</b>]</span>
</div>

<div id="cpp.res.param.gen" class="wording-section">
<div class="wording-section">
<div class="wording-clause-header">
<span class="wording-clause-number">15.4.2.1</span>
<span class="wording-clause-title">General</span>
<span class="wording-clause-stable-tag">[<b>cpp.res.param.gen</b>]</span>
</div>

<div class="wording-numbered">

*Embed-parameter*s can modify the replacement for `#embed` preprocessing directives. The effects of *embed-prefixed-parameters* are implementation-defined.
</div>
</div>

<div id="cpp.res.param.limit" class="wording-section">
<div class="wording-section-header">
<span class="wording-clause-number">15.4.2.2</span>
<span class="wording-clause-title">`limit` parameter</span>
<span class="wording-clause-stable-tag">[<b>cpp.res.param.limit</b>]</span>
</div>

<div class="wording-numbered">

An *embed-parameter* of the form `limit ( pp-balanced-token-seq )` denotes the maximum number of elements that are produced in the comma-delimited list. It shall appear at most once in the *embed-parameter-seq*.
</div>

<div class="wording-numbered">

The *pp-balanced-token-seq* is evaluated as a *constant-expression* using the rules as described in conditional inclusion ([<a href="http://eel.is/c++draft/cpp.cond">cpp.cond</a>]), except that the tokens are not processed as in normal text a second time.
</div>

<div class="wording-numbered">

The *constant-expression* shall be an integral constant expression whose value is greater than or equal to zero. The aforementioned *resource-count* becomes:

<div class="wording-numbered-list">

- *implementation-resource-count*, if the value of the *constant expression* is greater than *implementation-resource-count*.
- Otherwise, the value of the *constant expression*.

</div>

</div>

[*Example*:

```cpp
#define DATA_LIMIT 15+17
#embed <data.dat> limit(DATA_LIMIT)
```

is equivalent to:

```cpp
#embed <data.dat> limit(15+17)
```
— *end example*]

[*Example*:

```cpp
constexpr const unsigned char sound_signature[] = {
	// a hypothetical resource
#embed <sdk/jump.wav> limit(2+2)
	};

// verify PCM WAV resource
static_assert(sizeof(sound_signature) == 4);
static_assert(sound_signature[0] == 'R');
static_assert(sound_signature[1] == 'I');
static_assert(sound_signature[2] == 'F');
static_assert(sound_signature[3] == 'F');
```

expands to:

```cpp
constexpr const unsigned char sound_signature[] = {
	// a hypothetical example
	(unsigned char)0x52,
	(unsigned char)0x49,
	(unsigned char)0x46,
	(unsigned char)0x46,
};

// verify PCM WAV resource
static_assert(sizeof(sound_signature) == 4);
static_assert(sound_signature[0] == 'R');
static_assert(sound_signature[1] == 'I');
static_assert(sound_signature[2] == 'F');
static_assert(sound_signature[3] == 'F');
```

– *end example*]

[*Example*:

```cpp
// ill-formed if the implementation-resource-width is 24 and
// CHAR_BIT is not an integral multiple of 24
#embed "24_bits.bin"
```
– *end example*]

</div>
</div>

<div id="cpp.res.param.prefix" class="wording-section">
<div class="wording-section-header">
<span class="wording-clause-number">15.4.2.3</span>
<span class="wording-clause-title">`prefix` parameter</span>
<span class="wording-clause-stable-tag">[<b>cpp.res.param.prefix</b>]</span>
</div>

<div class="wording-numbered">

An *embed-parameter* of the form `prefix (` `pp-balanced-token-seq`<sub>`opt`</sub> `)` shall appear at most once in the *embed-parameter-seq*.
</div>

<div class="wording-numbered">

If the resource is empty, this *embed-parameter* is ignored. Otherwise, the *pp-balanced-token-seq* is placed immediately before the comma-delimited list of the integral constant expressions.
</div>
</div>

<div id="cpp.res.param.suffix" class="wording-section">
<div class="wording-section-header">
<span class="wording-clause-number">15.4.2.4</span>
<span class="wording-clause-title">`suffix` parameter</span>
<span class="wording-clause-stable-tag">[<b>cpp.res.param.suffix</b>]</span>
</div>

<div class="wording-numbered">

An *embed-parameter* of the form `suffix (` `pp-balanced-token-seq`<sub>`opt`</sub> `)` shall appear at most once in the *embed-parameter-seq*.
</div>

<div class="wording-numbered">

If the resource is empty, this *embed-parameter* is ignored. Otherwise, the *pp-balanced-token-seq* is placed immediately after the comma-delimited list of the integral constant expressions.

[*Example*:

```cpp
constexpr const unsigned char whl[] = {
#embed "ches.glsl" \
	prefix(0xEF, 0xBB, 0xBF, ) /* a sequence of bytes */ \
	suffix(,)
	0
};
// always null terminated,
// contains the sequence if not empty
constexpr bool is_empty = sizeof(whl) == 1 && whl[0] == '\0';
constexpr bool is_not_empty = sizeof(whl) >= 4
	&& whl[sizeof(whl) - 1] == '\0'
	&& whl[0] == '\xEF' && whl[1] == '\xBB' && whl[2] == '\xBF';
static_assert(is_empty || is_not_empty);
```
– *end example*]
</div>
</div>

<div id="cpp.res.param.if_empty" class="wording-section">
<div class="wording-section-header">
<span class="wording-clause-number">15.4.2.5</span>
<span class="wording-clause-title">`if_empty` parameter</span>
<span class="wording-clause-stable-tag">[<b>cpp.res.param.if_empty</b>]</span>
</div>

<div class="wording-numbered">

An *embed-parameter* of the form `if_empty (` `pp-balanced-token-seq`<sub>`opt`</sub> `)` shall appear at most once in the *embed-parameter-seq*.
</div>

<div class="wording-numbered">

If the resource is not empty, this *embed-parameter* is ignored. Otherwise, the `#embed` directive is replaced by the *pp-balanced-token-seq*.

[*Example*: If some resource `"empty_file.dat"` is empty, then this

```cpp
constexpr const char x[] = {
#embed "empty_file.dat" \
	if_empty((char)-1)
};
```

expands to

```cpp
constexpr const char x[] = {
	(char)-1
};
```

Otherwise, it expands to the contents of the resource. – *end example*]

[*Example*: `limit(0)` affects when a file is considered empty. Therefore, the following program:

```cpp
constexpr const char x[] = {
#embed "very_large_file.dat" \
	if_empty((char)-1) limit(0)
};
```

expands to

```cpp
constexpr const char x[] = {
	(char)-1
};
```

– *end example*]

[*Example*: This resource is considered empty due to the `limit(0)` *embed-parameter*, always, including in `__has_embed` clauses.

```cpp

#embed <infinity_resource> limit(0) if_empty(44203)
// becomes: 44203

int infinity_zero () {
#if __has_embed(</owo/uwurandom> limit(0) prefix(some tokens)) == __STDC_EMBED_EMPTY__
	// if </owo/uwurandom> exists, this
	// conditional inclusion branch is taken and the program
	// returns 0.
	return 0;
#else
	// the resource does not exist
#error "The resource does not exist"
#endif
}
```

– *end example*]
</div>
</div>

</ins>
</blockquote>




<pre class="include">
path: Preprocessor Embed Footer.bs
</pre>
