<pre class='metadata'>
Title: Strict Compatibility for Translation-Time Type Matching Improvements
Shortname: 3695 
Revision: 0
!Previous Revisions: None
Status: P
Date: 2025-12-17
Group: WG14
!Proposal Category: Change Request, Feature Request  
!Target: C2y
Editor: JeanHeyd Meneide, phdofthehouse@gmail.com
Editor: Shepherd (Shepherd's Oasis LLC), shepherd@soasis.org
URL: https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Strict%20Compatibility%20for%20Translation-Time%20Type%20Matching%20Improvements.html
!Paper Source: <a href="https://thephd.dev/_vendor/future_cxx/papers/source/C%20-%20Strict%20Compatibility%20for%20Translation-Time%20Type%20Matching%20Improvements.bs">GitHub</a>
Issue Tracking: GitHub https://github.com/ThePhD/future_cxx/issues
Metadata Order: Previous Revisions, Editor, This Version, Paper Source, Implementation, Issue Tracking, Project, Audience, Proposal Category, Target
Markup Shorthands: markdown yes
Toggle Diffs: no
Abstract: The recent changes to generic selection have allowed an undefined behavior that was only available to functions to now leak into generic. This paper attempts to provide some stricter constraints without jeopardizing the use cases of the necessary feature.
</pre>

<pre class="include-raw">
path: resources/css/bikeshed-wording.html
</pre>

<div class="pagebreak"></div>




# Changelog # {#changelog}



## Revision 0 - December 16<sup>th</sup>, 2025 ## {#changelog-r0}

- Initial release. ✨




# Introduction and Motivation # {#intro}

There are several strange hiccups and problems with `_Generic` as it concerns constant sized arrays, variable length arrays, `_BitInt`, and other (potentially new) feature sets. Aaron Ballman's [[N3260]] provided a way to do direct type matching, which eliminated some of these concerns when using a type as the controlling indicator for generic selection. But, this was not enough to stop the few situations where implementation quirks were exposed and the inadequacies of type compatibility for a compile-time, zero run-time cost feature that `_Generic` was meant to be.

Additionally, the integration of Martin Uecker's [[N3348]] has let an existing Undefined Behavior leak into `_Generic` by allow Variable-Length Arrays (VLAs) of non-constant size match with arrays of both constant and non-constant sizes (including ones whose size does not match the input, perhaps at multiple dimensions). The problem was acknowledged during the integration of [[N3348]] by WG14, but it was voted in with the promise that a paper would provide a better array matching capability later on.

There was some degree of agreement to pursue a similar-but-differently-specified approach to matching that was contained in [[N3441]]. Unfortunately, a revision of this paper was not ready for WG14 by the previous meeting, and therefore it was skipped over and WG14 simply settled on Martin Uecker's [[N3348]]. At the meeting, it was voiced that if it was possible, another paper doing better matching should be brought forward, and one of us (JeanHeyd) volunteered to produce a paper that was in line with Martin Uecker's design in [[N3348]].

The core approach for multidimensional matching and stricter matching from our [[N3441]] is still possible even after the integration of Martin Uecker's tweaks, repurposing the use of `[*]` and `[]` in multidimensional matching to be more in line with what Martin Uecker designed and what WG14 has accepted in the current Working Draft of the C Standard. This paper sets out performing that behavior and extending the concept even to `_BitInt`, to aid with improved `_Generic` matching.



## Unusual Array Behavior ## {#intro-arrays}

Consider the following:

```cpp
int main () {
	int arr[10] = {};
	int result = _Generic(typeof(arr),
		int[10]: 0,
		int[11]: 1,
		int[20]: 2,
		default: 3
	);
	return result;
}
```

This works just fine: constant sized arrays are considered compatible only with arrays of the same type and constant size. The above programs compiles, runs, returns `0` dependably, and exits. Consider the same program, however, with a variable length array for the controlling type of the generic selection expression:

```cpp
int main () {
	int n = 20;
	int vla[n] = {};
	int result = _Generic(typeof(vla),
		int[10]: 0,
		int[11]: 1,
		int[20]: 2,
		default: 3
	);
	return result;
}
```

This program is fine even with the `typeof(vla)` thanks to the latest changes in the C Working Draft ([[N3348]]). The problem is after that, as every non-default branch of this generic selection is considered a match. Every variable length array is compatible with every other kind of array insofar as the compatibility rules are concerned. This provokes a constraint violation after the whole `_Generic`, in that only one branch of a generic selection expression may match the controlling type (or none, in which case there must be a default branch).

[[N3348]] exacerbated this problem by not only leaving the compatibility rules around this matter unresolved, but introducing variable length array types as a plausible branch for generic selection by stripping the constraint out:

```cpp
int main () {
	int n = 20;
	int vla[n] = {};
	int result = _Generic(typeof(vla),
		int[20]: 0, // VLA... matches?
		int[11]: 1,
		int[10]: 2,
		int[ n]: 3, // VLA matches?? Double-compatibility issue??
		default: 4
	);
	return result;
}
```

Unfortunately, this too results in the same problem: all of these branches are considered compatible with one another under the changes and direction that [[N3348]] added to the C standard around August 2025. Even if one went back to matching on constant sized arrays for the controlling type, this code would still not compile because the VLA branch is considered compatible with all of the **other** type branches in the list: the compiler would reject the code still as no two generic selection branches may contain a compatible type, either:

```cpp
int main () {
	int n = 20;
	int arr[20] = {};
	int result = _Generic(typeof(arr),
		int[10]: 0,
		int[11]: 1,
		int[20]: 4,
		int[ n]: 3, // compiler error: non-distinct branch from
		             // every other generic selection branch
		default: 4
	);
	return result;
}
```

This continues to deteriorate when using `int[*]` to match "any-sized integer array"; both of them are compatible with one another and they both match on arrays that are either variable length arrays or constant sized arrays. Nominally, this might not be a problem, except there is further issue: the compatibility rules themselves have Bad Behavior on them even if you strip out all of the compatible match branches and only have one:

```cpp
int main () {
	int n = 10;
	int arr[n] = {}; // variable length array
	int result = _Generic(typeof(arr),
		int[11] : 0, // this matches for some reason???
		default: 1
	);
	return result;
}
```

This program returns 0, which makes no sense from the perspective of `_Generic`, which is a translation time-capable matching algorithm. The sizes do not match, but because we defined this in terms of compatibility (and all constant sized and variable length arrays are compatible with one another) we have introduced undefined behavior here. Worse, this gives the impression that the array has the size `11` when it clearly does not. This is easily spotted in these simple toy programs, but is far less usable when applied to larger programs with much more complex control flow and no ahead-of-time knowable constant values.

The acceptance of [[N3348]] made this situation slightly worse by allowing variable length arrays to be put inside of `_Generic` as well, leading to a situation where variable length arrays can easily match array types that are not of the same length.

```cpp
int main () {
	int n = 10;
	int arr[20] = {};
	int result = _Generic(typeof(arr),
		int[n] : 0, // fixed-size arrays now match against any variable length array
		default: 1
	);
	return result;
}
```

Given these issues, we propose a general overhaul and a new phrase-of-power that we are going to term *strict compatibility*, that would be applied within generic selection context. The goal is to remove the recently introduced undefined behavior in generic selection and bring better type matching.




# Design # {#design}

This paper is, exclusively, focusing on improvements to `_Generic`. In particular, we:

- make it so `T[]` can match specifically arrays of fixed size in `_Generic`;
- make it so `T[*]` can match all array sizes in `_Generic` (as is the case after [[N3348]]);
- make it so using both `T[]` and `T[*]` means that fixed-size arrays are matched by `T[]` and VLAs are matched by `T[*]`, if they are both present.







# Prior Art # {#prior}

There is no prior art for this. We intend to gauge Committee reaction, refine the paper, and then submit patches to existing implementations for this behavioral improvement.




# Wording # {#wording}

The wording is relative to the latest Working Draft.



## Intent ## {#wording-intent}

The intent of this wording is to provide:

- a change in the definition of incomplete types for arrays, which makes it so an incomplete constant sized array specification with `T[]` and incomplete variable size `T[*]` can complete their respective constant and incomplete array types;
- move the array types wording and concentrate it into §6.2.5;
- improvements to how type completion works for both categories of incomplete array types, allowing multiple type derivations to be completed at once.

This wording is broken up into two major sections:

1. the incomplete type changes and array matching changes for both `_Generic` and initialization in [[#wording-incomplete]];
2. and, the wording that allows `_Generic` to start with "strict matching" and then fall back to "l-value conversion" matching in [[#wording-fallback]].

These are the ways in which the changes are separable. If WG14 so desires, these two sections can be voted on separately using the paper's section numbers to indicate the section currently being voted on.



## Wording: Incomplete Types, Initialization, and Arrays ## {#wording-incomplete}


### General Standard: Change "unspecified size" to "unknown size" globally ### {#wording-incomplete-unspecified.size}

There are a handful of places where describing a VLA refers to an unspecified size, where the term of art should be an *unknown size*. There are far more uses of "unknown size" than "unspecified size".


### Modify §6.2.5 Types ### {#wording-incomplete-6.2.5}

> <sup>25</sup> Any number of derived types can be constructed from the object and function types, as follows:
>
> - An array type describes a contiguously allocated nonempty set of objects with a particular member object type, called the *element type*. <del>The element type shall be complete whenever the array type is specified.</del><ins>If the element type is an incomplete type, then the array type is an incomplete type.</ins> Array types are characterized by their element type and by the number of elements in the array. An array type is said to be derived from its element type, and if its element type is *T*, the array type is sometimes called "array of *T*". The construction of an array type from an element type is called "array type derivation".
> - …
> 
> …
>
> <sup><ins>✨</ins></sup> <ins>A signed or unsigned bit-precise integer type with no specified width, `_BitInt()`, `signed _BitInt()` or `unsigned _BitInt()`, is an incomplete type called a *bit-precise incomplete integer type*. It is completed, for an identifier of that type, by specifying the width in a later declaration (with internal or external linkage) or during initialization.</ins>
>
> <sup><ins>✨</ins></sup> <ins>An array type of known size is either a constant array type or a variable length array type. If the array type has an integer constant expression and the element type has a known constant size, the array type is a *constant array type*; otherwise, the array type is a *variable length array type*. (Variable length arrays with automatic storage duration are a conditional feature that implementations may support; see 6.10.10.4.)</ins>
> 
> <sup>27</sup> An array type of unknown size is an incomplete type.<ins>An *unknown size* for an array type is one where the size is not specified or the size is specified as `*`. An unknown size of `*` means the array type is a *variably incomplete array type*. An unknown size that is not specified means the array type is an *unspecified incomplete array type*.</ins> It is completed, for an identifier of that type, by specifying <del>the size</del><ins>the constant size, for an unspecified incomplete array type, or the non-constant size, for a variably incomplete array type,</ins> in a later declaration (with internal or external linkage)<ins>  or during initialization</ins>.
> 
> <sup><ins>✨</ins></sup> <ins>Array types have a *rank*, which is the number of dimensions of that array. An array type with a non-array element type has a rank of 1. For every element type of an array type that is itself also an array, the rank of the array increases by 1. Each dimension of a potentially nested array has an index from *0* (outermost) to *rank - 1* (innermost). Incomplete array types still have a rank and still have an index that identifies that dimension.</ins>
>
> <sup><ins>✨</ins></sup> <ins>NOTE &emsp; Contrary to the lexicographic order in a multidimensional array type, the set of balanced square brackets seen first is the outermost dimension, with each subsequent set of balanced square brackets denoting inner array sizes. For a declaration `int arr[3][4][5];`, `3` is the size for the outermost array dimension and `5` is the size for the innermost array dimension in `arr`.</ins>


### Modify §6.5.2.1 Generic selection ### {#wording-incomplete-6.5.2.1}

> **Constraints**
>
> <sup>2</sup> A generic selection shall have no more than one `default` generic association. The type name in a generic association shall specify a type, other than a variably modified type<ins> that is not a variably incomplete array type.</ins> No two generic associations in the same generic selection shall specify <del>compatible</del><ins>associated</ins> types<ins>, as defined later in this sublcause</ins>. If the generic controlling operand is an assignment expression, the *controlling type* of the generic selection expression is the type of the assignment expression as if it had undergone an lvalue conversion, array to pointer conversion, or function to pointer conversion. Otherwise, the controlling type of the generic selection expression is the type designated by the type name. The controlling type shall be compatible with at most one of the types named in the generic association list. If a generic selection has no `default` generic association, its controlling type shall be <del>compatible</del><ins>associated</ins> with exactly one of the types named in its generic association list.
>
> <ins><sup>✨</sup> Given an input type and a target type, the input type is *associated* with the target type under the following conditions.
>
> 1. If the input type is a bit-precise integer type:
> 	- If target type is a bit-precise incomplete integer type of the same signedness and same width, then the two types are associated.
> 	- Otherwise, if target type is a bit-precise incomplete integer type of the same signedness, then the two types are associated.
> 2. If the input type is an array type and it has a constant size:
> 	- If the target type is an array type with both an element type that is associated with the input array type's element type and a constant size that is equivalent to the input array type's constant size, then the two types are associated.
> 	- Otherwise, if the target type is an array type with both an element type that is associated with the input array type's element type and is an empty incomplete array type, then the two types are associated.
> 3. Otherwise, if the input type is an array type and it has a non-constant size:
> 	- If the target type is an array type with both an element type that is associated with the input array type's element type and a constant size that is equivalent to the input array type's constant size, then the two types are associated.
> 	- Otherwise, if the target type is an array type with both an element type that is associated with the input array type's element type and is an empty incomplete array type, then the two types are associated.
> 4. Otherwise, if the input type is an array and it is an incomplete type:
> 	- If the target type is an array type with both an element type that is associated with the input array type's element type and is an variably incomplete, then the two types are associated.
> 	- Otherwise, if the target type is an array type with both an element type that is associated with the input array type's element type and is an empty incomplete array type, then the two types are associated.
> 5. Otherwise, the two types are associated if they are compatible.
> 
> </ins>
>
> **Semantics**
> 
> <sup>3</sup> The generic controlling operand is not evaluated. If a generic selection has a generic association with a type name that is <del>compatible</del><ins>associated</ins> with the controlling type, then the result expression of the generic selection is the expression in that generic association. Otherwise, the result expression of the generic selection is the expression in the `default` generic association. None of the expressions from any other generic association of the generic selection is evaluated.
>
> ...

<blockquote>
<ins>
<sup>✨</sup> EXAMPLE &emsp; Generic selection can match multidimensional arrays by using incomplete array types.

```cpp
int main () {
	int result = _Generic(int[20][10],
		int[][]: 0,
		default: 1
	);
	return result; // return 0
}
```

Constant array types are associated with other constant array types before they are associated with unspecified incomplete array types.

```cpp
int main () {
	int a = _Generic(int[20][10],
		int[][]: 0,
		default: 1
	);
	int b = _Generic(int[20][10],
		int[][]:   1,
		int[20][]: 0,
		default:   1
	);
	int c = _Generic(int[20][10],
		int[][]:     1,
		int[20][]:   1,
		int[20][10]: 0,
		default:     1
	);
	return a + b + c; // return 0
}
```

Multiple types associated with the controlling operand is a constraint violation.

```cpp
int main () {
	int a = _Generic(int[20][10],
		int[][]:   1,
		int[][10]: 0,
		int[][*]:  1,
		default:   1
	);
	// okay, a is 0
	
	_Generic(int,
		int:     0,
		int:     0, // constraint violation
		default: 1
	);
	_Generic(int[20][10],
		int[][]: 0,
		int[][]: 0, // constraint violation
		default: 1
	);
	_Generic(int[20][10],
		int[][]:  0,
		int[*][]: 1, // constraint violation
		int[*][]: 1, // constraint violation
		default:  1
	);
}
```
</ins>
</blockquote>

<blockquote>
<ins>
<sup>✨</sup> EXAMPLE &emsp; A variable length array is associated with variably incomplete array types before unspecified incomplete array types.

```cpp
int main () {
	int n = 10;
	int vla[n] = {};
	
	static_assert(_Generic(typeof(vla),
		int[10]: 0,
		int[11]: 0,
		int[20]: 0,
		default: 1
	));

	static_assert(_Generic(typeof(vla),
		int[10]: 0,
		int[]:   1,
		default: 0
	));

	static_assert(_Generic(typeof(vla),
		int[]:   0,
		default: 1
	));

	static_assert(_Generic(typeof(vla),
		int[]:   0,
		int[*]:  1,
		default: 0
	));

	static_assert(_Generic(typeof(vla),
		int[10]: 0,
		int[]:   0,
		int[*]:  1,
		default: 0
	));
}
```
</ins>
</blockquote>


<blockquote>
<ins>
<sup>✨</sup> EXAMPLE &emsp; A bit-precise incomplete integer type can match on multiple kinds of bit int.

```cpp
int main () {
	_BitInt() bits = 2wb; // type is _BitInt(2)
	
	static_assert(_Generic(typeof(bits),
		signed _BitInt(): 1,
		unsigned _BitInt(): 0,
		default: 0
	));

	static_assert(_Generic(typeof(3uwb),
		_BitInt(): 0,
		unsigned _BitInt(): 1,
		default: 0
	));
}
```
</ins>
</blockquote>


### Modify §6.7.3 Type specifiers/§6.7.3.1 General ### {#wording-incomplete-6.7.3}

> **Syntax**
>
> *type-specifier:*
>
> :: …
> :: `_BitInt` `(` *constant-expression* `)`
> :: <ins>`_BitInt` `(` `)`</ins>
> :: …


### Modify §6.7.7.3 Array declarators ### {#wording-incomplete-6.7.7.3}

> <sup>1</sup> In addition to optional type qualifiers and the keyword `static`, the `[` and `]` can delimit an expression or `*`. If they delimit an expression (which specifies the size of an array), the expression shall have an integer type. If the expression is a constant expression, it shall have a value greater than zero. The element type shall not be a<del>n incomplete or</del> function type. The optional type qualifiers and the keyword `static` shall appear only in a declaration of a function parameter with an array type, and then only in the outermost array type derivation.
>
> …
>
> <sup><del>4</del></sup> <del>If the size is not present the array type is an incomplete type. If the size is `*` instead of being an expression, the array type is a variable length array type of unspecified size, which can only be usedas part of the nested sequence of declarators or abstract declarators for a parameter declaration, not including anything inside an array size expression in one of those declarators;<sup>163)</sup> such arrays are nonetheless complete types. If the size is an integer constant expression and the element type has a known constant size, the array type is not a variable length array type; otherwise, the array type is a variable length array type. (Variable length arrays with automatic storage duration are a conditional feature that implementations may support; see 6.10.10.4.)</del>
> 
> …


### Modify §6.7.11 Initialization ### {#wording-incomplete-6.7.11}

> **Constraints**
>
> …
>
> <sup>7</sup> <ins>For an array, if the element type of an array is itself an incomplete array type, the initializer shall be a brace-enclosed list of initializers. Otherwise, the initializer</ins><del>The initializer for an array</del> shall be either a string literal, optionally enclosed in braces, or a brace-enclosed list of initializers for the elements. An array initialized by character string literal or UTF-8 string literal shall have a character type as element type. An array initialized with a wide string literal shall have element type compatible with a qualified or unqualified `wchar_t`, `char16_t`, or `char32_t`, and the string literal shall have the corresponding encoding prefix (`L`, `u`, or `U`, respectively).
>
> …
>
> **Semantics**
>
> …
>
> <sup>25</sup> If an <del>array of unknown size</del><ins>incomplete array type</ins> is initialized, its size is determined by the largest indexed element with an explicit initializer. The array type is completed at the end of its initializer list.
>
> <sup><ins>✨</ins></sup> <ins>If a bit-precise incomplete integer type is initialized, its width is determined by the smallest bit-precise integer type needed to hold a value of the type of the initialization.</ins>
>
> …



## Wording: Generic Strict Matching and Fallback Matching Harmonization ## {#wording-fallback}


### Modify §6.5.2.1 Generic selection ### {#wording-fallback-6.5.2.1}

> <sup>2</sup> A generic selection shall have no more than one `default` generic association. The type name in a generic association shall specify a type other than a variably modified type. No two generic associations in the same generic selection shall specify compatible types. <del>If the generic controlling operand is an assignment expression, the *controlling type* of the generic selection expression is the type of the assignment expression as if it had undergone an lvalue conversion, array to pointer conversion, or function to pointer conversion. Otherwise, the *controlling type* of the generic selection expression is the type designated by the type name.</del><ins> The generic controlling operand specifies the *controlling type* of the generic expression, which is:</ins>
> 
> - <ins>first, the type specified by the provided type name or assignment expression;</ins>
> - <ins>otherwise, if none of the generic associations are compatible with that type (excluding `default` generic associations), the type specified by the provided type name or assignment expression as if it had undergone an lvalue conversion, array to pointer conversion, or function to pointer conversion.</ins>
> 
>  The controlling type shall be compatible with at most one of the types named in the generic association list. If a generic selection has no `default` generic association, its controlling type shall be compatible with exactly one of the types named in its generic association list. If a generic selection has no `default` generic association, its controlling type shall be compatible with exactly one of the types named in its generic association list.


### Modify §6.5.2.1 Generic selection EXAMPLE 2 to change `int` and `const int` matching based on type vs. expression ### {#wording-fallback-6.5.2.1.example2}






<pre class="biblio">
{
	"N3348": {
		"authors": [
			"Martin Uecker"
		],
		"title": "N3348 - Matching of Multi-Dimensional Arrays in Generic Selection Expressions",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3348.pdf",
		"date": "June 28th, 2024"
	},
	"N3260": {
		"authors": [
			"Aaron Ballman"
		],
		"title": "N3260 - Generic selection expression with a type operand",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3260.pdf",
		"date": "May 12th, 2024"
	},
	"N3441": {
		"authors": [
			"JeanHeyd Meneide",
			"Shepherd"
		],
		"title": "_Generic and VLA realignment and improvement, r1 (updates N3331)",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3441.htm",
		"date": "January 25th, 2025"
	}
}
</pre>
