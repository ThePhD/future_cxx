<pre class='metadata'>
Title: Strict Compatibility for Translation-Time Type Matching Improvements
Shortname: 3695 
Revision: 0
!Previous Revisions: None
Status: P
Date: 2026-01-07
Group: WG14
!Proposal Category: Change Request, Feature Request  
!Target: C2y
Editor: JeanHeyd Meneide, phdofthehouse@gmail.com
Editor: Shepherd (Shepherd's Oasis LLC), shepherd@soasis.org
URL: https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Strict%20Compatibility%20for%20Translation-Time%20Type%20Matching%20Improvements.html
!Paper Source: <a href="https://thephd.dev/_vendor/future_cxx/papers/source/C%20-%20Strict%20Compatibility%20for%20Translation-Time%20Type%20Matching%20Improvements.bs">GitHub</a>
Issue Tracking: GitHub https://github.com/ThePhD/future_cxx/issues
Metadata Order: Previous Revisions, Editor, This Version, Paper Source, Implementation, Issue Tracking, Project, Audience, Proposal Category, Target
Markup Shorthands: markdown yes
Toggle Diffs: no
Abstract: The recent changes to generic selection have allowed an undefined behavior that was only available to functions as a necessary evil to now leak into generic. This paper attempts to provide some stricter constraints without jeopardizing the use cases of the necessary feature.
</pre>

<pre class="include-raw">
path: resources/css/bikeshed-wording.html
</pre>

<div class="pagebreak"></div>




# Changelog # {#changelog}



## Revision 0 - January 7<sup>th</sup>, 2025 ## {#changelog-r0}

- Initial release. ✨




# Introduction and Motivation # {#intro}

There are several strange hiccups and problems with `_Generic` as it concerns constant sized arrays, variable length arrays, `_BitInt`, and other (potentially new) feature sets. Aaron Ballman's [[N3260]] provided a way to do direct type matching, which eliminated some of these concerns when using a type as the controlling indicator for generic selection. But, this was not enough to stop the few situations where implementation quirks were exposed and the inadequacies of type compatibility for a compile-time, zero run-time cost feature that `_Generic` was meant to be.

Additionally, the integration of Martin Uecker's [[N3348]] has let an existing Undefined Behavior leak into `_Generic` by allow Variable-Length Arrays (VLAs) of non-constant size match with arrays of both constant and non-constant sizes (including ones whose size does not match the input, perhaps at multiple dimensions). The problem was acknowledged during the integration of [[N3348]] by WG14, but it was voted in with the promise that a paper would provide a better array matching capability later on.

There was some degree of agreement to pursue a similar-but-differently-specified approach to matching that was contained in [[N3441]]. Unfortunately, a revision of this paper was not ready for WG14 by the previous meeting, and therefore it was skipped over and WG14 simply settled on Martin Uecker's [[N3348]]. At the meeting, it was voiced that if it was possible, another paper doing better matching should be brought forward, and one of us (JeanHeyd) volunteered to produce a paper that was in line with Martin Uecker's design in [[N3348]].

The core approach for multidimensional matching and stricter matching from our [[N3441]] is still possible even after the integration of Martin Uecker's tweaks, repurposing the use of `[*]` and `[]` in multidimensional matching to be more in line with what Martin Uecker designed and what WG14 has accepted in the current Working Draft of the C Standard. This paper sets out performing that behavior and extending the concept even to `_BitInt`, to aid with improved `_Generic` matching.



## Unusual Array Behavior ## {#intro-arrays}

Consider the following:

```cpp
int main () {
	int arr[10] = {};
	int result = _Generic(typeof(arr),
		int[10]: 0,
		int[11]: 1,
		int[20]: 2,
		default: 3
	);
	return result;
}
```

This works just fine: constant sized arrays are considered compatible only with arrays of the same type and constant size. The above programs compiles, runs, returns `0` dependably, and exits. Consider the same program, however, with a variable length array for the controlling type of the generic selection expression:

```cpp
int main () {
	int n = 20;
	int vla[n] = {};
	int result = _Generic(typeof(vla),
		int[10]: 0,
		int[11]: 1,
		int[20]: 2,
		default: 3
	);
	return result;
}
```

This program is fine even with the `typeof(vla)` thanks to the latest changes in the C Working Draft ([[N3348]]). The problem is after that, as every non-default branch of this generic selection is considered a match. Every variable length array is compatible with every other kind of array insofar as the compatibility rules are concerned. This provokes a constraint violation after the whole `_Generic`, in that only one branch of a generic selection expression may match the controlling type (or none, in which case there must be a default branch).

[[N3348]] exacerbated this problem by not only leaving the compatibility rules around this matter unresolved, but introducing variable length array types as a plausible branch for generic selection by stripping the constraint out:

```cpp
int main () {
	int n = 20;
	int vla[n] = {};
	int result = _Generic(typeof(vla),
		int[20]: 0, // VLA... matches?
		int[11]: 1,
		int[10]: 2,
		int[ n]: 3, // VLA matches?? Double-compatibility issue??
		default: 4
	);
	return result;
}
```

Unfortunately, this too results in the same problem: all of these branches are considered compatible with one another under the changes and direction that [[N3348]] added to the C standard around August 2025. Even if one went back to matching on constant sized arrays for the controlling type, this code would still not compile because the VLA branch is considered compatible with all of the **other** type branches in the list: the compiler would reject the code still as no two generic selection branches may contain a compatible type, either:

```cpp
int main () {
	int n = 20;
	int arr[20] = {};
	int result = _Generic(typeof(arr),
		int[10]: 0,
		int[11]: 1,
		int[20]: 4,
		int[ n]: 3, // compiler error: non-distinct branch from
		             // every other generic selection branch
		default: 4
	);
	return result;
}
```

This continues to deteriorate when using `int[*]` to match "any-sized integer array"; both of them are compatible with one another and they both match on arrays that are either variable length arrays or constant sized arrays. Nominally, this might not be a problem, except there is further issue: the compatibility rules themselves have Bad Behavior on them even if you strip out all of the compatible match branches and only have one:

```cpp
int main () {
	int n = 10;
	int arr[n] = {}; // variable length array
	int result = _Generic(typeof(arr),
		int[11] : 0, // this matches for some reason???
		default: 1
	);
	return result;
}
```

This program returns 0, which makes no sense from the perspective of `_Generic`, which is a translation time-capable matching algorithm. The sizes do not match, but because we defined this in terms of compatibility (and all constant sized and variable length arrays are compatible with one another) we have introduced undefined behavior here. Worse, this gives the impression that the array has the size `11` when it clearly does not. This is easily spotted in these simple toy programs, but is far less usable when applied to larger programs with much more complex control flow and no ahead-of-time knowable constant values.

The acceptance of [[N3348]] made this situation slightly worse by allowing variable length arrays to be put inside of `_Generic` as well, leading to a situation where variable length arrays can easily match array types that are not of the same length.

```cpp
int main () {
	int n = 10;
	int arr[20] = {};
	int result = _Generic(typeof(arr),
		int[n] : 0, // fixed-size arrays now match against any variable length array
		default: 1
	);
	return result;
}
```

Given these issues, we propose a general overhaul and a new phrase-of-power that we are going to term *strict compatibility*, that would be applied within generic selection context. The goal is to remove the recently introduced undefined behavior in generic selection and bring better type matching.




# Design # {#design}

This paper is, exclusively, focusing on improvements to `_Generic`. In particular, we:

- make it so `T[CONSTANT]` can match only other fixed 
- make it so `T[]` can match specifically arrays of fixed size or other incomplete arrays in `_Generic`;
- make it so `T[*]` can match all types of array sizes in `_Generic` (as is the case after [[N3348]]);
- make it so using both `T[]` and `T[*]` means that fixed-size arrays are matched by `T[]` and VLAs are matched by `T[*]`, if they are both present (preferentially matching `T[]` over `T[*]`).

We do this by defining "strict compatibility" first and foremost, which more precisely allows Known Constant Length Arrays, Incomplete Arrays, and Variable Length Arrays to match an array dimension with a size specification of `T[*]`. `T[]` allows Known Constant Length Arrays and Incomplete Arrays, but not Variable Length Arrays. `T[CONSTANT]` precisely matches `T[CONSTANT]`, where the two constants compute the same integer constant expression.

Then, we define a second algorithm in the Generic Selection section of the standard that ranks certain kinds of array matches higher than others based on the use of `[]`, `[*]`/`[non_constant]`, and `[CONSTANT]`. The algorithm effectively states that, provided all of the strictly compatible associations are all derived from pointer or array types, we count how many constant, unknown size, and "any" (variable length or `*`) matches there are. The one with the highest "constant" dimensions wins, and if not that then the one with the highest "unknown size" dimensions win, and then finally the one with the highest "any" dimension matches wins. If any are equal and we run out of discriminators, then too many are compatible and it results in an error. The reason it is important to count is because you want something that looks like this:

```cpp
int main () {
	return _Generic(int[2][2],
		int[][2]: 0,
		int[2][]: 1
	);
}
```

to be an error, while this:

```cpp
int main () {
	return _Generic(int[2][2],
		int[2][2]: 0,
		int[2][]:  1
	);
}
```

should return `0`. It also makes it so `[*]` binds "last" since it binds to any given dimension, while `[]` either binds to itself or a constant:

```cpp
int main () {
	return _Generic(int[2][2],
		int[2][*]: 1
		int[2][]:  0
	)
	+ _Generic(int[2][2],
		int[*][*]: 1
		int[*][]:  0
	);
	// equivalent to return 0 + 0;
}
```

Obviously, `[2]` and `[3]` are considered different for the purposes of the algorithm as well (they have to compute the same known constant value in order to match), which finally gives up proper separation of array types in `_Generic`.



## Undefined Behavior / Perceived Value Mismatch ## {#design-undefined.behavior}

This paper eliminates the undefined behavior of matching constant-sized arrays or incomplete array to variable-length arrays and vice-versa. The case of undefined behavior / wrongful perception that it does not fix that was introduced by [[N3348]] is where a VLA is matched to another VLA of the wrong size:

```cpp
int main () {
	int n = foo();
	int m = n + 1;
	_Generic(int[n][m],
		int[n][m]: 1, // dimensions are swappe (incorrect), but
		// generic selection still picks this one
	);
}
```

This is because the variable length array types are all substituted with `[*]`, such that the compiler reads it as:

```cpp
int main () {
	int n = foo();
	int m = n + 1;
	_Generic(int[n][m],
		int[*][*]: 1, // all variable length dimensions are
		// replaced with [*], so technically fine even if
		// visually misleading
	);
}
```

This can be problematic for reading purposes and for other uses. But, this 'cat" is already "out of the bag", so to speak, since the changes in [[N3348]]. There's no real fix for this, unfortunately, other than just going back to banning the use of non-`[*]` variable length arrays in the type names of generic associations. But we removed that constraint, so this paper simply leaves this one untouched case of seeming undefined behavior in place, even though by-the-specification the replacement makes it somewhat "better'.


## Array Usage Examples: Constant Sized Input ## {#design-array.examples.constant}

Here is an example of expected behavior from matching on a constant sized array with the whole gamut of different types deployed:

```cpp
#include <assert.h>

int main () {
	int arr[10] = {};
	
	int result_constants = _Generic(typeof(arr),
		int[10]: 0,
		int[11]: 1,
		int[20]: 2,
		default: 3
	);
	assert(result_constants == 0);

	int result_constant_and_incomplete = _Generic(typeof(arr),
		int[10]: 0,
		int[]: 1,
		default: 2
	);
	assert(result_constant_and_incomplete == 0);

	int result_incomplete = _Generic(typeof(arr),
		int[]: 0,
		default: 1
	);
	assert(result_incomplete == 0);

	int result_incomplete_and_vla = _Generic(typeof(arr),
		int[]: 0,
		int[*]: 1,
		default: 2
	);
	assert(result_incomplete_and_vla == 0);

	int result_incomplete_constant_and_vla = _Generic(typeof(arr),
		int[10]: 0,
		int[]: 1,
		int[*]: 2,
		default: 3
	);
	assert(result_incomplete_constant_and_vla == 0);
	
	return 0;
}
```



## Array Usage Examples: Variable Length Input ## {#design-array.examples.vla}

Here is a similar example, but with the input array being a VLA:

```cpp
#include <assert.h>

int main () {
	int n = 10;
	int vla[n] = {};
	
	int vla_result_constants = _Generic(typeof(vla),
		int[10]: 1,
		int[11]: 2,
		int[20]: 3,
		default: 0
	);
	assert(vla_result_constants == 0);

	int vla_result_constant_and_incomplete = _Generic(typeof(vla),
		int[10]: 1,
		int[]:   0,
		default: 2
	);
	assert(vla_result_constant_and_incomplete == 0);

	int vla_result_incomplete = _Generic(typeof(vla),
		int[]:   1,
		default: 0
	);
	assert(vla_result_incomplete == 0);

	int vla_result_incomplete_and_vla = _Generic(typeof(vla),
		int[]:   1,
		int[*]:  0,
		default: 2
	);
	assert(vla_result_incomplete_and_vla == 0);

	int vla_result_incomplete_constant_and_vla = _Generic(typeof(vla),
		int[10]: 1,
		int[]:   2,
		int[*]:  0,
		default: 3
	);
	assert(vla_result_incomplete_constant_and_vla == 0);
	
	return 0;
}
```




# Prior Art # {#prior}

There is no prior art for this. We intend to gauge Committee reaction since this was supported by commentary during the integration of Martin Uecker's [[N3348]].




# Wording # {#wording}

The wording is relative to the latest Working Draft.



## Intent ## {#wording-intent}

The intent of this wording is to provide:

- add a new definition for "strict compatible"/"strict compatibility" types;
- and, modify Generic Selection to use this new "strict compatibility" for types.


## Modify §6.2.7 "Compatible type and composite type" ## {#wording-6.2.7}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.2.7</span> <span class="wording-clause-title">Compatible type and composite type</span>
</div>

<div class="wording-section">

<div class="wording-numbered">

Two types are *compatible types* if they are the same. Additional rules for determining whether two types are compatible are described in 6.7.3 for type specifiers, in 6.7.4 for type qualifiers, and in 6.7.7 for <ins>certain</ins> declarators. <ins>Two pointer types are compatible if both are identically qualified and both are pointers to compatible types. Two array types are compatible if and only if both of the following hold:</ins>

- <ins>they have compatible element types;</ins>
- <ins>and, if both array length expressions are present, and are integer constant expressions, then they same constant value.</ins>

<ins>If the two array types are used in a context which requires them to be compatible, the behavior is undefined if the lengths of both are specified and the corresponding array length expressions evaluate to unequal values.</ins> Moreover, two complete structure, union, or enumerated types declared with the same tag are compatible if members satisfy the following requirements:

- there shall be a one-to-one correspondence between their members such that each pair of corresponding members are declared with compatible types;
- if one member of the pair is declared with an alignment specifier, the other is declared with an equivalent alignment specifier;
- and, if one member of the pair is declared with a name, the other is declared with the same name.

For two structures, corresponding members shall be declared in the same order. For two unions declared in the same translation unit, corresponding members shall be declared in the same order. For two structures or unions, corresponding bit-fields shall have the same widths. For two enumerations, corresponding members shall have the same values; if one has a fixed underlying type, then the other shall have a compatible fixed underlying type. For determining type compatibility, anonymous structures and unions are considered a regular member of the containing structure or union type, and the type of an anonymous structure or union is considered compatible with the type of another anonymous structure or union, respectively, if their members fulfill the preceding requirements.

Furthermore, two structure, union, or enumerated types declared in separate translation units are
compatible in the following cases:

- both are declared without tags and they fulfill the preceding requirements;
- both have the same tag and are completed somewhere in their respective translation units and they fulfill the preceding requirements;
- both have the same tag and at least one of the two types is not completed in its translation unit.

Otherwise, the structure, union, or enumerated types are incompatible.</div>

<ins>
<div class="wording-newnumbered">

Two types are *strictly compatible* if, in certain cases, they meet more stringent requirements than just being compatible. Two pointer types are strictly compatible if the referenced types are strictly compatible and both are identically qualified. For two array types:

- if they both have a known constant length, then the two types are strictly compatible if the constant lengths are the same and the element types are strictly compatible;
- if they both have an unknown size, then the two types are strictly compatible if the element types are strictly compatible;
- if they both have a length expression of `*` , then the two types are strictly compatible if the element types are strictly compatible;
- if one has a known constant length and the other has unknown size, then the two types are strictly compatible if the element types are strictly compatible;
- if one has a non-constant length and the other has unknown size, then the two types are strictly compatible if the element types are strictly compatible;
- or, if one has a non-constant length and the other has an array length expression of `*`, then the two types are strictly compatible if the element types are strictly compatible.

Otherwise, the two array types are not strictly compatible. Other types are strictly compatible if they are compatible.
</div>
</ins>

<div class="wording-numbered">

All declarations that refer to the same object or function shall have compatible type; otherwise, the
behavior is undefined.
</div>

<div>
...
</div>

</div>
</blockquote>


## Modify §6.5.2.1 "Generic selection" ## {#wording-6.5.2.1}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.5.2.1</span> <span class="wording-clause-title">Generic selection</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Syntax
</div>

<div class="wording-numbered">
...
</div>

<div class="wording-clause-section-title">
Constraints
</div>

<div class="wording-numbered">

A generic selection shall have no more than one `default` generic association. No two generic associations in the same generic selection shall specify <ins>strictly </ins>compatible types. If the generic controlling operand is an assignment expression, the controlling type of the generic selection expression is the type of the assignment expression as if it had undergone an lvalue conversion, array to pointer conversion, or function to pointer conversion. Otherwise, the controlling type of the generic selection expression is the type designated by the type name. <del>The controlling type shall be compatible with at most one of the types named in the generic association list. If a generic selection has no `default` generic association, its controlling type shall be compatible with exactly one of the types named in its generic association list.</del><ins>One generic association shall be the selected association as described further in this subclause, unless there is a `default` generic association in the generic association list, in which case there may be one or zero selected associations.</ins>
</div>

<div class="wording-clause-section-title">
Semantics
</div>

<ins>
<div class="wording-newnumbered">

Let <i>determine-association(<code>T<sub>control</sub></code>, <code>T<sub>assoc</sub></code>)</i> be the algorithm which takes two strictly compatible types <code>T<sub>control</sub></code> and <code>T<sub>assoc</sub></code>. It computes a triplet of integer values as the result, with each value called <i>(<code>N<sub>constant</sub></code>, <code>N<sub>unknown</sub></code>, <code>N<sub>any</sub></code>)</i>. Each value <code>N<sub>constant</sub></code>, <code>N<sub>unknown</sub></code>, and <code>N<sub>any</sub></code> starts at 0 when the algorithm is utilized.

-  If <code>T<sub>assoc</sub></code> is a pointer type, then the current result is added to the result of *determine-association* utilized on <code>T<sub>control</sub></code> and <code>T<sub>assoc</sub></code>'s referenced type and that is yielded as the result.
- Otherwise, if <code>T<sub>assoc</sub></code> is an array type, then the values of the triplet are added to the result of *determine-association* utilized on with the element types of <code>T<sub>control</sub></code> and <code>T<sub>assoc</sub></code>. Then, the values are increased by the first of the following that is true, before the algorithm then yields that as the result:
	- if <code>T<sub>control</sub></code> has a known constant length and <code>T<sub>assoc</sub></code> has a known constant length, increase <code>N<sub>constant</sub></code> by 1;
	- if <code>T<sub>control</sub></code> has unknown size and <code>T<sub>assoc</sub></code> has either a known constant length or unknown size, increase <code>N<sub>unknown</sub></code> by 1;
	- or, if <code>T<sub>control</sub></code> has a size of `*` or a non-constant, variable length, increase <code>N<sub>any</sub></code> by one.
- Otherwise, if <code>T<sub>assoc</sub></code> is not an array type or a pointer type, the algorithm yields the current value of the triplet (<code>N<sub>constant</sub></code>, <code>N<sub>unknown</sub></code>, <code>N<sub>any</sub></code>).

</div>
</ins>

<ins>
<div class="wording-newnumbered">

Let the controlling type be "<code>T<sub>control</sub></code>" and the generic association's type name be "<code>T<sub>assoc</sub></code>". Let "compatible associations" be the generic associations where <code>T<sub>control</sub></code> is strictly compatible with <code>T<sub>assoc</sub></code>.

- If there are zero compatible associations and there is no `default` generic association, a constraint is violated.
- Otherwise, if there are zero compatible associations and there is a `default` generic association, that is the selected association.
- Otherwise, if there is only one compatible association, that is the selected association.
- Otherwise, there are two or more compatible associations. Each compatible association <code>T<sub>compat</sub></code> is used to produce a set of integer triplets using <i>determine-association(<code>T<sub>control</sub></code>, <code>T<sub>compat</sub></code>)</i>, and those triplets are translated as follows:
	- If any of the resulting triplets is equivalent to *(`0`, `0`, `0`)*, then there are compatible associations which are neither pointer derivations or a constraint has been violated.
	- Otherwise, the compatible association with the greatest value of <code>N<sub>constant</sub></code> that is not equal to any other is the selected association.
	- Otherwise, if the greatest value of <code>N<sub>constant</sub></code> of the compatible associations is equal to any other compatible association's <code>N<sub>constant</sub></code> value, then the compatible association with the greatest value of <code>N<sub>unknown</sub></code> that is not equal to any other is the selected association.
	- Otherwise, if the greatest value of <code>N<sub>unknown</sub></code> of the compatible associations is equal to any other compatible association's <code>N<sub>unknown</sub></code> value, then the compatible association with the greatest value of <code>N<sub>any</sub></code> that is not equal to any other is the selected association.
	- Otherwise, there are multiple selected associations and a constraint is violated.

</div>
</ins>

<div class="wording-numbered">

The generic controlling operand is not evaluated. If a generic selection has a <ins>selected association</ins><del>generic association with a type name that is compatible with the controlling type</del>, then the result expression of the generic selection is the expression in that generic association. Otherwise, the result expression of the generic selection is the expression in the `default` generic association. None of the expressions from any other generic association of the generic selection is evaluated.
</div>

<div class="wording-numbered">

The type and value of a generic selection are identical to those of its result expression. It is an lvalue, a function designator, or a void expression if its result expression is, respectively, an lvalue, a function designator, or a void expression.
</div>

<div class="wording-numbered">
EXAMPLE &emsp;&emsp; A cbrt type-generic macro can be implemented as follows:
```cpp
#define cbrt(X) _Generic((X), \
	long double: cbrtl, \
	default: cbrt, \
	float: cbrtf \
	)(X)
```
</div>


<div class="wording-numbered">
EXAMPLE &emsp;&emsp; The following two generic selection expressions select different associations because the assign-
ment expression operand undergoes lvalue conversion while the type name operand is unchanged:

```cpp
int func(const int i) {
	return _Generic(i,
		int : 0, // int is selected
		const int : 1,
		default : 2) +
	_Generic(typeof(i),
		int : 0,
		const int : 1, // const int is selected
		default : 2);
}
```

Thus, this function returns 1.
</div>

<div class="wording-numbered">
EXAMPLE &emsp;&emsp; The following generic selection expressions are valid and all evaluate to 1.

```cpp
void foo(int n, int m) {
	_Generic(int[3][2], int[3][*]: 1, int[2][*]: 0);
	_Generic(int[3][2], int[*][2]: 1, int[*][3]: 0);
	_Generic(int[3][n], int[3][*]: 1, int[2][*]: 0);
	_Generic(int[n][m], int[*][*]: 1, char[*][*]: 0);
	_Generic(int(*)[2], int(*)[*]: 1);
}
```
</div>

<ins>
<div class="wording-newnumbered">
EXAMPLE &emsp;&emsp; Generic selection can match multidimensional arrays by using incomplete array types or variable length array types.

```cpp
int main () {
	int result = _Generic(int[20][10],
		int[][*]: 0,
		default: 1
	);
	return result; // return 0
}
```

Constant array types are associated with other constant array types before they are associated with incomplete array types.

```cpp
int main () {
	static_assert(_Generic(int[20][10],
		int[][]: 1,
		default: 0
	))
	static_assert(_Generic(int[20][10],
		int[][]:   0,
		int[20][]: 1,
		default:   0
	));
	static_assert(_Generic(int[20][10],
		int[][]:     0,
		int[20][]:   0,
		int[20][10]: 1,
		default:     0
	));
}
```

Multiple types compatible associations with the controlling operand is a constraint violation.

```cpp
int main () {
	static_assert(_Generic(int[20][10],
		int[][]:   0,
		int[][10]: 1,
		int[][*]:  0,
		default:   0
	));

	static_assert(_Generic(int[20][10],
		int[*][]: 0,
		int[][]:  1,
	));
	static_assert(_Generic(int[][],
		int[*][]: 0,
		int[][]:  1,
	));
	static_assert(_Generic(int[][],
		int[][]:  1,
		int[56][]: 0,
	));
	
	_Generic(int,
		int: 1,
		int: 1, // constraint violation
	);
	_Generic(int[20][10],
		int[20][]: 1,
		int[20][]: 1, // constraint violation
	);
	_Generic(int[20][10],
		int[][]: 1,
		int[][]: 1, // constraint violation
	);
	_Generic(int[20][10],
		int[*][]: 1,
		int[*][]: 1, // constraint violation
	);
	_Generic(int[20][10],
		int[20][]: 1,
		int[][10]: 1, // constraint violation
	);
}
```
</div>
</ins>

<ins>
<div class="wording-newnumbered">

EXAMPLE &emsp; A variable length array is associated with variable length array types before incomplete array types.

```cpp
extern int n;

int main () {
	int vla[n] = {};
	
	static_assert(_Generic(typeof(vla),
		int[10]: 0,
		int[11]: 0,
		int[20]: 0,
		default: 1
	));

	static_assert(_Generic(typeof(vla),
		int[10]: 0,
		int[]:   1,
		default: 0
	));

	static_assert(_Generic(typeof(vla),
		int[]:   0,
		default: 1
	));

	static_assert(_Generic(typeof(vla),
		int[]:   0,
		int[*]:  1,
		default: 0
	));

	static_assert(_Generic(typeof(vla),
		int[10]: 0,
		int[]:   0,
		int[*]:  1,
		default: 0
	));
}

int n = 10;
```
</div>
</ins>

</div>
</blockquote>



## Delete compatibility requirements from §6.7.7.2 "Pointer declarators" to move them to Compatible/composite types section ## {#wording-6.7.7.2}

> <del>
> <sup>2</sup> For two pointer types to be compatible, both shall be identically qualified and both shall be pointers to compatible types.
> </del>



## Modify §6.7.7.3 "Array declarators", moving compatible requirements to Compatible/composite types section and allowing multiple incomplete array type specifications in generic selection ## {#wording-6.7.7.3}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.5.2.1</span> <span class="wording-clause-title">Generic selection</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Constraints
</div>

<div class="wording-numbered">

In addition to optional type qualifiers and the keyword `static`, the `[` and `]` can delimit an expression or `*`. If they delimit an expression, called the *array length expression*, the expression shall have an integer type. If the expression is a constant expression, it shall have a value greater than zero. The element type shall not be <del>an incomplete or function type.</del><ins>a function type. The element type shall not be an incomplete type, except when used as part of the potentially nested sequence of declarators or abstract declarators for the controlling type of a generic selection or as part of the type name for a generic association.</ins> The optional type qualifiers and the keyword `static` shall appear only in a declaration of a function parameter with an array type, and then only in the outermost array type derivation.
</div>

<div class="wording-numbered">
...
</div>

<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">
...
</div>

<div>
...
</div>

<del>
<div class="wording-numbered wording-numbered-6">

Two array types are compatible if and only if both of the following hold:

- They have compatible element types.
- If both array length expressions are present, and are integer constant expressions, then they same constant value.

If the two array types are used in a context which requires them to be compatible, the behavior is undefined if the lengths of both are specified and the corresponding array length expressions evaluate to unequal values.
</div>
</del>


</div>
</blockquote>




<pre class="biblio">
{
	"N3348": {
		"authors": [
			"Martin Uecker"
		],
		"title": "N3348 - Matching of Multi-Dimensional Arrays in Generic Selection Expressions",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3348.pdf",
		"date": "June 28th, 2024"
	},
	"N3260": {
		"authors": [
			"Aaron Ballman"
		],
		"title": "N3260 - Generic selection expression with a type operand",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3260.pdf",
		"date": "May 12th, 2024"
	},
	"N3441": {
		"authors": [
			"JeanHeyd Meneide",
			"Shepherd"
		],
		"title": "_Generic and VLA realignment and improvement, r1 (updates N3331)",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3441.htm",
		"date": "January 25th, 2025"
	}
}
</pre>
