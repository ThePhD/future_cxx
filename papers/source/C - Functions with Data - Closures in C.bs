<pre class='metadata'>
Title: Functions with Data - Closures in C (A Comprehensive Proposal Overviewing Blocks, Nested Functions, and Lambdas)
Shortname: 37XA
Revision: 2
!Previous Revisions: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3694.htm">n3694 (r1)</a>, <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3657.htm">n3657</a>
Status: P
Date: 2025-12-28
Group: WG14
!Proposal Category: Change Request, Feature Request  
!Target: C2y
Editor: JeanHeyd Meneide, phdofthehouse@gmail.com
Editor: Shepherd (Shepherd's Oasis LLC), shepherd@soasis.org
URL: https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Functions%20with%20Data%20-%20Closures%20in%20C.html
!Paper Source: <a href="https://thephd.dev/_vendor/future_cxx/papers/source/C%20-%20Functions%20with%20Data%20-%20Closures%20in%20C.bs">GitHub</a>
Issue Tracking: GitHub https://github.com/ThePhD/future_cxx/issues
Metadata Order: Previous Revisions, Editor, This Version, Paper Source, Implementation, Issue Tracking, Project, Audience, Proposal Category, Target
Markup Shorthands: markdown yes
Toggle Diffs: no
Abstract: Nested Functions (GCC), Blocks (Clang & Apple-derived compilers), Wide Function Pointers (Borland and existing C library functions), and Lambdas (C++) provide a series of takes on how to, effectively, bundle functions with data in different ways and transport that information to the caller. This proposal goes through the existing practice and enumerates their tradeoffs so as to propose the best possible solution to the problem space in C, prioritizing C-like syntax and avoiding pitfalls from the existing solutions.
</pre>

<pre class="include-raw">
path: resources/css/bikeshed-wording.html
</pre>

<div class="pagebreak"></div>




# Changelog # {#changelog}



## Revision 2 - December 28<sup>th</sup>, 2025 ## {#changelog-r2}

- Talk more directly about `__builtin_call_with_static_chain`, which is sometimes used to call Go-style functions from C [[#intro-static.chain]].
- Add benchmarks for various existing Closures solutions from the Man or Boy test into [[#design-benchmarks]]. Discusses performance and design impacts thorough for the Man or Boy tests and how it relates to other proposals in the conclusions section ([[#design-benchmarks-manorboy-conclusions]]).
- Talk about how type names and non-identified declarators are silly for Capture Functions ([[#design-catpure.functions-forward.decls.silly]]).


## Revision 1 - October 6<sup>th</sup>, 2025 ## {#changelog-r1}

- Integrate `__self_func` ([[__self_func]]) into this paper. Hopefully the reasoning for this is self-evident and nobody asks me justify the obvious in this version of the proposal.
- Comment on Function Literals / Local Functions in [[#intro-function.literals]].
- Initial wording. ✨
	- There is no wording for 6.7.3.4 "Tags" because the type is not accessible from the declarator; the type is generated by the implementation and the entire apparatus of declaration types is covered under the existing rules for declarations of the same identifier, same as they are for functions in a way.
	- There is currently a constraint on accessing a capture function's members with `.` and `->` if there is no definition available at that point. This makes it easier to prevent accessing a value at the wrong time. However, it might not be elegant or useful enough in certain situations. This is paired with [[#design-capture.functions-forward.decls]].
	- Unfortunately, the wording is effectively a major surgery to parts of the standard to enable an elegant use. The good news is that it will enable using a "wide function pointer type" easily by just stating it is an invocable type and, particularly, a closure type. Even if we never accept Capture Functions or Lambdas, this is a useful rewrite of the core part of how functions/callables work.
	- There is no Clause 7 wording. This will explicitly be a separate paper.


## Revision 0 - July 24<sup>th</sup>, 2025 ## {#changelog-r0}

- Initial release. ✨
- This paper has no wording. It is not fit for standardization at the moment and only tries to thoroughly discuss the motivation and design behind this work.




<pre class="include">
path: C - Functions with Data Introduction.bs
</pre>




# Design # {#design}

Given the following properties from all of the extensions and proposals for this in the wild:

<table class="basic"><thead>
<tr>
<th>Feature</th>
<th>GNU Nested Functions</th>
<th>Apple Blocks</th>
<th>C++-Style Lambdas in C</th>
<th>Function Literals</th>
<th>Local Functions</th>
</tr></thead>
<tbody>
<tr>
<td>Capture By-Name</td>
<td>✅<br>(default, use-based)</td>
<td>✅<br>(`__block ident;`)</td>
<td>✅<br>(`[&]`, `[&ident]`)</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>Capture By-Value</td>
<td>❌</td>
<td>✅<br>(default, use-based)</td>
<td>✅<br>(`[=]`, `[ident]`)</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>Selective Capture</td>
<td>❌<br>(use-based, by-name only)</td>
<td>✅<br>(for by-name)<br>❌<br>(for by-value, use-based)</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>Safe to Return Closure</td>
<td>❌</td>
<td>⚠️<br>(requires `Block_copy`)</td>
<td>✅</td>
<td>✅<br>(never unsafe)</td>
<td>✅<br>(never unsafe)</td>
</tr>
<tr>
<td>Relocatable to Heap<br>(Lifetime Management)</td>
<td>❌</td>
<td>✅<br>(`Block_copy`/`Block_release`)</td>
<td>✅<br>(`malloc`/`memcpy`/`free`)</td>
<td>✅<br>(not needed)</td>
<td>✅<br>(not needed)</td>
</tr>
<tr>
<td>Usable Directly as Expression</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>Forward-Declarable</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Immediately Invokable</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>Convertible to Function Pointer</td>
<td>✅</td>
<td>❌</td>
<td>⚠️<br>(only capture-less)</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Convertible to "Wide" Function Type</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Access to Non-Erased Object/Type</td>
<td>❌<br>((wide) function pointer only)</td>
<td>❌<br>(Block type/wide function pointer only)</td>
<td>✅<br>(unique type/size)</td>
<td>❌<br>(no object to access)</td>
<td>❌</td>
</tr>
<tr>
<td>Access to Captures through Object/Type</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>Recursion Possible</td>
<td>✅<br>(use the identifier of the nested function)</td>
<td>❌<br>(`__self_func` required)</td>
<td>❌<br>(`__self_func` required)</td>
<td>❌<br>(`__self_func` required)</td>
<td>✅<br>(use the identifier of the local function)</td>
</tr>
</tbody></table>

This proposal is going to propose two distinct options for standardization, with the recommendation to do both. It is critical to do both for the approval of the C ecosystem in general (with [[#design-capture.functions]]), and for  the maximum amount of external language compatibility (C++ in particular, with [[#design-lambdas]]). The necessary and core goals of this proposal are focused on

- compile-time knowable size of the function object (can be treated as a regular object);
- that has a unique type with its own size;
- does not require a heap or a special stack (unless type-erased or otherwise relocated by (explicit) user action);
- can be interacted with like a normal function (but not necessarily as a normal function pointer);
- and, does not compromise the security of all or a portion of the program.

Lambdas already have usage experience with well-known properties that can be directly translated to C and is easy enough to understand, despite the unfortunate syntax. Capture Functions are a simple modification of Nested Functions that produce a sized object (similar to Lambdas) and makes their captures explicit, allowing for a degree of control and additional safety that was not present in the original Nested Functions design.

We are **not** focused on interoperability with singular function pointers. We believe that should be left to a separate, explicit mechanism in the language, capable of allowing the user to choose where the memory comes from and setting it up appropriately. This way, a user can make the decision **on their own** if they want to use e.g. executable stack (with the consequences that it brings) or just have a part of (heap) memory they set with e.g. Linux `mprotect(...)` or Win32 `VirtualProtect` to be readable, writable, and executable. Such a trampoline-maker (as briefly talked about in [[#appendix-make.trampoline]]) can also be applied across implementations in a way that the secret sauce powering Nested Functions cannot be: this is much more appealing as an approach.

We **DO NOT** take any of the design from Blocks because the Blocks design is, as a whole, unsuitable for C. While its deployment of a blocks "type" to fulfill the necessary notion of a "wide function pointer" type is superior to what Nested Functions have produced, the implementation details it imposes for `__block` variables and the excessive reliance on an (underspecified) runtime/heap are detrimental to a shared & unified approach to C.

NOTE: The Blocks runtime/heap layout has changed (at least) once in its history: the only reason this worked is because Apple owned every part of the Blocks ecosystem. Apple can do whatever they want with it, however they want, whenever they want: this does not work in a language with diverse, loosely coordinated implementations like C and not Objective-C, Objective-C++, or Swift.

As the heap is (typically) repulsive to some freestanding implementations, we do not want to standardize something that will have similar technological drawbacks like VLAs, where -- even if no syntactical or language-design issues exist from the way blocks are written -- the presence of an unspecified source of memory (stack or heap) produces uncertainty in the final code generation of a program.

The feature table for these two looks like this:

<table class="basic"><thead>
<tr>
<th>Feature</th>
<th>C Lambdas</th>
<th>Capture Functions</th>
</tr></thead>
<tbody>
<tr>
<td>Capture By-Name</td>
<td>✅ (`[&]`, `[&ident]`)</td>
<td>✅ (`_Capture(&)`, `_Capture(&ident)`)</td>
</tr>
<tr>
<td>Capture By-Value</td>
<td>✅ (`[=]`, `[ident]`)</td>
<td>✅ (`_Capture(=)`, `_Capture(ident)`)</td>
</tr>
<tr>
<td>Selective Capture</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Safe to Return Closure</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Relocatable to Heap<br>(Lifetime Management)</td>
<td>✅ (`malloc`/`memcpy`/`free`)</td>
<td>✅ (`malloc`/`memcpy`/`free`)<br></td>
</tr>
<tr>
<td>Usable Directly as Expression</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>Forward-Declarable</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Immediately Invokable</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Convertible to Function Pointer</td>
<td>⚠️<br>(only capture-less)</td>
<td>⚠️<br>(only capture-less)</td>
</tr>
<tr>
<td>Convertible to "Wide" Function Type</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Access to Non-Erased Object/Type</td>
<td>✅<br>(unique type/size)</td>
<td>✅<br>(unique type/size)</td>
</tr>
<tr>
<td>Access to Captures through Object/Type</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Recursion Possible</td>
<td>❌<br>(`__self_func` required)</td>
<td>✅</td>
</tr>
</tbody></table>



## What is NOT Being Proposed! ## {#design-no}

While we would like to standardize them in the future, this proposal is NOT looking to standardize statement expressions, a "make trampoline" compiler intrinsic, or a wide function pointer type.


### Statement Expressions? ### {#design-no-statement.expressions}

Statement Expressions should be standardized. While it is related to these efforts, it is entirely separate and has a full, robust set of constraints and concerns in standardizing. It has more existing implementation experience, deployment experience, and implementer practice than any of Blocks or Nested Functions combined. Therefore, it will be pursued in a different proposal. This was briefly noted in a proposal collecting existing extensions in 2007 by Stoughton ([[n1229]]); while there was enthusiastic support at the time, nothing materialized of the mention nor the in-meeting enthusiasm. Some attempts are being made at standardizing it, but it is notably difficult to standardize due to the large number of corner cases that arise from needing to clarify semantics of constructs that normally cannot appear in certain places being able to suddenly appear there, like a `break;` being placed in the initializer expression of a `for` loop.

Another advantage of Statement Expressions is that, unlike any of Apple Blocks / C++ Lambdas / GNU Nested Functions, there is no separating function body. This is critical for writing macros that coordinate with one another, AND is critical in writing reusable macros that have no additional cost and does not set up extra individual entry points. For example, there are hundreds of permutations of the functions in C2y's `<stdmchar.h>` that could be written to make them easier to use, to make them not require double-pointers, to infer the size from a C-style string, and so on, and so forth. The choice of having a bunch of macros which simply repeat the same code means not having to add hundreds of permutations of the `<stdmchar.h>` functions (5 different character types across 5 different encoding types with 6 forms of "pointer and length, just pointer" for input/output, and typical skip/ignore/replace-character error handling strategies, pairwise with one another where order matters).

Another place that statement expressions come in handy is with `RESULT`/`TRY`/etc. macros, primarily used for low-level code where handling (and possibly enforcing error handling) is desirable through error codes and return types, as demonstrated [by jade and lak here: https://gist.github.com/LAK132/0d264549745e8196df1e632d5b518c37](https://gist.github.com/LAK132/0d264549745e8196df1e632d5b518c37). Being able to error and jump out or error and stop if things do not work is a very common (and powerful) idiom for writing straightforward code, and is employed heavily in many different ways across the C ecosystem in various forms.

This paper does not standardize Statement Expressions, and leaves that to a future paper similar to n3643 ([[n3643]]).



### Wide Function Pointer Type? ### {#design-no-wide.function.pointer}

We do hope that another paper creates a new "Wide Function Pointer" type of some kind. Some suggestions can be found in [[#appendix-wide.function.pointer]].


## Capture Functions: Rehydrated Nested Function ## {#design-capture.functions}

Capture Functions are a slight modification of the design of Nested Functions. We start from the base of Nested Functions with three goals in mind.

- Implementers are not comfortable with the implementation baggage associated with Nested Functions or maintaining potential ABI compatibility with those choices (heap/stack trampolines versus separate-page allocations).
- We want to allow a way to access captured values explicitly, and control how those captures work.
- We want them to be safe to move around and relocate, whether to the heap or copied into static memory or otherwise.

A brief demonstration of all of the well-defined behavior:

```cpp
auto make_seven (int x) {
	int y = 7;
	int seven_fn() _Capture(x, y) {
		return x * y;
	}
	return seven_fn; // OK: unique type which
	// is a complete object
}

typedef int eight_fn_t();

eight_fn_t* make_eight () {
	int eight_fn () _Capture() {
		return 8;
	}
	return eight_fn; // OK: empty capture converts to function pointer
}

#if 0
typedef int nine_fn_t();

nine_fn_t* make_nine () {
	int val = 30;
	int nine_fn () _Capture(val) {
		return val;
	}
	return nine_fn; // constraint violation: cannot convert
	// captures to function pointer
}
#endif

int main () {
	int x = 3;
	int zero () {
		// OK, no external variables used
		return 0;
	}
	int also_zero () _Capture() {
		// same as above, just explicit
		return 0;
	}
#if 0
	int double_it () {
		return x * 2; // constraint violation
	}
#endif
	int triple_it () _Capture(x) {
		return x * 3; // OK, x = 3 when called
	}
	int quadruple_it () _Capture(&x) {
		return x * 4; // OK, x = 5 when called
	}
	int quintuple_it () _Capture(=) {
		return x * 5; // OK, x = 3 when called
	}
	int sextuple_it () _Capture(&) {
		return x * 6; // OK, x = 5 when caled
	}
	x = 5;
	auto seven_tuple_it = make_seven(x);
	eight_fn_t* eight = make_eight();
	return zero() + triple_it() + quadruple_it()
		+ quintuple_it() + sextuple_it() + seven_tuple_it()
		+ eight();
	// same as
	// return 117;
	// 0 + (3 * 3) + (5 * 4)
	// + (3 * 5) + (5 * 6) + (5 * 7)
	// + 8
}
```

We go over the purpose of the design of this and the reasons for that design here.


### Capture Functions are Complete Objects (unless only Declared) ### {#design-capture.functions-complete.objects}

The most important change from typical GNU Nested Functions and mirroring behavior from C++ Lambdas is that nested functions -- the identifier itself introduced by the definition of the function -- is a regular, normal, complete C object. This enables it to be:

- returned, if the type is knowable at the time of function definition (or `auto` return types are incorporated into the language);
- passed to a function, if the function is defined after the creation of the capture functions;
- and, stored elsewhere through static/`_Thread_local` data with assignment or `memcpy`, or even on the heap.

These are important qualities to allow these functions with data to be used with asynchronous code, as (stored) callbacks, and in other scenarios. The size and alignment of the object is implementation-defined, and its layout is also entirely implementation-defined, much like the properties of a regular `struct` or `union` type. This allows implementations to not have to figure out how to squash everything into a single erased type, and instead enforce the Single Responsibility Principle; they already know how to create unique types, they already know how to create and fill structure types, and now separately a wide function pointer type or a "make trampoline" compiler feature ([[#appendix-make.trampoline]]) can be developed.

Given an extremely simple example:

```cpp
#include <stdlib.h>
#include <stdio.h>

typedef void work_fn_t(void* user);
void add_work(work_fn_t* work, void* user);
bool work_done();

void kickoff(int start, int limit) {
	void work() _Capture(start, limit) {
		printf("doing work for %d to %d\n", start, limit);
		for (int i = start; i < limit; ++i) {
			printf("sooo much work - %d\n", i);
		}
	}
	void work_trampoline(void* user) {
		(*((typeof(work)*)user))()
		// free lambda after work is done
		free(user);
	};
	// elevate to higher lifetime to survive async function call time
	void* work_ptr = malloc(sizeof(work));
	memcpy(work_ptr, &work, sizeof(work));
	add_work(work_trampoline, work_ptr);
}

int main (int argc, char* argv[]) {
	int start = 0;
	int limit = 30;
	if (argc > 1)
		start = atoi(argv[1]);
	if (argc > 2)
		limit = atoi(argv[2]);

	kickoff(start, limit);

	while (!work_done());
	// no memory leaks at the end of the program
	return 0;
}
```

There are caveats about this, but they are related to forward declarations ([[#design-capture.functions-forward.decls]]).


### Deduced Return Types, Unique Types ### {#design-capture.functions-unique.types}

Reusing an example from the above code, the `make_seven` function needs to have a special, inferred/deduced return type. This is because the type of a capture function is not known until it is defined:

```cpp
auto make_seven (int x) {
	int y = 7;
	int seven_fn() _Capture(x, y) {
		return x * y;
	}
	return seven_fn; // OK: unique type which
	// is a complete object
}
```

The `auto` return type here just means "the first `return` expression is the return type of the function". This only works with in-line function definitions, and does not allow for a separated function declaration/definition (as the separated declaration would not have a material, real type until the definition could be read). This only applies to functions with inferred return types like this, where the first declaration of such a function must also be its definition.

If no `return` appears in such a function, or all the `return`s do not contain an expression, the return type is inferred to be `void`. Otherwise, all the `return <expr>;` must return the exact same type. If there exists one or more `return <expr>;`s and the types are not exactly the same in the whole function definition, then it is a hard error. This is already partly described in Jens Gustedt's "Type inference for variable definitions and function returns v6" ([[n2923]]); reviving this paper would be a matter of rebasing it on the current working draft and improving the wording present.


### Data Captures are Explicit ### {#design-capture.functions-data.captures}

Data captures, the way in which local data is accessible inside of the function, are explicit. The only reason captures are explicit is because it is impossible to tell if something should be captured by value (and copied into whatever implementation-defined holding space is used for the Capture Functions's complete object), or if something should be captured by name/reference (and only have its pointer/address copied into whatever implementation-defined holding space is used for the Capture Functions's complete object). This detail matters both for safety reasons when assigning, copying, storing, and otherwise relocating a capture function from its original scope.

NOTE: `static` and `_Thread_local` objects, as well as typical file-scope declarations, are accessible within a capture function in the normal way. `constexpr` objects, without a `static` specifier, at local scope are also accessible.

Allowing for explicit captures also allows for better type checking (used objects must be explicit acknowledged by the programmer that they should be used), and allows for covering both the use cases of Apple Blocks (default by-value capture) and GNU Nested Functions (default by-name capture) without breaking anything. The lack of a capture also covers all of the use cases that Function Literals would have covered, which means that Capture Functions can sufficiently cover all of the existing use cases currently in production in C ecosystems. To match the default behaviors:

- Apple Blocks: `_Capture(=)` (capture all by-value).
- GNU Nested Functions: `_Capture(&)` (capture all by-name/reference).
- Function Literals: `_Capture()` (capture nothing).

Only one "capture all" is allowed. That is, `_Capture(=, &)` (and vice-versa) is illegal. The rest of the *specific* captures for accessible identifiers can be specified in any order. Note that *specific* captures for a given object override the default implicit "capture all" behavior. For example:

```cpp
int main () {
	int x = 30;
	int y = 10;
	int fn () _Capture(&, x) {
		return x + y;
	}
	x = 50;
	y = 40;
	return fn();
}
```

This program returns `70` (`x` is captured by-value as `30`, `y` is captured by-name and is changed to `40` before invocation). The change to `x` on the outside to `50` is not reflected inside of the invocation. This allows an ease-of-use for specifying the "default" implicit all-capture, while letting the user select specifically which captures should work.


### Data Captures can be Renamed ### {#design-capture.functions-data.captures.rename}

Data captures can be renamed (or computed, with an expression that does not include a `,` unless it is parenthesized). This is important for e.g. incrementing reference counters for copying large, important data structures into callbacks that may either be invoked multiple times or have their own long-lived lifetime. The syntax for this occurs within the `_Capture` clause of a capture function:

```cpp
#include <tree.h>

TREE_DECLARE(int_tree_t, int_tree, int);
TREE_IMPLEMENT(int_tree_t, int_tree, int);

#include <stdcountof.h>

enum queue_status {
	qs_success,
	qs_timedout,
	qs_busy,
	qs_fail,
	qs_invalid
};

typedef int work_fn_t(void* user);

queue_status add_dispatch_work(work_fn_t* work, void* user);
queue_status is_work_done();
void work_shutdown();

int main () {
	int data[] = { 2, 11, 32, 49, 57, 20, 110, 203 };
	int_tree_t tree = int_tree_init_with(data, data + countof(data));
	int work () _Capture(my_tree = int_tree_copy(tree)) {
		/* do work.... */
		int elem = int_tree_remove(my_tree, int_tree_min_node(my_tree));
		/* blah blah blah */
		return 0;
	}
	int work_trampoline (void* user) _Capture() {
		return (*((typeof(work)*)user))();
	}
	if (add_dispatch_work(work_trampoline, &work) != qs_success) {
		return 1;
	}
	queue_status err;
	while ((err = work_done()) != qs_success) {
		swith () {
			case qs_invalid:
			case qs_timedout:
			case qs_failed:
				// some error happened
				work_shutdown();
				return 2;
			default:
				break;
		}
	}
	work_shutdown();
	return 0;
}
```


### NEW: Data Captures are Accessible ### {#design-capture.functions-data.captures.fields}

An important adjustment to make sure this code works better than the way it did for Blocks or Nested Functions is the ability not only to copy ([[#design-capture.functions-complete.objects]]) or otherwise rename objects ([[#design-capture.functions-data.captures.rename]]), but ALSO to get at the internals of a given Capture Functions. This is something missing from GNU Nested Functions (which provides no real resolution for it) as well, and something that could matter for Apple Blocks but does not in practice because they can turn any object into a shared one with the `__block` modifier on an object. In particular, this only matters in the case of a closure which is given a (copied) resource that must either be released or freed.

NOTE: Thanks to Alex Celeste, for being the first person to bring this to my attention!

The syntax looks just like normal structure access, and is based on the names placed in the `_Capture` clause:

```cpp
#include <stdio.h>

int main () {
	int x = 30;
	double y = 5.0;
	char z = 'a';

	int cap_fn0 () _Capture(=, &renamed_x = x) {
		printf("inside cap_fn0 | renamed_x: %d, y: %f, z: %c\n",
			renamed_x, y, z);
	}
	
	int cap_fn1 () _Capture(&, renamed_y = y) {
		printf("inside cap_fn1 | x: %d, renamed_y: %f, z: %c\n",
			x, renamed_y, z);
	}
	
	x = 60;
	y = 10.0;
	z = 'z';

	cap_fn0();
	cap_fn1();
	
	printf("\n");

	printf("inside main fn | cap_fn0.renamed_x: %d, cap_fn0.y: %f, cap_fn0.z: %c\n",
		cap_fn0.renamed_x, cap_fn0.y, cap_fn0.z);
	printf("inside main fn | cap_fn1.x: %d, cap_fn1.renamed_y: %f, cap_fn1.z: %c\n",
		cap_fn1.x, cap_fn1.renamed_y, cap_fn1.z);

	return 0;
}
```

This would print:

```sh
inside cap_fn0 | renamed_x: 60, y: 5.0, z: a
inside cap_fn1 | x: 60, renamed_y: 10.0, z: z

inside main fn | cap_fn0.renamed_x: 60, cap_fn0.y: 5.0, cap_fn0.z: a
inside main fn | cap_fn1.x: 60, cap_fn1.renamed_y: 10.0, cap_fn1.z: z
```

How the implementation actually accesses the information is implementation-defined, and the layout of the Capture Functions object is not defined the specification, except to say it's implementation-defined ([[#wording]]).

NOTE: This leaves room for an implementation to, for example, use creative ways to retrieve objects and object references. Using a pointer to the current stack frame and then computing a raw offset to get to a specific bit of data, or using entirely registers, are all possible depending on how the captures are implemented. Such improvements and optimizations -- especially in the face of potential asynchronous calls and the need to protect against false sharing -- must be left up to Quality of Implementation.

As an example for releasing resources outside of the function call itself for the purposes of a function call that gets used more than once and isn't passed a "We're Done" signal, we can reuse the example from [[#intro-nested.functions-captures.no.workaround]]:

```cpp
#include <stdlib.h>
#include <string.h>
#include <stddef.h>

typedef int compare_fn_t(const void* left, const void* right);

auto make_compare(int argc, char* argv[]) {
	/* LOCAL, heap-allocated variable.... */
	int* in_reverse = malloc(sizeof(int));
	*in_reverse = 0;

	if (argc > 1) {
		char* r_loc = strchr(argv[1], 'r');
		if (r_loc != NULL) {
			ptrdiff_t r_from_start = (r_loc - argv[1]);
			if (r_from_start == 1 && argv[1][0] == '-' && strlen(r_loc) == 1) {
				*in_reverse = 1;
			} 
		}
	}
	
	int compare(const void* untyped_left, const void* untyped_right) _Capture(in_reverse) {
		const int* left = untyped_left;
		const int* right = untyped_right;
		return (*in_reverse) ? *right - *left : *left - *right;
	}
	return compare;
}

int main(int argc, char* argv[]) {
	int list[] = { 2, 11, 32, 49, 57, 20, 110, 203 };	

	auto compare = make_compare(argc, argv);
	qsort_r(list, (sizeof(list)/sizeof(*list)), sizeof(*list), compare, &compare);
	// with data field captures, we can now `free` the
	// field `in_reverse` from the lambda
	free(compare.in_reverse);
	
	return list[0];
}
```

Thanks to the capture of `in_reverse` with the by-value `_Capture(in_reverse)` indication, the return of this function is safe. And, since we have access to the unique type that is generated (through the `auto` return type), we can access the pointer `in_reverse` normally and naturally. This isn't possible with normal C++-style lambdas, as they haven't decided to make this available (though our design for Lambdas in C will also include the named captures as accessible fields). It's also not possible in the other solutions which rely on type-erasure as a first-class part of the design (Apple Blocks with the Blocks type, GNU Nested Functions only being accessible through a pointer or convertible to a wide function pointer in [[n2661]] or [[n3564]], Borland's closure annotation or function literals). This is why making it possible to access the unique type first and foremost is of great benefit.


### Forward Declarations Work ### {#design-capture.functions-forward.decls}

Capture functions can be forward declared, similar to how GNU Nested Functions can be forward-declared if one uses the `auto` keyword in front of the definition of a Nested Functions:

```cpp
#include <stdlib.h>
#include <string.h>
#include <stddef.h>

int main(int argc, char* argv[]) {
	int in_reverse = 0;
	// forward-declared compare
	int compare(const void* untyped_left, const void* untyped_right) _Capture(in_reverse);
	// even though it is captured by value...
	
	if (argc > 1) {
		char* r_loc = strchr(argv[1], 'r');
		if (r_loc != NULL) {
			ptrdiff_t r_from_start = (r_loc - argv[1]);
			if (r_from_start == 1 && argv[1][0] == '-' && strlen(r_loc) == 1) {
				in_reverse = 1;
			} 
		}
	}

	/*
	compare.in_reverse; // CONSTRAINT VIOLATION: cannot access until definition
	*/
	
	int compare_trampoline(const void* untyped_left,
		const void* untyped_right,
		void* user)
	_Capture() {
		return (*(typeof(compare)*)user)(untyped_left, untyped_right);
	}

	int list[] = { 2, 11, 32, 49, 57, 20, 110, 203 };
	qsort_r(list, (sizeof(list)/sizeof(*list)), sizeof(*list),
		compare_trampoline,
		&compare
	);
	// define it here;
	// captures and arguments must be identical otherwise it is a violation
	// `in_reverse` is captured at the point of definition, not the point of declaration.
	int compare(const void* untyped_left, const void* untyped_right) _Capture(in_reverse) {
			const int* in_reverse = (const int*)user;
			const int* left = untyped_left;
			const int* right = untyped_right;
			return (*in_reverse) ? *right - *left : *left - *right;
	};
	return list[0];
}
```

Some important points for Capture Functions's forward declarations:

- the values captured have their values taken at the point of definition, not at the point of declaration;
- because of this, one cannot use the `.` or the `->` operators on a capture function declaration, only a definition;
- and, forward declarations can only have the function call operation applied to them, before they are defined.

NOTE: It is unclear whether the Apple Blocks-like by-value capture should occur at the point of the first declaration or the definition. Currently, the reasoning is that using the definition for the values captured is better because there can be multiple forward declarations (in perhaps sprawling manners due to `#include` and other code copy-paste mechanisms) but only one definition, and thus the definition should be the important part.

NOTE: The other opinion is that restricting access to `.` and `->` by effectively labeling the "object" part of the closure type as an incomplete type is not worth it, and that capturing things by-value at the first forward declaration is good.

There is no existing practice for this due to the way GNU Nested Functions -- the only existing practice where forward-declaraing the closure type is allowed -- work. That is, they only capture by-name/by-reference, and so the value is always the value at the point of execution and not at the point of evaluation. Apple Blocks and other solutions do not have this problem since they are expressions and thus do not have to engage in any sort of work with the "split between declaration vs. definition" issue at all.


### Forward Declarations without a name are a bit useless ### {#design-catpure.functions-forward.decls.silly}

Forward declarations without a name are a bit silly, because they are unique types. An unnamed declarator means that there's a unique type that has been forward-declared but serves no other purpose:

```cpp
int main(int argc, char* argv[]) {
	typedef int (compare_closure1_t)(const void* untyped_left, const void* untyped_right) _Capture(=);
	typedef int (compare_closure2_t)(const void* untyped_left, const void* untyped_right) _Capture(=);
	typedef compare_closure_t compare_closure1_t;
	typedef compare_closure_t compare_closure2_t; // constraint violation: not a compatible type redeclaration
	return 0;
}
```

The syntax is kept for parity with the rest of the declarator syntax. It also allows a user to make a unique type within a translation unit, though there are obviously other ways to do this.


### Capable of Recursion ### {#design-capture.functions-recursion}

Capture Functions are able to refer to themselves for the purpose of recursion. This means that `__self_func` ([[__self_func]]), unlike for expression-based/unnamed Function Literals/Lambdas/Block literals, is not required:

```cpp
int main () {
	int tripling (int times, int start) {
		if (times >= 5) {
			return start;
		}
		return tripling(times + 1, start * 3); // normal recursion
	}
	return tripling(0, 1);
}
```


### Not An Expression ### {#design-capture.functions-expression}

The one true technical downside is that Capture Functions are declarations / definitions. They cannot be used (without the Statement Expression extension) in a function call's argument list, which means that (short) closures and anonymous functions still need the full function definition. This is annoying and, honestly, one of the reasons [[#design-lambdas]] are preferred as a shorthand syntax.

It also means that, without Statement Expressions, Capture Functions cannot be used for the implementation of many macros which are typically expected to be usable as normal expressions.


### Footgun: By-Name Capture Exceeds Captures's Lifetime ### {#design-capture.functions-footgun.reference}

A brief display of the undefined behavior:

```cpp
auto ub (int parameter) {
	int automatic = 7;
	int fn() _Capture(parameter, &automatic) {
		return parameter + automatic;
	}
	return fn; // well-defined copy return
	// but dangling reference to `automatic`!
}

int main () {
	auto fn = ub(2);
	return fn(); // undefined behavior:
	// `automatic` no longer exists.
}
```

In general, undefined behavior occurs in the same way that it occurs within existing C code: use of an object after its lifetime has ended (in this case, an automatic storage duration object has gone out-of-scope). The fix for `ub` in this case is to capture `automatic` by-value. This makes it safe to copy that function object to the heap, or the stack. Additionally, no UB is possible by conversion to a function pointer.


### Future Footgun: Wide Function Pointers ### {#design-capture.functions-footgun.wide}

Wide function pointers, if and when they come to C, can make for footguns with capturing lambdas given that they will (likely) allow conversions from any Nested Function / Block / Lambda to them implicitly. Using a fictional wide function pointer syntax using `%`:

```cpp
typedef int foo_fn_t(int);

foo_fn_t% call_me (int x) {
	return [x](int y) { return x + y; }; // converts to wide function pointer type!
	// undefined behavior if the return value is ever
	// called outside of this function 
}

int use_me(foo_fn_t% fn) {
	return fn(2);
}

int main () {
	int x = 30;
	return use_me(call_me(x));
}
```

This is a similar problem to Nested Functions returning a regular function pointer from a function call. Unfortunately, a conversion being allowed here is necessary to allow the 75%+ use case of passing it as a parameter, such as:

```cpp
typedef int foo_fn_t(int);

void pass_to_me (foo_fn_t% func);

int main () {
	int x = 30;
	pass_to_me(
		[x](int y) { return x + y; }
	); // converts to wide function pointer type!
	return 0; 
}
```

Thusly, in a future with a wide function pointer type, such a problem might be allowed. This is similar to the [[#design-capture.functions-footgun.reference]]. A special carveout in the specification for the return value case could be developed, but this would need work to avoid precluding useful cases.



## Lambdas ## {#design-lambdas}

Lambdas are simply a reskinned version of Capture Functions. They have all the same functionality, but with the benefits that they are:

- expressions, and therefore can be used in-line in a function call as an argument or as part of an argument;
- expressions, and therefore can be immediately invoked;
- and, C++-compatible in their design.

We are deliberately leaving these as the only three benefits of lambdas over Capture Functions for the sole reason that, after Capture Functions, Lambdas will be VERY minimal effort to support. The reason for that is that they are, semantically, just a "Syntactic Reskin" of Capture Functions, save for their presence as an expression.

```cpp
auto make_seven (int x) {
	int y = 7;
	return [x, y]() { return x * y; };
}

int main () {
	int x = 3;
	auto zero = [] () {
		// OK, no external variables used
		return 0;
	};
#if 0
	auto double_it = [] () {
		return x * 2; // constraint violation
	};
#endif
	auto triple_it = [x] () {
		return x * 3; // OK, x = 3 when called
	};
	auto quadruple_it = [&x] () {
		return x * 4; // OK, x = 5 when called
	};
	auto quintuple_it = [=] () {
		return x * 5; // OK, x = 3 when called
	};
	auto sextuple_it = [&] () {
		return x * 6; // OK, x = 5 when caled
	};
	x = 5;
	auto seven_tuple_it = make_seven(x);
	return zero() + triple_it() + quadruple_it()
		+ quintuple_it() + sextuple_it() + seven_tuple_it();
	// return 109;
	// 0 + (3 * 3) + (5 * 4)
	// + (3 * 5) + (5 * 6)
	// + (5 * 7)
}
```

Given this, there is nothing else to write for this section: all of the benefits of Capture Functions ([[#design-capture.functions]]) applies to these types in full, and just copying all of that text from one to another to say exactly the same thing is not important. We will instead just talk about the differences exclusively in comparison to Capture Functions in the next few sections.


### Lambdas are Expressions ### {#design-lambdas-expressions}

```cpp
#include <stdlib.h>
#include <string.h>
#include <stddef.h>

static int in_reverse = 0;

int main(int argc, char* argv[]) {
	if (argc > 1) {
		char* r_loc = strchr(argv[1], 'r');
		if (r_loc != NULL) {
			ptrdiff_t r_from_start = (r_loc - argv[1]);
			if (r_from_start == 1 && argv[1][0] == '-' && strlen(r_loc) == 1) {
				in_reverse = 1;
			} 
		}
	}
	int list[] = { 2, 11, 32, 49, 57, 20, 110, 203 };
	qsort(list, (sizeof(list)/sizeof(*list)), sizeof(*list),
		// expression, fits in-line
		[](const void* untyped_left, const void* untyped_right) {
			const int* left = (const int*)untyped_left;
			const int* right = (const int*)untyped_right;
			return (in_reverse) ? *right - *left : *left - *right;
		}
	);
	
	return list[0];
}
```

This also makes it **suitable for use in macros**, which is not something a regular Capture Functions can accomplish.

NOTE: This can be alleviated by using Statement Expressions, which would allow Capture Functions to work within typical macro contexts.


### Recursion Is Impossible ### {#design-lambdas-recursion}

Unfortunately, it is impossible to call a lambda from within itself (not without C++'s feature "deducing this", which requires templates and other things to work), and therefore that is another disadvantage. It can be fixed with the proposed `__self_func` feature ([[__self_func]]):

```cpp
int main () {
	int tripling (int times, int start) {
		if (times >= 5) {
			return start;
		}
		return __self_func(times + 1, start * 3); // __self_func feature
	}
	return tripling(0, 1);
}
```


### Trailing Return Types / Deduced Return Type ### {#design-lambdas-returns}

Finally, one may need to add the concept of a "trailing return type" to C in order to allow modifying the return type of a lambda. At the moment, the way a lambda with no specified return type works is that every single `return` statement must have exactly the same type (there is no negotiation for some "promoted" type or similar). That is, returning a `long` in one branch and an `int` in another branch is an error: they all must be cast to `int` or they all must be cast to `long`:

```cpp
int main () {
	auto okay0 = []() {
		if (1) {
			return 0;
		}
		else {
			return 0;
		}
	}(); // ok
	auto violation0 = []() {
		if (1) {
			return 0U;
		}
		else {
			return 0L;
		}
	}(); // constraint violation: different return types
	auto okay1 = []() {
		if (1) {
			return (unsigned long long)0U;
		}
		else {
			return (unsigned long long)0L;
		}
	}(); // ok: cast to identical types
	return 0;
}
```

This can be **extremely** annoying to deal with. Trailing return types fix this problem by allowing lambdas to use a trailing `-> type-name` to have the function return type become `type-name`:

```cpp
int main () {
	auto okay0 = []() {
		if (1) {
			return 0;
		}
		else {
			return 0;
		}
	}(); // ok
	auto violation0 = []() -> unsigned int {
		if (1) {
			return 0U;
		}
		else {
			return 0L;
		}
	}(); // now okay: fixed return type, conversions happen normally
	auto okay1 = []() {
		if (1) {
			return (unsigned long long)0U;
		}
		else {
			return (unsigned long long)0L;
		}
	}(); // ok: cast to identical types
	return 0;
}
```

This fixes other problems in the C language as well, such as not being able to specify functions with proper variable-length array returns without using ugly syntax. The `auto` part only applies for regular function definitions, and could also be applied to Capture Functions for ease-of-use (but is not required for it to function appropriately). One could also just have `auto` but no `->` to have regular functions achieve the lambda behavior, where all `return` expressions must evaluate to the exact same type. Not having a `return` or having a `return;` both imply the return type is `void`, and thus any other kind of `return <expr>;` in that function would be illegal.


### Forward-declaration is Impossible ### {#design-lambdas-forward.decls}

It is impossible to forward-declare a lambda given the fact that every lambda is a definition of a unique object as an expression and does not do the usual declaration/definition split. Implementations may fold identical lambdas together but that is only observable as an optimization, and is not a guarantee of the design. This contrasts with Capture Functions, wherein they can be declared (with all of their captures) under a specific identifier in a specific scope and reserve that identifier for that type, and then later defined in that scope or a dependent scope.


That is the full set of notable technical differences between Lambdas and Capture Functions.



## Measuring Solution Spaces ## {#design-benchmarks}

One of the ways we can increase the confidence we have in our data is to provide benchmarks for the things we are working on proposing to the C standard. We do not mind adding new and improved functionality to the benchmarks to do more measurements it is an open set and we would appreciate any help in benchmarking or measuring or coming up with new ways to observe behavior.


### Donald Knuth's Man or Boy Test ### {#design-benchmarks-manorboy}

This is a set of benchmarks using Donald Knuth's Man or Boy program, which tests self-references and recursion in the same function / closure object. It also flexes a number of properties that can evaluate the quality of a closure implementation, and so is suitable as a microbenchmark. Both a linear version and a logarithmic version of the graphs are made available due to how the performance differences skew things wildly in one direction or another. The benchmark's source code is available in the ztd.idk repository ([[ztd-idk-closures-benchmark]]).

#### Methodology #### {#design-benchmarks-manorboy-methodology}

The tests were ran on a 13-inch 2020 MacBook Pro M1. It has 16 GB of RAM and is on MacOS 15.7.2 Sequoia at the time the test was taken, using the stock MacOS AppleClang Compiler and the stock brew install gcc compiler in order to produce the numbers seen on December 28<sup>th</sup>, 2025.

The experimental setup used the Man or Boy test, but with the given `k` value loaded by calling a function in a DLL / Shared Object. The expected `k` value that the Man or Boy test is supposed to yield is also loaded from a DLL / Shared Object. This prevents optimizing out all recursion and doing enough ahead-of-time computation to simply collapse the benchmarked code into a constant-time, translation-time calculation. It ensures the benchmark is actually measuring the actual performance characteristics of the technique used, as all of them are computing from the same initial `k` value and all of them are expected to produce the same `expected_k` answer.

There 2 measures being conducted: Real ("wall clock") Time and CPU Time. The time is gathered by running a single iteration of the code within a `for` loop. That loop runs anywhere from a couple thousand to hundreds of thousands of times to produce confidence in that run of the benchmark, and each loop run is considered an individual iteration. The iterations are then averaged to produce the first point after there is confidence that the measurement is accurate and the benchmark is warm. The iteration process to produce a single mean was then repeated 150 times. All 150 means are used as the points for the values (shown as transparent dots) on the bar graph, and the average of all of those 150 means is then used as the height of a bar in a bar graph.

The bars are presented side-by-side as a horizontal bar chart with various categories of C or C++ code being measured. The 13 total categories of C and C++ code are:

- no-op: Literally doing nothing. It’s just there to test environmental noise and make sure none of our benchmarks are so off-base that we’re measuring noise rather than computation. Helps keep us grounded in reality.
- Normal Functions: regular C functions which add an extra argument to the function call in order to pass more data. Somewhat similar in representation to rewriting `qsort` to `qsort_r`/`qsort_s` to pass a user data pointer.
- Normal Functions (Rosetta Code): regular C functions which add an extra argument to the function call in order to pass more data. Taken directly from the Rosetta Code weekly, and uses a pointer `int* k` to refer to an already-existing value of `k` during a series of recursive calls.
- Normal Functions (Static): regular C function which uses a static variable to pass the specific context to the next function. Not thread safe.
- Normal Functions (Thread Local): same as "Normal Functions (Static)" but using a `thread_local` variable instead of a `static` variable. Obviously thread safe.
- Lambdas (No Function Helpers): a solution using C++-style lambdas. Rather than using helper functions like `f0`, `f1`, and `f_1`, we compute a raw lambda that stores the value meant to be returned for the Man-or-Boy test (with a body of just `return i;`) in the lambda itself and then pass that uniquely-typed lambda to the core of the test. The entire test is templated and uses a fake recursion template parameter to halt the translation-time recursion after a certain depth.
- Lambdas: The same as above but actually using `int f0(void)`, etc. helper functions at the start rather than lambdas. Tries to reduce optimizer pressure by using “normal” types which do not add to the generated number of lambda-typed, recursive, templated function calls.
- Lambdas (`std::function_ref`): The same as above, but rather than using a function template to handle each uniquely-typed lambda like a precious baby bird, it instead erases the lambda behind a `std::function_ref<int(void)>`. This allows the recursive function to retain exactly one signature.
- Lambdas (`std::function`): The same as above, but replaces `std::function_ref<int(void)>` with `std::function<int(void)>`. This is an allocating, C++03-style type.
- Lambdas (Rosetta Code): The code straight out of the C++11 Rosetta Code Lambda section on the Man-or-Boy Rosetta Code implementation.
- Apple Blocks: Uses Apple Blocks to implement the test, along with the __block specifier to refer directly to certain variables on the stack.
- GNU Nested Functions (Rosetta Code): The code straight out of the C Rosetta Code section on the Man-or-Boy Rosetta Code implementation.
- GNU Nested Functions: GNU Nested Functions similar to the Rosetta Code implementation, but with some slight modifications in a hope to potentially alleviate some stack pressure if possible by using regular helper functions like `f0`, `f1`, and `f_1`.
- Custom C++ Class: A custom-written C++ class using a discriminated union to decide whether it’s doing a straight function call or attempting to engage in the Man-or-Boy recursion.
- C++03 shared_ptr (Rosetta Code): A C++ class using `std::enable_shared_from_this` and `std::shared_ptr` with a virtual function call to invoke the “right” function call during recursion.

Each bar graph has a black error bar at the end, representing the standard error of the measurements performed. At 150 iterations, the error bars (which are most easily understood and read in the linear graphs) are a decent visual approximation of whether or not two solutions are within a statistical threshold of one another.

The two compilers tested are Apple Clang 17 and GCC 15. There are two graph images for each kind of measurement (linear, logarithmic, and linear-but-with-outliers-removed) because one is for Apple Clang and the other is for GCC. This is particularly important because neither compiler implements the other’s closure extension (Clang does Apple Blocks but not Nested Functions, while GCC does Nested Functions in exclusively its C frontend but does not implement Apple Blocks).

MSVC was not tested because MSVC implements none of the extensions being tested, and we do not expect that its performance characteristics would be wildly different.

#### Results #### {#design-benchmarks-manorboy-results}

The result graphs are as follows, presented in pairs for Apple Clang 17 and GCC 15:

<pre class="include">
path: assets/C - Functions with Data/manorboy-appleclang17-linear.bs
</pre>

<pre class="include">
path: assets/C - Functions with Data/manorboy-gcc15-linear.bs
</pre>

Because some of the checked categories perform so astronomically poorly, we have a version of the graphs that are logarithmic, which are the two following graphs:

<pre class="include">
path: assets/C - Functions with Data/manorboy-appleclang17-logarithmic.bs
</pre>

<pre class="include">
path: assets/C - Functions with Data/manorboy-gcc15-logarithmic.bs
</pre>

This obscures some of the changes in performance because it skews towards big order-of-magnitude differences. To show the differences without the heavy skew due to the extremely poor performance of the bottom two/three categories, we also provide a "focused" graph which eliminates the poor performers and shows the linear performance of the more competitive top 12 performers.

<pre class="include">
path: assets/C - Functions with Data/manorboy-appleclang17-linear-focused.bs
</pre>

<pre class="include">
path: assets/C - Functions with Data/manorboy-gcc15-linear-focused.bs
</pre>

A full writeup is available at [[closures-in-c-benchmark]] and [[closures-in-c-benchmark-followup]] which includes methodology and other information about the tests.

#### Conclusions, Comparisons to Other Proposals, and Inferences #### {#design-benchmarks-manorboy-conclusions}

Note: A wide function pointer type is necessary no matter the solution chosen.

Note: A fixed, statically-known object that can be optionally type-erased behind a Wide Function Pointer seems optimal for even complex usages of closures in C.

Note: Apple Blocks and GNU Nested Functions have intrinsic design flaws that drastically impact their performance, meaning that even transporting a context pointer through a global variable with a normal C function is better.

Note: Manual management of closure pointer-to-function pointer trampolines may produce much better code generation and quality than implementation can currently handle, while allowing the user to have as much or as little security as possible.

In addition to the key takeaways above, some other details we have understood are as follows. C++-style lambdas have the capability to be both awful (Lambdas using the Rosetta Code technique) and powerful (Lambdas with Perfect Type Information). Both of these techniques are unusable as-is in C as the things that make them awful or great are tied not due to lambdas design but moreso how they are used (e.g., `std::function` abstractions or translation-time recursion prevention.) Normal C functions (storing the integer `k` by value) can achieve near-parity with C++-style Lambdas at their best in terms of performance. However, it requires the modification of the function signature, which may not be viable in all cases (such as calling already-compiled interfaces or working with FFI). The use of `static` and `thread_local` to pass information across function boundaries comes with an unshakeable and implicit cost. `thread_local` is -- for obvious reasons -- more expensive than just `static`, but both incur overhead.

After evaluating current industry extensions, we find them to be strangely poorly-performing despite being decades-old in some cases. Apple Blocks ([[apple-blocks]]) and similar heap-based solutions incur a fixed overhead due to the Blocks Runtime scheme, making it unsuitable for resource-constrained C environments. This means it is not worth pursuing this as a long-term solution in our technical opinion. GNU Nested Functions ([[nested-functions]]), as a quirk of its current most popular implementation, really inhibit inlining and other similar optimizations. A different implementation (e.g., the current `-ftrampoline-impl=heap` work that is currently available on 5 platforms in GCC trunk at time-of-writing) could be better. But, the fact that a typical quality of implementation provides such awful performance characteristics compared to every other solution despite being the oldest solution means that they too should be looked at skeptically for direct ISO C standardization. The heap-based trampolines of GNU Nested Functions also look like they may incur a similar fixed overhead just like the Apple Blocks implementation.

The Function Literals and Local Functions ([[n3678]], [[n3679]]) proposals can have their performance approximated in their best-case as following the performance of the series of Normal Functions. This requires modifying the function signature. If the function signature isn't modified, there isn't really a point of comparison in these benchmarks other than falling back to other means of context transportation. All of these solutions vary wildly in performance, from Apple Blocks runtimes to various style of trampolines. This makes it impossible to understand Function Literals and Local Functions as solving the problem at hand, because they provide no plausible forward path on which to judge. Thus, we consider them incomplete.

Accessing the Context of Nested Functions ([[n3654]]), even in its later iterations, approximates either the Normal Functions (can modify the signature, best case) or GNU Nested Functions (([[nested-functions]], [[n2661]])) (creates an invisible trampoline to transport closure context, worst case) performance. We are unsure of how this would continue given the deeply negative impact given access to the current invocation's stack frame / "function environment" is on the optimizer's ability to push for performance. While we think there is potential for this, we believe explicitly or implicitly capturing just the data -- and not the environment or stack frame abstraction itself -- would result in better performance characteristics no matter the design.

Finally, any solution is going to need a Wide Function Pointer type in the C ecosystem to make it usable and worthwhile. In particular, Lambdas with `std::function_ref` is a directly applicable proxy to what "Capture Functions and Wide Function Pointers" and/or "Lambdas and Wide Function Pointers" could bring in terms of worst-case performance to the C ecosystem as a whole.




<pre class="include">
path: C - Functions with Data Wording.bs
</pre>




<pre class="include">
path: C - Functions with Data Appendix.bs
</pre>


<pre class="biblio">
{
	"ztd-idk-closures-benchmark": {
		"authors": [
			"JeanHeyd Meneide"
		],
		"title": "ztd.idk Closures Benchmark",
		"date": "December 28th, 2025",
		"href": "https://github.com/soasis/idk/tree/main/benchmarks/closures"
	},
	"closures-in-c-benchmark": {
		"authors": [
			"JeanHeyd Meneide"
		],
		"title": "The Cost of a Closure in C",
		"date": "December 10th, 2025",
		"href": "https://thephd.dev/the-cost-of-a-closure-in-c-c2y"
	},
	"closures-in-c-benchmark-followup": {
		"authors": [
			"JeanHeyd Meneide"
		],
		"title": "The Cost of a Closure in C",
		"date": "December 28th, 2025",
		"href": "https://thephd.dev/the-cost-of-a-closure-in-c-c2y-followup"
	},
	"_Any_func": {
		"authors": [
			"JeanHeyd Meneide",
			"Shepherd (Shepherd's Oasis)"
		],
		"title": "_Any_func - A Universal Function Pointer Storage Type",
		"date": "July 6th, 2025",
		"href": "https://thephd.dev/_vendor/future_cxx/papers/C%20-%20_Any_func.html"
	},
	"builtin_call_with_static_chain_gcc": {
		"authors": [
			"GNU Compiler Collection Contributors",
			"Free Software Foundation"
		],
		"title": "GCC Online Documentation: Constructing Calls",
		"date": "May 3rd, 2025",
		"href": "https://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html#index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain"
	},
	"nested-functions": {
		"authors": [
			"GNU Compiler Collection Contributors"
		],
		"title": "Nested Functions (Using the GNU Compiler Collection (GCC))",
		"date": "May 3rd, 2025",
		"href": "https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html"
	},
	"n2661": {
		"authors": [
			"Martin Uecker"
		],
		"title": "n2661: Nested Functions",
		"date": "February 13th, 2021",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2661.pdf"
	},
	"n3654": {
		"authors": [
			"Martin Uecker"
		],
		"title": "n3654: Accessing the Context of Nested Functions",
		"date": "July 20th, 2025",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3654.pdf"
	},
	"apple-blocks": {
		"authors": [
			"Apple & Contributors"
		],
		"title": "Documentation Archive: Declaring and Creating Blocks",
		"date": "May 3rd, 2025",
		"href": "https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/bxDeclaringCreating.html#//apple_ref/doc/uid/TP40007502-CH4-SW1"
	},
	"n1370": {
		"authors": [
			"Blaine Garst",
			"Apple, Inc."
		],
		"title": "n1370: Apple Extensions to C",
		"date": "March 10th, 2009",
		"href": "https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1370.pdf"
	},
	"n1451": {
		"authors": [
			"Blaine Garst",
			"Apple"
		],
		"title": "n1451: Blocks Proposal",
		"date": "April 13th, 2010",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1451.pdf"
	},
	"n1457": {
		"authors": [
			"Blaine Garst",
			"Apple"
		],
		"title": "n1457: Blocks",
		"date": "April 20th, 2010",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1457.pdf"
	},
	"n2030": {
		"authors": [
			"Blaine Garst"
		],
		"title": "n2030: A Closure for C",
		"date": "March 11th, 2016",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2030.pdf"
	},
	"clang-blocks-spec": {
		"authors": [
			"The Clang Team",
			"LLVM and Contributors",
			"Apple"
		],
		"title": "Clang + LLVM (Latest): Block Implementation Specification",
		"date": "July 8th, 2025",
		"href": "https://clang.llvm.org/docs/Block-ABI-Apple.html"
	},
	"swift-escapes": {
		"authors": [
			"Swift Development Team and Contributors",
			"Apple"
		],
		"title": "The Swift Programming Language: Closures",
		"date": "July 6th, 2025",
		"href": "https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures/#Escaping-Closures"
	},
	"objective-c-block-trampoline": {
		"authors": [
			"Objective-C Development Team and Contributors",
			"Apple"
		],
		"title": "Objective-C Runtime / imp_implementationWithBlock ",
		"date": "July 17th, 2025",
		"href": "https://developer.apple.com/documentation/objectivec/imp_implementationwithblock(_:)?language=objc"
	},
	"n2862": {
		"authors": [
			"Martin Uecker",
			"Jens Gustedt"
		],
		"title": "n2862: Wide Function Pointer Types for Pairing Code and Data ",
		"date": "November 30th, 2021",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2862.pdf"
	},
	"n1229": {
		"authors" : [
			"Nick Stoughton"
		],
		"title": "Potential Extensions For Inclusion In a Revision of ISO/IEC 9899",
		"date": "March 26th, 2007",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1229.pdf"
	},
	"transparent-aliases": {
		"authors" : [
			"JeanHeyd Meneide",
			"Shepherd (Shepherd's Oasis, LLC)"
		],
		"title": "Transparent Aliases",
		"date": "February 20th, 2025",
		"href": "https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Transparent%20Aliases.html"
	},
	"n2923": {
		"authors" : [
			"Jens Gustedt"
		],
		"title": "Type inference for variable definitions and function returns",
		"date": "January 30th, 2022",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2923.pdf"
	},
	"n2924": {
		"authors" : [
			"Jens Gustedt"
		],
		"title": "Type-generic Lambdas",
		"date": "January 30th, 2022",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2924.pdf"
	},
	"n2892": {
		"authors" : [
			"Jens Gustedt"
		],
		"title": "Basic lambdas for C",
		"date": "December 25th, 2021",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2892.pdf"
	},
	"n2893": {
		"authors" : [
			"Jens Gustedt"
		],
		"title": "Options for Lambdas",
		"date": "December 25th, 2021",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2893.htm"
	},
	"lambdas-nested-functions-block-expressions-oh-my": {
		"authors" : [
			"JeanHeyd Meneide"
		],
		"title": "Lambdas, Nested Functions, and Blocks, oh my!",
		"date": "July 16th, 2021",
		"href": "https://thephd.dev/lambdas-nested-functions-block-expressions-oh-my"
	},
	"gamingonlinux-dawe": {
		"authors": [
			"Liam Dawe"
		],
		"title": "The glibc 2.41 update has been causing problems for Linux gaming",
		"date": "February 13th, 2025",
		"href": "https://www.gamingonlinux.com/2025/02/the-glibc-2-41-update-has-been-causing-problems-for-linux-gaming/"
	},
	"wsl-no-executable-stack": {
		"authors": [
			"Microsoft",
			"WSL Authors and Contributors",
			"Martin Uecker"
		],
		"title": "fis-gtm does not run due to missing support for executable stack",
		"date": "August 7th, 2018",
		"href": "https://github.com/Microsoft/WSL/issues/286"
	},
	"solar-non-executable-stack-exploits": {
		"authors": [
			"solar FALSE COM (Solar Designer)"
		],
		"title": "Getting around non-executable stack (and fix)",
		"date": "August 10th, 1997",
		"href": "https://seclists.org/bugtraq/1997/Aug/63"
	},
	"n3678": {
		"authors": [
			"Thiago R. Adams"
		],
		"title": "Local Functions",
		"date": "September 30th, 2025",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3678.pdf"
	},
	"n3679": {
		"authors": [
			"Thiago R. Adams"
		],
		"title": "Function Literals",
		"date": "September 30th, 2025",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3679.pdf"
	},
	"n3643": {
		"authors": [
			"Jakub Łukasiewicz"
		],
		"title": "n3643: Statement Expressions (draft)",
		"date": "July 10th, 2025",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3643.htm"
	},
	"__self_func": {
		"authors": [
			"JeanHeyd Meneide",
			"Shepherd (Shepherd's Oasis, LLC)"
		],
		"title": "__self_func",
		"date": "February 11th, 2025",
		"href": "https://thephd.dev/_vendor/future_cxx/papers/C%20-%20__self_func.html"
	},
	"thread-attributes": {
		"authors": [
			"JeanHeyd Meneide",
			"Shepherd (Shepherd's Oasis, LLC)"
		],
		"title": "Thread Attributes - Implementation Extensible and ABI-Resistant",
		"date": "July 6th, 2025",
		"href": "https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Thread%20Attributes%20-%20Implementation%20Extensible%20and%20ABI-Resistant.html"
	}
}
</pre>
