<pre class='metadata'>
Title: Functions with Data - Closures in C (A Comprehensive Proposal Overviewing Blocks, Nested Functions, and Lambdas)
Shortname: 3780
Revision: 2
!Previous Revisions: <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3694.htm">n3694 (r1)</a>, <a href="https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3657.htm">n3657</a>
Status: P
Date: 2026-01-13
Group: WG14
!Proposal Category: Change Request, Feature Request  
!Target: C2y
Editor: JeanHeyd Meneide, phdofthehouse@gmail.com
Editor: Shepherd (Shepherd's Oasis LLC), shepherd@soasis.org
URL: https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Functions%20with%20Data%20-%20Closures%20in%20C.html
!Paper Source: <a href="https://thephd.dev/_vendor/future_cxx/papers/source/C%20-%20Functions%20with%20Data%20-%20Closures%20in%20C.bs">GitHub</a>
Issue Tracking: GitHub https://github.com/ThePhD/future_cxx/issues
Metadata Order: Previous Revisions, Editor, This Version, Paper Source, Implementation, Issue Tracking, Project, Audience, Proposal Category, Target
Markup Shorthands: markdown yes
Toggle Diffs: no
Abstract: Nested Functions (GCC), Blocks (Clang & Apple-derived compilers), Wide Function Pointers (Borland and existing C library functions), and Lambdas (C++) provide a series of takes on how to, effectively, bundle functions with data in different ways and transport that information to the caller. This proposal goes through the existing practice and enumerates their tradeoffs so as to propose the best possible solution to the problem space in C, prioritizing C-like syntax and avoiding pitfalls from the existing solutions.
</pre>

<pre class="include-raw">
path: resources/css/bikeshed-wording.html
</pre>

<div class="pagebreak"></div>




# Changelog # {#changelog}



## Revision 2 - January 13<sup>th</sup>, 2026 ## {#changelog-r2}

- Talk more directly about `__builtin_call_with_static_chain`, which is sometimes used to call Go-style functions from C [[#intro-static.chain]].
- Add benchmarks for various existing Closures solutions from the Man or Boy test into [[#benchmarks]]. Discusses performance and design impacts thorough for the Man or Boy tests and how it relates to other proposals in the conclusions section ([[#benchmarks-conclusions]]).
- Talk about how type names and non-identified declarators are silly for Capture Functions ([[#design-capture.functions-forward.decls.silly]]).


## Revision 1 - October 6<sup>th</sup>, 2025 ## {#changelog-r1}

- Integrate `__self_func` ([[__self_func]]) into this paper. Hopefully the reasoning for this is self-evident and nobody asks me justify the obvious in this version of the proposal.
- Comment on Function Literals / Local Functions in [[#intro-function.literals]].
- Initial wording. ✨
	- There is no wording for 6.7.3.4 "Tags" because the type is not accessible from the declarator; the type is generated by the implementation and the entire apparatus of declaration types is covered under the existing rules for declarations of the same identifier, same as they are for functions in a way.
	- There is currently a constraint on accessing a capture function's members with `.` and `->` if there is no definition available at that point. This makes it easier to prevent accessing a value at the wrong time. However, it might not be elegant or useful enough in certain situations. This is paired with [[#design-capture.functions-forward.decls]].
	- Unfortunately, the wording is effectively a major surgery to parts of the standard to enable an elegant use. The good news is that it will enable using a "wide function pointer type" easily by just stating it is an invocable type and, particularly, a closure type. Even if we never accept Capture Functions or Lambdas, this is a useful rewrite of the core part of how functions/callables work.
	- There is no Clause 7 wording. This will explicitly be a separate paper.


## Revision 0 - July 24<sup>th</sup>, 2025 ## {#changelog-r0}

- Initial release. ✨
- This paper has no wording. It is not fit for standardization at the moment and only tries to thoroughly discuss the motivation and design behind this work.




<pre class="include">
path: C - Functions with Data - Closures in C - Introduction.bs
</pre>




# Design # {#design}

Given the following properties from all of the extensions and proposals for this in the wild:

<table class="basic"><thead>
<tr>
<th>Feature</th>
<th>GNU Nested Functions</th>
<th>Apple Blocks</th>
<th>C++-Style Lambdas in C</th>
<th>Function Literals</th>
<th>Local Functions</th>
</tr></thead>
<tbody>
<tr>
<td>Capture By-Name</td>
<td>✅<br>(default, use-based)</td>
<td>✅<br>(`__block ident;`)</td>
<td>✅<br>(`[&]`, `[&ident]`)</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>Capture By-Value</td>
<td>❌</td>
<td>✅<br>(default, use-based)</td>
<td>✅<br>(`[=]`, `[ident]`)</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>Selective Capture</td>
<td>❌<br>(use-based, by-name only)</td>
<td>✅<br>(for by-name)<br>❌<br>(for by-value, use-based)</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>Safe to Return Closure</td>
<td>❌</td>
<td>⚠️<br>(requires `Block_copy`)</td>
<td>✅</td>
<td>✅<br>(never unsafe)</td>
<td>✅<br>(never unsafe)</td>
</tr>
<tr>
<td>Relocatable to Heap<br>(Lifetime Management)</td>
<td>❌</td>
<td>✅<br>(`Block_copy`/`Block_release`)</td>
<td>✅<br>(`malloc`/`memcpy`/`free`)</td>
<td>✅<br>(not needed)</td>
<td>✅<br>(not needed)</td>
</tr>
<tr>
<td>Usable Directly as Expression</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>Forward-Declarable</td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Immediately Invokable</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>Convertible to Function Pointer</td>
<td>✅</td>
<td>❌</td>
<td>⚠️<br>(only capture-less)</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Convertible to "Wide" Function Type</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Access to Non-Erased Object/Type</td>
<td>❌<br>((wide) function pointer only)</td>
<td>❌<br>(Block type/wide function pointer only)</td>
<td>✅<br>(unique type/size)</td>
<td>❌<br>(no object to access)</td>
<td>❌</td>
</tr>
<tr>
<td>Access to Captures through Object/Type</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>Recursion Possible</td>
<td>✅<br>(use the identifier of the nested function)</td>
<td>❌<br>(`__self_func` required)</td>
<td>❌<br>(`__self_func` required)</td>
<td>❌<br>(`__self_func` required)</td>
<td>✅<br>(use the identifier of the local function)</td>
</tr>
</tbody></table>

This proposal is going to propose two distinct options for standardization, with the recommendation to do both. It is critical to do both for the approval of the C ecosystem in general (with [[#design-capture.functions]]), and for  the maximum amount of external language compatibility (C++ in particular, with [[#design-lambdas]]). The necessary and core goals of this proposal are focused on

- compile-time knowable size of the function object (can be treated as a regular object);
- that has a unique type with its own size;
- does not require a heap or a special stack (unless type-erased or otherwise relocated by (explicit) user action);
- can be interacted with like a normal function (but not necessarily as a normal function pointer);
- and, does not compromise the security of all or a portion of the program.

Lambdas already have usage experience with well-known properties that can be directly translated to C and is easy enough to understand, despite the unfortunate syntax. Capture Functions are a simple modification of Nested Functions that produce a sized object (similar to Lambdas) and makes their captures explicit, allowing for a degree of control and additional safety that was not present in the original Nested Functions design.

We are **not** focused on interoperability with singular function pointers. We believe that should be left to a separate, explicit mechanism in the language, capable of allowing the user to choose where the memory comes from and setting it up appropriately. This way, a user can make the decision **on their own** if they want to use e.g. executable stack (with the consequences that it brings) or just have a part of (heap) memory they set with e.g. Linux `mprotect(...)` or Win32 `VirtualProtect` to be readable, writable, and executable. Such a trampoline-maker (as briefly talked about in [[#appendix-make.trampoline]]) can also be applied across implementations in a way that the secret sauce powering Nested Functions cannot be: this is much more appealing as an approach.

We **DO NOT** take any of the design from Blocks because the Blocks design is, as a whole, unsuitable for C. While its deployment of a blocks "type" to fulfill the necessary notion of a "wide function pointer" type is superior to what Nested Functions have produced, the implementation details it imposes for `__block` variables and the excessive reliance on an (underspecified) runtime/heap are detrimental to a shared & unified approach to C.

NOTE: The Blocks runtime/heap layout has changed (at least) once in its history: the only reason this worked is because Apple owned every part of the Blocks ecosystem. Apple can do whatever they want with it, however they want, whenever they want: this does not work in a language with diverse, loosely coordinated implementations like C and not Objective-C, Objective-C++, or Swift.

As the heap is (typically) repulsive to some freestanding implementations, we do not want to standardize something that will have similar technological drawbacks like VLAs, where -- even if no syntactical or language-design issues exist from the way blocks are written -- the presence of an unspecified source of memory (stack or heap) produces uncertainty in the final code generation of a program.

The feature table for these two looks like this:

<table class="basic"><thead>
<tr>
<th>Feature</th>
<th>C Lambdas</th>
<th>Capture Functions</th>
</tr></thead>
<tbody>
<tr>
<td>Capture By-Name</td>
<td>✅ (`[&]`, `[&ident]`)</td>
<td>✅ (`_Capture(&)`, `_Capture(&ident)`)</td>
</tr>
<tr>
<td>Capture By-Value</td>
<td>✅ (`[=]`, `[ident]`)</td>
<td>✅ (`_Capture(=)`, `_Capture(ident)`)</td>
</tr>
<tr>
<td>Selective Capture</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Safe to Return Closure</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Relocatable to Heap<br>(Lifetime Management)</td>
<td>✅ (`malloc`/`memcpy`/`free`)</td>
<td>✅ (`malloc`/`memcpy`/`free`)<br></td>
</tr>
<tr>
<td>Usable Directly as Expression</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>Forward-Declarable</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Immediately Invokable</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Convertible to Function Pointer</td>
<td>⚠️<br>(only capture-less)</td>
<td>⚠️<br>(only capture-less)</td>
</tr>
<tr>
<td>Convertible to "Wide" Function Type</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Access to Non-Erased Object/Type</td>
<td>✅<br>(unique type/size)</td>
<td>✅<br>(unique type/size)</td>
</tr>
<tr>
<td>Access to Captures through Object/Type</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Recursion Possible</td>
<td>❌<br>(`__self_func` required)</td>
<td>✅</td>
</tr>
</tbody></table>



## What is NOT Being Proposed! ## {#design-no}

While we would like to standardize them in the future, this proposal is NOT looking to standardize statement expressions, a "make trampoline" compiler intrinsic, or a wide function pointer type.


### Statement Expressions? ### {#design-no-statement.expressions}

Statement Expressions should be standardized. While it is related to these efforts, it is entirely separate and has a full, robust set of constraints and concerns in standardizing. It has more existing implementation experience, deployment experience, and implementer practice than any of Blocks or Nested Functions combined. Therefore, it will be pursued in a different proposal. This was briefly noted in a proposal collecting existing extensions in 2007 by Stoughton ([[n1229]]); while there was enthusiastic support at the time, nothing materialized of the mention nor the in-meeting enthusiasm. Some attempts are being made at standardizing it, but it is notably difficult to standardize due to the large number of corner cases that arise from needing to clarify semantics of constructs that normally cannot appear in certain places being able to suddenly appear there, like a `break;` being placed in the initializer expression of a `for` loop.

Another advantage of Statement Expressions is that, unlike any of Apple Blocks / C++ Lambdas / GNU Nested Functions, there is no separating function body. This is critical for writing macros that coordinate with one another, AND is critical in writing reusable macros that have no additional cost and does not set up extra individual entry points. For example, there are hundreds of permutations of the functions in C2y's `<stdmchar.h>` that could be written to make them easier to use, to make them not require double-pointers, to infer the size from a C-style string, and so on, and so forth. The choice of having a bunch of macros which simply repeat the same code means not having to add hundreds of permutations of the `<stdmchar.h>` functions (5 different character types across 5 different encoding types with 6 forms of "pointer and length, just pointer" for input/output, and typical skip/ignore/replace-character error handling strategies, pairwise with one another where order matters).

Another place that statement expressions come in handy is with `RESULT`/`TRY`/etc. macros, primarily used for low-level code where handling (and possibly enforcing error handling) is desirable through error codes and return types, as demonstrated [by jade and lak here: https://gist.github.com/LAK132/0d264549745e8196df1e632d5b518c37](https://gist.github.com/LAK132/0d264549745e8196df1e632d5b518c37). Being able to error and jump out or error and stop if things do not work is a very common (and powerful) idiom for writing straightforward code, and is employed heavily in many different ways across the C ecosystem in various forms.

This paper does not standardize Statement Expressions, and leaves that to a future paper similar to n3643 ([[n3643]]).



### Wide Function Pointer Type? ### {#design-no-wide.function.pointer}

We do hope that another paper creates a new "Wide Function Pointer" type of some kind. Some suggestions can be found in [[#appendix-wide.function.pointer]].



<pre class="include">
path: C - Functions with Data - Closures in C - Design Capture Functions.bs
</pre>



<pre class="include">
path: C - Functions with Data - Closures in C - Design Lambdas.bs
</pre>



## Capture Functions and Lambdas are Complete Objects ## {#design-complete.objects}

The most important change from typical GNU Nested Functions and mirroring behavior from C++ Lambdas is that capture functions and these C-style lambdas -- the identifier itself introduced by the definition of the function -- is a regular, normal, complete C object. This enables it to be:

- returned, if the type is knowable at the time of function definition (or `auto` return types are incorporated into the language);
- passed to a function, if the function is defined after the creation of the capture functions;
- and, stored elsewhere through static/`_Thread_local` data with assignment or `memcpy`, or even on the heap.

These are important qualities to allow these functions with data to be used with asynchronous code, as (stored) callbacks, and in other scenarios. The size and alignment of the object is implementation-defined, and its layout is also entirely implementation-defined, much like the properties of a regular `struct` or `union` type. This allows implementations to not have to figure out how to squash everything into a single erased type, and instead enforce the Single Responsibility Principle; they already know how to create unique types, they already know how to create and fill structure types, and now separately a wide function pointer type or a "make trampoline" compiler feature ([[#appendix-make.trampoline]]) can be developed.

Given an extremely simple example:

```cpp
#include <stdlib.h>
#include <stdio.h>

typedef void work_fn_t(void* user);
void add_work(work_fn_t* work, void* user);
bool work_done();

void kickoff(int start, int limit) {
	void work() _Capture(start, limit) {
		printf("doing work for %d to %d\n", start, limit);
		for (int i = start; i < limit; ++i) {
			printf("sooo much work - %d\n", i);
		}
	}
	void work_trampoline(void* user) {
		(*((typeof(work)*)user))()
		// free lambda after work is done
		free(user);
	};
	// elevate to higher lifetime to survive async function call time
	void* work_ptr = malloc(sizeof(work));
	memcpy(work_ptr, &work, sizeof(work));
	add_work(work_trampoline, work_ptr);
}

int main (int argc, char* argv[]) {
	int start = 0;
	int limit = 30;
	if (argc > 1)
		start = atoi(argv[1]);
	if (argc > 2)
		limit = atoi(argv[2]);

	kickoff(start, limit);

	while (!work_done());
	// no memory leaks at the end of the program
	return 0;
}
```

There are caveats about this, but they are related to forward declarations ([[#design-capture.functions-forward.decls]]).



## Mutability Problem ## {#design-mutability}

This proposal does not address the mutability issue of all captures being `const`-by-default. That required a new keyword in C++, `mutable`, to be applied to the lambda to allow captures to be modified by the function call. Another alternative is allowing type specifiers / qualifiers on the storage of these types, where `mutable` can be applied to allow for that specific capture to be updated as well as used.

We have not chosen a direction for this paper yet. This is something we can talk about in focused WG14 discussion, but the current attitude is to simply not bother until WG14 picks up the `mutable` keyword for the same reasons `mutable` exists in C++, which is to update certain parts of an e.g. `struct cache_t` type that is morally and spiritually `const` but has an internal field that needs to be updated to save computation for specific problems.



## `restrict` Problem ## {#design-restrict}

Similar to the [[#design-mutability]] issue, `restrict` cannot be added to individual captures. This means that pointers may lose the ability to assert they are not aliasing anything when copied into the captured structure.

NOTE: While this applies to essentially all qualifiers lost by l-value conversion, `_Atomic` as a qualifier does not mean the same thing, and therefore is safe from this problem.

We think the proper direction here would follow the same path as the ability to use `mutable`. A solution devised for that will cover this space as well; the ability to use type specifiers, qualifiers, and more on captures or the closure function/object type itself would solve many of these issues, and we think it is a worthwhile endeavor. But, such a change deviates from how captures work in existing practice, and therefore will not be directly added to the proposal until discussion is had.



## Not `constexpr` Capable ## {#design-constexpr}

The lambdas and capture functions here cannot be used to compute translation-time (compile-time) values. This is something to be explored only after further advancements of the Generalized Function Calls / `constexpr` Technical Specification ([[constexpr-functions-ts]]). It is alright if this is not `constexpr` at the moment, because no C functions can be `constexpr`. Whatever rules for `constexpr` functions appear from the TS, we would likely incorporate here by allowing the addition of a `constexpr` specifier for the closure's function type.




<pre class="include">
path: C - Functions with Data - Closures in C - Benchmarks.bs
</pre>




<pre class="include">
path: C - Functions with Data - Closures in C - Wording.bs
</pre>




<pre class="include">
path: C - Functions with Data - Closures in C - Appendix.bs
</pre>

<pre class="biblio">
{
	"ztd-idk-closures-benchmark": {
		"authors": [
			"JeanHeyd Meneide"
		],
		"title": "ztd.idk Closures Benchmark",
		"date": "December 28th, 2025",
		"href": "https://github.com/soasis/idk/tree/main/benchmarks/closures"
	},
	"closures-in-c-benchmark": {
		"authors": [
			"JeanHeyd Meneide"
		],
		"title": "The Cost of a Closure in C",
		"date": "December 10th, 2025",
		"href": "https://thephd.dev/the-cost-of-a-closure-in-c-c2y"
	},
	"closures-in-c-benchmark-followup": {
		"authors": [
			"JeanHeyd Meneide"
		],
		"title": "The Cost of a Closure in C, The Rest",
		"date": "December 28th, 2025",
		"href": "https://thephd.dev/the-cost-of-a-closure-in-c-c2y-followup"
	},
	"_Any_func": {
		"authors": [
			"JeanHeyd Meneide",
			"Shepherd (Shepherd's Oasis)"
		],
		"title": "_Any_func - A Universal Function Pointer Storage Type",
		"date": "July 6th, 2025",
		"href": "https://thephd.dev/_vendor/future_cxx/papers/C%20-%20_Any_func.html"
	},
	"builtin_call_with_static_chain_gcc": {
		"authors": [
			"GNU Compiler Collection Contributors",
			"Free Software Foundation"
		],
		"title": "GCC Online Documentation: Constructing Calls",
		"date": "May 3rd, 2025",
		"href": "https://gcc.gnu.org/onlinedocs/gcc/Constructing-Calls.html#index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain"
	},
	"nested-functions": {
		"authors": [
			"GNU Compiler Collection Contributors"
		],
		"title": "Nested Functions (Using the GNU Compiler Collection (GCC))",
		"date": "May 3rd, 2025",
		"href": "https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html"
	},
	"n2661": {
		"authors": [
			"Martin Uecker"
		],
		"title": "n2661: Nested Functions",
		"date": "February 13th, 2021",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2661.pdf"
	},
	"n3654": {
		"authors": [
			"Martin Uecker"
		],
		"title": "n3654: Accessing the Context of Nested Functions",
		"date": "July 20th, 2025",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3654.pdf"
	},
	"apple-blocks": {
		"authors": [
			"Apple & Contributors"
		],
		"title": "Documentation Archive: Declaring and Creating Blocks",
		"date": "May 3rd, 2025",
		"href": "https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/bxDeclaringCreating.html#//apple_ref/doc/uid/TP40007502-CH4-SW1"
	},
	"n1370": {
		"authors": [
			"Blaine Garst",
			"Apple, Inc."
		],
		"title": "n1370: Apple Extensions to C",
		"date": "March 10th, 2009",
		"href": "https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1370.pdf"
	},
	"n1451": {
		"authors": [
			"Blaine Garst",
			"Apple"
		],
		"title": "n1451: Blocks Proposal",
		"date": "April 13th, 2010",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1451.pdf"
	},
	"n1457": {
		"authors": [
			"Blaine Garst",
			"Apple"
		],
		"title": "n1457: Blocks",
		"date": "April 20th, 2010",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1457.pdf"
	},
	"n2030": {
		"authors": [
			"Blaine Garst"
		],
		"title": "n2030: A Closure for C",
		"date": "March 11th, 2016",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2030.pdf"
	},
	"clang-blocks-spec": {
		"authors": [
			"The Clang Team",
			"LLVM and Contributors",
			"Apple"
		],
		"title": "Clang + LLVM (Latest): Block Implementation Specification",
		"date": "July 8th, 2025",
		"href": "https://clang.llvm.org/docs/Block-ABI-Apple.html"
	},
	"swift-escapes": {
		"authors": [
			"Swift Development Team and Contributors",
			"Apple"
		],
		"title": "The Swift Programming Language: Closures",
		"date": "July 6th, 2025",
		"href": "https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures/#Escaping-Closures"
	},
	"objective-c-block-trampoline": {
		"authors": [
			"Objective-C Development Team and Contributors",
			"Apple"
		],
		"title": "Objective-C Runtime / imp_implementationWithBlock ",
		"date": "July 17th, 2025",
		"href": "https://developer.apple.com/documentation/objectivec/imp_implementationwithblock(_:)?language=objc"
	},
	"n2862": {
		"authors": [
			"Martin Uecker",
			"Jens Gustedt"
		],
		"title": "n2862: Wide Function Pointer Types for Pairing Code and Data ",
		"date": "November 30th, 2021",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2862.pdf"
	},
	"n1229": {
		"authors" : [
			"Nick Stoughton"
		],
		"title": "Potential Extensions For Inclusion In a Revision of ISO/IEC 9899",
		"date": "March 26th, 2007",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n1229.pdf"
	},
	"transparent-aliases": {
		"authors" : [
			"JeanHeyd Meneide",
			"Shepherd (Shepherd's Oasis, LLC)"
		],
		"title": "Transparent Aliases",
		"date": "February 20th, 2025",
		"href": "https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Transparent%20Aliases.html"
	},
	"n2923": {
		"authors" : [
			"Jens Gustedt"
		],
		"title": "Type inference for variable definitions and function returns",
		"date": "January 30th, 2022",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2923.pdf"
	},
	"n2924": {
		"authors" : [
			"Jens Gustedt"
		],
		"title": "Type-generic Lambdas",
		"date": "January 30th, 2022",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2924.pdf"
	},
	"n2892": {
		"authors" : [
			"Jens Gustedt"
		],
		"title": "Basic lambdas for C",
		"date": "December 25th, 2021",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2892.pdf"
	},
	"n2893": {
		"authors" : [
			"Jens Gustedt"
		],
		"title": "Options for Lambdas",
		"date": "December 25th, 2021",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n2893.htm"
	},
	"lambdas-nested-functions-block-expressions-oh-my": {
		"authors" : [
			"JeanHeyd Meneide"
		],
		"title": "Lambdas, Nested Functions, and Blocks, oh my!",
		"date": "July 16th, 2021",
		"href": "https://thephd.dev/lambdas-nested-functions-block-expressions-oh-my"
	},
	"gamingonlinux-dawe": {
		"authors": [
			"Liam Dawe"
		],
		"title": "The glibc 2.41 update has been causing problems for Linux gaming",
		"date": "February 13th, 2025",
		"href": "https://www.gamingonlinux.com/2025/02/the-glibc-2-41-update-has-been-causing-problems-for-linux-gaming/"
	},
	"wsl-no-executable-stack": {
		"authors": [
			"Microsoft",
			"WSL Authors and Contributors",
			"Martin Uecker"
		],
		"title": "fis-gtm does not run due to missing support for executable stack",
		"date": "August 7th, 2018",
		"href": "https://github.com/Microsoft/WSL/issues/286"
	},
	"solar-non-executable-stack-exploits": {
		"authors": [
			"solar FALSE COM (Solar Designer)"
		],
		"title": "Getting around non-executable stack (and fix)",
		"date": "August 10th, 1997",
		"href": "https://seclists.org/bugtraq/1997/Aug/63"
	},
	"n3678": {
		"authors": [
			"Thiago R. Adams"
		],
		"title": "Local Functions",
		"date": "September 30th, 2025",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3678.pdf"
	},
	"n3679": {
		"authors": [
			"Thiago R. Adams"
		],
		"title": "Function Literals",
		"date": "September 30th, 2025",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3679.pdf"
	},
	"n3643": {
		"authors": [
			"Jakub Łukasiewicz"
		],
		"title": "n3643: Statement Expressions (draft)",
		"date": "July 10th, 2025",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3643.htm"
	},
	"__self_func": {
		"authors": [
			"JeanHeyd Meneide",
			"Shepherd (Shepherd's Oasis, LLC)"
		],
		"title": "__self_func",
		"date": "February 11th, 2025",
		"href": "https://thephd.dev/_vendor/future_cxx/papers/C%20-%20__self_func.html"
	},
	"thread-attributes": {
		"authors": [
			"JeanHeyd Meneide",
			"Shepherd (Shepherd's Oasis, LLC)"
		],
		"title": "Thread Attributes - Implementation Extensible and ABI-Resistant",
		"date": "July 6th, 2025",
		"href": "https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Thread%20Attributes%20-%20Implementation%20Extensible%20and%20ABI-Resistant.html"
	},
	"constexpr-functions-ts": {
		"authors": [
			"Alexandria Celeste"
		],
		"title": "Programming Languages — C — C Extensions to support generalized function calls",
		"date": "July 6th, 2025",
		"href": "https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3582.pdf"
	}
}
</pre>
