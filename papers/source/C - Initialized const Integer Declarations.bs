<pre class='metadata'>
Title: Integer Constant Expression Initialized const Integer Declarations are Implicitly constexpr
H1: Integer Constant Expression-Initialized <code>const</code> Integer Declarations are Implicitly <code>constexpr</code>
Shortname: XXX1
Revision: 0
!Previous Revisions: None
Status: P
Date: 2024-01-02
Group: WG14
!Proposal Category: Feature Request
!Target: C2y/C3a
Editor: JeanHeyd Meneide (https://thephd.dev), wg14@soasis.org
Editor: Shepherd (Shepherd's Oasis LLC), shepherd@soasis.org
URL: https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Initialized%20const%20Integer%20Declarations.html
!URL: <a href="https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Initialized%20const%20Integer%20Declarations.html">https://thephd.dev/_vendor/future_cxx/papers/C - Initialized const Integer Declarations.html</a>
!Paper Source: <a href="https://thephd.dev/_vendor/future_cxx/papers/source/C%20-%20Initialized%20const%20Integer%20Declarations.bs">GitHub ThePhD/future_cxx</a>
Issue Tracking: GitHub https://github.com/ThePhD/future_cxx/issues
Metadata Order: Previous Revisions, Editor, Latest, Paper Source, Issue Tracking, Project, Audience, Proposal Category, Target
Markup Shorthands: markdown yes
Toggle Diffs: no
Abstract: <code>const</code> integer type declarations initialized with constant expressions have been a fairly important staple of C programs both large and small over the last 30 years. Attempts to make such declarations ineligible as constant expressions and e.g. force an array declared with them to be a Variable-Length Array (VLA) type failed due to overwhelming existing practice in the opposite direction. This proposal therefore swings with said opposite direction now that we have <code>constexpr</code>. It asks that such <code>const</code> integer type declarations that are both declared and initialized in the same statement are implicitly made <code>constexpr</code>, thereby fulfilling the expectations of users.  
</pre>

<pre class="include-raw">
path: resources/css/bikeshed-wording.html
</pre>

<div class="pagebreak"></div>




# Changelog # {#changelog}



## Revision 0 - August 21<sup>st</sup>, 2023 ## {#changelog-r0}

- Initial release üéâ!




# Introduction and Motivation # {#intro}

A common annoyance amongst C developers has been the ephemeral nature of the following code snippet:

```c
int main () {
	const int n = 1 + 2;
	const int a[n];
	return sizeof(a);
}
```

Does this create a VLA type all the time, or is this a valid constant expression that produces a translation time (AKA compile-time) sized array with an extent of `3`? Will `sizeof(a)` be executed at compile-time or will it be run at execution time (AKA run-time) and pull the value from somewhere in the binary? Furthermore, if an implementation defines `__STDC_NO_VLA__`, is this supposed to compile? All of these questions and more revolved around this issue were brought up in [n2713](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2713.htm). n2713 was accepted into C23, and subsequently forced the above code to resolve with `a` being a VLA, even if the implementation could ascertain this was a constant expression and treat it as a constant expression at compile-time. This allowed all implementations to have the same semantic frontend errors and/or warnings, while letting them optimize things as necessary during typical linking and code generation/lowering. (E.g., never using `alloca` with a dynamic value and instead just sizing the stack appropriately to accommodate the array directly for a binary implementation.)

However, during National Body (NB) comment processing, an NB comment pointed out that there was a lot of code relying on the fact that this was being treated -- not just by the backend with its optimizations -- but by the frontend of many compilers to be a plain, compile-time C array. This was formalized in [n3138](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3138.pdf), which presented cases similar to the above. It also presented various other constant expressions to make it clear that there is a wide berth of existing practice beyond just MSVC, GCC, and Clang that accept many additional forms of constant expressions in many different situations. However, the array case remains of very significant impact that affects the most existing code. n3138 promised that a potential future version of C should look into the impact of changing constant expressions one way or another again.

This paper introduces a change for a portion of constant expressions in the opposite direction of N2713, by asking that `const` integer type declarations that are also immediately initialized with an integer constant expression are implicitly declared `constexpr`.





# Prior Art # {#prior}

This is existing practice on a wide variety of compilers both large and small, ranging from SDCC all the way up to much more powerful compilers like ICC (Intel), Clang and GCC. The snippet in [[#intro]] compiles and runs on many implementations with no run-time execution, even on its intentionally-weakest optimization settings (where applicable for a compiler with such settings). It also runs on many implementations even where VLAs are not allowed (e.g. with `__STDC_NO_VLA__` or where `-Wvla` is combined with `-Werror`).

Furthermore, C++ has a similar feature for all `const`-declared integer types. However, rather than modeling this after the C++ wording and C++ feature, we instead focus on solidifying and cleaning up the existing practice of implementation's C mode (for implementations with shared C and C++ modes) and existing purely C compilers. Most importantly, we do not apply the full "manifestly constant evaluated" or "constantly evaluated" powers that C++ has adopted, and instead focus exclusively on what follows from the existing practice of existing C codebases and C implementations.




# Design # {#design}

The design of this feature is such that it requires a declaration that is the first declaration of its kind, without external linkage, and is immediately initialized. It also only applies to declarations whose only qualifier is `const` and, optionally, has `static`, `auto` or `register` for its *storage-class specifiers*. (If the storage-class is already `constexpr`, then this proposal affects no change to the declaration at all.) This means that, under this proposal, of the following declarations:

```cpp
int file_d0 = 1;
_Thread_local int file_d1 = 1;
extern int file_d2;
static int file_d3 = 1;
_Thread_local static int file_d4 = 1;
const int file_d5 = 1;
constexpr int file_d6 = 1;
static const int file_d7 = 1;

int file_d2 = 1;

int main (int argc, char* argv[]) {
	int block_d0 = 1;
	extern int block_d1;
	static int block_d2 = 1;
	_Thread_local static int block_d3 = 1;
	const int block_d4 = 1;
	const int block_d5 = file_d6;
	const int block_d6 = block_d4;
	static const int block_d7 = 1;
	static const int block_d8 = file_d5;
	static const int block_d9 = file_d6;
	constexpr int block_d10 = 1;
	static constexpr int block_d11 = 1;
	int block_d12 = argc;
	const int block_d13 = argc;
	const int block_d14 = block_d0;
	const volatile int block_d15 = 1;

	return 0;
}

int block_d1 = 1;
```

A handful of these declarations become `constexpr`, as indicated by the table below which explains the changes for the above code snippet:

<!--- Data Source:
| Declaration |  `constexpr` Before ? |    `constexpr` After ? | Comment                                                     |
|-------------|-----------------------|-----------------------|--------------------------------------------------------------|
| file_d0     | ‚ùå                    | ‚ùå                   | no change; `extern` implicitly, non-`const`                  |
| file_d1     | ‚ùå                    | ‚ùå                   | no change; `_Thread_local`, `extern` implicitly, non-`const` |
| file_d2     | ‚ùå                    | ‚ùå                   | no change; `extern` explicitly, non-`const`                  |
| file_d3     | ‚ùå                    | ‚ùå                   | no change; non-`const`                                       |
| file_d4     | ‚ùå                    | ‚ùå                   | no change; `_Thread_local`, non-`const`                      |
| file_d5     | ‚ùå                    | ‚ùå                   | no change; `extern` implicitly                               |
| file_d6     | ‚úÖ                    | ‚úÖ                   | no change; `constexpr` explicitly                            |
| file_d7     | ‚ùå                    | ‚úÖ                   | `static` and `const`, initialized by constant expression     |
| block_d0    | ‚ùå                    | ‚ùå                   | no change; non-`const`                                       |
| block_d1    | ‚ùå                    | ‚ùå                   | no change; `extern` explicitly, non-`const`                  |
| block_d2    | ‚ùå                    | ‚ùå                   | no change; non-`const`, `static`                             |
| block_d3    | ‚ùå                    | ‚ùå                   | no change; `_Thread_local`, `static`, non-`const`            |
| block_d4    | ‚ùå                    | ‚úÖ                   | `const`; initialized with literal                            |
| block_d5    | ‚ùå                    | ‚úÖ                   | `const`; initialized with other `constexpr` variable         |
| block_d6    | ‚ùå                    | ‚úÖ                   | `const`, initialized by other constant expression            |
| block_d7    | ‚ùå                    | ‚úÖ                   | `static` and `const`, initialized with literal               |
| block_d8    | ‚ùå                    | ‚ùå                   | no change; non-constant expression initializer               |
| block_d9    | ‚ùå                    | ‚úÖ                   | `static` and `const`, initialized by constant expression     |
| block_d10   | ‚úÖ                    | ‚úÖ                   | no change; `constexpr` explicitly                            |
| block_d11   | ‚úÖ                    | ‚úÖ                   | no change; `constexpr` explicitly                            |
| block_d12   | ‚ùå                    | ‚ùå                   | no change; non-`const`, non-constant expression initializer  |
| block_d13   | ‚ùå                    | ‚ùå                   | no change; non-constant expression initializer               |
| block_d14   | ‚ùå                    | ‚ùå                   | no change; non-constant expression initializer               |
| block_d15   | ‚ùå                    | ‚ùå                   | no change; `volatile`                                        |
--->

<table>
<thead>
<tr>
<th>Declaration</th>
<th>`constexpr` Before ?</th>
<th>`constexpr` After ?</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>file_d0</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; `extern` implicitly, non-`const`</td>
</tr>
<tr>
<td>file_d1</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; `_Thread_local`, `extern` implicitly, non-`const`</td>
</tr>
<tr>
<td>file_d2</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; `extern` explicitly, non-`const`</td>
</tr>
<tr>
<td>file_d3</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; non-`const`</td>
</tr>
<tr>
<td>file_d4</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; `_Thread_local`, non-`const`</td>
</tr>
<tr>
<td>file_d5</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; `extern` implicitly</td>
</tr>
<tr>
<td>file_d6</td>
<td>‚úÖ</td>
<td>‚úÖ</td>
<td>no change; `constexpr` explicitly</td>
</tr>
<tr>
<td>file_d7</td>
<td>‚ùå</td>
<td>‚úÖ</td>
<td>`static` and `const`, initialized by constant expression</td>
</tr>
<tr>
<td>block_d0</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; non-`const`</td>
</tr>
<tr>
<td>block_d1</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; `extern` explicitly, non-`const`</td>
</tr>
<tr>
<td>block_d2</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; non-`const`, `static`</td>
</tr>
<tr>
<td>block_d3</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; `_Thread_local`, `static`, non-`const`</td>
</tr>
<tr>
<td>block_d4</td>
<td>‚ùå</td>
<td>‚úÖ</td>
<td>`const`; initialized with literal</td>
</tr>
<tr>
<td>block_d5</td>
<td>‚ùå</td>
<td>‚úÖ</td>
<td>`const`; initialized with other `constexpr` variable</td>
</tr>
<tr>
<td>block_d6</td>
<td>‚ùå</td>
<td>‚úÖ</td>
<td>`const`, initialized by other constant expression</td>
</tr>
<tr>
<td>block_d7</td>
<td>‚ùå</td>
<td>‚úÖ</td>
<td>`static` and `const`, initialized with literal</td>
</tr>
<tr>
<td>block_d8</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; non-constant expression initializer</td>
</tr>
<tr>
<td>block_d9</td>
<td>‚ùå</td>
<td>‚úÖ</td>
<td>`static` and `const`, initialized by constant expression</td>
</tr>
<tr>
<td>block_d10</td>
<td>‚úÖ</td>
<td>‚úÖ</td>
<td>no change; `constexpr` explicitly</td>
</tr>
<tr>
<td>block_d11</td>
<td>‚úÖ</td>
<td>‚úÖ</td>
<td>no change; `constexpr` explicitly</td>
</tr>
<tr>
<td>block_d12</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; non-`const`, non-constant expression initializer</td>
</tr>
<tr>
<td>block_d13</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; non-constant expression initializer</td>
</tr>
<tr>
<td>block_d14</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; non-constant expression initializer</td>
</tr>
<tr>
<td>block_d15</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>no change; `volatile`</td>
</tr>
</tbody>
</table>

This matches the existing practice that occurs today.



## Changes in Existing Code ## {#design-changes}

Besides what is enumerated above for given declarations, some typical consequences on existing code are:

- Implementation-defined variable-Length Arrays (VLAs) in many cases are promoted to standard-guaranteed Fixed-Length Arrays (typical "C arrays"). This change is anticipated and wanted, and is part of the original motivation for this proposal.
- Some manner of `_Generic(‚Ä¶)` expressions are not constant expressions. This is a natural addendum from the concrete rules about generic selection, where if the selected expression is a constant expression, then the `_Generic` expression itself is a constant expression. A small class of these become guaranteed to be constant expressions now since the use of such integer type declarations now counts. This is intended, and simply a side-effect of the pass-through nature of `_Generic`'s selection process. It does not negatively impact existing code in any appreciable way.

Otherwise, all the effects of this proposal are for newly written code that can confidently take advantage of such now rather than leave it implementation-defined.



## What if Someone Takes the Address of a `const` Declaration that has been Promoted to `constexpr`? ## {#design-address.of}

This is fine. Naked `constexpr` variables are already implicitly `const`, and taking the address of one produces an `int const*` consistent with having a pointer to a variable that cannot be modified. A compiler may be robbed of a constant expression optimization (e.g., doing literal computation replacement and removing the existence of the variable inside of the program) by such a move, but it is fine and behaves perfectly in-line with the expected semantics of having a `const` integer. Modification of such an object by casting away its `const`-ness is, as it is throughout the C standard, Undefined Behavior and it should not be done. If it is done, the same rules apply as ever; undefined behavior. This proposal does not change anything in the way these values were being used to-date in either C or C++.



## Why Not More Than Integer Types? ## {#design-integers}

We limit this proposal to integer types because that is the widest-spread existing practice and easiest to compute. `constexpr` serves as not just a marker, but as a way to let an implementation know that no matter how complex the initializer or its contained expressions become, it must be evaluated at compile-time. This represents a contract between the user and the compiler, and also serves as a courtesy so that the compiler can be appropriate prepared when processing the declaration.

Conversely, this is an implicit promotion. To ensure compilers are not unduly burdened, we capture what is already existing practice on the vast majority of existing compilers: integer types. If, in the future, implementations process many more declarations at compile-time, then such expansions can be made easily.




# Wording # {#wording}

The following wording is relative to the latest draft standard of C.

*üìù Editor's Note: The ‚ú® characters are intentional. They represent stand-ins to be replaced by the editor.*



## Add a new paragraph to 6.7 "Declarations", just after paragraph 12 and before "EXAMPLE 3" ## {#wording-¬ß6.7¬∂21}

<blockquote>
<div class="wording-section">

<div class="wording-numbered wording-numbered-12">

A declaration such that the declaration specifiers contain no type specifier or that is declared with `constexpr` is said to be *underspecified*. If such a declaration is not a definition, if it declares no or more than one ordinary identifier, if the declared identifier already has a declaration in the same scope, if the declared entity is not an object, or if anywhere within the sequence of tokens making up the declaration identifiers that are not ordinary are declared, the behavior is implementation-defined.<sup>136)</sup>
</div>

<div class="wording-newnumbered wording-newnumbered-13">
<ins>

If one of a declaration's init declarator matches the second form (a declarator followed by an equal sign `=` and an initializer) meets the following criteria:

:: ‚Äî it is the first visible declaration of the identifier;
:: ‚Äî it contains no other storage-class specifiers except `static`, `auto`, or `register`;
:: ‚Äî it does not declare the identifier with external linkage;
:: ‚Äî its type is an integer type, is `const`-qualified but not otherwise qualified, and is non-atomic;
:: ‚Äî and, its initializer is an integer constant expression (6.6);

then it behaves as if a `constexpr` storage-class specifier is implicitly added for that declarator specifically. The declared identifier is then a named constant and is valid in all contexts where a named constant of the corresponding type is valid to form a constant expression of that specific kind (6.6).
</ins>
</div>



</div>
</blockquote>
