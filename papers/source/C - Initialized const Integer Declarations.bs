<pre class='metadata'>
Title: Integer Constant Expression Initialized const Integer Declarations are Implicitly constexpr
H1: Integer Constant Expression-Initialized <code>const</code> Integer Declarations are Implicitly <code>constexpr</code>
Shortname: XXXX
Revision: 0
!Previous Revisions: None
Status: P
Date: 2023-08-21
Group: WG14
!Proposal Category: Feature Request
!Target: C2y/C3a
Editor: JeanHeyd Meneide (https://thephd.dev), wg14@soasis.org
Editor: Shepherd (Shepherd's Oasis LLC), shepherd@soasis.org
URL: https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Initialized%20const%20Integer%20Declarations.html
!URL: <a href="https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Initialized%20const%20Integer%20Declarations.html">https://thephd.dev/_vendor/future_cxx/papers/C - Initialized const Integer Declarations.html</a>
!Paper Source: <a href="https://thephd.dev/_vendor/future_cxx/papers/source/C%20-%20Initialized%20const%20Integer%20Declarations.bs">GitHub ThePhD/future_cxx</a>
Issue Tracking: GitHub https://github.com/ThePhD/future_cxx/issues
Metadata Order: Previous Revisions, Editor, Latest, Paper Source, Issue Tracking, Project, Audience, Proposal Category, Target
Markup Shorthands: markdown yes
Toggle Diffs: no
Abstract: Block scope <code>const</code> integer type declarations initialized with constant expressions have been a fairly important staple of C programs both large and small over the last 30 years. Attempts to make such declarations ineligible as constant expressions and e.g. force an array declared with them to be a Variable-Length Array (VLA) type failed due to overwhelming existing practice in the opposite direction. This proposal therefore swings with said opposite direction now that we have <code>constexpr</code>. It asks that such <code>const</code> integer type declarations that are both declared and initialized in the same statement are implicitly made <code>constexpr</code>, thereby fulfilling the expectations of users.  
</pre>

<pre class="include-raw">
path: resources/css/bikeshed-wording.html
</pre>

<div class="pagebreak"></div>




# Changelog # {#changelog}



## Revision 0 - August 21<sup>st</sup>, 2023 ## {#changelog-r0}

- Initial release 🎉!




# Introduction and Motivation # {#intro}

A common annoyance amongst C developers has been the ephemeral nature of the following code snippet:

```c
int main () {
	const int n = 1 + 2;
	const int a[n];
	return sizeof(a);
}
```

Does this create a VLA type all the time, or is this a valid constant expression that produces a translation time (AKA compile-time) sized array with an extent of `3`? Will `sizeof(a)` be executed at compile-time or will it be run at execution time (AKA run-time) and pull the value from somewhere in the binary? Furthermore, if an implementation defines `__STDC_NO_VLA__`, is this supposed to compile? All of these questions and more revolved around this issue were brought up in [n2713](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2713.htm). n2713 was accepted into C23, and subsequently forced the above code to resolve with `a` being a VLA, even if the implementation could ascertain this was a constant expression and treat it as a constant expression at compile-time. This allowed all implementations to have the same semantic frontend errors and/or warnings, while letting them optimize things as necessary during typical linking and code generation/lowering. (E.g., never using `alloca` with a dynamic value and instead just sizing the stack appropriately to accommodate the array directly for a binary implementation.)

However, during National Body (NB) comment processing, an NB comment pointed out that there was a lot of code relying on the fact that this was being treated -- not just by the backend with its optimizations -- but by the frontend of many compilers to be a plain, compile-time C array. This was formalized in [n3138](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3138.pdf), which presented cases similar to the above. It also presented various other constant expressions to make it clear that there is a wide berth of existing practice beyond just MSVC, GCC, and Clang that accept many additional forms of constant expressions in many different situations. However, the array case remains of very significant impact that affects the most existing code. n3138 promised that a potential future version of C should look into the impact of changing constant expressions one way or another again.

This paper introduces a change for a portion of constant expressions in the opposite direction of N2713, by asking that block scope (non-file scope) `const` integer type declarations that are also immediately initialized with an integer constant expression are implicitly declared `constexpr`.





# Prior Art # {#prior}

This is existing practice on a wide variety of compilers both large and small, ranging from SDCC all the way up to much more powerful compilers like ICC (Intel), Clang and GCC. The snippet in [[#intro]] compiles and runs on many implementations with no run-time execution, even on its intentionally-weakest optimization settings (where applicable for a compiler with such settings). It also runs on many implementations even where VLAs are not allowed (e.g. with `__STDC_NO_VLA__` or where `-Wvla` is combined with `-Werror`).

Furthermore, C++ has a similar feature for all `const`-declared integer types. However, rather than modeling this after the C++ wording and C++ feature, we instead focus on solidifying and cleaning up the existing practice of implementation's C mode (for implementations with shared C and C++ modes) and existing purely C compilers. Most importantly, we do not apply the full "manifestly constant evaluated" or "constantly evaluated" powers that C++ has adopted, and instead focus exclusively on what follows from the existing practice of existing C codebases and C implementations.




# Design # {#design}

The design of this feature is such that it requires a declaration that is immediately initialized. The declarations eligible for this, unlike C++, are only for block scope declarations (that is, declarations within the body of a function call). It also only applies to declarations whose *storage-class specifier* is `const` and, optionally, `static` or `auto`. (If the storage-class is already `constexpr`, then this proposal affects no change to the declaration at all.) This means that, under this proposal, of the following declarations:

```cpp
int file_d0 = 1;
_Thread_local int file_d1 = 1;
extern int file_d2;
static int file_d3 = 1;
_Thread_local static int file_d4 = 1;
const int file_d5 = 1;
constexpr int file_d6 = 1;
static const int file_d7 = 1;

int file_d2 = 1;

int main (int argc, char* argv[]) {
	int block_d0 = 1;
	extern int block_d1;
	static int block_d2 = 1;
	_Thread_local static int block_d3 = 1;
	const int block_d4 = 1;
	const int block_d5 = file_d6;
	const int block_d6 = block_d4;
	static const int block_d7 = 1;
	static const int block_d8 = file_d5;
	static const int block_d9 = file_d6;
	constexpr int block_d10 = 1;
	static constexpr int block_d11 = 1;
	int block_d12 = argc;
	const int block_d13 = argc;
	const int block_d14 = block_d0;
	const volatile int block_d15 = 1;

	return 0;
}

int block_d1 = 1;
```

A handful of these variables at block scope become `constexpr`, as indicated by the table below which explains the changes for the above code snippet:

<!--- Data Source:
| Declaration |  `constexpr` Before ? |    `constexpr` After ? | Comment                                                     |
|-------------|-----------------------|-----------------------|--------------------------------------------------------------|
| file_d0     | ❌                    | ❌                   | no change; `extern` implicitly, non-`const`                  |
| file_d1     | ❌                    | ❌                   | no change; `_Thread_local`, `extern` implicitly, non-`const` |
| file_d2     | ❌                    | ❌                   | no change; `extern` explicitly, non-`const`                  |
| file_d3     | ❌                    | ❌                   | no change; non-`const`                                       |
| file_d4     | ❌                    | ❌                   | no change; `_Thread_local`, non-`const`                      |
| file_d5     | ❌                    | ❌                   | no change; `extern` implicitly                               |
| file_d6     | ✅                    | ✅                   | no change; `constexpr` explicitly                            |
| file_d7     | ❌                    | ❌                   | no change; file-scope `static`                               |
| block_d0    | ❌                    | ❌                   | no change; non-`const`                                       |
| block_d1    | ❌                    | ❌                   | no change; `extern` explicitly, non-`const`                  |
| block_d2    | ❌                    | ❌                   | no change; non-`const`, `static`                             |
| block_d3    | ❌                    | ❌                   | no change; `_Thread_local`, `static`, non-`const`            |
| block_d4    | ❌                    | ✅                   | `const`; initialized with literal                            |
| block_d5    | ❌                    | ✅                   | `const`; initialized with other `constexpr` variable         |
| block_d6    | ❌                    | ✅                   | `const`, initialized by other constant expression            |
| block_d7    | ❌                    | ✅                   | `static` and `const`, initialized with literal               |
| block_d8    | ❌                    | ❌                   | no change; non-constant expression initializer               |
| block_d9    | ❌                    | ✅                   | `static` and `const`, initialized by constant expression     |
| block_d10   | ✅                    | ✅                   | no change; `constexpr` explicitly                            |
| block_d11   | ✅                    | ✅                   | no change; `constexpr` explicitly                            |
| block_d12   | ❌                    | ❌                   | no change; non-`const`, non-constant expression initializer  |
| block_d13   | ❌                    | ❌                   | no change; non-constant expression initializer               |
| block_d14   | ❌                    | ❌                   | no change; non-constant expression initializer               |
| block_d15   | ❌                    | ❌                   | no change; `volatile`                                        |
--->

<table>
<thead>
<tr>
<th>Declaration</th>
<th>`constexpr` Before?</th>
<th>`constexpr` After?</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>file_d0</td>
<td>❌</td>
<td>❌</td>
<td>no change; `extern` implicitly, non-`const`</td>
</tr>
<tr>
<td>file_d1</td>
<td>❌</td>
<td>❌</td>
<td>no change; `_Thread_local`, `extern` implicitly, non-`const`</td>
</tr>
<tr>
<td>file_d2</td>
<td>❌</td>
<td>❌</td>
<td>no change; `extern` explicitly, non-`const`</td>
</tr>
<tr>
<td>file_d3</td>
<td>❌</td>
<td>❌</td>
<td>no change; non-`const`</td>
</tr>
<tr>
<td>file_d4</td>
<td>❌</td>
<td>❌</td>
<td>no change; `_Thread_local`, non-`const`</td>
</tr>
<tr>
<td>file_d5</td>
<td>❌</td>
<td>❌</td>
<td>no change; `extern` implicitly</td>
</tr>
<tr>
<td>file_d6</td>
<td>✅</td>
<td>✅</td>
<td>no change; `constexpr` explicitly</td>
</tr>
<tr>
<td>file_d7</td>
<td>❌</td>
<td>❌</td>
<td>no change; file-scope `static`</td>
</tr>
<tr>
<td>block_d0</td>
<td>❌</td>
<td>❌</td>
<td>no change; non-`const`</td>
</tr>
<tr>
<td>block_d1</td>
<td>❌</td>
<td>❌</td>
<td>no change; `extern` explicitly, non-`const`</td>
</tr>
<tr>
<td>block_d2</td>
<td>❌</td>
<td>❌</td>
<td>no change; non-`const`, `static`</td>
</tr>
<tr>
<td>block_d3</td>
<td>❌</td>
<td>❌</td>
<td>no change; `_Thread_local`, `static`, non-`const`</td>
</tr>
<tr>
<td>block_d4</td>
<td>❌</td>
<td>✅</td>
<td>`const`; initialized by constant expression thus `constexpr` implicitly</td>
</tr>
<tr>
<td>block_d5</td>
<td>❌</td>
<td>✅</td>
<td>`const`; initialized by constant expression thus `constexpr` implicitly</td>
</tr>
<tr>
<td>block_d6</td>
<td>❌</td>
<td>✅</td>
<td>`const`, initialized by constant expression thus `constexpr` implicitly</td>
</tr>
<tr>
<td>block_d7</td>
<td>❌</td>
<td>✅</td>
<td>`static` and `const`, initialized by constant expression thus `constexpr` implicitly</td>
</tr>
<tr>
<td>block_d8</td>
<td>❌</td>
<td>❌</td>
<td>no change; initializer is non-constant expression</td>
</tr>
<tr>
<td>block_d9</td>
<td>❌</td>
<td>✅</td>
<td>`static` and `const`, initialized by constant expression thus `constexpr` implicitly</td>
</tr>
<tr>
<td>block_d10</td>
<td>✅</td>
<td>✅</td>
<td>no change; `constexpr` explicitly</td>
</tr>
<tr>
<td>block_d11</td>
<td>✅</td>
<td>✅</td>
<td>no change; `constexpr` explicitly</td>
</tr>
<tr>
<td>block_d12</td>
<td>❌</td>
<td>❌</td>
<td>no change; non-`const`, initializer is non-constant expression</td>
</tr>
<tr>
<td>block_d13</td>
<td>❌</td>
<td>❌</td>
<td>no change; initializer is non-constant expression</td>
</tr>
<tr>
<td>block_d14</td>
<td>❌</td>
<td>❌</td>
<td>no change; initializer is non-constant expression</td>
</tr>
<tr>
<td>block_d15</td>
<td>❌</td>
<td>❌</td>
<td>no change; `volatile`</td>
</tr>
</tbody>
</table>

This matches the existing practice that occurs today.



## What about the `static` Declarations? ## {#design-static}

`static` implies internal linkage at file scope. At block scope, however, it makes the declaration is a "global" of sorts (albeit one still with internal linkage). This means that, since it would not impact or change any semantics in an untoward manner, this proposal could also promote `static const` (with no other storage-class specifiers) variables at block-scope to have this feature. This proposal therefore commits to such a change.

This cannot be done at file-scope because file-scope variables can have their linkages rewritten or changed in unpredictable ways by existing compilers. For example, this program marks a `static const` file-scope `int` type variable definition, after its declarations and initialization, as `extern`, and produces no warnings:

```cpp
static const int x = 1;
extern const int x;

int main(){
	return x;
}
```

(See it live [here](https://godbolt.org/z/j8rPMT44n) under strict compilation settings for GCC and Clang.) While we personally cannot attest to the required visibility of specific linkers symbols or otherwise in the final executable / library, we cannot rule out that this may be used in the wild as it is currently accepted by existing compilers and the symbol name may be reachable with default-compiled programs. It may represent values that can be logically "read only" at execution time, but manipulated at e.g. link-time and after `constexpr`/compile-time.

Furthermore, C++ allows for the above to be used at compile-time with e.g. `static_assert(x == 1, "👍")`. We have no idea what this would mean if this became a potentially link-time overridden read-only value, and how that would impact the evaluation according to the semantics of the abstract machine.

For all the aforementioned reasons, file-scope statics are not included in this proposal. If there is clarity that can be provided around these semantics, a future proposal should look into expanding the rights of their proposal where applicable.



## What if Someone Takes the Address of a `const` Declaration that has been Promoted to `constexpr`? ## {#design-address.of}

This is fine. Naked `constexpr` variables are already implicitly `const`, and taking the address of one produces an `int const*` consistent with having a pointer to a variable that cannot be modified. A compiler may be robbed of a constant expression optimization (e.g., doing literal computation replacement and removing the existence of the variable inside of the program) by such a move, but it is fine and behaves perfectly in-line with the expected semantics of having a `const` integer. Modification of such an object by casting away its `const`-ness is, as it is throughout the C standard, Undefined Behavior and it should not be done. If it is done, the same rules apply as ever; undefined behavior. This proposal does not change anything in the way these values were being used to-date in either C or C++.




# Wording # {#wording}

The following wording is relative to the latest draft standard of C.

*📝 Editor's Note: The ✨ characters are intentional. They represent stand-ins to be replaced by the editor.*



## Add a new paragraph to 6.7 "Declarations", just after paragraph 12 and before "EXAMPLE 3" ## {#wording-§6.7¶21}

<blockquote>
<div class="wording-section">

<div class="wording-numbered wording-numbered-12">

A declaration such that the declaration specifiers contain no type specifier or that is declared with `constexpr` is said to be *underspecified*. If such a declaration is not a definition, if it declares no or more than one ordinary identifier, if the declared identifier already has a declaration in the same scope, if the declared entity is not an object, or if anywhere within the sequence of tokens making up the declaration identifiers that are not ordinary are declared, the behavior is implementation-defined.<sup>136)</sup>
</div>

<div class="wording-newnumbered wording-newnumbered-13">
<ins>

If a declaration with the second form of an init declarator (a declarator with an equal sign `=` and an initializer) meets the following criteria:

:: — it is declared with the `const` storage class specifier (6.7.1) and has no other storage-class specifiers except `static` or `auto`;
:: — its type is an integer type;
:: — it is at block scope;
:: — and, its initializer is an integer constant expression;

then that declaration's storage-class specifiers will implicitly include `constexpr` and such integer type declarations will be suitable for use as integer constant expressions.
</ins>
</div>

</div>
</blockquote>
