# Wording # {#wording}

ADVISEMENT: THIS SECTION IS NOT GOING TO BE OFFICIAL UNTIL THE DESIGN SHAKEDOWN IS COMPLETE.

NOTE: THIS PROPOSAL WILL ONLY INCLUDE LANGUAGE (CLAUSE 6) WORDING. LIBRARY WORDING WILL BE DONE AFTER THE LANGUAGE IS HANDLED, LIKELY IN A SEPARATE PROPOSAL.


## `__self_func` Changes ## {#wording-__self_func}



### Modify "Predefined identifiers" (6.4.3.2) ### {#wording-__self_func-6.4.3.2}

- change the mention of "execution encoding" in this section to instead be "literal encoding (6.2.9)";
- and, add `constexpr` to the list of storage class specifiers for `static const char __func__[] = "function-name"`.


### Add the new keyword `__self_func` to ยง6.4.2 ### {#wording-__self_func-6.4.2}

> **Syntax**
>
> <sup>1</sup>
> *keyword:* one of
> :: ...
> :: <ins>`__self_func`</ins>


### Add `__self_func` to the *primary-expression* grammar of ยง6.5.2 ### {#wording-__self_func-6.5.2}

> **Syntax**
>
> <sup>1</sup>
> *primary-expression:*
> :: identifier
> :: constant
> :: string-literal
> :: ( expression )
> :: generic-selection
> :: <ins>`__self_func`</ins>


### Add a new section ยง6.5.2.โจ "`__self_func` after ยง6.5.2.1 "Generic selection" ### {#wording-__self_func-6.5.2.โจ}

<blockquote>
<ins>
<div class="wording-clause-header">
<span class="wording-clause-number">6.5.2.โจ</span> <span class="wording-clause-title">`__self_func`</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Constraints
</div>

<div class="wording-numbered">

`__self_func` shall only appear in the body of an invocable, and refers to the innermost invocable scope it is inside.
</div>

<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">

`__self_func` is either:

- the lvalue of the closure (6.2.โจ1) that it is contained within;
- or, the function designator (6.3.3.1) designating and having the type of the function it is used in.

</div>
</ins>
</blockquote>



## Core, Shared Changes ## {#wording-core}


### Modify ยง6.2.1 "Scopes of identifiers, type names, and compound literals" ### {#wording-core-6.2.1}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.2.1</span> <span class="wording-clause-title">Scopes of identifiers, type names, and compound literals</span>
</div>

<div class="wording-section">

<div class="wording-numbered">

An identifier can denote:

- a standard attribute, an attribute prefix, or an attribute name;
- an object;
- a function;
- <ins>a closure;</ins>
- a tag or a member of a structure, union, or enumeration;
- a typedef name;
- a label name;
- a macro name;
- or, a macro parameter.

</div>

<div class="wording-numbered">

For each different entity that an identifier designates, the identifier is *visible* (i.e. can be used) only within a region of program text called its scope. Different entities designated by the same identifier either have different scopes or are in different name spaces. There are four kinds of scopes: <del>function</del><ins>invocable</ins>, file, block, and function prototype. (A *function prototype* is a declaration of a function.)
</div>

<div class="wording-numbered">

A label name is the only kind of identifier that has <del>*function scope*</del><ins>*invocable scope*</ins>. It can be used (in a `goto` statement) anywhere in the <del>function</del><ins>body of the invocable (6.2.โจ0)</ins> in which it appears<del>, and</del><ins> excluding the body of any nested invocables, unless otherwise specified. It</ins> is declared implicitly by its syntactic appearance (followed by a `:` and a statement).<ins> Each invocable body has an invocable scope that is separate from the invocable scope of any other invocable body. In particular, a label is visible in exactly one invocable scope (the innermost body in which it appears) and distinct invocable bodies may use the same identifier to designate different labels.</ins>
</div>

<div>
...
</div>

<ins>
<div class="wording-newnumbered wording-numbered-9">

NOTE&emsp;&emsp; Properties of the feature to which an identifier refers are not necessarily uniformly available within its whole scope of visibility. Examples are identifiers or functions with an incomplete type that is only completed in a subscope of its visibility, labels that are only valid targets of `goto` statements when the jump does not cross the scope of a VLA, identifiers of objects to which the access is restricted in specific contexts such as signal handlers or closures, or library features such as `setjmp` where the use is restricted to a specific subset of the grammar.
</div>
</ins>

</div>
</blockquote>


### Modify ยง6.2.5 "Types" ### {#wording-core-6.2.5}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.2.5</span> <span class="wording-clause-title">Types</span>
</div>

<div class="wording-section">

<div class="wording-numbered">

...
</div>

<div>

...
</div>

<div class="wording-numbered wording-numbered-25">

Any number of derived types can be constructed from the object and function types, as follows:

โ ...
- A *function type* describes a function with specified return type. A function type is characterized by its return type and the number and types of its parameters. A function type is said to be derived from its return type, and if its return type is *T*, the function type is sometimes called "function returning *T*". The construction of a function type from a return type is called "function type derivation".
- <ins>A *closure type* describes a structure or union type that is similar to a function with a specified or inferred return type (6.2.โจ1). It is characterized by: its return type; the number, order, and type of its parameters; its lexical position in the program; and, the number, order, and type of its captures. The function type that has the same return type and list of parameter types as the closure type is the *closure's function type*. A closure type is said to be derived from its function type's return type and, if present, any of its captures. If its return type is *T*, the closure type is sometimes called "closure returning *T*" or "closure with captures returning *T*" (referring to closures with any number of captures, including zero captures).</ins>
- ...

These methods of constructing derived types can be applied recursively.
</div>

<div>
...
</div>

<div class="wording-numbered wording-numbered-29">

A complete type shall have a size that is less than or equal to `SIZE_MAX`. A type has *known constant size* if it is complete and is not a variable length array type.
</div>

<ins>
<div class="wording-newnumbered">

An *invocable type* is either a closure type, a function type, or a pointer to function type (6.2.โจ0).
</div>

<div class="wording-newnumbered">

A *closure literal type* is a closure type characterized by having no captures. If its return type is *T*, the closure literal type is sometimes called "closure literal returning *T*" or "closure with no captures returning *T*". Closure literal types are a proper subset of the closure types.
</div>
</ins>

<div>

...
</div>

</div>
</blockquote>


### Modify ยง6.2.7 "Compatible type and composite type" ### {#wording-core-6.2.7}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.2.7</span> <span class="wording-clause-title">Compatible type and composite type</span>
</div>

<div>
...
</div>

<div class="wording-section">

<div class="wording-numbered wording-numbered-3">

A *composite type* can be constructed from two types that are compatible. If both types are the same type, the composite type is this type. Otherwise, it is a type that is compatible with both and satisfies the following conditions:

- If both types are structure types or both types are union types, the composite type is determined recursively by forming the composite types of their members.
- If both types are array types, the following rules are applied:
	- If one type is an array of known constant length, the composite type is an array of that length.
	- Otherwise, if one type is a variable length array whose length is specified, the composite type is a variable length array of that length.
	- Otherwise, if one type is a variable length array of unspecified length, the composite type is a variable length array of unspecified length.
	- Otherwise, both types are arrays of unknown length, and the composite type is an array of unknown length.

	The element type of the composite type is the composite type of the two element types.

- If both types are function types, the type of each parameter in the composite parameter type list is the composite type of the corresponding parameters.
- <ins>If both types are closure types, the composite function type of the closure types' function types and the composite of the implementation-defined structure or union type of the closure types is the composite type of the two closure types.</ins>
- If one of the types has a standard attribute, the composite type also has that attribute.
- If both types are enumerated types, the composite type is an enumerated type.
- If one type is an enumerated type and the other is an integer type other than an enumerated type, it is implementation-defined whether or not the composite type is an enumerated type.

These rules apply recursively to the types from which the two types are derived.
</div>

</div>
</blockquote>

### Add a new section ยง6.2.โจ0 "Invocable", likely ยง6.2.10 ### {#wording-core-6.2.new0}

<blockquote class="quote-ins">
<div class="wording-clause-header">
<span class="wording-clause-number">6.2.โจ0</span> <span class="wording-clause-title">Invocable</span>
</div>


<div class="wording-section">

<div class="wording-clause-section-title">
Syntax
</div>

<div class="wording-numbered">

*parameter-clause*:
:: `(` *parameter-type-list*<sub>*opt*</sub> `)`

</div>

<div class="wording-clause-section-title">
Description
</div>

<div class="wording-numbered">

An *invocable* is something with zero or more parameters (and possibly zero or more captures if it is a closure) that may be invoked/called to trigger an entry into and subsequent execution of an associated series of statements and/or expressions.
</div>

<div class="wording-numbered">

Certain invocables can be declared (6.7.7) and potentially used before they are defined.
</div>

<div class="wording-numbered">

Invocables are:

- functions and pointers to functions (6.3.3.1, 6.5.3.3, 6.7.7.4, 6.9.2);
- and, closures (6.2.โจ1).

</div>

<div class="wording-numbered">

The associated series of statements and/or expressions is called the *invocable body* or *body of the invocable*. The body of an invocable has its own scope, and that scope includes any captures it was created with and arguments it was invoked with. The scope that includes just the associated series of statements and/or expressions without the arguments or captures is called the *invocable statement list*. The scope in which an invocable is declared or defined is called the invocable's *surrounding scope*, which is either the block scope of another invocable or file scope.
</div>

<div class="wording-numbered">

As part of the declaration or definition of its parameter list, an invocable may include an ellipses in its list, either as the sole argument or at the end of its list. This is called a *variadic parameter*. Arguments supplied to an invocable whose positions match or come after the ellipses in the parameter list are its *varying arguments*. Any invocable which contains a variadic parameter is a *variadic invocable*. Additionally, functions with a variadic parameter are sometimes specifically called *variadic functions* and closures with a variadic parameter are sometimes specifically called *variadic closures*.
</div>

<div class="wording-clause-section-title">
Constraints
</div>

<div class="wording-numbered">

Although variable length array types of unspecified size and incomplete types can be used as part of a parameter declaration for the declaration of an invocable, they shall not be used as part of a parameter declaration in the definition of an invocable.
</div>

<div class="wording-numbered">

The only storage-class specifier that shall occur in a parameter declaration is `register`.
</div>

<div class="wording-numbered">

After adjustment, the parameters in a parameter type list in an invocable declarator (such as a function declarator) that is part of a definition of that invocable shall not have incomplete type.
</div>

<div class="wording-numbered">

Except for `void`, an invocable shall not specify a return type that is a function type, an array type, or an incomplete type.
</div>

<div class="wording-numbered">

A parameter declaration shall not specify a `void` type, except for the special case of a single unnamed parameter of type `void` with no storage-class specifier, no type qualifier, and no following ellipsis terminator. If the parameter list consists of a single parameter of type `void`, the parameter declarator shall not include an identifier.
</div>

<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">

An invocable can have a sequence of arguments passed to it that comply with the constraints and requirements of the invocable's list of parameters. An invocable's parameters have automatic storage duration.
</div>

<div class="wording-numbered">

The identifier of the parameter, if any, is an lvalue in the invocable body. Variable length array types of unspecified size shall not be used as part of a parameter declaration in an invocable definition. The layout of the storage for parameters is unspecified. The type of each parameter is adjusted as described later in this subclause.
</div>

<div class="wording-numbered">

NOTE&emsp;&emsp; A parameter that has no declared name is inaccessible within the invocable body. A parameter's identifier cannot be redeclared in the invocable body except in an enclosed block. The visibility scope of a parameter in a function definition starts when its declaration is completed, extends to following parameter declarations, to possible attributes that follow the parameter type list, and then to the entire function body. The lifetime of each instance of a parameter starts when the declaration is evaluated starting a call and ends when that call terminates.
</div>

<div class="wording-numbered">

The special case of an unnamed parameter of type `void` as the only item in the parameter list specifies that the function has no parameters.
</div>

<div class="wording-numbered">

A declaration of a parameter as "array of *type*" shall be adjusted to "qualified pointer to *type*", where the type qualifiers (if any) are those specified within the `[` and `] `of the array type derivation. If the keyword `static` also appears within the `[` and `]` of the array type derivation, then for each call to the function, the value of the corresponding actual argument must provide access to the first element of an array with at least as many elements as specified by the size expression.
</div>

<div class="wording-numbered">

If, in a parameter declaration, an identifier can be treated either as a typedef name or as a parameter name, it shall be taken as a typedef name.
</div>

<div class="wording-numbered">

A declaration of a parameter as "function returning *type*" shall be adjusted to "pointer to function returning *type*", as in 6.3.3.1.
</div>

<div class="wording-numbered">

If the invocable declarator is not part of a definition of that invocable, parameters can have incomplete type and can use the `[*]` notation in their sequences of declarator specifiers to specify variable length array types.
</div>

<div class="wording-numbered">

The storage-class specifier in the declaration specifiers for a parameter declaration, if present, is ignored unless the declared parameter is one of the members of the parameter type list for the definition of the invocable. The optional attribute specifier sequence in a parameter declaration appertains to the parameter.
</div>

<div class="wording-numbered">

On entry to the invocable, the size expressions of each variably modified parameter and typeof operators used in declarations of parameters are evaluated and the value of each argument expression is converted to the type of the corresponding parameter as if by assignment. (Array expressions and function designators as arguments were converted to pointers before the call.)
</div>

<div class="wording-numbered">

After all parameters have been assigned, the invocable statement list is executed.
</div>

<div class="wording-numbered">

Upon return to its invoker/caller from either finishing the execution of its body or returning, an invocable can either return nothing (indicated by the return type `void`) or return a value of object type (6.8.7.5). Unless otherwise specified, if the end of the invocable body is reached (such as the terminating `{`), and the value of the function call is used by the caller, the behavior is undefined.
</div>

</div>
</blockquote>


### Add a new section ยง6.2.โจ1 "Closures", after ยง6.2.โจ0 "Invocables", likely ยง6.2.11 ### {#wording-core-6.2.new1}

<blockquote class="quote-ins">
<div class="wording-clause-header">
<span class="wording-clause-number">6.2.โจ1</span> <span class="wording-clause-title">Closures</span>
</div>
<div class="wording-clause-header">
<span class="wording-clause-number">6.2.โจ1.1</span> <span class="wording-clause-title">General</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Description
</div>

<div class="wording-numbered">

A *closure* is a structure or union object of invocable type which has zero or more captures and zero or more parameters.
</div>

<div class="wording-numbered">

A closure's object is composed of at least any information necessary to invoke it with its arguments and for its implicit or explicit captures (6.2.โจ1.2).
</div>

<div class="wording-clause-section-title">
Constraints
</div>

<div class="wording-numbered">

Within the invocable body of a closure, identifiers shall be used according to the usual scoping rules. Captures and parameters can be accessed by their name in the invocable body. However, no identifier that is a variably modified type or an object of variably modified type shall be captured and used in the invocable statement list.
</div>

<div class="wording-numbered">

An identifier that is an object of automatic storage duration which has a storage-class specifier of `constexpr` may also be used, but its address shall not be taken in the invocable body of the closure.
</div>

<div class="wording-numbered">

An object of closure literal type shall be convertible to a function pointer.
</div>

<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">

A closure with zero captures has closure literal type. Otherwise, it has closure type.
</div>

<div class="wording-numbered">

A closure literal is convertible to a function pointer. That function pointer is the same for every closure literal of that closure literal type. An invocation of that function pointer invokes the associated body of that closure with the provided arguments.
</div>


<div class="wording-numbered">

A closure's size, layout, and representation are all implementation-defined unless otherwise specified. Each closure's type is unique, and is characterized by:

- any captures it can have;
- the function type it has, particularly any parameters it can have and its return type;
- and, the lexical position of the first declaration and/or definition.

A closure's type is not required to be compatible with any other type, unless otherwise specified.
</div>

<div class="wording-numbered">

NOTE&emsp;&emsp; Two closures with identical captures and parameter types are not necessarily compatible (e.g. assignable) to one another.
</div>

<div class="wording-numbered">

Unless otherwise specified for the associated closure, each captured value can be accessed with the member access operator `.` on that closure, or with the member access operator `->` on a pointer to that closure, using the capture's name. The layout of the storage for the captures of a closure is implementation-defined.
</div>

<div class="wording-numbered">

NOTE&emsp;&emsp; While accessing captures uses the member access operators, there is no requirements or constraints on what the actual members, layout, and other details of a closure is.
</div>

</div>

<div class="wording-clause-header">
<span class="wording-clause-number">6.2.โจ1.2</span> <span class="wording-clause-title">Captures</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Syntax
</div>

<div class="wording-numbered">

*capture-list*
:: *capture-default*
:: *capture-name-list*
:: *capture-default* `,` *capture-name-list*

*capture-name-list*:
:: *capture*
:: *capture-name-list* `,` *capture*

*capture-default*:
:: `=`
:: `&`

*capture*:
:: `&`<sub>opt</sub> *identifier* *capture-rename*<sub>*opt*</sub>

*capture-rename*:
:: `=` *assignment-expression*

</div>

<div class="wording-clause-section-title">
Description
</div>

<div class="wording-numbered">

"Capturing" an object or a "captured" object describes the process of making visible objects from a surrounding scope visible in an inner, more nested invocable scope.
</div>

<div class="wording-numbered">

A *capture list* allows access to objects visible in a certain scope named by the capture's identifier or computed by the optional capture rename. A *capture* is an entry in the capture list.
</div>

<div class="wording-numbered">

The `=` capture default is a *default value capture*. The `&` capture default is a *default reference capture*. Either one is called a *default capture*. The identifier in a capture is the *capture name*. The optional capture rename is the *capture initialization expression*. A capture with no capture initialization expression is called a *identifier capture*. A capture with a capture initialization expression is called an *expression capture*.
</div>

<div class="wording-numbered">

If present, the closure which the capture partly characterizes and modifies is called the *associated closure*. The capture list's *associated scope* is the surrounding scope of the associated closure unless otherwise specified.
</div>

<div class="wording-numbered">

A capture name with no preceding `&` is called a *value capture*. A capture name preceded by a `&` is called a *reference capture*.
</div>

<div class="wording-clause-section-title">
Constraints
</div>

<div class="wording-numbered">

The capture name shall appear at most once across the capture list and, if present, the parameter names of an associated closure. If the capture list's associated scope is file scope, then no captures or default captures are permitted in the list.
</div>

<div class="wording-numbered">

For a capture that is a reference capture and an identifier capture, the identifier shall be an object which is addressable. For a capture that is a reference capture and an expression capture, the capture initialization expression shall be an addressable lvalue.
</div>

<div class="wording-numbered">

For an identifier capture, the capture name shall be a visible identifier of automatic storage duration from the associated scope.
</div>

<div class="wording-numbered">

If a default value capture is specified, then subsequent captures shall only be reference captures. If a default reference capture is specified, then subsequent captures shall only be value captures.
</div>

<div class="wording-numbered">

The type of the capture shall not be a variably modified type.
</div>

<div class="wording-numbered">

NOTE&emsp;&emsp; Parameters of variably modified type are allowed to be captured because their type after adjustment is a pointer type.
</div>

<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">

Capture lists are evaluated when their associated closure is defined and evaluated. The order of evaluation for captures are sequenced in order of declaration. The capture name is complete after its optional capture initialization expression. An earlier capture may occur within the capture initialization expression of a later capture.
</div>

<div class="wording-numbered">

Value captures provide the value at time of evaluation of the capture when used. It is either the value of the identifier it refers to if it is an identifier capture, or the value of the capture initialization expression used to compute it if it is an expression capture. Unless otherwise specified, value captures have either:

- the storage duration of an associated closure (if present);
- or, automatic storage duration.

</div>

<div class="wording-numbered">

NOTE&emsp;&emsp; A possible implementation of value captures is having a stored member in the closure object that is accessed every time it is used within the associated closure.
</div>

<div class="wording-numbered">

Reference captures are lvalues that either:

- refer to an identifier which exists in the surrounding scope identified by the capture name (if it is an identifier capture);
- or, to the addressable lvalue of the capture initialization expression at the time of evaluation (if it is an expression capture).

If a reference capture is used after the lifetime of what it refers to or addresses finishes, the behavior is undefined.
</div>

<div class="wording-numbered">

NOTE&emsp;&emsp; A possible implementation of reference captures is storing a value capture of the address of the desired addressable lvalue in the closure object, and automatically dereferencing it upon its use in the associated closure.
</div>

<div class="wording-numbered">

If a default capture is present, then it behaves as if all automatic storage duration objects visible in the surrounding scope are:

- value captured, for `=`;
- or, reference captured, for `&`.

</div>

<div class="wording-numbered">

For a capture, let *T*<sub>*capture-initial*</sub> be:

- `typeof(identifier)`, where `identifier` is the capture name if it is identifier capture;
- or, the type of the capture initialization expression if it is an expression capture.

Let *T*<sub>*capture*</sub> be the type of the capture after lvalue, array-to-pointer, or function designator to pointer conversion is applied to *T*<sub>*capture-initial*</sub>. The type of a capture is <code>T<sub>*capture*</sub> const</code>, unless otherwise specified.
</div>

<div class="wording-numbered">

NOTE&emsp;&emsp; A capture therefore will not have array type itself, but a member of the captured type can possibly have array type.
</div>

<div class="wording-clause-section-title">
Recommended practice
</div>

<div class="wording-numbered">

If all captures in a capture list are reference captures, implementations are encouraged to take advantage of potential layout and storage optimizations which respect to the lifetime of any associated closure.
</div>

</div>

</blockquote>


### Modify ยง6.3.3.1 "Lvalues, arrays, and function designators" ### {#wording-core-6.3.3.1}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.3.3.1</span> <span class="wording-clause-title">Lvalues, arrays, and function designators</span>
</div>

<div class="wording-section">

<div class="wording-numbered">

...
</div>

<div class="wording-numbered wording-numbered-4">

A *function designator* is an expression that has <del>function</del><ins>invocable</ins> type. Except when it is the operand of the `sizeof` operator, a typeof operator, or the unary `&` operator, a function designator with type<del> "function returning *type*" is converted to an expression that has type "pointer to function returning *type*"</del><ins>:</ins>

<ins>

- "function returning *R*";
- or, "closure literal returning *R*",

is converted to an expression that has type "pointer to function returning *R*", where "*R*" is the return type.
</ins>
</div>

</div>
</blockquote>


### Modify ยง6.5.3.3 "Function calls" ### {#wording-core-6.5.3.3}

In order,
1. Replace the title "Function calls" with "Invocation"
2. Outside the EXAMPLE and NOTE text, replace every instance of "type pointer to function" with "invocable type".
3. Outside the EXAMPLE and NOTE text, replace every instance of "function type" with "invocable type".
4. Outside the EXAMPLE and NOTE text, replace every instance of "a function" with "an invocable".
5. Outside the EXAMPLE and NOTE text, replace every instance of "function" with "invocable", EXCEPT:
	- "... ellipses in a variadic function declarator (6.7.7.4) ..." becomes "... ellipsis notation in a variadic invocable (6.2.โจ0) ..."
6. Add a new description section before the Constraints:
	> <ins>
	> **Description**
	>
	> <sup>1</sup> Invocation, sometimes referred to as a "function call", "invocable call", "closure call", "function invocation", or "closure invocation", refers to calling an invocable (e.g. a function or (closure) object) and triggering the execution of the invocable's statement list, as described in 6.2.โจ0.
	>
	> </ins>


### Modify ยง6.5.5 "Cast operators" ### {#wording-core-6.5.5}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.5.5</span> <span class="wording-clause-title">Cast operators</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Constraints
</div>

<div>
...
</div>

<div class="wording-numbered wording-numbered-4">

A pointer type shall be converted only to `void`, an integer type, or a pointer type. Only a pointer, integer,<ins> closure literal</ins> or `nullptr_t` type shall be converted to a pointer type. The type `nullptr_t` shall not be converted to any type other than `void`, `bool` or a pointer type. If the target type is `nullptr_t`, the cast expression shall be a null pointer constant or have type `nullptr_t`.<ins> A closure literal type shall not be converted to any pointer type other than a pointer to the closure's function type.</ins>
</div>

<div class="wording-clause-section-title">
Semantics
</div>

<div>
...
</div>

</div>
</blockquote>


### Modify ยง6.5.17.2 "Simple assignment" ### {#wording-core-6.5.17.2}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.5.17.2</span> <span class="wording-clause-title">Simple assignment</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Constraints
</div>

<div class="wording-numbered">

One of the following shall hold:

- the left operand has atomic, qualified, or unqualified arithmetic type, and the right operand has arithmetic type;
- the left operand has an atomic, qualified, or unqualified version of a structure or union type compatible with the type of the right operand;
- the left operand has atomic, qualified, or unqualified pointer type, and (considering the type the left operand would have after lvalue conversion) both operands are pointers to qualified or unqualified versions of compatible types, and the type pointed to by the left operand has all the qualifiers of the type pointed to by the right operand;
- the left operand has atomic, qualified, or unqualified pointer type, and (considering the type the left operand would have after lvalue conversion) one operand is a pointer to an object type, and the other is a pointer to a qualified or unqualified version of `void`, and the type pointed to by the left operand has all the qualifiers of the type pointed to by the right operand;
- <ins>the left operand has atomic, qualified, or unqualified pointer type, and (considering the type the left operand would have after lvalue conversion) one operand is a pointer to a function type, and the other is a closure literal type whose function type is compatible with the left's pointed to function type;</ins>
- the left operand has an atomic, qualified, or unqualified version of the `nullptr_t` type and the right operand is a null pointer constant or its type is `nullptr_t`;
- the left operand is an atomic, qualified, or unqualified pointer, and the right operand is a null pointer constant or its type is `nullptr_t`; or
- the left operand has type atomic, qualified, or unqualified `bool`, and the right operand is a pointer or its type is `nullptr_t`.

</div>

</div>
</blockquote>


### Remove ยง6.7.7.4 "Function declarators" to rewrite in a new version it in terms of invocables ### {#wording-core-6.7.7.4}

<blockquote class="quote-ins">
<div class="wording-clause-header">
<span class="wording-clause-number">6.7.7.4</span> <span class="wording-clause-title">Function declarators</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Description
</div>

<div class="wording-numbered">

If, in the declaration "`T D1`", `D1` has the form

:: `D` *parameter-clause* *attribute-specifier-sequence*<sub>*opt*</sub>

and the type specified for ident in the declaration "`T D`" is "*derived-declarator-type-list* `T`", then it is an invocable declarator (6.2.โจ0) and the type specified for *ident* is "*derived-declarator-type-list* function returning the unqualified, non-atomic version of `T`".
</div>

<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">

The optional attribute specifier sequence appertains to the function type.
</div>

<div class="wording-numbered">

Two function types are compatible if and only if all of the following hold:

- They specify compatible return types.
- The parameter type lists agree in the number of parameters and in whether the function is variadic or not.
- The corresponding parameters have compatible types.

In the determination of type compatibility and of a composite type, each parameter declared with function or array type is taken as having the adjusted type and each parameter declared with qualified type is taken as having the unqualified version of its declared type.
</div>

<div class="wording-numbered">

EXAMPLE&emsp;&emsp; The declaration

```cpp
int f(void), *fip(), (*pfi)();
```

declares a function `f` with no parameters returning an `int`, a function `fip` with no parameters returning a pointer to an `int`, and a pointer `pfi` to a function with no parameters returning an `int`. It is especially useful to compare the last two. The binding of `*fip()` is `*(fip())`, so that the declaration suggests, and the same construction in an expression requires, the calling of a function `fip`, and then using indirection through the pointer result to yield an `int`. In the declarator `(*pfi)()`, the extra parentheses are necessary to indicate that indirection through a pointer to a function yields a function designator, which is then used to call the function; it returns an `int`.

If the declaration occurs outside of any function, the identifiers have file scope and external linkage. If the declaration occurs inside a function, the identifiers of the functions `f` and `fip` have block scope and either internal or external linkage (depending on what file scope declarations for these identifiers are visible), and the identifier of the pointer `pfi` has block scope and no linkage.
</div>

<div class="wording-numbered">

EXAMPLE&emsp;&emsp; The declaration

```cpp
int (*apfi[3])(int *x, int *y);
```

declares an array `apfi` of three pointers to functions returning `int`. Each of these functions has two parameters that are pointers to `int`. The identifiers `x` and `y` are declared for descriptive purposes only and go out of scope at the end of the declaration of `apfi`.
</div>

<div class="wording-numbered">

EXAMPLE&emsp;&emsp; The declaration

```cpp
int (*fpfi(int (*)(long), int))(int, ...);
```

declares a function `fpfi` that returns a pointer to a function returning an `int`. The function `fpfi` has two parameters: a pointer to a function returning an `int` (with one parameter of type `long int`), and an `int`. The pointer returned by `fpfi` points to a function that has one int parameter and accepts zero or more additional arguments of any type.
</div>


<div class="wording-numbered">

EXAMPLE&emsp;&emsp; The following prototype has a variably modified parameter.

```cpp
void addscalar(int n, int m, double a[n][n*m+300], double x);

int main(void)
{
	double b[4][308];
	addscalar(4, 2, b, 2.17);
	return 0;
}

void addscalar(int n, int m, double a[n][n*m+300], double x)
{
	for (int i = 0; i < n; i++)
		for (int j = 0, k = n*m+300; j < k; j++)
			// a is a pointer to a VLA with n*m+300 elements
			a[i][j] += x;
}
```
</div>

<div class="wording-numbered">

EXAMPLE&emsp;&emsp; The following are all compatible function prototype declarators.

```cpp
double maximum(int n, int m, double a[n][m]);
double maximum(int n, int m, double a[*][*]);
double maximum(int n, int m, double a[ ][*]);
double maximum(int n, int m, double a[ ][m]);
```

as are:

```cpp
void f(double (* restrict a)[5]);
void f(double a[restrict][5]);
void f(double a[restrict 3][5]);
void f(double a[restrict static 3][5]);
```

The last declaration also specifies that the argument corresponding to a in any call to `f` can be expected to be a non-null pointer to the first of at least three arrays of 5 `double`s, which the others do not.
</div>

</div>
</blockquote>

*๐ IMPORTANT Editor's Note: Undefined Behavior List J.2 references 6.7.7.4 -- change to 6.2.โจ0.*


### Modify ยง6.8 "Statements and blocks"'s ยง6.8.1 "General" for blanket jump/label banning ### {#wording-core-6.8.1}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.8</span> <span class="wording-clause-title">Statements and blocks</span>
</div>
<div class="wording-clause-header">
<span class="wording-clause-number">6.8.1</span> <span class="wording-clause-title">General</span>
</div>

<div class="wording-section">

<ins>
<div class="wording-clause-section-title">
Constraints
</div>

<div class="wording-newnumbered">

Unless otherwise specified, every jump and label is associated with the innermost invocable body it is contained within. Nested declarations or definitions of invocable bodies shall not refer to jump, iteration, or labeled statements in the invocable's surrounding scope and shall only refer to a visible label or statement in the body of the associated invocable's scope.
</div>
</ins>

<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">

A *statement* specifies an action to be performed. Except as indicated, statements are executed in sequence. The optional attribute specifier sequence appertains to the respective statement.
</div>

</div>
</blockquote>


### Modify ยง6.8.3 "Compound Statement" ### {#wording-core-6.8.3}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.8.3</span> <span class="wording-clause-title">Compound Statement</span>
</div>

<div class="wording-section">



<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">

A *compound statement* that is a <del>function body</del><ins>invocable body</ins> together with the parameter type list and the optional attribute specifier sequence between them forms the block associated with the function definition<ins> or closure definition</ins> in which it appears. Otherwise, it is a block that is different from any other block. A label that is not followed by another label or an unlabeled statement shall be translated as if it were followed by a null statement.
</div>

</div>
</blockquote>


### Rewrite ยง6.9.2 "Function definitions" in terms of Invocables ### {#wording-core-6.9.2}

<blockquote class="quote-ins">
<div class="wording-clause-header">
<span class="wording-clause-number">6.9.2</span> <span class="wording-clause-title">Function definition</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Description
</div>

<div class="wording-numbered">

A function definition defines (or declares and defines) the invocable body of a function call. Its surrounding scope is always file scope, even if a function declarator at block scope is the first encountered declaration of such a function.
</div>

<div class="wording-clause-section-title">
Constraints
</div>

<div class="wording-numbered">

The identifier declared in a function definition (which is the name of the function) shall have a function type, as specified by the declarator portion of the function definition.
</div>

<div class="wording-numbered">

The storage-class specifier, if any, in the declaration specifiers shall be either `extern` or `static`.
</div>

<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">

The optional attribute specifier sequence in a function definition appertains to the function.
</div>

<div class="wording-numbered">

The declarator in a function definition specifies the name of the function being defined and the types (and optionally the names) of all the parameters; the declarator also serves as a function prototype for later calls to the same function in the same translation unit. The type of each parameter is adjusted as described in 6.2.โจ0.
</div>


<div class="wording-numbered">

NOTE&emsp;&emsp; In a function definition, the return type of the function and its prototype cannot be inherited from a typedef:

```cpp
typedef int F(void);
// type F is "function with no parameters returning int"

F f, g;                      // f and g both have type compatible with F
F f { /* ... */ }            // WRONG: syntax/constraint error
F g() { /* ... */ }          // WRONG: declares that g returns a function
int f(void) { /* ... */ }    // RIGHT: f has type compatible with F
int g() { /* ... */ }        // RIGHT: g has type compatible with F
F *e(void) { /* ... */ }     // e returns a pointer to a function
F *((e))(void) { /* ... */ } // same: parentheses irrelevant
int (*fp)(void);             // fp points to a function that has type F
F *Fp;                       // Fp points to a function that has type F
```
</div>

<div class="wording-numbered">

EXAMPLE&emsp;&emsp;In the following:

```cpp
extern int max(int a, int b)
{
	return a > b ? a: b;
}
```

`extern` is the storage-class specifier and `int` is the type specifier; `max(int a, int b)` is the function declarator; and `{ return a > b ? a: b; }` is the function body.
</div>


<div class="wording-numbered">

EXAMPLE&emsp;&emsp;To pass one function to another, one can say

```cpp
int f(void);
/* ... */
g(f);
```

Then the definition of `g` can read

```cpp
void g(int (*funcp)(void))
{
	/* ... */
	(*funcp)(); /* or funcp(); */
}
```

or, equivalently,

```cpp
void g(int func(void))
{
	/* ... */
	func(); /* or (*func)(); */
}
```
</div>

</div>

</blockquote>



## Lambda Expression Changes ## {#wording-lambda}


### Add *lambda-expression* to the *postfix-expression* grammar of ยง6.5.3.1 ### {#wording-lambda-6.5.3.1}

> **Syntax**
>
> <sup>1</sup>
> *postfix-expression:*
> :: *primary-expression*
> :: *postfix-expression* `[` *expression* `]`
> :: *postfix-expression* `(` *argument-expression-list*<sub>*opt*</sub> `)`
> :: *postfix-expression* `.` *identifier*
> :: *postfix-expression* `->` *identifier*
> :: *postfix-expression* `++`
> :: *postfix-expression* `--`
> :: *compound-literal*
> :: <ins>*lambda-expression*</ins>


### Add a new section ยง6.5.3.โจ "Lambda expressions" somewhere after ยง6.5.3.4 "Structure and union members", likely ยง6.5.3.5 ### {#wording-lambda-6.5.3.new}

<blockquote class="quote-ins">
<div class="wording-clause-header">
<span class="wording-clause-number">6.5.3.โจ</span> <span class="wording-clause-title">Lambda expressions</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Syntax
</div>

<div class="wording-numbered">

*lambda-expression*:
:: *terse-capture-clause* *attribute-specifier-sequence*<sub>*opt*</sub> *parameter-clause*<sub>*opt*</sub> *attribute-specifier-sequence*<sub>*opt*</sub> *trailing-return-clause*<sub>*opt*</sub> *function-body*

*terse-capture-clause*:
:: `[` *capture-list*<sub>*opt*</sub> `]`

*trailing-return-clause*:
:: `->` *type-name*

</div>

<div class="wording-clause-section-title">
Description
</div>

<div class="wording-numbered">

A lambda expression (or just "lambda") creates a closure definition that is immediately usable as an invocable. It is introduced and partly characterized by the terse capture clause, has parameters listed in the optional parameter clause, and has a surrounding scope of either:

- the block scope at the lexical position within an invocable;
- or, file scope.

</div>

<div class="wording-clause-section-title">
Constraints
</div>

<div class="wording-numbered">

If a lambda or pointer to lambda is the first operand of the `.` operator or `->` operator, respectively, the second operand shall only specify a capture name from that lambda's capture clause as the identifier to designate a member.
</div>

<div class="wording-numbered">

If the trailing return clause is specified, the return type of the lambda is the specified type name. Otherwise, the return type is inferred from the body of the lambda expression. If the return type is inferred, then:

- all `return` statements shall have an expression which is the exact same type of any one `return` statement's an expression;
- or, `void` if there is no expression for all the return statements or there are no return statements.

</div>

<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">

The optional attribute specifier sequence in a lambda expression appertains to the resulting lambda type and to its function type. If the parameter clause is omitted, and parameter clause of the form `()` is assumed.
</div>

<div class="wording-numbered">

EXAMPLE&emsp;&emsp; In following lambda object initialization:

```cpp
int main () {
	[[deprecated]] auto f = []() [[unsequenced]] {
		return 2;
	}
	return f();
}
```

`[[unsequenced]]` describes the properties of the invocable body through its its function type, while `[[deprecated]]` applies to the closure object `f` and a diagnostic is encouraged at the invocation of `f` in `return f()`.
</div>

<div class="wording-numbered">

Similar to a function definition, a lambda expression forms a single block that comprises all of its parts. Each capture and parameter has a scope of visibility that starts immediately after its definition is completed and extends to the end of the lambda body. Captures and parameters are visible throughout the body of a lambda unless they are redeclared in an inner block within that lambda's body.
</div>

<div class="wording-numbered">

Value captures have the same storage duration as the lambda. Value captures are initialized and formed during the evaluation of the lambda expression, and are tied to that specific lambda expression's closure. Each invocation to the formed lambda creates a new instance of each parameter, similar to a function call. The layout of the storage for parameters is unspecified.
</div>

<div class="wording-numbered">

The behavior is undefined if the lifetime of the lvalue referred ends and the reference capture is used.
</div>

<div class="wording-numbered">

EXAMPLE&emsp;&emsp; Non-capturing lambdas can be immediately converted to function pointers, which makes them usable in functions such as `qsort`:

```cpp
#include <stdlib.h>

int main(int argc, char* argv[]) {
	int list[] = { 2, 11, 32, 49, 57, 20, 110, 203 };
	qsort(list, _Countof(list), sizeof(*list),
		[]() (const void* untyped_left, const void* untyped_right) {
			const int* left = untyped_left;
			const int* right = untyped_right;
			return *left - *right;
		}
	);
	
	return list[0]; // return 2;
}
```
</div>

</div>

</blockquote>


## Capture Function Changes ## {#wording-capture.functions}


### Add *capture-function-declarator* to the *direct-declarator* grammars of ยง6.7.7.1 "General" of "Declarators" ### {#wording-capture.functions-6.7.7.1}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.7.7.1</span> <span class="wording-clause-title">General</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Syntax
</div>

<div class="wording-numbered">

...

*direct-declarator*:
:: *identifier* *attribute-specifier-sequence*<sub>*opt*</sub>
:: `(` *declarator* `)`
:: *array-declarator* *attribute-specifier-sequence*<sub>*opt*</sub>
:: *function-declarator* *attribute-specifier-sequence*<sub>*opt*</sub>
:: <ins>*capture-function-declarator* *attribute-specifier-sequence*<sub>*opt*</sub></ins>

...

</div>

<div>
...
</div>

</div>
</blockquote>


### Add a new section ยง6.7.7.โจ "Capture function declarators" somewhere after ยง6.7.7.4 "Function declarators", likely becoming ยง6.7.7.5 ### {#wording-capture.functions-6.7.7.new}

<blockquote class="quote-ins">
<div class="wording-clause-header">
<span class="wording-clause-number">6.7.7.โจ</span> <span class="wording-clause-title">Capture function declarators</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Syntax
</div>

<div class="wording-numbered">

*capture-function-declarator*:
:: *direct-declarator* *parameter-clause* *function-capture-clause*

*function-capture-clause*:
:: `_Capture` `(` *capture-list*<sub>*opt*</sub> `)`

</div>

<div class="wording-clause-section-title">
Description
</div>

<div class="wording-numbered">

A capture function declarator declares a closure object. It is introduced similarly to a function declarator but is characterized by the function capture clause as well as its lexical position, and has a surrounding scope of either:

- the block scope at the lexical position within an invocable;
- or, file scope.

</div>

<div class="wording-clause-section-title">
Constraints
</div>

<div class="wording-numbered">

The identifier declared in a capture function declarator (which is the name of the capture function) shall have closure type, as specified by the declarator portion of the capture function declarator.
</div>

<div class="wording-numbered">

A capture function object that is declared but not yet defined (6.9.โจ) shall not have the member access operators `.` on the object or `->` the a pointer to that object applied to it.
</div>

<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">


</div>

<div class="wording-numbered">

If, in the declaration "`T D1`", `D1` has the form

:: `D` *parameter-clause* *function-capture-clause* *attribute-specifier-sequence*<sub>*opt*</sub>

and the type specified for the identifier *ident* in the declaration "`T` `D`" is "*derived-declarator-type-list* `T`", then the type specified for *ident* is "*derived-declarator-type-list* closure with *function-capture-clause* captures returning the unqualified, non-atomic version of `T`". The type is complete after the end of the function capture clause. The optional attribute specifier sequence appertains to the closure's function type.
</div>

<div class="wording-numbered">

The second optional attribute specifier sequence after the parameter type list appertains to the closure object.
</div>

<div class="wording-numbered">

EXAMPLE&emsp;&emsp; In following capture function declaration and definition:

```cpp
int main () {
	[[unsequenced]] int f () _Capture() [[deprecated]] {
		return 2;
	}
	return f();
}
```

`[[unsequenced]]` appertains to and describes the properties of the invocable body through its its function type, while `[[deprecated]]` appertains and applies to the closure object `f` and a diagnostic is encouraged at the invocation of `f` in `return f()`.
</div>

</div>

</blockquote>


### Add *capture-function-abstract-declarator* to the *direct-abstract-declarator* grammars of ยง6.7.8 "Type names" ### {#wording-capture.functions-6.7.8}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.7.8</span> <span class="wording-clause-title">Type names</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Syntax
</div>

<div class="wording-numbered">

...

*direct-abstract-declarator*:
:: `(` *abstract-declarator* `)`
:: *array-abstract-declarator* *attribute-specifier-sequence*<sub>*opt*</sub>
:: *function-abstract-declarator* *attribute-specifier-sequence*<sub>*opt*</sub>
:: <ins>*capture-function-abstract-declarator* *attribute-specifier-sequence*<sub>*opt*</sub></ins>

...

<ins>

*capture-function-abstract-declarator*:
:: *direct-abstract-declarator*<sub>*opt*</sub> *parameter-clause* *function-capture-clause*

</ins>
</div>

<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">

In several contexts, it is necessary to specify a type. This is accomplished using a type name, which is syntactically a declaration for a function or an object of that type that omits the identifier. The optional attribute specifier sequence in a direct abstract declarator appertains to the preceding array or function type. The attribute specifier sequence affects the type only for the declaration it appears in, not other declarations involving the same type.
</div>

<div class="wording-numbered">
EXAMPLE&emsp;&emsp; The constructions

```cpp
(a)	int
(b)	int *
(c)	int *[3]
(d)	int (*)[3]
(e)	int (*)[*]
(f)	int *()
(g)	int (*)(void)
(h)	int (*const [])(unsigned int, ...)
(i)	int (*)() _Capture(&)
(j)	int (*const [])(unsigned int, ...) _Capture(=)
```

name respectively the types
:: (a) `int`,
:: (b) pointer to `int`,
:: (c) array of three pointers to `int`,
:: (d) pointer to an array of three `int`s,
:: (e) pointer to a variable length array of an unspecified number of `int`s,
:: (f) function with no parameters returning a pointer to `int`,
:: (g) pointer to function with no parameters returning an `int`, and
:: (h) array of an unspecified number of constant pointers to functions, each with one parameter that has type `unsigned int` and an unspecified number of other parameters, returning an `int`.
:: <ins>(i) pointer to closure which takes no parameters and default captures the current scope by reference, returning an `int`.</ins>
:: <ins>(j) array of an unspecified number of constant pointers to closures, which take an `unsigned int`, an unspecified number of other parameters, and default captures by value of the current scope, returning an `int`.</ins>

<ins>The constructions (i) and (j), while valid types, are nonsensical as the lexical position of the abstract declarator for such a types makes it unique, regardless of the similarity of captures and function types of the closure type. Such a type may not be meaningfully useful in the program's text for interacting with closures and closure types.</ins>
</div>

<ins>
<div class="wording-numbered">

NOTE&emsp;&emsp; As indicated by the syntax, empty parentheses in a type name are interpreted as "function with no parameters", rather than redundant parentheses around the omitted identifier.
</div>
</ins>

</div>
</blockquote>


### Modify ยง6.8.3 "Compound statements" and add a new grammar production for "*block-item*" ### {#wording-capture.functions-6.8.3}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.8.3</span> <span class="wording-clause-title">Compound statements</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Syntax
</div>

<div class="wording-numbered">

...

*block-item*:
:: *declaration*
:: <ins>*function-definition*</ins>
:: <ins>*capture-function-definition*</ins>
:: *unlabeled-statement*
:: *label*

</div>

</div>
</blockquote>


### Modify the title of ยง6.9 to feature more than external definitions to "Definitions" and add a new grammar production for "*external-declaration*" ### {#wording-capture.functions-6.9}

<blockquote>
<div class="wording-clause-header">
<span class="wording-clause-number">6.9</span> <span class="wording-clause-title"><ins>Definitions</ins><del>External definitions</del></span>
</div>


<div class="wording-clause-header">
<span class="wording-clause-number">6.9.1</span> <span class="wording-clause-title">General</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Syntax
</div>

<div class="wording-numbered">

*translation-unit*:
:: *external-declaration*
:: *translation-unit* *external-declaration*

*external-declaration*:
:: *function-definition*
:: <ins>*capture-function-definition*</ins>
:: *declaration*

</div>

</div>
</blockquote>



### Add a new section ยง6.9.โจ "Capture function definitions" somewhere after ยง6.9.2 "Function definitions", likely 6.9.3 ### {#wording-capture.functions-6.9.new}

<blockquote class="quote-ins">
<div class="wording-clause-header">
<span class="wording-clause-number">6.9.โจ</span> <span class="wording-clause-title">Capture function definitions</span>
</div>

<div class="wording-section">

<div class="wording-clause-section-title">
Syntax
</div>

<div class="wording-numbered">

*capture-function-definition*:
:: *direct-declarator* *parameter-clause* *function-capture-clause* *attribute-specifier-sequence*<sub>*opt*</sub> *function-body*

</div>

<div class="wording-clause-section-title">
Description
</div>

<div class="wording-numbered">

A capture function definition declares and defines an invocable of closure type. All of the description, constraints, and semantic requirements in 6.7.7.โจ apply to a capture function definition, with a few additional constraints and semantics as follows.
</div>

<div class="wording-clause-section-title">
Constraints
</div>

<div class="wording-numbered">

The storage-class specifier, if any, in the declaration specifiers shall not be `typedef`.
</div>

<div class="wording-numbered">

If a capture function or pointer to capture functions is the first operand of the `.` operator or `->` operator, respectively, the second operand shall only specify a capture name from its function capture clause as the identifier to designate a member.
</div>

<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">

At block scope, a function definition is interpreted as a capture function definition with the empty function capture clause `_Capture()`.
</div>

<div class="wording-numbered">

EXAMPLE&emsp;&emsp; In following capture function declaration:

```cpp
int main () {
	[[unsequenced]] int f () _Capture() [[deprecated]] {
		return 2;
	}
	return f();
}
```

`[[unsequenced]]` describes the properties of the invocable body through its its function type, while `[[deprecated]]` applies to the closure object `f` and a diagnostic is encouraged at the invocation of `f` in `return f()`.
</div>

<div class="wording-numbered">

Similar to a function definition, a capture function forms a single block that comprises all of its parts. Each capture and parameter has a scope of visibility that starts immediately after its definition is completed and extends to the end of the capture function's body. Captures and parameters are visible throughout the body of a capture function unless they are redeclared in an inner block within that capture function's body.
</div>

<div class="wording-numbered">

Value captures have the same storage duration as the capture function. Value captures are initialized and formed during the evaluation of the capture function, and are tied to that specific capture function's closure. Each invocation of the capture function creates a new instance of each parameter, similar to a function call. The layout of the storage for parameters is implementation-defined.
</div>

<div class="wording-numbered">

```cpp
#include <stdlib.h>

typedef int seven_fn_trampoline_t(void*);
typedef struct seven_fn_data {
	seven_fn_trampoline_t* f;
	void* p;
} seven_fn_data;

seven_fn_data make_seven (int x) {
	int y = 7;
	int seven_fn() _Capture(x, y) {
		return x * y;
	}
	typedef typeof(seven_fn) seven_fn_t;
	int seven_fn_trampoline(void* p) {
		seven_fn_t* seven_fn = p;
		return seven_fn();
	}
	seven_fn_data d = {
		.f = seven_fn_trampoline, // OK: closure literal
		.p = malloc(sizeof(seven_fn))
	};
	// simple assignment of closure into allocated storage
	*((seven_fn_t*)d.p) = seven_fn;
	return d; 
}

typedef int eight_fn_t();

eight_fn_t* make_eight () {
	int eight_fn () _Capture() {
		return 8;
	}
	return eight_fn; // OK: empty capture means closure literal
}

typedef int nine_fn_t();

nine_fn_t* make_nine () {
	int val = 30;
	int nine_fn () _Capture(val) {
		return val;
	}
	return nine_fn; // constraint violation: cannot convert
	// closure to function pointer
}

int main () {
	int x = 10;
	int zero () {
		// OK, no external variables used
		return 0;
	}
	int also_zero () _Capture() {
		// same as above, just explicit
		return 0;
	}
	int double_it () {
		return x * 2; // constraint violation
	}
	int also_wrong () _Capture() {
		return x * 2; // constraint violation
	}
	int triple_it () _Capture(x) {
		return x * 3; // OK, x = 3 when called
	}
	int quadruple_it () _Capture(&x) {
		return x * 4; // OK, x = 5 when called
	}
	int quintuple_it () _Capture(=) {
		return x * 5; // OK, x = 3 when called
	}
	int sextuple_it () _Capture(&) {
		return x * 6; // OK, x = 5 when caled
	}
	x = 1000;
	
	void* trampoline_data = nullptr;
	auto seven_tuple_it = make_seven(x);
	
	eight_fn_t* eight = make_eight();
	int result = zero()
		+ triple_it() + quadruple_it()
		+ quintuple_it() + sextuple_it()
		+ seven_tuple_it.f(seven_tuple_it.d)
		+ eight();
	// same as
	// int result = 17088;
	// 0
	// + (10 * 3) + (1000 * 4)
	// + (10 * 5) + (1000 * 6)
	//            + (1000 * 7)
	// + 8
	free(seven_tuple_it.d);
	return result;
}
```
</div>

</div>

</blockquote>
