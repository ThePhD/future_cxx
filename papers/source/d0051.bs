
<!--
Distributed under the Boost Software License v1.0 (boost.org/LICENSE_1_0.txt)
-->
<pre class='metadata'>
Title: std::overload 
H1: <code>std::overload</code>
Shortname: P0051
Revision: 4
Status: D
Group: WG21
Audience: LWG
Editor: JeanHeyd Meneide, phdofthehouse@gmail.com
Editor: Vicente J. Botet Escribá, vicente.botet@wanadoo.fr
Editor: Bryce Adelstein Lelbach, NVIDIA, brycelelbach@gmail.com
URL: https://wg21.link/P0051R1
!Source: <a href="https://github.com/brycelelbach/wg21_p0051_std_overload/blob/master/std_overload.bs">GitHub</a>
Issue Tracking: GitHub https://github.com/brycelelbach/wg21_p0051_std_overload/issues
Metadata Order: Author, This Version, Source, Issue Tracking, Project, Audience
Markup Shorthands: markdown yes
Toggle Diffs: no
No Abstract: yes
Boilerplate: style-syntax-highlighting off
</pre>

<pre class=include>
path: wording_style_bryce.bs
</pre>




# Introduction # {#intro}

This paper proposes a `std::overload` function for the C++ Standard Library. It creates an implementation-defined object which uses C++ overload resolution to select one of the provided functions to call. The overloaded functions are copied and there is no what to access to the stored functions. There will be another proposal to take care state full function objects and a mean to access them.




# Motivation # {#motivation#}

As lambdas functions, function objects, can’t be overloaded in the usual implicit way, but they can be “explicitly overloaded” using the proposed overload function. It is primarily useful for creating visitors, e.g. for `variant`:

```c++
auto visitor = std::overload(+)
```

```c++
```


# Acknowledgements # {#acknowledgements}

Thanks to Daniel Krügler who helped me to improve the wording and that pointe out to me the use case for a final Callable. Thanks to Scott Pager who suggested to add overloads for non-member and member functions. Thanks to Paul Fultz II and Bjørn Ali authors of the [Fit library](https://github.com/pfultz2/Fit) and the [FTL library](https://github.com/beark/ftl) from where the idea of the first_overload function comes from. Thanks to Matt Calabrese for its useful improvement suggestions on the library usability. Thanks to Tony Van Eerd for championing the original proposal at Kona and for insightful comments. Thanks to Stephan TL for pointing to [CWG-1581 - "When are constexpr member functions defined?"](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1581). Thanks to Peter Remmers that reported [issue 16](https://github.com/viboes/std-make/issues/16). Thanks to Tomasz Kaminski helping me to refine the implementation for final function object and to the private discussion about the possibility to have the combination of unique_overload and first_overload as a much safer solution.

Special thanks and recognition goes to Technical Center of Nokia: Lannion for supporting in part the production of this proposal.

Special thanks to Bryce Adelstein Lelbach for his notifying the new primary author of this proposal so it could be cleaned up.

# History # {#history#}



## Review ## {#review#}

TODO



## Revision History ## {#history-changelog}

### Revision 4 ### {#history-changelog-r4}

- Change primary author and point of contact.
- Prepare paper for LWG with wording for parts approved by LEWG.


### Revision 3 ### {#history-changelog-r3}

- Signal a limitation on the design: final structs, reference_wrapper/perfect forwarders, and other not-quite-derivable types.
- Remove the wording waiting for a decision on how deal with these limitations.


### Revision 2 ### {#history-changelog-r2}

- Add `constexpr` and conditional `noexcept`.
- Confirmed the use of universal references as parameters of `std::overload`.
- Ensure that cv-qualifiers and reference-qualifiers are forwarded correctly.
- Note that the use case for `final`-marked Callables is acceptable.
- Check the working with an expert from LWG before sending a new revision to LEWG and LWG.

### Revision 1 ### {#history-changelog-r1}

This paper has been splintered into 3 proposals, following discussion in the Kona meeting for the original [[p0051r0]]:
- `std::overload` selects teh best overload using C++ overload resolution (this paper)
- `std::first_overload` selects the first overload that matches using C++ overload resolution (**not** this paper)
- Providing access to the stored function objects when they are stateful (**not** this paper)

### Revision 0 ### {#history-changelog-r0}

Initial release.


# Proposed Wording # {#wording}

Note: The following changes are relative to the post Rapperswil 2018 working draft of ISO/IEC 14882, 
([[N4762]]).

Note: The � character is used to denote a placeholder number which shall be selected by the editor.

<!--
Look at https://github.com/brycelelbach/wg21_p1135_cpp20_synchronization_library for examples of how to use my stylesheet
It does stuff like automatic paragraph and bulleted list numbering
-->

Insert a new entry into 

Modify the header synopsis for `<atomic>` in <a href="http://eel.is/c++draft/atomics.syn">[**atomics.syn**]</a> as follows:

<blockquote>
<b>29.2 Header `<atomic>` synopsis <span style="float: right;">[atomics.syn]</span></b>
</blockquote>
