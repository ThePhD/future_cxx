<pre class='metadata'>
Title: Flexible Array Members for C++
Shortname: P1039
Revision: 0
Audience: EWG, LEWG
Status: P
Group: WG21
URL: 
!Source: <a href="https://github.com/ThePhD/future_cxx/blob/master/papers/source/p1039.bs">github.com/ThePhD/future_cxx/blob/master/papers/source/p1039.bs</a>
Editor: JeanHeyd Meneide, phdofthehouse@gmail.com
Editor: Arvid Gerstmann
Editor: Nicole Mazzuca
Abstract: Bringing C99 Flexible Array Member (FAM) syntax into C++ in a safe, well-defined manner.
Date: 2018-05-07
Markup Shorthands: markdown yes
</pre>

# Motivation # {#motivation}

C99 defined Flexible Array Members (FAMs), a way of having a dynamic array of similary typed data laid out in a contiguous, flat format beyond an initial sequence in a struct. Flexible Array Members have been used to great success to interface with many low-latency networking and binary protocols and formats, making it the go-to choice for working with large amounts of data prefixed by header values. The key in its success in high-performance systems, components and software such as Operating Systems, Financial Bidding, Networking and Firmware is the guarantee that there will be at most one allocation for a variably-sized structure.

Despite this success, nothing like this exists in C++, making it's usage unspecified behavior by omission. All compilers warn or error about its usage when working with C Code, making it hard to confidently employ the C technique in C++ code bases. This presents a fairly painful chasm between what is possible in C and what is possible in C++, and prevents Bjarne Stroustrup's long-stated vision of making it possible to fully merge the performance and goals of C with C++.

We propose a safe, well-reasoned extension of the C++ Language in order to accommodate and properly define FAMs for C++ that is compatible with the C99 standard.


# Design # {#design}

In order to provide a reasonable featureset without having to compromise the entire language, FAMs

- implicitly mark their containing `struct`s/`class`es as `final`,
- must be public members of their containing type,
- cannot be a subobject of an array,
- must be the last member of their containing type,
- and, do not contribute to the `sizeof()` for the containing type.

These sets of constraints help us properly integrate FAMs into the C++ language and properly matches the constraints of the C language. Our goals for proposing Flexible Array Members is simple:

1. Allow a succinct, portable way for C++ to refer to memory that is preceded by a header and laid out with its associated data payload in a contiguous manner.
2. Ease the porting of C code into C++ for users who wish to have correct, well-specified and well-defined behavior of their code.
3. Enable developers who must work with the data laid out in #1 to rely on standards-compliant, reasonable code.

Furthermore, we aim to provide a set of overridable traits that -- if specified for a type -- will override how that type is handled

## Use Cases ## {#motivation-uses}

FAMs are used in the wild for many binary formats, particularly those that find themselves need to precisely align and pack data according to transfer formats. Some uses of FAMs in the wild:

- HSA BRIG modules and their contiguously-laid-out BRIG sections: http://www.hsafoundation.com/html/Content/PRM/Topics/18_BRIG/BRIG_module.htm
- TODO: Windows API Calls (List Them)
- TODO: Networking Protocols (List Them)
- TODO: Binary Formats (List Them)

This proposal's Flexible Array Members cover the use cases specified.
