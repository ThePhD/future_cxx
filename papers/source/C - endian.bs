<pre class='metadata'>
Title: Endian and Byteswap
Shortname: 28XX
Revision: 0
!Previous Revisions: None
Status: P
Date: 2021-10-15
Group: WG14
!Proposal Category: Change Request
!Target: General Developers
Editor: JeanHeyd Meneide, phdofthehouse@gmail.com
URL: https://thephd.dev/_vendor/future_cxx/papers/C%20-%20Endian.html
!Paper Source: <a href="https://thephd.dev/_vendor/future_cxx/papers/source/C%20-%20Endian.bs">GitHub</a>
Issue Tracking: GitHub https://github.com/ThePhD/future_cxx/issues
Metadata Order: Previous Revisions, Editor, This Version, Paper Source, Implementation, Issue Tracking, Project, Audience, Proposal Category, Target
Markup Shorthands: markdown yes
Toggle Diffs: no
Abstract: Endian preprocessor and enumeration directives, alongside byte swapping and big endian / little endian functions.
</pre>

<pre class="include-raw">
path: resources/css/bikeshed-wording.html
</pre>

<div class="pagebreak"></div>


# Changelog # {#changelog}



## Revision 0 - October 15th, 2021 ## {#changelog-r0}

- Initial release. ✨




# Introduction & Motivation # {#motivation}

There is a lot of proposals and work that goes into figuring out the "byte order" of integer values that occupy more than 1 octet (8 bits). This is nominally important when dealing with data that comes over network interfaces and is read from files, where the data can be laid out in various orders of octets for 2-, 3-, 4-, 6-, or 8-tuples of octets. The most well-known endian structures on existing architectures include "Big Endian", where the least significant bit comes "first" and is featured prominently in network protocols and file protocols; and, "Little Endian", where the least significant bit comes "last" and is typically the orientation of data for processor and user architectures most prevalent today.

In more legacy architectures (Honeywell, PDP), there also exists other orientations called "mixed" or "middle" endian. The uses of such endianness are of dubious benefit and are vanishingly rare amongst commodity and readily available hardware today, but nevertheless still represent an applicable ordering of octets.

In other related programming interfaces, the C functions/macros `ntoh` ("network to host") and `hton` ("host to network") (usually suffixed with `l` or `ul` or others to specify which native data type it was being performed on such as `long`) were used to change the byte order of a value and returned that value. This became such a common operation that many compilers - among them Clang and GCC - optimized the code down to use an intrinsic `__builtin_bytewap(...)`/`__builtin_bswap(...)` ([for MSVC](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/byteswap-uint64-byteswap-ulong-byteswap-ushort?view=msvc-160), [for Clang](https://clang.llvm.org/docs/LanguageExtensions.html#intrinsics-support-within-constant-expressions), and [for GCC](https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html)). These intrinsics often compiled into binary code representing cheap, simple, and fast byte swapping instructions available on many CPUs for 16, 32, 64, and sometimes 128 bit numbers. The `bswap`/`byteswap` intrinsics were used as the fundamental underpinning for the `ntoh` and `hton` functions, where a check for the translation-time endianness of the program determined if the byte order would be flipped or not.

This proposal puts forth the fundamentals that make a homegrown implementation of `htonl`, `ntoh`, and other endianness-based functions possible in Standard C code.




# Design # {#design}

This is a pure library addition. It is meant to expose both macros and enumeration values that can be used for both translation-time checks and for execution-time runs. It provides a way to check if the endianness within the preprocessor, and gives definitive names that allow for knowing whether the endianness is big, little, or neither. We state big, little, or neither, because there is no settled-upon name for the legacy endianness of "middle" or "mixed", nor any agreed upon ordering for such a "middle" or "mixed" endianness between architectures. This is not the case for big endian or little endian, where one is simply the reverse of the other, always, in every case, across architectures, file protocols, and network specifications.



## The Endianness Enumeration ## {#design-enum}

The enumeration is specified as follows:

```cpp
#define __STDC_ENDIAN_LITTLE__ 1 /* some unique value */
#define __STDC_ENDIAN_BIG__ 2 /* some other unique value */
#define __STDC_ENDIAN_NATIVE__ see-below

typedef enum stdc_endian {
	stdc_endian_little = STDC_ENDIAN_LITTLE,
	stdc_endian_big = STDC_ENDIAN_BIG,
	stdc_endian_native = STDC_ENDIAN_NATIVE
} stdc_endian;
```

The goal of this enumeration is that if the system identifies as a "little endian" system, then `__STDC_ENDIAN_LITTLE__ == __STDC_ENDIAN_NATIVE__`, and that is how an end-user knows that the implementation is little endian. Similarly, a user can check `__STDC_ENDIAN_BIG__ == __STDC_ENDIAN_NATIVE__`, and they can know the implementation is big endian. Finally, if the system is neither big nor little endian, than `__STDC_ENDIAN_NATIVE__` is a unique value that does not compare equal to either value:


```cpp
#include <stdendian.h>
#include <stdio.h>

int main () {
	if (stdc_endian_native == stdc_endian_little) {
		printf("little endian! uwu\n");
	}
	else if (stdc_endian_native == stdc_endian_big) {
		printf("big endian OwO!\n");
	}
	else {
		printf("what is this?!\n");
	}
	return 0;
}
```

If a user has a Honeywell architecture or a PDP architecture, it is up to them to figure out which flavor of "middle endian"/"mixed endian"/"bi endian" they are utilizing.



## Hey! Some Architectures Can Change Their Endianness at Run-time! ## {#design-run.time}

This is beyond the scope of this proposal. This is meant to capture the translation-time endianness. There also does not appear to be any operating system written today that can tolerate an endianness change happening arbitrarily at runtime, after a program has launched. This means that the property is effectively a translation-time property, and therefore can be exposed as a compile-time constant. A future proposal to determine the run-time byte order is more than welcome from someone who has suitable experience dealing with such architectures and programs, and this proposal does not preclude their ability to provide such a run-time function e.g. `stdc_get_endian get_endian(void);`.



# Wording # {#wording}

The following wording is [relative to N2596](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2596.pdf).





## Add `<stdendian.h>` and `<stdbit.h>` to freestanding headers in §4, paragraph 6 ## {#wording-4p6}

<blockquote>

A conforming freestanding implementation shall accept any strictly conforming program in which the use of the features specified in the library clause (Clause 7) is confined to the contents of the standard headers `<float.h>`,
`<iso646.h>`, `<limits.h>`, `<stdalign.h>`, `<stdarg.h>`, `<stdbool.h>`, `<stddef.h>`, `<stdint.h>`,<ins> `<stdendian.h>`, `<stdbit.h>`,</ins> and `<stdnoreturn.h>`

</blockquote>



## Add a new §7.3�x sub-clause for "Endian" in §7 ## {#wording-7.3�x}

<blockquote>
<ins>
<div class="wording-section">

<p><b>7.3�x Endian</b/</p>

<div class="wording-numbered">
The header `<stdendian.h>` defines the following macros, declares the following types, declares the following functions, and defines the following enumeration constants for determining the method of byte ordering used in multi-byte scalar types. Two common methods of byte ordering in multi-byte scalar types are <b>big-endian</b> and <b>little-endian</b>. Big-endian is a format for storage of binary data in which the most significant byte is placed first, with the rest in descending order. Little-endian is a format for storage or transmission of binary data in which the least significant byte is placed first, with the rest in ascending order. This clause describes the endianness of the execution environment.
</div>

<div class="wording-numbered">
The macros are:

> ```cpp
> __STDC_ENDIAN_LITTLE__
> ```

which represents a method of byte order storage least significant byte is placed first, and the rest are in ascending order is suitable for use in an `#if` preprocessing directive;

> ```cpp
> __STDC_ENDIAN_BIG__
> ```

which represents a method of byte order storage most significant byte is placed first, and the rest are in descending order is suitable for use in an `#if` preprocessing directive;

> ```cpp
> __STDC_ENDIAN_NATIVE__
> ```

which represents the method of byte order storage for the execution environment and is suitable for use in an `#if` preprocessing directive.
</div>

<div class="wording-numbered">

`__STDC_ENDIAN_NATIVE__` shall be identical to `__STDC_ENDIAN_LITTLE__` if the execution environment is little-endian. Otherwise, `__STDC_ENDIAN_NATIVE__` shall be identical to `__STDC_ENDIAN_BIG__` if the execution environment is big-endian. If `__STDC_ENDIAN_NATIVE__` is not equivalent to either, then the byte order for the execution environment is implementation-defined.
</div>

<div class="wording-numbered">
The enumeration type is

> ```cpp
> stdc_endian
> ```

whose corresponding enumeration constants are listed below.
</div>

<div class="wording-numbered">
The enumeration constants are:

> ```cpp
> stdc_endian_little = __STDC_ENDIAN_LITTLE__
> ```

which represents a method of byte order storage least significant byte is placed first, and the rest are in ascending order;

> ```cpp
> stdc_endian_big = __STDC_ENDIAN_BIG__
> ```

which represents a method of byte order storage most significant byte is placed first, and the rest are in descending order; and,

> ```cpp
> stdc_endian_native = __STDC_ENDIAN_NATIVE__
> ```

which represents the method of byte order storage for the execution environment.<sup>FOOTNOTE0</sup>
</div>

<sup>FOOTNOTE0</sup><sub>Comparing the enumeration constants by `stdc_endian_native == stdc_endian_little` or `stdc_endian_native == stdc_endian_big` is the same as checking the macros for whether or not the execution environment is big-endian, little-endian, or neither.</sub>
</div>
</div>
</ins>
</blockquote>



## Add a new §7.3�y sub-clause for "Bit Utilities" in §7 ## {#wording-7.3�y}

<blockquote>
<ins>

<p><b>7.3�y Bit Utilities</b/</p>

<p><b>7.3�y.1 Byteswap</b/</p>
<div class="wording-section">

<p><b>Synopsis</b/</p>
<div class="wording-numbered">

> ```cpp
> #include <stdbit.h>
> void stdc_byteswap(void* ptr, size_t n);
> ```
</div>

<p><b>Description</b/</p>
<div class="wording-numbered">

The `stdc_byteswap` function provides an interface to reverse the order of a given sequence of bytes. If `n` is less than or equal to `1`, then the function has no effect. Otherwise, let `R` represent the byte sequence represented by `ptr` and `n` in reverse order. Each byte's value is exchanged with the value in its corresponding reverse position in `R`.
</div>
</div>

<p><b>7.3�y.2 Exact-width Byteswap</b/</p>
<div class="wording-section">

<p><b>Synopsis</b/</p>
<div class="wording-numbered">

> ```cpp
> #include <stdbit.h>
> uintN_t stdc_byteswapN(uintN_t value);
> ```
</div>

<p><b>Description</b/</p>
<div class="wording-numbered">

The <code>stdc_byteswap<i>N</i></code> functions provide an interface to swap the bytes of a corresponding <code>uint<i>N</i>_t</code> object, where <i>N</i> matches an existing exact-width integer type (7.20.1.1). These functions are optional. However, if an implementation provides the corresponding <code>uint<i>N</i>_t</code> typedef (7.20.1.1), it shall define the corresponding exact-width byteswap functions.
</div>

<p><b>Returns</b/</p>
<div class="wording-numbered">

The <code>stdc_byteswap<i>N</i></code> functions provide an interface to swap the bytes of a corresponding <code>uint<i>N</i>_t</code> object, where <i>N</i> matches the number of bits from an existing exact-width integer type (7.20.1.1). These functions are optional. However, if an implementation provides the corresponding <code>uint<i>N</i>_t</code> typedef, it shall define the corresponding exact-width byteswap functions.
</div>
</div>

</ins>
</blockquote>

## Add a new entry for Implementation-defined behavior in Annex J.3 ## {#wording-annexj.3}

<blockquote>
<ins>— The value of `stdc_endian_native` and `__STDC_ENDIAN_NATIVE__` if the execution environment is not big-endian or little-endian (7.3�x).</ins>
</blockquote>
