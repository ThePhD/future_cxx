<pre class='metadata'>
Title: Explicitly Specified Returns for (Implicit) Conversions
Shortname: P1214
Revision: 0
Audience: EWG
Status: P
Group: WG21
URL: 
!Current Source: <a href="https://github.com/ThePhD/future_cxx/blob/master/papers/source/d1214.bs">github.com/ThePhD/future_cxx/blob/master/papers/source/d1214.bs</a>
!Current: <a href="https://rawgit.com/ThePhD/future_cxx/master/papers/d1214.html">https://rawgit.com/ThePhD/future_cxx/master/papers/d1214.html</a>
Repository: ThePhD/future_cxx
Editor: JeanHeyd Meneide
!Reply To: <a href="mailto:phdofthehouse@gmail.com">JeanHeyd Meneide</a>, <a href="https://twitter.com/thephantomderp">@thephantomderp</a>
Abstract: This paper proposes allowing a user to specify a return type to a conversion operator.
Date: 2018-10-06
Markup Shorthands: markdown yes, biblio yes, markup yes
</pre>

<pre class=include>
path: wording_style.bs
</pre>

# Revision History # {#changelog}

## Revision 0 - November 21st, 2014 ## {#changelog-r0}

	Initial release.



# Motivation # {#motivation}

There is an increasingly 



# Design # {#design}



# Impact # {#impact}



# Proposed Wording and Feature Test Macros # {#wording}

The following wording is relative to [[n4762]].


## Proposed feature Test Macro ## {#wording-feature}

The recommended feature test macro is `__cpp_conversion_return_types`.


## Intent ## {#wording-intent}

The intent of this wording is to 


## Proposed Wording ## {#wording-language}

Modify §7.6.1.2/1 [**expr.call**]/1 to read as follows:

<blockquote>
<sup>1</sup> A function call is a postfix expression followed by parentheses containing a possibly empty, comma-separated list of initializer-clauses which constitute the arguments to the function. The postfix expression shall have <del>function type or function pointer type</del><ins>function type, function pointer type, or pointer-to-member type</ins>. For a call to a non-member function or to a static member function, the postfix expression shall be either an lvalue that refers to a function (in which case the function-to-pointer standard conversion (7.3.3) is suppressed on the postfix expression), or it shall have function pointer type.
</blockquote>

Add one clause after §7.6.1.2/2 [**expr.call**]/2:

<blockquote>
<ins>
<sup>3</sup> For a call of the form `pm(a1, ..., aN)`, where `pm` is of type "pointer to member of `T`".
<dl>
	<dd>— if `pm` is a pointer to member function taking `M` arguments, then `N` shall be `1+M`. The result of the expression shall be equivalent to calling a pointer to member function (7.6.4) with the syntax `(a1.*pm)(a2, ..., aN)` if `a1` is a possibly cv-qualified class type of which `T` is a base class. Otherwise, the behavior of the expression shall be equivalent to `(a1->*pm)(a2, ..., aN)`.</dd>
	<dd>— if `pm` is a pointer to data member, then either</dd>
	<dl>
		<dd>— `N` shall be `1`. The behavior of the function call shall be as-if invoking a pointer to member data (**7.6.4**) with `a1.*pm` if `a1` is a possibly cv-qualified class type of which `T` is a base class or is convertible to such a class type, `a1->*pm` otherwise. Or,</dd>
		<dd>— `N` shall be `2`. The behavior of the function call shall be as-if assigning the second argument `a2` to the result of a pointer to member data (**7.6.4**) with `(a1.*pm) = a2` if `a1` is a possibly cv-qualified class type of which `T` is a base class or is convertible to such a class type, `(a1->*pm) = a2` otherwise.</dd>
	</dl>
</dl>
</ins>
</blockquote>

Append to §14.8.1 Predefined macro names [**cpp.predefined**]'s **Table 16** with one additional entry:

<blockquote>
<table>
<tr>
	<th>Macro name</th>
	<th>Value</th>
</tr>
<tr>
	<td><ins>__cpp_invokable_members</ins></td>
	<td><ins>201811L</ins></td>
</tr>
</table>
</blockquote>



# Acknowledgements # {#acknowledgements}

Thank you to Jason Turner for showing me some of the internals of ChaiScript a long time ago and bringing this common problem to light. Thank you to Stephan T. Lavavej for talking about this during one of his talks. Thank you to Barry Revzin and Peter Dimov for their previous work and scholarship on this matter.



<pre class=biblio>
{
	"cpp-sort": {
		"authors": [
			"Morwenn"
		],
		"title": "cpp-sort",
		"href": "https://github.com/Morwenn/cpp-sort",
		"date": "October 7th, 2018"
	},
	"n4762": {
		"authors": [
			"ISO/IEC JTC1/SC22/WG21 - The C++ Standards Committee",
			"Richard Smith"
		],
		"title": "N4762 - Working Draft, Standard for Programming Language C++",
		"href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4762.pdf",
		"date": "May 7th, 2018"
	},
	"p0312": {
		"authors": [
			"Barry Revzin"
		],
		"title": "Making Pointers to Members Callable",
		"href": "https://wg21.link/p0312",
		"date": "October 12th, 2018"
	},
	"pmf-SO": {
		"authors": [
			"Johannes Schaub - litb"
		],
		"title": "Function pointer to member function",
		"href": "https://stackoverflow.com/a/2402607",
		"date": "March 8th, 2010"
	},
	"pmf-SO-algo": {
		"authors":[
			"Piotr Skotnicki"
		],
		"title": "Passing C++ Member Function Pointer to STL Algorithm",
		"href": "https://stackoverflow.com/a/30355058",
		"date": "May 20th, 2015"
	},
	"pmf-CG": {
		"authors": [
			"CodeGuru"
		],
		"title": "C++ Tutorial: Pointer to Member Function",
		"href": "https://www.codeguru.com/cpp/cpp/article.php/c17401/C-Tutorial-PointertoMember-Function.htm",
		"date": "June 30th, 2010"
	},
	"pmf-iso": {
		"authors": [
			"C++ Standard Foundation"
		],
		"title": "Pointers to Member Functions",
		"href": "https://isocpp.org/wiki/faq/pointers-to-members",
		"date": "2018"
	}
}
</pre>
