<pre class='metadata'>
Title: Explicitly Specified Returns for (Implicit) Conversions
Shortname: P1193
Revision: 0
Audience: EWG
Status: P
Group: WG21
URL: 
!Current Source: <a href="https://github.com/ThePhD/future_cxx/blob/master/papers/source/d1193.bs">github.com/ThePhD/future_cxx/blob/master/papers/source/d1193.bs</a>
!Current: <a href="https://rawgit.com/ThePhD/future_cxx/master/papers/d1193.html">https://rawgit.com/ThePhD/future_cxx/master/papers/d1193.html</a>
Repository: ThePhD/future_cxx
Editor: JeanHeyd Meneide
!Reply To: <a href="mailto:phdofthehouse@gmail.com">JeanHeyd Meneide</a>, <a href="https://twitter.com/thephantomderp">@thephantomderp</a>
Abstract: This paper proposes allowing a user to specify a return type to a conversion operator.
Date: 2018-10-08
Markup Shorthands: markdown yes, biblio yes, markup yes
</pre>

<pre class=include>
path: wording_style.bs
</pre>

# Revision History # {#changelog}

## Revision 0 - November 21st, 2014 ## {#changelog-r0}

	Initial release.



# Motivation # {#motivation}

Consider a structure that is meant to be converted to anything that appears on the left hand side of an assignment expression or in any kind of constructor (an "omni" or "unicorn" proxy type):

```
struct unicorn_proxy {
	// ... members to construct / make proxy type

	template <typename T>
	T operator () {
		// convert to some T
		return make_some<T>();
	}
};
```



# Design # {#design}

The primary goal of this design is to make the feature an entirely opt-in specification that interacts with the language in the same way regular conversions do, just with the compiler no longer assuming the return type is exactly the same as the type argument used to select the conversion operator. Here is a motivating example:

```
struct new_unicorn_proxy {
	template <typename T>
	std::decay_t<T> operator T () {
		// ... return a T
	}
};
```


## Opt-In ## {#design-opt_in}

Any good language feature that wants to minimize potential problems and breakage must be opt-in. The syntax we require for our extension is entirely opt-in, and does not affect previous declarations:

```
struct old_unicorn_proxy {
	template <typename T>
	operator T () {
		// ... return a T
	}
};

struct new_unicorn_proxy {
	template <typename T>
	std::decay_t<T> operator T () {
		// ... return a T
	}
};
```

The meaning of this code does not change, and neither does the way it interacts with any of the code currently existing in the codebase. Old code continues to be good code, and this mechanism remains in the standard because it is usually what an individual wants to begin with: it can simply be seen as the compact version of the extension we are attempting to provide. Using the new syntax for an explicit return value does not actually change what, e.g. `T` would deduce to in the above case for the `new_unicorn_proxy`.

## Okay, but what if I keep returning proxies? ## {#design-infinity}

Someone could invent a proxy that returns another proxy, that in turn produces another proxy of a different type, that in turn produces yet another proxy of a different type. This would invoke an infinite chain of lookups, circularly between the types. This proposal does not enable this: it is possible with code written today. This is not a new concern, and so far there have been repeated reports of this egregious sin cropping up in user code that are public knowledge.

This is no different than the recursive function that has no base case or terminal branch or an infinite loop: the user programmed something very, very poorly in order for this to happen and the effect is also easy to test for. We do not anticipate this to be a problem, the same way infinite recursion is not a problem for the regular developer.

N.B.: you cannot just keep returning the same proxy object, because ([**class.conv.fct**]/1)[http://eel.is/c++draft/class.conv.fct] forbids it explicitly. This eliminates one of the most common ways to invoke an infinite loop, and only a rather dedicated attempt at this would result in this being a problem.

# Impact # {#impact}

Since this feature has been designed to be [[#design-opt_in]], the impact is thankfully incredibly small.

## On User Code ## {#impact-users}

While this introduces an extension to a previous language construct, it thankfully does not break any old code due to its opt-in nature. This is a very important design aspect of this extension syntax: it cannot and should not break any old code unless someone explicitly opts into the functionality. At that point, the potential breakage is still completely bounded, because the return type one chooses for a conversion operator member.

## On the Standard ## {#impact-standard}

This does not cause any breakages in the Standard Library or the 

# Proposed Wording and Feature Test Macros # {#wording}
## On User Code ## {#impact-users}


The following wording is relative to [[n4762]].


## Proposed feature Test Macro ## {#wording-feature}

The recommended feature test macro is `__cpp_conversion_return_types`.


## Intent ## {#wording-intent}

The intent of this wording is to allow for an explicit return type to be optionally defined on a member conversion operator.


## Proposed Wording ## {#wording-language}

Modify ยง... [**expr.call**] to read as follows:

<blockquote>
<sup>1</sup> 
</blockquote>

<blockquote>
<ins>
</ins>
</blockquote>

Append to ยง14.8.1 Predefined macro names [**cpp.predefined**]'s **Table 16** with one additional entry:

<blockquote>
<table>
<tr>
	<th>Macro name</th>
	<th>Value</th>
</tr>
<tr>
	<td><ins>__cpp_conversion_return_types</ins></td>
	<td><ins>201811L</ins></td>
</tr>
</table>
</blockquote>



# Acknowledgements # {#acknowledgements}

Thank you to Jason Turner for showing me some of the internals of ChaiScript a long time ago and bringing this common problem to light. Thank you to Stephan T. Lavavej for talking about this during one of his talks. Thank you to Barry Revzin and Peter Dimov for their previous work and scholarship on this matter.



<pre class=biblio>
{
	"cpp-sort": {
		"authors": [
			"Morwenn"
		],
		"title": "cpp-sort",
		"href": "https://github.com/Morwenn/cpp-sort",
		"date": "October 7th, 2018"
	},
	"n4762": {
		"authors": [
			"ISO/IEC JTC1/SC22/WG21 - The C++ Standards Committee",
			"Richard Smith"
		],
		"title": "N4762 - Working Draft, Standard for Programming Language C++",
		"href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4762.pdf",
		"date": "May 7th, 2018"
	},
	"p0312": {
		"authors": [
			"Barry Revzin"
		],
		"title": "Making Pointers to Members Callable",
		"href": "https://wg21.link/p0312",
		"date": "October 12th, 2018"
	},
	"pmf-SO": {
		"authors": [
			"Johannes Schaub - litb"
		],
		"title": "Function pointer to member function",
		"href": "https://stackoverflow.com/a/2402607",
		"date": "March 8th, 2010"
	},
	"pmf-SO-algo": {
		"authors":[
			"Piotr Skotnicki"
		],
		"title": "Passing C++ Member Function Pointer to STL Algorithm",
		"href": "https://stackoverflow.com/a/30355058",
		"date": "May 20th, 2015"
	},
	"pmf-CG": {
		"authors": [
			"CodeGuru"
		],
		"title": "C++ Tutorial: Pointer to Member Function",
		"href": "https://www.codeguru.com/cpp/cpp/article.php/c17401/C-Tutorial-PointertoMember-Function.htm",
		"date": "June 30th, 2010"
	},
	"pmf-iso": {
		"authors": [
			"C++ Standard Foundation"
		],
		"title": "Pointers to Member Functions",
		"href": "https://isocpp.org/wiki/faq/pointers-to-members",
		"date": "2018"
	}
}
</pre>
