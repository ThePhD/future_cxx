<pre class='metadata'>
Title: Type Punning Is (Not?!) Real
Shortname: 38X7
Revision: 0
!Previous Revisions: None
Status: P
Date: 2026-02-12
Group: WG14
!Proposal Category: Change Request, Feature Request  
!Target: C2y
Editor: JeanHeyd Meneide, phdofthehouse@gmail.com
Editor: Shepherd (Shepherd's Oasis LLC), shepherd@soasis.org
URL: https://thephd.dev/_vendor/future_cxx/papers/C%20-%20The%20Big%20Size%20Survey.html
!Paper Source: <a href="https://thephd.dev/_vendor/future_cxx/papers/source/C%20-%20The%20Big%20Size%20Survey">GitHub</a>
Issue Tracking: GitHub https://github.com/ThePhD/future_cxx/issues
Metadata Order: Previous Revisions, Editor, This Version, Paper Source, Implementation, Issue Tracking, Project, Audience, Proposal Category, Target
Markup Shorthands: markdown yes
Toggle Diffs: no
Abstract: Type punning should be real or it should not be real. Right now it exists in a sort of pseudo-real, where implementers and experts reply with conflicting opinions and diverge on whether or not union type punning is effectively the same as performing a memory copy and accessing the copied data in the new type.
</pre>

<pre class="include-raw">
path: resources/css/bikeshed-wording.html
</pre>

<div class="pagebreak"></div>




# Changelog # {#changelog}



## Revision 0 - February 12<sup>th</sup>, 2026 ## {#changelog-r0}

- Initial release. ✨




# Introduction and Motivation # {#intro}

We have personally claimed that type punning is a legal action in C. It is unambiguously **NOT** allowed in C++, but vendors fall on different sides of the divide when it comes to the behavior of type punning with a `union` in C. That is, given the following asserts produce no constraint violations on a given implementation:

```cpp
#include <stddef.h>
#include <string.h>
#include <stdalign.h>

int main () {
	static_assert(sizeof(float) == sizeof(int), "sizes are not similar");
	static_assert(alignof(float) == alignof(int), "alignments are not similar");
	typedef union u {
		float f;
		int i;
	} u;
#if defined(UNNECESSARY_CHECK) && UNNECESSARY_CHECK == 1
	// Not ncessary: both members start at an offset of `0` due to
	// §6.7.3.2 Structure and union specifiers, ❡18:
	// «A pointer to a union object, suitably converted,
	// points to each of its members (or if a member is a bit-field,
	// then to the unit in which it resides),
	// and vice versa. The members of a union object overlap in such a way
	// that pointers to them when
	// converted to pointers to character type point to the same byte.»
	static_assert(offsetof(u, f) == offsetof(u, i), "offsets are not similar");
#endif
	u pun = {.i = 0};
	const int nopun_i = 0;
	float nopun_f = 12334.0;

	memcpy(&nopun_f, &nopun_i, sizeof(int));
	if (memcmp(&nopun_f, &pun.f, sizeof(int)) == 0) {
		return 0;
	}
	return 1;
}
```

([Godbolt](https://godbolt.org/z/jrcPzKh5j)). Is this program guaranteed to work and return `0`? Some implementers say no, and others say yes. This proposal provides 2 pieces of wording attempting to either formalize that wording officially in a "Semantics" section, or to move the type-punning to an explicit "Recommended practice" section so that the divergence is either harmonized in a single, unified direction or explicitly blessed.

NOTE: There was explicit divergence in implementer **understanding**. Whether or not they have leveraged this into actual implementation divergence or not is not something the author has looked into, but getting conflicting answers from e.g. two Clang developers or two GCC developers has not been very encouraging for the future.

The wording that supports the undefined behavior interpretation comes from what is currently §6.2.5 "Representation of types":

> When a value is stored in a member of an object of union type, the bytes of the object representation that do not correspond to that member but do correspond to other members take unspecified values.

Thus, reading from such a member is undefined because there are no guarantees as to what those values may be, whether they are suitable for the type they have been placed into, and similar concerns. Additionally, the "Effective Type" rule from §6.5 "Expressions" requires that after a write into a byte array through a specific type, a read of that same data with a non-compatible type that is not otherwise covered by such Effective Type rules is undefined behavior (a violation of the semantic requirements of the subclause with no proscribed behavior or case):

> The *effective type* of an object that is not a byte array, for an access to its stored value, is the declared type of the object.<sup>84)</sup> If a value is stored into a byte array through an lvalue having a type that is not a byte type, then the type of the lvalue becomes the effective type of the object for that access and for subsequent accesses that do not modify the stored value. If a value is copied into a byte array using memcpy or memmove, or is copied as an array of byte type, then the effective type of the modified object for that access and for subsequent accesses that do not modify the value is the effective type of the object from which the value is copied, if it has one. For all other accesses to a byte array, the effective type of the object is simply the type of the lvalue used for the access
>
> ...
>
> An object shall have its stored value accessed only by an lvalue expression that has one of the following types:
> 
> - a type compatible with the effective type of the object,
> - a qualified version of a type compatible with the effective type of the object,
> - the signed or unsigned type corresponding to a type compatible with the underlying type of the effective type of the object,
> - the signed or unsigned type corresponding to a type compatible with a qualified version of the underlying type of the effective type of the object,
> - a byte type, or
> - an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union).

However, "effective type" rules only apply to storing things into a byte array; it does not apply for preexisting objects. Preexisting objects explicitly have "the declared type of the object". Therefore, storing into it does not allow the type to change because a `union` object already has a fixed effective type that is not a byte array and that cannot be changed.

The understanding here was supposed to be fixed by [[c99-issue-0283|C99's Issue 0283]], which added a footnote that, in conjunction with 6.2.5 "Representation of types" wording, should have solved the problem. The footnote's current form is:

> <sup>84)</sup> If the member used to read the contents of a union object is not the same as the member last used to store a value in the object the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called type punning). This can possibly be a non-value representation.

This footnote was suppsoed to make it clear that while the overall union and structure object could not become a ticking bombo due to the change in presentation of its members, the member that is read from could become a non-value representation (trap representations, abort representations, signaling/interrupt representations). It is these effects that are the focus of this paper. In one interpretation, if trap representations, aborts, signals, etc. can all manifest due to this, it is fairly specifically undefined behavior (that is, there's no bounds on what can or cannot happen upon reading this value). The other interpretation is that reading those unspecified values, even if it can result in all of these things, is not undefined behavior and is simply some lesser form of implementation-defined or unspecified behavior.

It cannot be unspecified behavior because it is not bounded or something an implementation can choose to do out of a select list of options. It could be implementation-defined, but it would be hard to have an implementation account for the (nearly infinite?) was a bit representation laid over another bit representation and interpretated as a different kind of object could go awry. This is the core conceit of the argument surrounding why it is undefined behavior or not.

Unfortunately, opinions continue to diverge on the matter. It seems like more explicit, clear text with regard to the use of the member access operators is required to make clear that this is an allowed and permitted operation. Or, more explicitly, the footnote needs to be moved up to a "Recommended practice" section, to make it clear the intentions of the code.




# Wording # {#wording}

The wording is against the latest working draft.

The intent is to provide 2 options.

- OPTION 1: formalize the semantics of `union` type punning by moving the bulk of the footnote's text into normative text and make the object representation identical to using `memcpy`.
- OPTION 2: allow implementation divergence by placing the appropriate wording and examples in the recommended practice.




## OPTION 1: Modify "§6.5.3.4 Structure and union members" to formalize union semantics ## {#wording-option.1}


<blockquote>

<div class="wording-clause-header">
<span class="wording-clause-number">6.5.3.4</span> <span class="wording-clause-title">Structure and union members</span>
</div>

<div class="wording-section">


<div class="wording-clause-section-title">
Constraints
</div>

<div class="wording-numbered">

The first operand of the `.` operator shall have an atomic, qualified, or unqualified complete structure or union type, and the second operand shall name a member of that type.
</div>


<div class="wording-numbered">

The first operand of the `->` operator shall be a pointer to an atomic, qualified, or unqualified complete structure or union type, and the second operand shall name a member of the type pointed to.
</div>

<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">

A postfix expression followed by the `.` operator and an identifier designates a member of a structure or union object.<ins>If the named member is a member of a union and it is not the member last stored into, then the value is the reinterpretation of the appropriate portion with the object representation (6.2.6) of the last stored value represented by the named member. Otherwise, the</ins><del>The</del> value is that of the named member<del>,</del><span class="footnote-ref"><del>94)</del></span><del> and</del><ins>. The value</ins> is an lvalue if the first expression is an lvalue. If the first expression has qualified type, the result has the so-qualified version of the type of the designated member.
</div>

<ins>
<div class="wording-newnumbered">

EXAMPLE&emsp;&emsp;&emsp; The process of reading members not explicitly written to in a union is sometimes called "type punning". This can possibly be a non-value representation. The following fragment returns `0` if no constraints are violated:

```cpp
#include <stddef.h>
#include <string.h>

int main () {
	static_assert(sizeof(float) == sizeof(int), "sizes are not similar");
	static_assert(alignof(float) == alignof(int), "alignments are not similar");
	typedef union u {
		float f;
		int i;
	} u;

	u pun = {.i = 0};
	const int nopun_i = 0;
	float nopun_f = 12334.0;

	memcpy(&nopun_f, &nopun_i, sizeof(int));
	if (memcmp(&nopun_f, &pun.f, sizeof(int)) == 0) {
		return 0;
	}
	return 1;
}
```
</div>
</ins>

<div class="wording-numbered">

A postfix expression followed by the `->` operator and an identifier designates a member of a structure or union object. The value is that of the named member of the object to which the first expression points, and is an lvalue.<span class="footnote-ref">95)</span> If the first expression is a pointer to a qualified type, the result has the so-qualified version of the type of the designated member.
</div>

<div class="wording-numbered">

Accessing a member of an atomic structure or union object results in undefined behavior.96)
</div>

<div class="wording-numbered">

One special guarantee is made to simplify the use of unions: if a union contains several structures that share a common initial sequence (see following sentence), and if the union object currently contains one of these structures, it is permitted to inspect the common initial part of any of them anywhere that a declaration of the completed type of the union is visible. Two structures share a *common initial sequence* if corresponding members have compatible types (and, for bit-fields, the same widths) for a sequence of one or more initial members.
</div>


<div>
<del>
<span class="footnote"><sup>94)</sup>If the member used to read the contents of a union object is not the same as the member last used to store a value in the object the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called type punning). This can possibly be a non-value representation.</span>
</del>
</div>

</div>

</blockquote>


## OPTION 2: Modify "§6.5.3.4 Structure and union members" to make union semantics a recommended practice ## {#wording-option.2}

<blockquote>

<div class="wording-clause-header">
<span class="wording-clause-number">6.5.3.4</span> <span class="wording-clause-title">Structure and union members</span>
</div>

<div class="wording-section">


<div class="wording-clause-section-title">
Constraints
</div>

<div class="wording-numbered">

The first operand of the `.` operator shall have an atomic, qualified, or unqualified complete structure or union type, and the second operand shall name a member of that type.
</div>


<div class="wording-numbered">

The first operand of the `->` operator shall be a pointer to an atomic, qualified, or unqualified complete structure or union type, and the second operand shall name a member of the type pointed to.
</div>

<div class="wording-clause-section-title">
Semantics
</div>

<div class="wording-numbered">

A postfix expression followed by the `.` operator and an identifier designates a member of a structure or union object. The value is that of the named member<span class="footnote-ref"><del>94)</del></span> and is an lvalue if the first expression is an lvalue. If the first expression has qualified type, the result has the so-qualified version of the type of the designated member.
</div>


<div class="wording-numbered">

A postfix expression followed by the `->` operator and an identifier designates a member of a structure or union object. The value is that of the named member of the object to which the first expression points, and is an lvalue.<span class="footnote-ref">95)</span> If the first expression is a pointer to a qualified type, the result has the so-qualified version of the type of the designated member.
</div>

<div class="wording-numbered">

Accessing a member of an atomic structure or union object results in undefined behavior.96)
</div>

<div class="wording-numbered">

One special guarantee is made to simplify the use of unions: if a union contains several structures that share a common initial sequence (see following sentence), and if the union object currently contains one of these structures, it is permitted to inspect the common initial part of any of them anywhere that a declaration of the completed type of the union is visible. Two structures share a *common initial sequence* if corresponding members have compatible types (and, for bit-fields, the same widths) for a sequence of one or more initial members.
</div>

<ins>
<div class="wording-clause-section-title">
Recommended practice
</div>
</ins>

<ins>
<div class="wording-numbered">

In the case a union member accessed with the `.` or `->` operators, if the named member is not the member last stored into, then the value is the reinterpretation of the appropriate portion with the object representation (6.2.6) of the last stored value represented by the named member. The process of reading members not explicitly or implicitly written to in a union is sometimes called "type punning".
</div>
</ins>


<ins>
<div class="wording-numbered">
EXAMPLE&emsp;&emsp;&emsp; Type punning can possibly result a non-value representation. The following fragment returns `0` if no constraints are violated:

```cpp
#include <stddef.h>
#include <string.h>

int main () {
	static_assert(sizeof(float) == sizeof(int), "sizes are not similar");
	static_assert(alignof(float) == alignof(int), "alignments are not similar");
	typedef union u {
		float f;
		int i;
	} u;

	u pun = {.i = 0};
	const int nopun_i = 0;
	float nopun_f = 12334.0;

	memcpy(&nopun_f, &nopun_i, sizeof(int));
	if (memcmp(&nopun_f, &pun.f, sizeof(int)) == 0) {
		return 0;
	}
	return 1;
}
```
</div>
</ins>

<div>
<del>
<span class="footnote"><sup>94)</sup>If the member used to read the contents of a union object is not the same as the member last used to store a value in the object the appropriate part of the object representation of the value is reinterpreted as an object representation in the new type as described in 6.2.6 (a process sometimes called type punning). This can possibly be a non-value representation.</span>
</del>
</div>

</div>

</blockquote>

<pre class="biblio">
{
	"c99-issue-0283": {
		"authors": [
			"J11",
			"Clark Nelson"
		],
		"title": "Accessing a non-current union member (\"type punning\")",
		"date": "September 18th, 2002",
		"href": "https://www.open-std.org/jtc1/sc22/wg14/issues/c99/issue0283.html"
	}
}
</pre>
