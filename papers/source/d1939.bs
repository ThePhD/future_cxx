<pre class='metadata'>
Title: if consteval { } -- fixing the std::is_constant_evaluated() trap
Shortname: P1939
Revision: 0
Audience: EWG
Status: P
Group: WG21
URL: 
!Target: C++20
!Latest: <a href="https://thephd.github.io/vendor/future_cxx/papers/d1939.html">https://thephd.github.io/vendor/future_cxx/papers/d1939.html</a>
Repository: ThePhD/future_cxx
Editor: JeanHeyd Meneide, phdofthehouse@gmail.com
Date: 2019-10-07
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract: With the advent of std::is_constant_evaluated and consteval, we now have ways of specifying code that should only ever be executed at compile time. While the consteval function-marking keyword is fine, there is a sincere and deep ergonomic and readability problem with std::is_constant_evaluated and a serious trap that has already begun to cost eager adopting users time in not understanding how to use this new magic library function. This paper proposes a new syntax for the if (std::is_constant_evaluated()) { ... } paradigm, preventing user errors and serious footguns from proliferating and tainting C++'s name any further.
</pre>

<pre class=include>
path: wording_style.bs
</pre>


# Revision History # {#changelog}



## Revision 0 - October 7th, 2019 ## {#changelog-r1}

	- Initial release.




# Motivation # {#motivation}

```
constexpr int func () {
	if constexpr (std::is_constant_evaluated()) {
		return 42;
	}
	else {
		return 2;
	}
}
```

The `else` branch in this code is never run. `std::is_constant_evaluated()` makes a compile-time choice, and when evaluated in an `if constexpr` branch it somewhat counterintuitively returns `false`. It must be written like this:

```
constexpr int func () {
	if (std::is_constant_evaluated()) {
		return 42;
	}
	else {
		return 2;
	}
}
```

One would think that this syntax is not that harmful, and that this only happens to a handful of users and that finding the fix would be easy for a common user to arrive upon.


## Nope. ## {#motivation-nope}

I wish.

Not only is this syntax obscenely counter-intuitive, almost nobody -- not even Committee Members who attended the meetings in which `std::is_constant_evaluated()` was standardized -- wrote this correctly the first time they used it (names removed to protect the innocent):

> why not `if constexpr(std::is_constant_evaluated())`

> `if constexpr (std::is_constant_evaluated())` is the `static_assert(false)` of C++20.

> why does this code fully inline the consteval function into my runtime output? We're heavily confused over here

> I expect that to be a very common mistake

> can we somehow make `std::is_constant_evaluated()` not usable in an if constexpr, or warn on it somehow?

> ... lol youre kidding me, right? this makes no sense lmao

> sweet, a brand new mechanism for introducing subtle, hard-to-find bugs into my code ðŸ‘Œ

> I do not expect anyone to use this correctly the first time around.

Even cppreference leaves this Note behind for developers:

> When directly used as the condition of static_assert declaration or constexpr if statement, `std::is_constant_evaluated()` always returns true. â€” [cppreference](https://en.cppreference.com/w/cpp/types/is_constant_evaluated)

There is already a question on Stack Overflow where a user made the mistake and came to some very quick and very alarming conclusions:

> According to these results, I extracted the following conclusions:
> 
>- if constexpr (std::is_constant_evaluated()) always evaluates the true branch. Therefore, it makes no sense to use this construct.
> 
>- If the compiler evaluates a variable at compile time, std::is_constant_evaluated()) is true, no matter whether that variable is explicitly annotated constexpr or not.
> 
> â€” [StackOverflow, metalfox's question](https://stackoverflow.com/questions/54251530/stdis-constant-evaluated-behavior)

Somehow, we have managed to create a feature so baffling to the users that it generates moderately upvoted Stack Overflow traffic within less a month of its Plenary Approval and has compiler developers [running to implement warnings for it](https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91428).

A C++Weekly describing this pitfall:

> Now, the first thing you might be thinking, having looked at this, is "wait shouldn't this be using `if constexpr` here" -- like this -- and what you might notice is that you're going to get the value `5` returned in all cases...
> 
> â€” [Jason Turner, C++Weekly 165](https://youtu.be/nkhhV5uSSLk?t=195)

Is this really a service to our users?

This paper proposes that the answer to that particular question is "absolutely not", and that we need a new syntax that rewards user intuition and does not punish them with the esoterica and minutiae of the language for the 99% case for `std::is_constant_evaluated()`.



# Design # {#design}

The design is very simple and is as follows:

```
constexpr int func () {
	if consteval {
		return 42;
	}
	else {
		return 5;
	}
}
```

This syntax is:

- Unambiguous with other features;
- Clean, easy to read, and entirely self-documenting;
- and, provides none of the pitfalls of the previous code.

The benefit is that this can also be used to implement the library function, without special compiler built-in magic:

```
namespace std {
	constexpr bool is_constant_evaluated() noexcept {
		if consteval {
			return true;
		}
		else {
			return false;
		}
	}
}
```

The implementation of the library function clearly shows exactly how the feature is intended to be used, in a succinct and beautiful moment where the code is readable by the utmost beginner and absolutely teachable, rather than being a compiler builtin that may or may not be documented by the implementation.

Let us not let a chance to have good defaults, understandable code, and clean syntax slip us by. We have a chance to make a storm of confusion for the greater amount of 4 million plus developers be much easier to handle.

Please consider `if consteval` for C++20.



# Acknowledgements # {#acknowledgements}

Thank you to Peter Bindels for running headlong into this problem. Thank you to all the developers at CppCon whose confusion confirmed my own suspicions. Thank you to Barry Revzin for the initial suggestion.
