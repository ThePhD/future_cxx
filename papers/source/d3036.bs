<pre class='metadata'>
Title: Stepanov is Correct: Output Ranges for std::format_to
H1: Stepanov is Correct: Output Ranges for <code>std::format_to</code>
Shortname: P3036
Revision: 0
Audience: LEWG, SG9
Status: iso/P
Group: WG21
URL: https://thephd.dev/_vendor/future_cxx/papers/d3036.html
!Target: C++26
!Latest: <a href="https://thephd.dev/_vendor/future_cxx/papers/d3036.html">https://thephd.dev/_vendor/future_cxx/papers/d3036.html</a>
Repository: ThePhD/future_cxx
Editor: JeanHeyd Meneide (https://thephd.dev), phdofthehouse@gmail.com
Date: 2023-12-12
Markup Shorthands: markdown yes, biblio yes, markup yes
Abstract: This proposal adds a new range type to the standard library and provides a practical example of adding an output range into an existing C++ interface for both improved safety and better performance. Rather than a policy proposal, this paper attempts to model what to do by taking an existing interface, answering difficult questions about how to improve it, and then show and document those improvements so it can be applied to other places in the C++ standard library and the greater ecosystem.
</pre>

<pre class="include-raw">
path: resources/css/bikeshed-wording.html
</pre>




# Revision History # {#changelog}



## Revision 0 - December 12<sup>th</sup>, 2023 ## {#changelog-r0}

	- Initial Release! üéâ




# Polls # {#polls}

These are the questions we would like answers to as this proposal progresses (unmentioned: a poll to continue progress of the paper in general).

Issue: Do we want to throw an error if the range is too small, or simply truncate the output?

Issue: Do we want dedicated `std::ranges::unbounded_view` and `std::ranges::views::unbounded`?

Issue: For `std::format_to`, Do we want to use a `std::ranges::to`-style formulation that does `push_back`/`insert`/`append`/etc.-style appending for containers, and then falls back to simply working over the range `[std::ranges::begin(rng)`, `std::ranges::begin(rng))`?

Issue: For `std::format_to`, Do we want to use a `std::ranges::to`-style formulation that does `push_back`/`insert`/`append`/etc.-style for containers and otherwise?

Issue: Do we want a function `std::format_into` that always works only over the region `[std::ranges::begin(rng)`, `std::ranges::begin(rng))`?



# Introduction and Motivation # {#intro}

Recently, the issue of security has been brought up for C and C++. While C++ has proven to show great resource safety with its general-purpose undo mechanism in the RAII idiom, it has failed spectacularly to take advantage of concepts already present in the C++ standard library to provide operational safety to C++ programs in a meaningful way beyond C. Large classes of output-writing algorithms ‚Äî such as `std::ranges::copy` ‚Äî still take an `OutputIterator` and will happily overwrite beyond the boundaries of an array with no standard-provided, guaranteed safety alternative. Users frequently have to pad their own usage of the algorithms with safety checks in order to achieve their own safety, and the standard library in a wide variety of cases remains completely silent on whether or not we should be providing better functionality.

In this proposal, we look at a recently added C++20 interface ‚Äî `std::format_to` ‚Äî and provide a meaningful improvement to its API that prevents a wide class of stack and heap linear buffer overruns. This is accomplished by taking advantage of statically-deducible size and type information that can be gleaned from the use of a [pre-existing C++20 concept ‚Äî `std::ranges::output_range` ‚Äî in the function template definition](http://eel.is/c++draft/range.refinements).

We also propose a new view type with an adaptor ‚Äî `std::ranges::unbounded_view<OutputIterator>` and `std::ranges::views::unbounded` ‚Äî that enables an explicit, grep-able, searchable, and type-system-optimizable pathway to preserve the same performance characters are prior. We provide a demonstration about how fast this is by using an existing library that takes advantage of the same type mechanisms as a proof-of-concept, building on top of Alexander Stepanov's and Eric Niebler's ideals for iterator and ranges.



## Motivating Example ## {#intro-example}

As pointed out by Olaf van der Spek, this code, unacceptably, will overwrite your stack:

<blockquote>

This snippet overflows the destination buffer. Is format_to too easy to misuse?
Shouldn't it requires an iterator to the end so it could avoid this issue?
It seems like a modern equivalent of `fgets()`

```cpp
#include <format>
#include <iostream>

int main()
{
	char d[10] = {};
	std::format_to(d, "0123456789 {}", 42);
	std::cout << std::string_view(d, 10) << std::endl;
}
```

‚Äî [Olaf van der Spek, Sunday October 2022](https://lists.isocpp.org/std-discussion/2022/10/1795.php)
</blockquote>

There is no reason for this code to behave in this fashion, but it can, will, and does despite the protestations of many both at the time of its standardization and those outside the Committee who have, for years, overrun hundreds of buffers and produced vulnerability after denial of service after privilege escalation with exactly these interfaces. While non-executable stack mitigations and stack cookies/canaries can prevent the worst of this from propagating the damage too far, this discounts the ability to write the exact same code using an incorrectly sized `std::vector`, `std::array`, or similar and relies on the user to perform size checking.

We can ‚Äì and should ‚Äî do better than this.



## Problem Statement Snippets ## {#intro-problems}

The first table in this section lists the old behaviors and their properties. The preamble code is listed here for both tables, to show the starting point of all of the snippets that will be discussed:

```cpp
#include <vector>
#include <list>
#include <string>
#include <array>
#include <span>

int main () {

	std::array<char, 4> tiny_arr;
	std::array<char, 50> arr;
	std::array<char, 0> empty_arr;

	char tiny_c_arr[4];
	char c_arr[50];
	// cannot have zero-sized C array

	std::vector<char> tiny_vec(size_t(4), '\0');
	std::vector<char> vec(size_t(50), '\0');
	std::vector<char> empty_vec{};

	std::span<char> tiny_arr_span(tiny_c_arr);
	std::span<char> arr_span(c_arr);
	std::span<char> empty_arr_span{};

	std::list<char> tiny_llist(size_t(4), '\0');
	std::list<char> llist(size_t(50), '\0');
	std::list<char> empty_llist{};

	/* ‚Ä¶ */
	// Below Table Code Here!
	/* ‚Ä¶ */
	return 0;
}
```

The "Properties" uses the following legend, with a numeric marker for each line of code it is referencing in the snippet. The properties are as follows:

- ‚úîÔ∏è Compiles, links, and runs without issue.
- ‚ùå Does not compile.
- ‚ò¢Ô∏è1 Stack buffer overrun.
- ‚ò¢Ô∏è2 Heap buffer overrun.
- ‚Ä†: Mitigation for ‚ò¢Ô∏è; Stopped by Undefined Behavior Sanitizer / Address Sanitizer.
- ‚Ä°: Mitigation for ‚ò¢Ô∏è; Implementation-specific iterator debugging will stop (unsafe in typical 'Release"-mode software).


### With `std::array` and `std::span` ### {#intro-problems-array.span.c_array}

Used Ranges/Views:

```cpp
	std::array<char, 4> tiny_arr;
	std::array<char, 50> arr;
	std::array<char, 0> empty_arr;

	char tiny_c_arr[4];
	char c_arr[50];

	std::span<char> tiny_arr_span(tiny_c_arr);
	std::span<char> arr_span(c_arr);
	std::span<char> empty_arr_span{};
```

Snippet of code utilizing the above ranges/views with the following identifiers used as references:

- `tiny_v`: `tiny_arr`, `tiny_c_arr`, `tiny_arr_span`
- `v`: `arr`, `c_arr`, `arr_span`
- `empty_v`: `empty_arr`, `empty_arr_span` (C-style arrays cannot have a size of `0`, so it is not included here)

```cpp

```

Properties:

0. ‚ùå
1. ‚ò¢Ô∏è1‚Ä†
2. ‚ò¢Ô∏è1‚Ä°
3. ‚ùå

4. ‚úîÔ∏è
5. ‚úîÔ∏è
6. ‚ùå
7. ‚ò¢Ô∏è1‚Ä†

8. ‚ùå
9. ‚ò¢Ô∏è1‚Ä°
10. ‚ò¢Ô∏è1‚Ä°
11. ‚ùå

<th>Properties</th>
<th>Code Snippet</th>
</tr>
</thead>
<tbody>

<tr>
<td>

`std::array<char, ‚Ä¶>`  
`std::span<char‚Ä¶>`
</td>
<td>


</td>
<td>

```cpp
	/* ‚Ä¶ */
	// 0.
	std::format_to(tiny_view, "Big: {}", 2234561011);
	// 1.
	std::format_to(tiny_view.data(), "Big: {}", 2234561011);
	// 2.
	std::format_to(tiny_view.begin(), "Big: {}", 2234561011);
	// 3.
	std::format_to(std::ranges::unbounded_view(view),
		"Big: {}", 2234561011);
	// 4.
	std::format_to(view, "Big: {}", 2234561011);
	// 5.
	std::format_to(view.data(), "Big: {}", 2234561011);
	// 6.
	std::format_to(view.begin(), "Big: {}", 2234561011);
	// 7.
	std::format_to(std::ranges::unbounded_view(view),
		"Big: {}", 2234561011);
	// 8.
	std::format_to(empty_view, "Big: {}", 2234561011);
	// 9.
	std::format_to(empty_view.data(), "Big: {}", 2234561011);
	// 10.
	std::format_to(empty_view.begin(), "Big: {}", 2234561011);
	// 11.
	std::format_to(std::ranges::unbounded_view(empty_view),
		"Big: {}", 2234561011);
	/* ‚Ä¶ */
```
</td>
</tr>


<tr>
<td>

`char[‚Ä¶]`
</td>
<td>
0. ‚ò¢Ô∏è1‚Ä†
1. ‚ò¢Ô∏è1‚Ä†
2. ‚ò¢Ô∏è1‚Ä°

3. ‚úîÔ∏è
4. ‚úîÔ∏è
5. ‚úîÔ∏è

</td>
<td>

```cpp
	/* ‚Ä¶ */
	// 0.
	std::format_to(tiny_arr, "Big: {}", 2234561011);
	// 1.
	std::format_to(std::data(tiny_arr), "Big: {}", 2234561011);
	// 2.
	std::format_to(std::begin(tiny_arr), "Big: {}", 2234561011);
	// 3.
	std::format_to(arr, "Big: {}", 2234561011);
	// 4.
	std::format_to(std::data(arr), "Big: {}", 2234561011);
	// 5.
	std::format_to(std::begin(arr), "Big: {}", 2234561011);
	/* ‚Ä¶ */
```
</td>
</tr>


<tr>
<td>

`std::vector<char>`  
`std::list<char>`
</td>
<td>
0. ‚ùå
1. ‚ò¢Ô∏è2‚Ä†
2. ‚ò¢Ô∏è2‚Ä°
3. ‚ò¢Ô∏è2‚Ä†
4. ‚ùå

5. ‚úîÔ∏è
6. ‚úîÔ∏è
7. ‚úîÔ∏è
8. ‚ùå
9. ‚ò¢Ô∏è2‚Ä°

10. ‚úîÔ∏è
11. ‚ùå
12. 
13. 
14. 

</td>
<td>

```cpp
	/* ‚Ä¶ */
	// 0.
	std::format_to(tiny_rng, "Big: {}", 2234561011);
	// 1.
	std::format_to(tiny_rng.begin(), "Big: {}", 2234561011);
	// 2.
	std::format_to(std::ranges::unbounded_view(tiny_rng),
		"Big: {}", 2234561011);
	// 3.
	std::format_to(std::inserter(tiny_rng, tiny_rng.begin()),
		"Big: {}", 2234561011);
	// 4.
	std::format_to(std::ranges::unbounded_view(
		std::inserter(tiny_rng, tiny_rng.begin())
		),
		"Big: {}", 2234561011);
	
	// 5.
	std::format_to(tiny_rng, "Big: {}", 2234561011);
	// 6.
	std::format_to(tiny_rng.begin(), "Big: {}", 2234561011);
	// 7.
	std::format_to(std::ranges::unbounded_view(tiny_rng),
		"Big: {}", 2234561011);
	// 8.
	std::format_to(std::inserter(tiny_rng, tiny_rng.begin()),
		"Big: {}", 2234561011);
	// 9.
	std::format_to(std::ranges::unbounded_view(
		std::inserter(tiny_rng, tiny_rng.begin())
		),
		"Big: {}", 2234561011);
	
	// 0.
	std::format_to(empty_rng, "Big: {}", 2234561011);
	// 1.
	std::format_to(empty_rng.begin(), "Big: {}", 2234561011);
	// 2.
	std::format_to(std::ranges::unbounded_view(empty_rng),
		"Big: {}", 2234561011);
	// 3.
	std::format_to(std::inserter(empty_rng, tiny_rng.begin()),
		"Big: {}", 2234561011);
	// 4.
	std::format_to(std::ranges::unbounded_view(
		std::inserter(empty_rng, empty_rng.begin())
		),
		"Big: {}", 2234561011);
	/* ‚Ä¶ */
```
</td>
</tr>

</tbody>
</table>

The above is the status quo. Notably, for C-style arrays, what should not compile like the rest of the examples falls into a case of buffer overrun (on the stack). The other examples are not really all that helpful either, with the container-like ranges still existing undefined behavior for too-small or empty ranges rather than having any sort of sensible stopping behavior. As noted, mitigations such as UBSan, ASan, or iterator debugging / standard library debugging can stop these, but there is no way to stop such errors in release mode software.

It is also more difficult to mandate certain safety macro definitions or force the use of undefined behavior/address sanitization as a library author, leaving library problems to percolate up to users if library authors do not aggressively check inputs and outputs. Arguably, library authors should already be aggressively checking inputs and making sure things do not fall outside the range of expected values, but as much as we would like to be perfect the people who are reading this are (we assume) fallible creatures such as human beings. Expecting perfection is not a tractable task, as has been proven over the course of security issues from the last 40 years of C and C++. Even with the rise of stringent code review, heavier testing, heavier fuzzing, and more, sincere vulnerabilities still make it through.

Therefore, we should start entertaining writing more safe-by-default range algorithms and functionality, and consider integrating the whole standard library with these principles. Rather than simply write a Policy Paper, this proposal takes the approach of using a much-loved piece of functionality ‚Äî `std::format_to` ‚Äî and directly enhancing its interface to handle ranges to make the shortest code (the one that passes the range directly) compile as well as have completely memory-safe and exception-resistant behavior.




# Design # {#design}

The design of this feature is not particularly new or spectacular in its usage. It simply follows a core set of principles for both predictable and well-defined behavior, and prevents a wide class of undefined behavior unless **explicitly** opted into using a new range that takes advantage of `unreachable_sentinel_t` to explicitly mark the case where a range wants iterate infinitely.

We get the design by starting with the innermost component ‚Äî `basic_format_context` ‚Äî and working out the consequences of the design from the inside. Most importantly, a few things need to be changed:

0. `out()` on the `basic_format_context` needs to allow `output_range<Iyt, charT&>` in addition to output iterators;
1. `formatter<‚Ä¶>::format(‚Ä¶)` needs to accept an output range and return an output range (e.g. a `subrange`) instead of just accepting an iterator and returning an iterator;
2. `format_to` and `vformat_to` need to take `Out&& out` (a universal reference) now to handle taking in ranges **and** iterators;
3. and, finally, `format_to` and `vformat_to` needs to select the right kind of `[iterator, sentinel)` set to pass down to the inner workings of the functions. In particular, whether to decay to a `format_to(container-inserter(out), ‚Ä¶)` in the case that `Out&& out` might be a container, or otherwise just `subrange(out)`.



## Table of Changed Behaviors ## {#design-tables}

Taking the table from the above section and taking into account the changes made, we can show the changes that these new APIs would enable:

<table>
<thead>
<tr>
<th>Used Ranges/Views</th>
<th>Properties</th>
<th>Code Snippet</th>
</tr>
</thead>
<tbody>

<tr>
<td>

`std::array<char, ‚Ä¶>`  
`std::span<char‚Ä¶>`
</td>
<td>
0. ‚ùå ‚áí ‚úîÔ∏è
1. ‚ò¢Ô∏è1‚Ä† ‚áí ‚úîÔ∏è
2. ‚ò¢Ô∏è1‚Ä° ‚áí ‚úîÔ∏è

3. ‚ùå ‚áí ‚úîÔ∏è
4. ‚úîÔ∏è
5. ‚úîÔ∏è

6. ‚ùå ‚áí ‚úîÔ∏è
7. ‚ò¢Ô∏è1‚Ä† ‚áí ‚úîÔ∏è
8. ‚ò¢Ô∏è1‚Ä° ‚áí ‚úîÔ∏è

</td>
<td>

```cpp
	/* ‚Ä¶ */
	// 0.
	std::format_to(tiny_view, "Big: {}", 2234561011);
	// 1.
	std::format_to(tiny_view.data(), "Big: {}", 2234561011);
	// 2.
	std::format_to(tiny_view.begin(), "Big: {}", 2234561011);
	// 3.
	std::format_to(view, "Big: {}", 2234561011);
	// 4.
	std::format_to(view.data(), "Big: {}", 2234561011);
	// 5.
	std::format_to(view.begin(), "Big: {}", 2234561011);
	// 6.
	std::format_to(empty_view, "Big: {}", 2234561011);
	// 7.
	std::format_to(empty_view.data(), "Big: {}", 2234561011);
	// 8.
	std::format_to(empty_view.begin(), "Big: {}", 2234561011);
	/* ‚Ä¶ */
```
</td>
</tr>


<tr>
<td>

`char[‚Ä¶]`
</td>
<td>
0. ‚ò¢Ô∏è1‚Ä† ‚áí ‚úîÔ∏è
1. ‚ò¢Ô∏è1‚Ä† ‚áí ‚úîÔ∏è
2. ‚ò¢Ô∏è1‚Ä† ‚áí ‚úîÔ∏è

3. ‚úîÔ∏è
4. ‚úîÔ∏è
5. ‚úîÔ∏è

</td>
<td>

```cpp
	/* ‚Ä¶ */
	// 0.
	std::format_to(tiny_arr, "Big: {}", 2234561011);
	// 1.
	std::format_to(std::data(tiny_arr), "Big: {}", 2234561011);
	// 2.
	std::format_to(std::begin(tiny_arr), "Big: {}", 2234561011);
	// 3.
	std::format_to(arr, "Big: {}", 2234561011);
	// 4.
	std::format_to(std::data(arr), "Big: {}", 2234561011);
	// 5.
	std::format_to(std::begin(arr), "Big: {}", 2234561011);
	/* ‚Ä¶ */
```
</td>
</tr>


<tr>
<td>

`std::vector<char>`  
`std::list<char>`
</td>
<td>
0. ‚ùå ‚áí ‚úîÔ∏è
1. ‚ò¢Ô∏è2‚Ä†
2. ‚ò¢Ô∏è2‚Ä°
3. ‚ò¢Ô∏è2‚Ä†

4. ‚ùå ‚áí ‚úîÔ∏è
5. ‚úîÔ∏è ‚áí ‚úîÔ∏è
6. ‚úîÔ∏è ‚áí ‚úîÔ∏è
7. ‚úîÔ∏è ‚áí ‚úîÔ∏è

8. ‚ùå ‚áí ‚úîÔ∏è
9. ‚ò¢Ô∏è2‚Ä°
10. ‚ò¢Ô∏è2‚Ä°
11. ‚ò¢Ô∏è2‚Ä° ‚áí ‚úîÔ∏è

</td>
<td>

```cpp
	/* ‚Ä¶ */
	// 0.
	std::format_to(tiny_rng, "Big: {}", 2234561011);
	// 1.
	std::format_to(tiny_rng.begin(), "Big: {}", 2234561011);
	// 2.
	// 4.
	std::format_to(std::inserter(tiny_rng, tiny_rng.begin()),
		"Big: {}", 2234561011);
	// 4.
	std::format_to(rng, "Big: {}", 2234561011);
	// 5.
	std::format_to(rng.begin(), "Big: {}", 2234561011);
	// 6.
	// 7.
	std::format_to(std::inserter(rng, rng.begin()),
		"Big: {}", 2234561011);
	// 8.
	std::format_to(empty_rng, "Big: {}", 2234561011);
	// 9.
	std::format_to(empty_rng.begin(), "Big: {}", 2234561011);
	// 10.
	// 11.
	std::format_to(std::inserter(empty_rng, empty_rng.begin()),
		"Big: {}", 2234561011);
	/* ‚Ä¶ */
```
</td>
</tr>

</tbody>
</table>



## Output Ranges ## {#design-output.ranges}

In general, as shown above, output ranges are superior to typical iterators. The only reason we have not deployed such things in the standard library has been, quintessentially, the question of what should happen in two of the cases shown above:


```cpp
std::vector<char> empty_rng;
std::vector<char> rng{'\0','\0','\0','\0','\0','\0'};
// (A)
std::format_to(empty_rng, "Big: {}", 2234561011);
// (B)
std::format_to(rng, "Big: {}", 2234561011);
```

There are two interpretations. `std::ranges::to` takes the interpretation that we should insert/append to such containers. This is also a natural choice for `std::ranges::to` because it is creating the whole container. Conversely, `std::format_to` does not create the target it is inserting to whole-cloth; it is very often writing into a pre-existing buffer or container. This leads to the second interpretation: filling only the space provided between `[std::ranges::begin, std::ranges::end)`.

We choose the `std::ranges::to` interpretation for `std::format_to`, and in conjunction with such a change also are going to probe LEWG/SG9 to ask for another set of functions ‚Äî `std::format_into` and `std::vformat_into` ‚Äî to take the second interpretation. This will provide the full set of functionality that covers 100% of the use cases, and provides a model for the rest of the standard library that needs to answer such questions.

The reason we choose the `std::ranges::to` interpretation in this proposal is because that is the most user-friendly behavior. It is also the most common way we expect `std::format_to` to be used when used with a plain range such as `std::string`, `std::vector`, and other containers from the ecosystem (such as `llvm::SmallString<‚Ä¶>` or `boost::static_vector`). This has also been the design of choice for a widely deployed, and independently re-implemented, encoding library ztd.text[[ztd.text]], which uses this interpretation to great effect across the C++ ecosystem.

Furthermore, the `std::ranges::to` interpretation is **safe** for other types of containers. In the `std::format_to` style of APIs, we will simply fall back to the `[begin, end)` behavior that is anticipated.



## Making Footguns Explicit with `std::ranges::unbounded_view` ## {#design-explicit.footguns}

It is not enough to introduce output ranges into the API and retain the performance benefits by allowing users to use e.g. `std::format_to(vec.begin(), "my buffer is {} appropriately sized!", ‚Ä¶)`. While output ranges provide safety, they do not provide something that is much more important to the ecosystem: easy reviewability and searchability of problematic code. In order to raise the ability to determine places where buffer overruns and other undefined behavior/footgun-prone behavior may be happening, we utilize the type system to leverage a new view with its adaptor: `std::ranges::unbounded_view` and `std::ranges::unbounded`.

These types are effectively `std::ranges::subrange<Iterator, unreachable_sentinel_t>` wrapped in a nice package for easy constructability and usability. The goal of this type is to make it directly transparent by allowing users in Code Review to see `std::ranges::unbounded(_view)` and double-check that the code has verified its invariants before proceeding. Similarly, users suffering from typical signs of memory corruption or overflow should have the ability to leverage the type system to know that they have created a range that will under unfavorable circumstances produce Undefined Behavior. This makes it easy to find typical places where such memory corruption may originate, especially if either `unbounded_view` or `unreachable_sentinel_t` appears in the output. This is what Bjarne Stroustrup continually refers to as "type-rich programming" in his Keynotes and Presentations:

> The aim is to support a type-rich style of programming. In particular, C++ supports type-safe programming with a non-trivial set of types.
>
> ‚Äî "Foundations of C++", Bjarne Stroustrup, ETAPS, [2012](https://www.stroustrup.com/ETAPS-corrected-draft.pdf)

Type-rich programming by deploying a new range type alongside the new `unreachable_sentinel_t` will allow us to directly and explicitly mark something as needing to perform an unbounded operation. Such a type has been implemented and has been able to explicitly deliver performance competitive with raw C code doing analogous operations: see [[#benchmarks]] for more discussion.



## Not Taking Things Away ## {#design-keep.your.footguns}

It is clear that having the unsafe overload is critical for performance use cases. Knowing the size in advance (due to e.g. advance knowledge at compile-time or having secured/known inputs or simply having done the size validation previously in the code) eliminates cycles and, in larger workloads, can easily accumulate performance benefits ([[#benchmarks]]).

However, it is ultimately hostile to folks who want safer behavior to not provide **any** alternatives to such behavior, or alternatives that only work in a subset of cases. This is not to say that `std::format_to_n` is nothing; it is something and it can be utilized to great purpose.

Unfortunately, C has had this problem for decades. Both `strcpy` and `strncpy`, as well as `sprintf` and `snprintf`, have been part of the standard library for ~34 and ~24 years, respectively. This has not stopped a wide variety of vulnerabilities, overflow bugs, improper-sizing bugs, and so much more. We have known for decades that keeping the size tightly coupled with the data it represents to be a boon (and every codebase for both C and C++ have perpetually reinvented the logical, moral, and spiritual equivalent of `std::span<‚Ä¶>` for ages):

> A slice is a non-owning reference to N contiguous elements in memory. In Rust, slice is a language feature. Compiler ensures the life time. C++20 finally introduced std::Span. At Ubisoft we used slices already 10+ years ago.
>
> Let's talk why this is a super important abstraction. ‚Ä¶
>
> ‚Äî Sebastian Aaltonen, [March 12th, 2022](http://web.archive.org/web/20220904024447/https://twitter.com/SebAaltonen/status/1502640283502227465)

Separating the iterator and the size into 2 separate arguments is a way to introduce boilerplate that represents the same class of design mistakes that C has made. By peeling the two apart, we end up in a situation where we risk repeating ourselves or ‚Äî worse ‚Äî risk repeating ourselves **incorrectly**. Every codebase and language small and large has learned not to do this, except C and C++ in their API design. In fact, the separation of these two has been considered a serious problem for a long time:

> What mistake has caused more grief, more bugs, more workarounds, more endless hours consumed, etc., than any other? Many people would say null pointers. I don‚Äôt agree.
> 
> Conflating pointers with arrays.
> 
> I don‚Äôt mean them using the same syntax, or the implicit conversion of arrays to pointers. I mean the inability to pass an array to a function as an array, even if it is declared to be an array.
>
> ‚Äî Walter Bright, [December 22, 2009](http://web.archive.org/web/20231013145702/https://www.digitalmars.com/articles/C-biggest-mistake.html)

What makes this doubly egregious for C++ is that it always had the capability of handling this problem. While in C one could reasonably not expect the C standard library to do anything (it has no `std::span` abstraction, after all, and one has to be put in the language to even begin to address the question in a feasibly scalable manner), C++ ‚Äî even without `std::span` ‚Äî had the ability to take size-templated arrays by reference the entire time.

Note: There was no need for the code in [[#intro-example]] to be as dangerous as it was, but we explicitly and purposefully made it dangerous because we prioritized speed over safety without even considering that someone could cast to a pointer to explicitly request the unsafe behavior. We made the default wrong, **again**, over making our code more defensibly robust for the 80% (estimated) array use case.

If we are going to claim that we are a better language than C for security purposes[[p2739r0]], then we should start designing interfaces like we are actually smarter than C. That means taking advantage of the concepts that Stepanov started and that Eric Niebler & Co. polished to a fine point in the C++ standard. And it means actually using using whole ranges ‚Äî `std::span`, array overloads, or otherwise ‚Äî in an appreciable way in our API surfaces. If our interfaces still have the moral, spiritual, and technical underpinnings of the wildly unsafe `memcpy`, `strcpy`, and similar bugprone APIs, than we have clearly not learned an important enough lesson over the several decades we have been in friendly competition with C and every other programming language on earth.



## Why `.insert`/`.push_back`/etc. by-default? ## {#design-insertable}

One of the immediate questions that comes from this interface is "do we really want to do insertion/appending, or do we want some other kind of behavior?".

We take the `std::ranges::to` approach to such a question. Any container matching the *container-insertable* exposition-only concept is chosen. Then, an iterator following the same design as `std::ranges::to` is chosen and passed to `std::format_to` to fill in the container. The container is not cleared (this would not make any sense and would invalidate progressive calls to `format`/`vformat`). If the range is not *container-insertable*, then we do not do any work in this regard.

A more conservative choice would consist of simply doing `std::ranges::begin()` and `std::ranges::end()`. `std::ranges::to` has cleared the way for allowing for such algorithms to use the many exposition-only concepts to automatically determine container-alike types that may be reserved, pushed back into, inserted into, and otherwise. Those concepts may need to be elevated from exposition-only concepts to instead be more dependable concepts so that they can be depended upon better by users who do not want to "silently" fall back to just working with the `[begin, end)` set of values.

One reason that might make the conservative choice more appealing here is the potential for other kinds of failure from the `std::ranges::to` approach. Using container insertion may add the additional failure conditions where allocations from the underlying container may trigger exceptions. None of the `std::ranges` algorithms that perform writing are marked as `noexcept`; neither is any overload of `std::format` or `std::format_to`. So, while the exception may not be expected, it will thankfully not trigger a full collapse or immediate termination. The only (potential) drawback is that it will prove more difficult, in the future, to appropriately mark any algorithm or I/O-less `format` call as `noexcept`.

Ultimately, we will leave this question in the hands of SG9 and LEWG, noting that -- at least in one library that uses output ranges thoroughly[[ztd.text]] --the conservative approach is taken. One set of functions is used to indicate the intent to `push_back`/`insert`/etc. (`*_to`-style functions) and another set of functions to indicate that we do not want any insertion with the plain `[begin, end)` region (`*_into`-style functions). This could work for `std::format_to` and `std::format_into`; we do not readily provide `std::format_into` in the first iteration of this proposal, but will pose the question to SG9 and LEWG as is appropriate.



## "Why not Sources/Sinks?" ## {#design-sources.sinks}

It was floated during conversation and during the standardization of the `std::ranges` algorithms back in C++20 that perhaps using sink functions would be a more ideal API surface for this behavior. Sources and sinks are simply the worst-case-scenario for ranges: they model the worst of the concepts `std::ranges::input_range` and `std::ranges::output_range` without the ability to upgrade their performance. A detailed breakdown of their failures is documented outside of this proposal[[throwing-out-kitchen-sink-output-ranges]], including performance testing and a demonstration of isomorphic behavior with the weakest kind of `std::ranges`.

If someone would prefer a source/sink API, it can be achieved by simply making a `source_range<GeneratingFunction>` input range and a `sink_range<ConsumingFunction>` that creates an iterator with a hand-crafted `reference` type that either calls the `GeneratingFunction` to produce a value on dereference, or calls the `ConsumingFunction` to accept a value on assignment. (With proper return types for tracking when to input is exhausted or output is full.) This is something that is covered (not directly, but through explaining iterator and range design) in [[Elements-of-Programming|Elements of Programming, ¬ß6.4]]. Sources, where things are modeled after a reading function call on the iterator, is the second-weakest form of a range (a simple "Readable Range" in the text). We should not be basing our design on the weakest kind of iterator/range in both Elements of Programming and the C++ Standard Library, and instead allow ourselves to reach all the way to `std::ranges::contiguous_range`, and other kinds of `contiguous_iterator`s with `unreachable_sentinel_t` sentinels to allow for direct writes and maximum performance in an opt-in fashion.

In conclusion, Input and Output Ranges are a vastly superior abstraction to Source/Sinks for performance and latency, flexibility of use, and API design. We should not entertain another design without significant effort on the hypothetical proposer's part to demonstrate the performance of, and API consequences due to, a Sources/Sinks-based design.



## Detailed Synopsis Overview ## {#design-synopsis}

The signatures for `format_to` get changed to have a deduced return:

```cpp
namespace std {
	// ‚Ä¶

	template<class Out>
		auto /* see-below */ vformat_to(Out&& out, string_view fmt, format_args args);
	template<class Out>
		auto /* see-below */ vformat_to(Out&& out, wstring_view fmt, wformat_args args);
	template<class Out>
		auto /* see-below */ vformat_to(Out&& out, const locale& loc, string_view fmt,
	                                format_args args);
	template<class Out>
		auto /* see-below */ vformat_to(Out&& out, const locale& loc, wstring_view fmt,
		                                wformat_args args);

	template<class Out, class... Args>
		auto /* see-below */  format_to(Out&& out,
		                                format_string<Args...> fmt, Args&&... args);
	template<class Out, class... Args>
		auto /* see-below */  format_to(Out&& out,
		                                wformat_string<Args...> fmt, Args&&... args);
	template<class Out, class... Args>
		auto /* see-below */  format_to(Out&& out,
		                                const locale& loc, format_string<Args...> fmt,
		                                Args&&... args);
	template<class Out, class... Args>
		auto /* see-below */  format_to(Out&& out,
		                                const locale& loc, wformat_string<Args...> fmt,
		                                Args&&... args);

	// ‚Ä¶
}
```

The output becomes deduced based on what `Out` is. If it is an output range, then it returns `subrange<iterator_t<Out>, sentinel_t<Out>>` where `iterator_t<Out>` is an output iterator. Otherwise, the return type remains the same as before (just an `Out`, which that is the iterator itself). More importantly, there are changes to the `basic_format_context` that allow for the use of an output range rather than **just** an iterator:

```cpp
namespace std {
	template<class Out, class charT>
	class basic_format_context {
		basic_format_args<basic_format_context> args_;      // exposition only
		/* see-below */ out_;                               // exposition only

	public:
		using range = /* see-below */; // if present `iterator` is not present
		using iterator = /* see-below */; // if present `range` is not present
		using char_type = charT;
		template<class T> using formatter_type = formatter<T, charT>;

		basic_format_arg<basic_format_context> arg(size_t id) const noexcept;
		std::locale locale();

		auto /* see-below */ out();
		void advance_to(/* see-below */ it);
	};
}
```

Notably, we need a new type definition -- `range` -- for use on `basic_format_context`, as well as turning `iterator` into a conditional definition. The `out()` and `advance(‚Ä¶)` functions take either the iterator-or-range arguments. The `Out` argument will be expanded to satisfy not only the constraint `output_iterator<Out, charT&>` to also allowing it to be `output_range<Out, charT&>`. All of the other changes to the API flow from these two changes.

For example, the above adjustments means that the definition of the exposition-only `formattable` has to be expanded to handle either calling `Context::format` with both a `Context::iterator` alongside a `Context::range`:

```cpp
template<class T, class Context,
		class Formatter = typename Context::template formatter_type<remove_const_t<T>>>
	concept formattable-with =                // exposition only
		semiregular<Formatter> &&
		requires(Formatter& f, const Formatter& cf, T&& t, Context fc,
		         basic_format_parse_context<typename Context::char_type> pc)
		{
			{ f.parse(pc) } -> same_as<typename decltype(pc)::iterator>;
			{ cf.format(t, fc) } -> same_as<typename Context::iterator>;
		};

template<class T, class Context,
		class Formatter = typename Context::template formatter_type<remove_const_t<T>>>
	concept formattable-with-output-range =   // exposition only
		semiregular<Formatter> &&
		requires(Formatter& f, const Formatter& cf, T&& t, Context fc,
		         basic_format_parse_context<typename Context::char_type> pc)
		{
			{ f.parse(pc) } -> same_as<typename decltype(pc)::iterator>;
			{ cf.format(t, fc) } -> same_as<typename Context::range>;
		};

template<class T, class charT>
	concept formattable =
		formattable-with<
			remove_reference_t<T>,
			basic_format_context<fmt-iter-for<charT>, charT>
		>
		|| formattable-with-output-range<
			remove_reference_t<T>,
			basic_format_context<fmt-range-for<charT>, charT>>
		>;
```

The rest of the specification ‚Äî `Formatter` and `BasicFormatter` requirements, detailing the `format_to` and `vformat_to` overloads, and similar ‚Äî flows from the above changes and is contained in the wording. More critically, at the top-level functions (`format_to`  and `vformat_to`), choose whether to insert into the container vs. write out of the container based on `std::ranges::to` logic.

Finally, we add the following range-only `std::format_into` and `std::vformat_into` overloads:

```cpp
namespace std {
	// ‚Ä¶

	template<borrowed_range Out>
		subrange<iterator_t<Out>, sentinel_t<Out>>
		vformat_into(Out out, string_view fmt, format_args args);
	template<borrowed_range Out>
		subrange<iterator_t<Out>, sentinel_t<Out>>
		vformat_into(Out out, wstring_view fmt, wformat_args args);
	template<borrowed_range Out>
		subrange<iterator_t<Out>, sentinel_t<Out>>
		vformat_into(Out out, const locale& loc, string_view fmt,
		             format_args args);
	template<borrowed_range Out>
		subrange<iterator_t<Out>, sentinel_t<Out>>
		vformat_into(Out out, const locale& loc, wstring_view fmt,
		             wformat_args args);

	template<borrowed_range Out, class... Args>
		subrange<iterator_t<Out>, sentinel_t<Out>>
		format_into(Out&& out, format_string<Args...> fmt,
		            Args&&... args);
	template<borrowed_range Out, class... Args>
		subrange<iterator_t<Out>, sentinel_t<Out>>
		format_into(Out&& out, wformat_string<Args...> fmt,
		            Args&&... args);
	template<borrowed_range Out, class... Args>
		subrange<iterator_t<Out>, sentinel_t<Out>>
		format_into(Out&& out, const locale& loc, format_string<Args...> fmt,
		            Args&&... args);
	template<borrowed_range Out, class... Args>
		subrange<iterator_t<Out>, sentinel_t<Out>>
		format_into(Out&& out, const locale& loc, wformat_string<Args...> fmt,
		            Args&&... args);

	// ‚Ä¶
}
```

The return type on these is just a subrange of what is input (contingent upon the input being a `borrowed_range`).




# Benchmarks # {#benchmarks}

`std::ranges::unbounded_view` has the potential to be an immense success in the standard library as a type-level indicator that such unlimited-write/unlimited-read optimizations are desired by the end-user. Here, we demonstrate a slurry of different text encoding APIs that use everything from C-style APIs in C, C-style APIs in C++, C++03 algorithm-style APIs, and the more advanced Output Ranges APIs detailed in this paper. The [benchmarks are also maintained and updated as part of the work on ztd.text](https://ztdtext.readthedocs.io/en/latest/benchmarks.html)[[ztd.text]]. Select examples for transcoding a large buffer of Unicode text are used to do the testing.


## Methodology ## {#benchmarks-methodology}

The method and materials for the benchmarks are as follows (performed December 2022): 

1. Windows 10 Pro machine, general user processes running in the background (but machine not being used).
2. AMD Ryzen 5 3600 6-Core @ 3600 MHz (12 Logical Processors), 32.0 GB Physical Memory
3. Clang 15.0.3, latest available Clang at the time of generation with MSVC ABI.
4.  Entire software stack for every dependency build under default CMake flags (including ICU and libiconv from vcpkg).
5. Anywhere from 150 to 10million samples per iteration, with mean (average) of 100 iterations forming transparent dots on graph.
6. Each bar graph is mean of the 100 iterations, with provided standard deviation-based error bars.
7. In general, unless explicitly noted, the **fastest possible API under the constraints was used to produce the data**.
	- ‚ÄúUnbounded‚Äù means that, where shown, the available space left for writing was not considered.
	- ‚ÄúUnchecked‚Äù/‚ÄúAssume Valid‚Äù means that, where shown, the input was not validated before being converted.
	- ‚ÄúWell-Formed‚Äù, in the title, means that the input was well-formed.



## Results ## {#benchmarks-results}

<pre class="include">
path: assets/d3036/utf8_to_utf16.bs
</pre>

<pre class="include">
path: assets/d3036/utf8_to_utf32.bs
</pre>

Importantly, from these benchmarks, we can see that (with a high degree of confidence and with closely-related error intervals), a conversion done with `ztd::ranges::unbounded_view` (analogous to what is being proposed here) is able to reach the same performance levels as raw, C-style APIs (e.g. those present as described in a foundational paper on SIMD processing of Unicode encoding[[billions-Unicode-characters]]). More critically, we are able to achieve those same levels of performance despite having an incredibly rich API surface[[c-c++-rust-encoding-api-comparison]], as compared to the API surfaces in the other APIs and even the C and C++ standard APIs[[standard-c-c++-encoding-api-breakdown]]. The performance drops off as we add back abstraction layers or use APIs that do not allow for such differentiations at compile-time or execution-time. But, as shown specifically by the "**ztd.text (unbounded, assume valid)**" part of the graph, we are competitive with the one of the fastest APIs in C++, simdutf[[simdutf]]; this is achieved by specializing on `ztd::ranges::unbounded_view`.

Note: Thusly, we have shown that we can retain low-level performance by using explicit, opt-in functionality and the aforementioned type-rich programming that Professor Bjarne Stroustrup continually advocates for.




# Implementation & Deployment Experience # {#experience}

As heavily discussed above, Output Ranges have been deployed in [[ztd.text]] since their inception. The authors of this paper have also spent a lot of time heavily advocating for the use of such abstractions and their essential need for performance-related scenarios, to great success outside of just this use case.

For the specific case of whether this has been implemented in `format_to`, a patch to Victor Zverovich's [[fmtlib]] is planned.

Advisement: TODO: finish the patch and submit it to `{fmt}` before submitting this paper officially.



# Specification # {#wording}

The specification is relative to the latest C++ Working Draft.

Advisement: TODO: finish writing the wording in accordance with the above and send an implementation to `{fmt}`.



## Library Wording ## {#wording-library}


### Feature Test Macros ### {#wording-library-feature.test}

The feature test macro for this should be `__cpp_lib_ranges_unbounded`, with an appropriate date provided. The other feature test macros related to the ranges library and `std::format` should also be updated:

```cpp
//‚Ä¶

#define __cpp_lib_format           202504L /* üìù EDITOR'S NOTE: APPROPRIATE VALUE HERE */
	// also in <format>

// ‚Ä¶

#define __cpp_lib_ranges           202504L /* üìù EDITOR'S NOTE: APPROPRIATE VALUE HERE */
	// also in <algorithm>, <functional>, <iterator>, <memory>, <ranges>

// ‚Ä¶

#define __cpp_lib_ranges_unbounded 202504L /* üìù EDITOR'S NOTE: APPROPRIATE VALUE HERE */
	// also in <ranges>

// ‚Ä¶
```


### Update Synopsis [range.syn] ### {#wording-library-range.syn}

<blockquote>
<div class="wording-section">

<div id="ranges.syn" class="wording-section-header">
<span class="wording-clause-number">26.2</span>
<span class="wording-clause-title">Header `<ranges>` synopsis</span>
<span class="wording-clause-stable-tag">[<b>ranges.syn</b>]</span>
</div>

```cpp
namespace std::ranges {
	// ‚Ä¶
```

<ins>

```cpp
	template<input_or_output_iterator I>
	class unbounded_view;                               // freestanding

	namespace views { inline constexpr unspecified unbounded = unspecified; } // freestanding
```

</ins>

```cpp
	// ‚Ä¶
}
```

</div>
</blockquote>


### Add a new section [range.unbounded] in [ranges] ### {#wording-library-range.unbounded}

<blockquote>
<ins>
<div class="wording-section">

<div id="range.unbounded" class="wordingsection-header">
<span class="wording-clause-number">26.7.33‚ú®</span>
<span class="wording-clause-title">Unbounded view</span>
<span class="wording-clause-stable-tag">[<b>range.unbounded</b>]</span>
</div>

<div id="range.unbounded.overview" class="wording-section-header">
<span class="wording-clause-number">26.7.33‚ú®.1</span>
<span class="wording-clause-title">Overview</span>
<span class="wording-clause-stable-tag">[<b>range.unbounded.overview</b>]</span>
</div>

<div class="wording-numbered">

`unbounded_view` pairs an iterator and an `unreachable_sentinel_t` together and provides convenient construction from a range or a single iterator.

</div>

<div class="wording-numbered">

The name `views::unbounded` denotes a range adaptor object (<a href="http://eel.is/c++draft/range.adaptor.object">[range.adaptor.object]</a>). Given subexpressions *E*, the expressions `views‚Äã::unbounded(E)` is expression-equivalent to `unbounded_view(E)`.

</div>

<div id="range.unbounded.view" class="wording-section-header">
<span class="wording-clause-number">26.7.33‚ú®.2</span>
<span class="wording-clause-title">Class template `unbounded_view`</span>
<span class="wording-clause-stable-tag">[<b>range.unbounded.view</b>]</span>
</div>

```cpp
namespace std::ranges {

	template<input_or_output_iterator I>
	using base-subrange = subrange<I, unreachable_sentinel_t>; /* exposition-only */


	template<input_or_output_iterator I>
	class unbounded_view
		/* exposition-only: inheritance not required */
		: private base-subrange<I> {
	public:
		unbounded_view(I it)
			: base-range(std::move(it), unreachable_sentinel_t{}) {}
		unbounded_view(I it, unreachable_sentinel_t end)
			: base-range(std::move(it), end) {}
		template <different-from<subrange> R>
			requires borrowed_range<R> &&
				convertible-to-non-slicing<iterator_t<R>, I>
		unbounded_view(R&& r)
			: base-range(ranges::begin(::std::forward<R>(r)), unreachable_sentinel_t{}) {}

		using base-range::begin;
		using base-range::end;
		using base-range::next;
		using base-range::prev;
		using base-range::advance;

	private:
		using base-range = base-subrange<I>; /* exposition-only */
	};

	template<borrowed_range R>
	unbounded_view(R&&) ->
		unbounded_view<iterator_t<R>>;
}
```

</div>
</ins>
</blockquote>

<pre class=biblio>
{
	"ztd.text": {
		"title": "ztd.text",
		"authors": [
			"JeanHeyd Meneide",
			"Shepherd's Oasis, LLC"
		],
		"href": "https://ztdtext.readthedocs.io/",
		"publisher": "Shepherd's Oasis, LLC",
		"date": "November 25th, 2023"
	},
	"c-c++-rust-encoding-api-comparison": {
		"authors": [
			"JeanHeyd Meneide"
		],
		"title": "The Wonderfully Terrible World of C and C++ Encoding APIs (with Some Rust)",
		"href": "https://thephd.dev/the-c-c++-rust-string-text-encoding-api-landscape",
		"publisher": "https://thephd.dev",
		"date": "October 12th, 2022"
	},
	"standard-c-c++-encoding-api-breakdown": {
		"authors": [
			"JeanHeyd Meneide"
		],
		"title": "cuneicode, and the Future of Text in C",
		"href": "https://thephd.dev/cuneicode-and-the-future-of-text-in-c",
		"publisher": "https://thephd.dev",
		"date": "June 7th, 2023"
	},
	"throwing-out-kitchen-sink-output-ranges": {
		"authors": [
			"JeanHeyd Meneide"
		],
		"title": "Throwing Out the Kitchen Sink - Output Ranges",
		"href": "https://thephd.dev/output-ranges",
		"publisher": "https://thephd.dev",
		"date": "August 15th, 2020"
	},
	"billions-Unicode-characters": {
		"authors": [
			"Daniel Lemire",
			"Wojciech Mu≈Ça"
		],
		"title": "Transcoding Billions of Unicode Characters per Second with SIMD Instructions",
		"href": "https://arxiv.org/abs/2109.10433",
		"publisher": "Software: Practice and Experience, Volume 52, Issue 2",
		"date": "February 2022"
	},
	"simdutf": {
		"authors": [
			"Daniel Lemire",
			"Robert Clausecker",
			"Wojciech Mu≈Ça",
			"John Keiser"
		],
		"title": "simdutf/simdutf",
		"href": "https://github.com/simdutf/simdutf",
		"publisher": "GitHub",
		"date": "December 4th, 2023"
	},
	"fmtlib": {
		"authors": [
			"Victor Zverovich"
		],
		"title": "fmtlib/fmt",
		"href": "https://github.com/fmtlib/fmt",
		"publisher": "GitHub",
		"date": "December 11th, 2023"
	},
	"Elements-of-Programming": {
		"authors": [
			"Alexander Stepanov",
			"Paul McJones"
		],
		"title": "Elements of Programming",
		"href": "http://elementsofprogramming.com/eop_coloredlinks.pdf",
		"publisher": "Semigroup Press",
		"date": "June 2019"
	}
}
</pre>
